package com.robotium.solo;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Stack;
import java.util.Timer;
import junit.framework.Assert;
import android.app.Activity;
import android.app.Instrumentation;
import android.app.Instrumentation.ActivityMonitor;
import android.content.IntentFilter;
import android.util.Log;
import android.view.KeyEvent;


/**
 * Contains activity related methods. Examples are:
 * getCurrentActivity(), getActivityMonitor(), setActivityOrientation(int orientation).
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class ActivityUtils {

	private final Instrumentation inst;
	private ActivityMonitor activityMonitor;
	private Activity activity;
	private final Sleeper sleeper;
	private final String LOG_TAG = "Robotium";
	private final int MINISLEEP = 100;
	private Stack<WeakReference<Activity>> activityStack;
	private WeakReference<Activity> weakActivityReference;
	private Stack<String> activitiesStoredInActivityStack;
	private Timer activitySyncTimer;
	private boolean registerActivities;
	Thread activityThread;

	/**
	 * Constructs this object.
	 *
	 * @param inst the {@code Instrumentation} instance.
	 * @param activity the start {@code Activity}
	 * @param sleeper the {@code Sleeper} instance
	 */

	public ActivityUtils(Instrumentation inst, Activity activity, Sleeper sleeper) {
		this.inst = inst;
		this.activity = activity;
		this.sleeper = sleeper;
		createStackAndPushStartActivity();
		activitySyncTimer = new Timer();
		activitiesStoredInActivityStack = new Stack<String>();
		setupActivityMonitor();
		setupActivityStackListener();
	}



	/**
	 * Creates a new activity stack and pushes the start activity. 
	 */

	private void createStackAndPushStartActivity(){
		activityStack = new Stack<WeakReference<Activity>>();
		if (activity != null){
			WeakReference<Activity> weakReference = new WeakReference<Activity>(activity);
			activity = null;
			activityStack.push(weakReference);
		}
	}
	

	/**
	 * Returns a {@code List} of all the opened/active activities.
	 * 
	 * @return a {@code List} of all the opened/active activities
	 */

	public ArrayList<Activity> getAllOpenedActivities()
	{
		ArrayList<Activity> activities = new ArrayList<Activity>();
		Iterator<WeakReference<Activity>> activityStackIterator = activityStack.iterator();

		while(activityStackIterator.hasNext()){
			Activity  activity = activityStackIterator.next().get();
			if(activity!=null)
				activities.add(activity);
		}
		return activities;
	}

	/**
	 * This is were the activityMonitor is set up. The monitor will keep check
	 * for the currently active activity.
	 */

	private void setupActivityMonitor() {

		try {
			IntentFilter filter = null;
			activityMonitor = inst.addMonitor(filter, null, false);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	
	/**
	 * Returns true if registration of Activites should be performed
	 * 
	 * @return true if registration of Activities should be performed
	 */
	
	public boolean shouldRegisterActivities() {
		return registerActivities;
	}


	/**
	 * Set true if registration of Activities should be performed
	 * @param registerActivities true if registration of Activities should be performed
	 * 
	 */
	
	public void setRegisterActivities(boolean registerActivities) {
		this.registerActivities = registerActivities;
	}

	/**
	 * This is were the activityStack listener is set up. The listener will keep track of the
	 * opened activities and their positions.
	 */

	private void setupActivityStackListener() {
		setRegisterActivities(true);
		
		Runnable runnable = new Runnable() {
			public void run() {
				while (shouldRegisterActivities()) {
					
					Activity activity = activityMonitor.waitForActivity();

					if(activity != null){
						if (activitiesStoredInActivityStack.remove(activity.toString())){
							removeActivityFromStack(activity);
						}
						if(!activity.isFinishing()){
							addActivityToStack(activity);
						}
					}
				}
			}
		};
		activityThread = new Thread(runnable, "activityMonitorThread");
		activityThread.start();
	}

	/**
	 * Removes a given activity from the activity stack
	 * 
	 * @param activity the activity to remove
	 */

	private void removeActivityFromStack(Activity activity){

		Iterator<WeakReference<Activity>> activityStackIterator = activityStack.iterator();
		while(activityStackIterator.hasNext()){
			Activity activityFromWeakReference = activityStackIterator.next().get();

			if(activityFromWeakReference == null){
				activityStackIterator.remove();
			}

			if(activity != null && activityFromWeakReference != null && activityFromWeakReference.equals(activity)){
				activityStackIterator.remove();
			}
		}
	}

	/**
	 * Returns the ActivityMonitor used by Robotium.
	 * 
	 * @return the ActivityMonitor used by Robotium
	 */

	public ActivityMonitor getActivityMonitor(){
		return activityMonitor;
	}

	/**
	 * Sets the Orientation (Landscape/Portrait) for the current activity.
	 * 
	 * @param orientation An orientation constant such as {@link android.content.pm.ActivityInfo#SCREEN_ORIENTATION_LANDSCAPE} or {@link android.content.pm.ActivityInfo#SCREEN_ORIENTATION_PORTRAIT}
	 */

	public void setActivityOrientation(int orientation)
	{
		Activity activity = getCurrentActivity();
		activity.setRequestedOrientation(orientation);	
	}

	/**
	 * Returns the current {@code Activity}, after sleeping a default pause length.
	 *
	 * @param shouldSleepFirst whether to sleep a default pause first
	 * @return the current {@code Activity}
	 */

	public Activity getCurrentActivity(boolean shouldSleepFirst) {
		return getCurrentActivity(shouldSleepFirst, true);
	}

	/**
	 * Returns the current {@code Activity}, after sleeping a default pause length.
	 *
	 * @return the current {@code Activity}
	 */

	public Activity getCurrentActivity() {
		return getCurrentActivity(true, true);
	}

	/**
	 * Adds an activity to the stack
	 * 
	 * @param activity the activity to add
	 */

	private void addActivityToStack(Activity activity){
		activitiesStoredInActivityStack.push(activity.toString());
		weakActivityReference = new WeakReference<Activity>(activity);
		activity = null;
		activityStack.push(weakActivityReference);
	}

	/**
	 * Waits for an activity to be started if one is not provided
	 * by the constructor.
	 */

	private final void waitForActivityIfNotAvailable(){
		if(activityStack.isEmpty() || activityStack.peek().get() == null){

			if (activityMonitor != null) {
				Activity activity = activityMonitor.getLastActivity();
				while (activity == null){
					sleeper.sleepMini();
					activity = activityMonitor.getLastActivity();
				}
				addActivityToStack(activity);
			}
			else{
				sleeper.sleepMini();
				setupActivityMonitor();
				waitForActivityIfNotAvailable();
			}
		}
	}
	
	/**
	 * Returns the name of the most recent Activity
	 *  
	 * @return the name of the current {@code Activity}
	 */
	
	public String getCurrentActivityName(){
		if(!activitiesStoredInActivityStack.isEmpty()){
			return activitiesStoredInActivityStack.peek();
		}
		return "";
	}

	/**
	 * Returns the current {@code Activity}.
	 *
	 * @param shouldSleepFirst whether to sleep a default pause first
	 * @param waitForActivity whether to wait for the activity
	 * @return the current {@code Activity}
	 */

	public Activity getCurrentActivity(boolean shouldSleepFirst, boolean waitForActivity) {
		if(shouldSleepFirst){
			sleeper.sleep();
		}
		if(waitForActivity){
			waitForActivityIfNotAvailable();
		}
		if(!activityStack.isEmpty()){
			activity=activityStack.peek().get();
		}
		return activity;
	}

	/**
	 * Check if activity stack is empty.
	 * 
	 * @return true if activity stack is empty
	 */
	
	public boolean isActivityStackEmpty() {
		return activityStack.isEmpty();
	}

	/**
	 * Returns to the given {@link Activity}.
	 *
	 * @param name the name of the {@code Activity} to return to, e.g. {@code "MyActivity"}
	 */

	public void goBackToActivity(String name)
	{
		ArrayList<Activity> activitiesOpened = getAllOpenedActivities();
		boolean found = false;	
		for(int i = 0; i < activitiesOpened.size(); i++){
			if(activitiesOpened.get(i).getClass().getSimpleName().equals(name)){
				found = true;
				break;
			}
		}
		if(found){
			while(!getCurrentActivity().getClass().getSimpleName().equals(name))
			{
				try{
					inst.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
				}catch(SecurityException ignored){}	
			}
		}
		else{
			for (int i = 0; i < activitiesOpened.size(); i++){
				Log.d(LOG_TAG, "Activity priorly opened: "+ activitiesOpened.get(i).getClass().getSimpleName());
			}
			Assert.fail("No Activity named: '" + name + "' has been priorly opened");
		}
	}

	/**
	 * Returns a localized string.
	 * 
	 * @param resId the resource ID for the string
	 * @return the localized string
	 */

	public String getString(int resId)
	{
		Activity activity = getCurrentActivity(false);
		return activity.getString(resId);
	}

	/**
	 * Finalizes the solo object.
	 */  

	@Override
	public void finalize() throws Throwable {
		activitySyncTimer.cancel();
		try {
			// Remove the monitor added during startup
			if (activityMonitor != null) {
				inst.removeMonitor(activityMonitor);
				activityMonitor = null;
			}
		} catch (Exception ignored) {}
		super.finalize();
	}

	/**
	 * All activites that have been opened are finished.
	 */

	public void finishOpenedActivities(){
		// Stops the activityStack listener
		activitySyncTimer.cancel();
		ArrayList<Activity> activitiesOpened = getAllOpenedActivities();
		// Finish all opened activities
		for (int i = activitiesOpened.size()-1; i >= 0; i--) {
			sleeper.sleep(MINISLEEP);
			finishActivity(activitiesOpened.get(i));
		}
		activitiesOpened = null;
		sleeper.sleep(MINISLEEP);
		// Finish the initial activity, pressing Back for good measure
		finishActivity(getCurrentActivity(true, false));
		setRegisterActivities(false);
		this.activity = null;
		sleeper.sleepMini();
		try {
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
			sleeper.sleep(MINISLEEP);
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
		} catch (Throwable ignored) {
			// Guard against lack of INJECT_EVENT permission
		}
		clearActivityStack();
	}

	/**
	 * Clears the activity stack.
	 */

	private void clearActivityStack(){
		
		activityStack.clear();
		activitiesStoredInActivityStack.clear();
	}

	/**
	 * Finishes an activity.
	 * 
	 * @param activity the activity to finish
	 */

	private void finishActivity(Activity activity){
		if(activity != null) {
			try{
				activity.finish();
			}catch(Throwable e){
				e.printStackTrace();
			}
		}
	}
}

@#$
package com.robotium.solo;

import junit.framework.Assert;
import android.app.Activity;
import android.app.ActivityManager;

/**
 * Contains assert methods examples are assertActivity() and assertLowMemory().
 * 
 * @author Renas Reda, renas.reda@robotium.com
 *
 */

class Asserter {
	private final ActivityUtils activityUtils;
	private final Waiter waiter;

	/**
	 * Constructs this object.
	 *
	 * @param activityUtils the {@code ActivityUtils} instance.
	 * @param waiter the {@code Waiter} instance.
	 */

	public Asserter(ActivityUtils activityUtils, Waiter waiter) {
		this.activityUtils = activityUtils;
		this.waiter = waiter;
	}

	/**
	 * Asserts that an expected {@link Activity} is currently active one.
	 *
	 * @param message the message that should be displayed if the assert fails
	 * @param name the name of the {@code Activity} that is expected to be active e.g. {@code "MyActivity"}
	 */

	public void assertCurrentActivity(String message, String name) {
		boolean foundActivity = waiter.waitForActivity(name);

		if(!foundActivity)
			Assert.assertEquals(message, name, activityUtils.getCurrentActivity().getClass().getSimpleName());		
	}

	/**
	 * Asserts that an expected {@link Activity} is currently active one.
	 *
	 * @param message the message that should be displayed if the assert fails
	 * @param expectedClass the {@code Class} object that is expected to be active e.g. {@code MyActivity.class}
	 */

	public void assertCurrentActivity(String message, Class<? extends Activity> expectedClass) {
		if(expectedClass == null){
			Assert.fail("The specified Activity is null!");
		}
		
		boolean foundActivity = waiter.waitForActivity(expectedClass);

		if(!foundActivity) {
			Assert.assertEquals(message, expectedClass.getName(), activityUtils.getCurrentActivity().getClass().getName());
		}
	}

	/**
	 * Asserts that an expected {@link Activity} is currently active one, with the possibility to
	 * verify that the expected {@code Activity} is a new instance of the {@code Activity}.
	 * 
	 * @param message the message that should be displayed if the assert fails
	 * @param name the name of the {@code Activity} that is expected to be active e.g. {@code "MyActivity"}
	 * @param isNewInstance {@code true} if the expected {@code Activity} is a new instance of the {@code Activity}
	 */

	public void assertCurrentActivity(String message, String name, boolean isNewInstance) {
		assertCurrentActivity(message, name);
		assertCurrentActivity(message, activityUtils.getCurrentActivity().getClass(),
				isNewInstance);
	}

	/**
	 * Asserts that an expected {@link Activity} is currently active one, with the possibility to
	 * verify that the expected {@code Activity} is a new instance of the {@code Activity}.
	 * 
	 * @param message the message that should be displayed if the assert fails
	 * @param expectedClass the {@code Class} object that is expected to be active e.g. {@code MyActivity.class}
	 * @param isNewInstance {@code true} if the expected {@code Activity} is a new instance of the {@code Activity}
	 */

	public void assertCurrentActivity(String message, Class<? extends Activity> expectedClass,
			boolean isNewInstance) {
		boolean found = false;
		assertCurrentActivity(message, expectedClass);
		Activity activity = activityUtils.getCurrentActivity(false);
		for (int i = 0; i < activityUtils.getAllOpenedActivities().size() - 1; i++) {
			String instanceString = activityUtils.getAllOpenedActivities().get(i).toString();
			if (instanceString.equals(activity.toString()))
				found = true;
		}
		Assert.assertNotSame(message, isNewInstance, found);
	}

	/**
	 * Asserts that the available memory is not considered low by the system.
	 */

	public void assertMemoryNotLow() {
		ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();
		((ActivityManager)activityUtils.getCurrentActivity().getSystemService("activity")).getMemoryInfo(mi);
		Assert.assertFalse("Low memory available: " + mi.availMem + " bytes!", mi.lowMemory);
	}

}

@#$
package com.robotium.solo;

/**
 * Used in conjunction with the web methods. Examples are By.id(String id) and By.cssSelector(String selector).
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

public abstract class By {

	/**
	 * Select a WebElement by its id.
	 * 
	 * @param id the id of the web element	
	 * @return the Id object
	 */

	public static By id(final String id) {
		return new Id(id); 

	}

	/**
	 * Select a WebElement by its xpath.
	 * 
	 * @param xpath the xpath of the web element
	 * @return the Xpath object
	 */

	public static By xpath(final String xpath) {
		return new Xpath(xpath); 

	}

	/**
	 * Select a WebElement by its css selector.
	 * 
	 * @param selectors the css selector of the web element
	 * @return the CssSelector object
	 */

	public static By cssSelector(final String selectors) {
		return new CssSelector(selectors); 

	}

	/**
	 * Select a WebElement by its name.
	 * 
	 * @param name the name of the web element
	 * @return the Name object
	 */

	public static By name(final String name) {
		return new Name(name); 

	}

	/**
	 * Select a WebElement by its class name.
	 * 
	 * @param className the class name of the web element
	 * @return the ClassName object
	 */

	public static By className(final String className) {
		return new ClassName(className); 

	}

	/**
	 * Select a WebElement by its text content.
	 * 
	 * @param textContent the text content of the web element
	 * @return the TextContent object
	 */

	public static By textContent(final String textContent) {
		return new Text(textContent); 

	}
	
	/**
	 * Select a WebElement by its tag name.
	 * 
	 * @param tagName the tag name of the web element
	 * @return the TagName object
	 */

	public static By tagName(final String tagName) {
		return new TagName(tagName); 

	}

	/**
	 * Returns the value. 
	 * 
	 * @return the value
	 */
	
	public String getValue(){
		return "";
	}


	static class Id extends By {
		private final String id;

		public Id(String id) {
			this.id = id;
		}

		@Override
		public String getValue(){
			return id;
		}
	}

	static class Xpath extends By {
		private final String xpath;

		public Xpath(String xpath) {
			this.xpath = xpath;
		}

		@Override
		public String getValue(){
			return xpath;
		}
	}

	static class CssSelector extends By {
		private final String selector;

		public CssSelector(String selector) {
			this.selector = selector;
		}

		@Override
		public String getValue(){
			return selector;
		}
	}

	static class Name extends By {
		private final String name;

		public Name(String name) {
			this.name = name;
		}

		@Override
		public String getValue(){
			return name;
		}
	}
	
	static class ClassName extends By {
		private final String className;

		public ClassName(String className) {
			this.className = className;
		}

		@Override
		public String getValue(){
			return className;
		}
	}
	
	static class Text extends By {
		private final String textContent;

		public Text(String textContent) {
			this.textContent = textContent;
		}

		@Override
		public String getValue(){
			return textContent;
		}
	}
	
	static class TagName extends By {
		private final String tagName;
		
		public TagName(String tagName){
			this.tagName = tagName;
		}
		
		@Override
		public String getValue(){
			return tagName;
		}
	}
}

@#$
package com.robotium.solo;

import java.util.ArrayList;
import android.widget.CheckedTextView;
import android.widget.CompoundButton;
import android.widget.Spinner;
import android.widget.TextView;


/**
 * Contains various check methods. Examples are: isButtonChecked(),
 * isSpinnerTextSelected.
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class Checker {
	
	private final ViewFetcher viewFetcher;
	private final Waiter waiter;

	/**
	 * Constructs this object.
	 * 
	 * @param viewFetcher the {@code ViewFetcher} instance
     * @param waiter the {@code Waiter} instance
	 */
	
	public Checker(ViewFetcher viewFetcher, Waiter waiter){
		this.viewFetcher = viewFetcher;
		this.waiter = waiter;
	}

	
	/**
	 * Checks if a {@link CompoundButton} with a given index is checked.
	 *
	 * @param expectedClass the expected class, e.g. {@code CheckBox.class} or {@code RadioButton.class}
	 * @param index of the {@code CompoundButton} to check. {@code 0} if only one is available
	 * @return {@code true} if {@code CompoundButton} is checked and {@code false} if it is not checked
	 */
	
	public <T extends CompoundButton> boolean isButtonChecked(Class<T> expectedClass, int index)
	{
		return (waiter.waitForAndGetView(index, expectedClass).isChecked());
	}
	
	/**
	 * Checks if a {@link CompoundButton} with a given text is checked.
	 *
	 * @param expectedClass the expected class, e.g. {@code CheckBox.class} or {@code RadioButton.class}
	 * @param text the text that is expected to be checked
	 * @return {@code true} if {@code CompoundButton} is checked and {@code false} if it is not checked
	 */

	public <T extends CompoundButton> boolean isButtonChecked(Class<T> expectedClass, String text)
	{
		T button = waiter.waitForText(expectedClass, text, 0, Timeout.getSmallTimeout(), true);

		if(button != null && button.isChecked()){
			return true;
		}
		return false;
	}

	/**
	 * Checks if a {@link CheckedTextView} with a given text is checked.
	 *
	 * @param checkedTextView the {@code CheckedTextView} object
	 * @param text the text that is expected to be checked
	 * @return {@code true} if {@code CheckedTextView} is checked and {@code false} if it is not checked
	 */

	public boolean isCheckedTextChecked(String text)
	{
		CheckedTextView checkedTextView = waiter.waitForText(CheckedTextView.class, text, 0, Timeout.getSmallTimeout(), true);

		if(checkedTextView != null && checkedTextView.isChecked()) {
			return true;
		}
		return false;
	}

	
	/**
	 * Checks if a given text is selected in any {@link Spinner} located on the current screen.
	 * 
	 * @param text the text that is expected to be selected
	 * @return {@code true} if the given text is selected in any {@code Spinner} and false if it is not
	 */
	
	public boolean isSpinnerTextSelected(String text)
	{
		waiter.waitForAndGetView(0, Spinner.class);
				
		ArrayList<Spinner> spinnerList = viewFetcher.getCurrentViews(Spinner.class, true);
		for(int i = 0; i < spinnerList.size(); i++){
			if(isSpinnerTextSelected(i, text))
					return true;
		}
		return false;
	}
	
	/**
	 * Checks if a given text is selected in a given {@link Spinner} 
	 * @param spinnerIndex the index of the spinner to check. 0 if only one spinner is available
	 * @param text the text that is expected to be selected
	 * @return true if the given text is selected in the given {@code Spinner} and false if it is not
	 */
	
	public boolean isSpinnerTextSelected(int spinnerIndex, String text)
	{
		Spinner spinner = waiter.waitForAndGetView(spinnerIndex, Spinner.class);
		
		TextView textView = (TextView) spinner.getChildAt(0);
		if(textView.getText().equals(text))
			return true;
		else
			return false;
	}
}

@#$
package com.robotium.solo;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collection;
import junit.framework.Assert;
import android.app.Activity;
import android.app.Instrumentation;
import android.content.Context;
import android.os.SystemClock;
import android.util.Log;
import android.view.KeyEvent;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.Window;
import android.widget.AbsListView;
import android.widget.TextView;

/**
 * Contains various click methods. Examples are: clickOn(),
 * clickOnText(), clickOnScreen().
 *
 * @author Renas Reda, renas.reda@robotium.com
 *
 */

class Clicker {

	private final String LOG_TAG = "Robotium";
	private final ActivityUtils activityUtils;
	private final ViewFetcher viewFetcher;
	private final Instrumentation inst;
	private final Sender sender;
	private final Sleeper sleeper;
	private final Waiter waiter;
	private final WebUtils webUtils;
	private final DialogUtils dialogUtils;
	private final int MINI_WAIT = 200;
	private final int WAIT_TIME = 1500;


	/**
	 * Constructs this object.
	 *
	 * @param activityUtils the {@code ActivityUtils} instance
	 * @param viewFetcher the {@code ViewFetcher} instance
	 * @param sender the {@code Sender} instance
	 * @param inst the {@code android.app.Instrumentation} instance
	 * @param sleeper the {@code Sleeper} instance
	 * @param waiter the {@code Waiter} instance
	 * @param webUtils the {@code WebUtils} instance
	 * @param dialogUtils the {@code DialogUtils} instance
	 */

	public Clicker(ActivityUtils activityUtils, ViewFetcher viewFetcher, Sender sender, Instrumentation inst, Sleeper sleeper, Waiter waiter, WebUtils webUtils, DialogUtils dialogUtils) {

		this.activityUtils = activityUtils;
		this.viewFetcher = viewFetcher;
		this.sender = sender;
		this.inst = inst;
		this.sleeper = sleeper;
		this.waiter = waiter;
		this.webUtils = webUtils;
		this.dialogUtils = dialogUtils;
	}

	/**
	 * Clicks on a given coordinate on the screen.
	 *
	 * @param x the x coordinate
	 * @param y the y coordinate
	 */

	public void clickOnScreen(float x, float y, View view) {
		boolean successfull = false;
		int retry = 0;
		SecurityException ex = null;

		while(!successfull && retry < 10) {
			long downTime = SystemClock.uptimeMillis();
			long eventTime = SystemClock.uptimeMillis();
			MotionEvent event = MotionEvent.obtain(downTime, eventTime,
					MotionEvent.ACTION_DOWN, x, y, 0);
			MotionEvent event2 = MotionEvent.obtain(downTime, eventTime,
					MotionEvent.ACTION_UP, x, y, 0);
			try{
				inst.sendPointerSync(event);
				inst.sendPointerSync(event2);
				successfull = true;
			}catch(SecurityException e){
				ex = e;
				dialogUtils.hideSoftKeyboard(null, false, true);
				sleeper.sleep(MINI_WAIT);
				retry++;
				View identicalView = viewFetcher.getIdenticalView(view);
				if(identicalView != null){
					float[] xyToClick = getClickCoordinates(identicalView);
					x = xyToClick[0]; 
					y = xyToClick[1];
				}
			}
		}
		if(!successfull) {
			Assert.fail("Click at ("+x+", "+y+") can not be completed! ("+(ex != null ? ex.getClass().getName()+": "+ex.getMessage() : "null")+")");
		}
	}

	/**
	 * Long clicks a given coordinate on the screen.
	 *
	 * @param x the x coordinate
	 * @param y the y coordinate
	 * @param time the amount of time to long click
	 */

	public void clickLongOnScreen(float x, float y, int time, View view) {
		boolean successfull = false;
		int retry = 0;
		SecurityException ex = null;
		long downTime = SystemClock.uptimeMillis();
		long eventTime = SystemClock.uptimeMillis();
		MotionEvent event = MotionEvent.obtain(downTime, eventTime, MotionEvent.ACTION_DOWN, x, y, 0);

		while(!successfull && retry < 10) {
			try{
				inst.sendPointerSync(event);
				successfull = true;
				sleeper.sleep(MINI_WAIT);
			}catch(SecurityException e){
				ex = e;
				dialogUtils.hideSoftKeyboard(null, false, true);
				sleeper.sleep(MINI_WAIT);
				retry++;
				View identicalView = viewFetcher.getIdenticalView(view);
				if(identicalView != null){
					float[] xyToClick = getClickCoordinates(identicalView);
					x = xyToClick[0];
					y = xyToClick[1];
				}
			}
		}
		if(!successfull) {
			Assert.fail("Long click at ("+x+", "+y+") can not be completed! ("+(ex != null ? ex.getClass().getName()+": "+ex.getMessage() : "null")+")");
		}

		eventTime = SystemClock.uptimeMillis();
		event = MotionEvent.obtain(downTime, eventTime, MotionEvent.ACTION_MOVE, x + 1.0f, y + 1.0f, 0);
		inst.sendPointerSync(event);
		if(time > 0)
			sleeper.sleep(time);
		else
			sleeper.sleep((int)(ViewConfiguration.getLongPressTimeout() * 2.5f));

		eventTime = SystemClock.uptimeMillis();
		event = MotionEvent.obtain(downTime, eventTime, MotionEvent.ACTION_UP, x, y, 0);
		inst.sendPointerSync(event);
		sleeper.sleep();
	}


	/**
	 * Clicks on a given {@link View}.
	 *
	 * @param view the view that should be clicked
	 */

	public void clickOnScreen(View view) {
		clickOnScreen(view, false, 0);
	}

	/**
	 * Private method used to click on a given view.
	 *
	 * @param view the view that should be clicked
	 * @param longClick true if the click should be a long click
	 * @param time the amount of time to long click
	 */

	public void clickOnScreen(View view, boolean longClick, int time) {
		if(view == null)
			Assert.fail("View is null and can therefore not be clicked!");

		float[] xyToClick = getClickCoordinates(view);
		float x = xyToClick[0];
		float y = xyToClick[1];

		if(x == 0 || y == 0){
			sleeper.sleepMini();
			try {
				view = viewFetcher.getIdenticalView(view);
			} catch (Exception ignored){}

			if(view != null){
				xyToClick = getClickCoordinates(view);
				x = xyToClick[0];
				y = xyToClick[1];
			}
		}

		if (longClick)
			clickLongOnScreen(x, y, time, view);
		else
			clickOnScreen(x, y, view);
	}	

	/**
	 * Returns click coordinates for the specified view.
	 * 
	 * @param view the view to get click coordinates from
	 * @return click coordinates for a specified view
	 */

	private float[] getClickCoordinates(View view){
		sleeper.sleep(MINI_WAIT);
		int[] xyLocation = new int[2];
		float[] xyToClick = new float[2];

		view.getLocationOnScreen(xyLocation);

		final int viewWidth = view.getWidth();
		final int viewHeight = view.getHeight();
		final float x = xyLocation[0] + (viewWidth / 2.0f);
		float y = xyLocation[1] + (viewHeight / 2.0f);

		xyToClick[0] = x;
		xyToClick[1] = y;

		return xyToClick;
	}
	
	


	/**
	 * Long clicks on a specific {@link TextView} and then selects
	 * an item from the context menu that appears. Will automatically scroll when needed.
	 *
	 * @param text the text that should be clicked on. The parameter <strong>will</strong> be interpreted as a regular expression.
	 * @param index the index of the menu item that should be pressed
	 */

	public void clickLongOnTextAndPress(String text, int index)
	{
		clickOnText(text, true, 0, true, 0);
		dialogUtils.waitForDialogToOpen(Timeout.getSmallTimeout(), true);
		try{
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
		}catch(SecurityException e){
			Assert.fail("Can not press the context menu!");
		}
		for(int i = 0; i < index; i++)
		{
			sleeper.sleepMini();
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
		}
		inst.sendKeyDownUpSync(KeyEvent.KEYCODE_ENTER);
	}

	/**
	 * Opens the menu and waits for it to open.
	 */

	private void openMenu(){
		sleeper.sleepMini();

		if(!dialogUtils.waitForDialogToOpen(MINI_WAIT, false)) {
			try{
				sender.sendKeyCode(KeyEvent.KEYCODE_MENU);
				dialogUtils.waitForDialogToOpen(WAIT_TIME, true);
			}catch(SecurityException e){
				Assert.fail("Can not open the menu!");
			}
		}
	}

	/**
	 * Clicks on a menu item with a given text.
	 *
	 * @param text the menu text that should be clicked on. The parameter <strong>will</strong> be interpreted as a regular expression.
	 */

	public void clickOnMenuItem(String text)
	{
		openMenu();
		clickOnText(text, false, 1, true, 0);
	}

	/**
	 * Clicks on a menu item with a given text.
	 *
	 * @param text the menu text that should be clicked on. The parameter <strong>will</strong> be interpreted as a regular expression.
	 * @param subMenu true if the menu item could be located in a sub menu
	 */

	public void clickOnMenuItem(String text, boolean subMenu)
	{
		sleeper.sleepMini();

		TextView textMore = null;
		int [] xy = new int[2];
		int x = 0;
		int y = 0;

		if(!dialogUtils.waitForDialogToOpen(MINI_WAIT, false)) {
			try{
				sender.sendKeyCode(KeyEvent.KEYCODE_MENU);
				dialogUtils.waitForDialogToOpen(WAIT_TIME, true);
			}catch(SecurityException e){
				Assert.fail("Can not open the menu!");
			}
		}
		boolean textShown = waiter.waitForText(text, 1, WAIT_TIME, true) != null;

		if(subMenu && (viewFetcher.getCurrentViews(TextView.class, true).size() > 5) && !textShown){
			for(TextView textView : viewFetcher.getCurrentViews(TextView.class, true)){
				x = xy[0];
				y = xy[1];
				textView.getLocationOnScreen(xy);

				if(xy[0] > x || xy[1] > y)
					textMore = textView;
			}
		}
		if(textMore != null)
			clickOnScreen(textMore);

		clickOnText(text, false, 1, true, 0);
	}

	/**
	 * Clicks on an ActionBar item with a given resource id
	 *
	 * @param resourceId the R.id of the ActionBar item
	 */

	public void clickOnActionBarItem(int resourceId){
		sleeper.sleep();
		inst.invokeMenuActionSync(activityUtils.getCurrentActivity(), resourceId, 0);
	}

	/**
	 * Clicks on an ActionBar Home/Up button.
	 */

	public void clickOnActionBarHomeButton() {
		Activity activity = activityUtils.getCurrentActivity();
		MenuItem homeMenuItem = null;

		try {
			Class<?> cls = Class.forName("com.android.internal.view.menu.ActionMenuItem");
			Class<?> partypes[] = new Class[6];
			partypes[0] = Context.class;
			partypes[1] = Integer.TYPE;
			partypes[2] = Integer.TYPE;
			partypes[3] = Integer.TYPE;
			partypes[4] = Integer.TYPE;
			partypes[5] = CharSequence.class;
			Constructor<?> ct = cls.getConstructor(partypes);
			Object argList[] = new Object[6];
			argList[0] = activity;
			argList[1] = 0;
			argList[2] = android.R.id.home;
			argList[3] = 0;
			argList[4] = 0;
			argList[5] = "";
			homeMenuItem = (MenuItem) ct.newInstance(argList);
		} catch (Exception ex) {
			Log.d(LOG_TAG, "Can not find methods to invoke Home button!");
		}

		if (homeMenuItem != null) {
			try{
				activity.getWindow().getCallback().onMenuItemSelected(Window.FEATURE_OPTIONS_PANEL, homeMenuItem);
			}catch(Exception ignored) {}
		}
	}

	/**
	 * Clicks on a web element using the given By method.
	 *
	 * @param by the By object e.g. By.id("id");
	 * @param match if multiple objects match, this determines which one will be clicked
	 * @param scroll true if scrolling should be performed
	 * @param useJavaScriptToClick true if click should be perfomed through JavaScript
	 */

	public void clickOnWebElement(By by, int match, boolean scroll, boolean useJavaScriptToClick){
		WebElement webElement = null;
		
		if(useJavaScriptToClick){
			webElement = waiter.waitForWebElement(by, match, Timeout.getSmallTimeout(), false);
			if(webElement == null){
				Assert.fail("WebElement with " + webUtils.splitNameByUpperCase(by.getClass().getSimpleName()) + ": '" + by.getValue() + "' is not found!");
			}
			webUtils.executeJavaScript(by, true);
			return;
		}
		
		WebElement webElementToClick = waiter.waitForWebElement(by, match, Timeout.getSmallTimeout(), scroll);
		
		if(webElementToClick == null){
			if(match > 1) {
				Assert.fail(match + " WebElements with " + webUtils.splitNameByUpperCase(by.getClass().getSimpleName()) + ": '" + by.getValue() + "' are not found!");
			}
			else {
				Assert.fail("WebElement with " + webUtils.splitNameByUpperCase(by.getClass().getSimpleName()) + ": '" + by.getValue() + "' is not found!");
			}
		}
		
		clickOnScreen(webElementToClick.getLocationX(), webElementToClick.getLocationY(), null);
	}


	/**
	 * Clicks on a specific {@link TextView} displaying a given text.
	 *
	 * @param regex the text that should be clicked on. The parameter <strong>will</strong> be interpreted as a regular expression.
	 * @param longClick {@code true} if the click should be a long click
	 * @param match the regex match that should be clicked on
	 * @param scroll true if scrolling should be performed
	 * @param time the amount of time to long click
	 */

	public void clickOnText(String regex, boolean longClick, int match, boolean scroll, int time) {
		TextView textToClick = waiter.waitForText(regex, match, Timeout.getSmallTimeout(), scroll, true, false);

		if (textToClick != null) {
			clickOnScreen(textToClick, longClick, time);
		}

		else {

			if(match > 1){
				Assert.fail(match + " matches of text string: '" + regex +  "' are not found!");
			}

			else{
				ArrayList<TextView> allTextViews = RobotiumUtils.removeInvisibleViews(viewFetcher.getCurrentViews(TextView.class, true));
				allTextViews.addAll((Collection<? extends TextView>) webUtils.getTextViewsFromWebView());

				for (TextView textView : allTextViews) {
					Log.d(LOG_TAG, "'" + regex + "' not found. Have found: '" + textView.getText() + "'");
				}
				allTextViews = null;
				Assert.fail("Text string: '" + regex + "' is not found!");
			}
		}
	}


	/**
	 * Clicks on a {@code View} of a specific class, with a given text.
	 *
	 * @param viewClass what kind of {@code View} to click, e.g. {@code Button.class} or {@code TextView.class}
	 * @param nameRegex the name of the view presented to the user. The parameter <strong>will</strong> be interpreted as a regular expression.
	 */

	public <T extends TextView> void clickOn(Class<T> viewClass, String nameRegex) {
		T viewToClick = (T) waiter.waitForText(viewClass, nameRegex, 0, Timeout.getSmallTimeout(), true, true, false);

		if (viewToClick != null) {
			clickOnScreen(viewToClick);
		} else {
			ArrayList <T> allTextViews = RobotiumUtils.removeInvisibleViews(viewFetcher.getCurrentViews(viewClass, true));

			for (T view : allTextViews) {
				Log.d(LOG_TAG, "'" + nameRegex + "' not found. Have found: '" + view.getText() + "'");
			}
			Assert.fail(viewClass.getSimpleName() + " with text: '" + nameRegex + "' is not found!");
		}
	}

	/**
	 * Clicks on a {@code View} of a specific class, with a certain index.
	 *
	 * @param viewClass what kind of {@code View} to click, e.g. {@code Button.class} or {@code ImageView.class}
	 * @param index the index of the {@code View} to be clicked, within {@code View}s of the specified class
	 */

	public <T extends View> void clickOn(Class<T> viewClass, int index) {
		clickOnScreen(waiter.waitForAndGetView(index, viewClass));
	}


	/**
	 * Clicks on a certain list line and returns the {@link TextView}s that
	 * the list line is showing. Will use the first list it finds.
	 *
	 * @param line the line that should be clicked
	 * @return a {@code List} of the {@code TextView}s located in the list line
	 */

	public ArrayList<TextView> clickInList(int line) {
		return clickInList(line, 0, false, 0);
	}

	/**
	 * Clicks on a certain list line on a specified List and
	 * returns the {@link TextView}s that the list line is showing.
	 *
	 * @param line the line that should be clicked
	 * @param index the index of the list. E.g. Index 1 if two lists are available
	 * @return an {@code ArrayList} of the {@code TextView}s located in the list line
	 */

	public ArrayList<TextView> clickInList(int line, int index, boolean longClick, int time) {
		final long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();

		int lineIndex = line - 1;
		if(lineIndex < 0)
			lineIndex = 0;

		ArrayList<View> views = new ArrayList<View>();
		final AbsListView absListView = waiter.waitForAndGetView(index, AbsListView.class);

		if(absListView == null)
			Assert.fail("ListView is null!");

		while(lineIndex > absListView.getChildCount()){
			final boolean timedOut = SystemClock.uptimeMillis() > endTime;
			if (timedOut){
				int numberOfLines = absListView.getChildCount();
				Assert.fail("Can not click on line number " + line + " as there are only " + numberOfLines + " lines available");
			}
			sleeper.sleep();
		}

		View view = getViewOnListLine(absListView, index, lineIndex);

		if(view != null){
			views = viewFetcher.getViews(view, true);
			views = RobotiumUtils.removeInvisibleViews(views);
			clickOnScreen(view, longClick, time);
		}
		return RobotiumUtils.filterViews(TextView.class, views);
	}

	/**
	 * Returns the view in the specified list line
	 * 
	 * @param absListView the ListView to use
	 * @param index the index of the list. E.g. Index 1 if two lists are available
	 * @param lineIndex the line index of the View
	 * @return the View located at a specified list line
	 */

	private View getViewOnListLine(AbsListView absListView, int index, int lineIndex){
		final long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();
		View view = absListView.getChildAt(lineIndex);

		while(view == null){
			final boolean timedOut = SystemClock.uptimeMillis() > endTime;
			if (timedOut){
				Assert.fail("View is null and can therefore not be clicked!");
			}
			
			sleeper.sleep();
			absListView = (AbsListView) viewFetcher.getIdenticalView(absListView);

			if(absListView == null){
				absListView = waiter.waitForAndGetView(index, AbsListView.class);
			}
			
			view = absListView.getChildAt(lineIndex);
		}
		return view;
	}
}

@#$
package com.robotium.solo;

/**
 * Represents a conditional statement.<br/>
 * Implementations may be used with {@link Solo#waitForCondition(Condition, int)}.
 */
public interface Condition {

	/**
	 * Should do the necessary work needed to check a condition and then return whether this condition is satisfied or not.
	 * @return {@code true} if condition is satisfied and {@code false} if it is not satisfied
	 */
	public boolean isSatisfied();

}

@#$
package com.robotium.solo;


import android.app.Activity;
import android.content.Context;
import android.os.SystemClock;
import android.view.ContextThemeWrapper;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;


/**
 * Contains the waitForDialogToClose() method.
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class DialogUtils {

	private final ActivityUtils activityUtils;
	private final ViewFetcher viewFetcher;
	private final Sleeper sleeper;
	private final static int TIMEOUT_DIALOG_TO_CLOSE = 1000;
	private final int MINISLEEP = 200;

	/**
	 * Constructs this object.
	 * 
	 * @param activityUtils the {@code ActivityUtils} instance
	 * @param viewFetcher the {@code ViewFetcher} instance
	 * @param sleeper the {@code Sleeper} instance
	 */

	public DialogUtils(ActivityUtils activityUtils, ViewFetcher viewFetcher, Sleeper sleeper) {
		this.activityUtils = activityUtils;
		this.viewFetcher = viewFetcher;
		this.sleeper = sleeper;
	}


	/**
	 * Waits for a {@link android.app.Dialog} to close.
	 *
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if the {@code Dialog} is closed before the timeout and {@code false} if it is not closed
	 */

	public boolean waitForDialogToClose(long timeout) {
		waitForDialogToOpen(TIMEOUT_DIALOG_TO_CLOSE, false);
		final long endTime = SystemClock.uptimeMillis() + timeout;

		while (SystemClock.uptimeMillis() < endTime) {

			if(!isDialogOpen()){
				return true;
			}
			sleeper.sleep(MINISLEEP);
		}
		return false;
	}



	/**
	 * Waits for a {@link android.app.Dialog} to open.
	 *
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if the {@code Dialog} is opened before the timeout and {@code false} if it is not opened
	 */

	public boolean waitForDialogToOpen(long timeout, boolean sleepFirst) {
		final long endTime = SystemClock.uptimeMillis() + timeout;
		boolean dialogIsOpen = isDialogOpen();

		if(sleepFirst)
			sleeper.sleep();
		
		if(dialogIsOpen){
			return true;
		}

		while (SystemClock.uptimeMillis() < endTime) {

			if(isDialogOpen()){
				return true;
			}
			sleeper.sleepMini();
		}
		return false;
	}

	/**
	 * Checks if a dialog is open. 
	 * 
	 * @return true if dialog is open
	 */

	private boolean isDialogOpen(){
		final Activity activity = activityUtils.getCurrentActivity(false);
		final View[] views = viewFetcher.getWindowDecorViews();
		View view = viewFetcher.getRecentDecorView(views);	
		
		if(!isDialog(activity, view)){
			for(View v : views){
				if(isDialog(activity, v)){
					return true;
				}
			}
		}
		else {
			return true;
		}
		return false;
	}
	
	/**
	 * Checks that the specified DecorView and the Activity DecorView are not equal.
	 * 
	 * @param activity the activity which DecorView is to be compared
	 * @param decorView the DecorView to compare
	 * @return true if not equal
	 */
	
	private boolean isDialog(Activity activity, View decorView){
		if(decorView == null || !decorView.isShown()){
			return false;
		}
		Context viewContext = null;
		if(decorView != null){
			viewContext = decorView.getContext();
		}
		
		if (viewContext instanceof ContextThemeWrapper) {
			ContextThemeWrapper ctw = (ContextThemeWrapper) viewContext;
			viewContext = ctw.getBaseContext();
		}
		Context activityContext = activity;
		Context activityBaseContext = activity.getBaseContext();
		return (activityContext.equals(viewContext) || activityBaseContext.equals(viewContext)) && (decorView != activity.getWindow().getDecorView());
	}

	/**
	 * Hides the soft keyboard
	 * 
	 * @param shouldSleepFirst whether to sleep a default pause first
	 * @param shouldSleepAfter whether to sleep a default pause after
	 */

	public void hideSoftKeyboard(EditText editText, boolean shouldSleepFirst, boolean shouldSleepAfter) {
		Activity activity = activityUtils.getCurrentActivity(shouldSleepFirst);

		InputMethodManager inputMethodManager = (InputMethodManager)  activity.getSystemService(Activity.INPUT_METHOD_SERVICE);

		if(editText != null) {
			inputMethodManager.hideSoftInputFromWindow(editText.getWindowToken(), 0);
			return;
		}
		View focusedView = activity.getCurrentFocus();

		if(!(focusedView instanceof EditText)) {
			EditText freshestEditText = viewFetcher.getFreshestView(viewFetcher.getCurrentViews(EditText.class, true));
			if(freshestEditText != null){
				focusedView = freshestEditText;
			}
		}
		if(focusedView != null) {
			inputMethodManager.hideSoftInputFromWindow(focusedView.getWindowToken(), 0);
		}
		if(shouldSleepAfter){
			sleeper.sleep();
		}
	}
}

@#$
package com.robotium.solo;

import java.nio.IntBuffer;
import java.util.concurrent.CountDownLatch;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;
import android.graphics.Bitmap;
import android.opengl.GLES20;
import android.opengl.GLSurfaceView;
import android.opengl.GLSurfaceView.Renderer;
import android.view.View;

/**
 * Used to wrap and replace the renderer to gain access to the gl context.  
 * 
 * @author Per-Erik Bergman, bergman@uncle.se
 * 
 */

class GLRenderWrapper implements Renderer {

	private Renderer renderer;
	private int width;
	private int height;
	private final GLSurfaceView view;
	private CountDownLatch latch;
	private boolean takeScreenshot = true;
	private int glVersion;

	/**
	 * Constructs this object.
	 * 
	 * @param view the current glSurfaceView
	 * @param renderer the renderer to wrap
	 * @param latch the count down latch
	 */
	
	public GLRenderWrapper(GLSurfaceView view,
			Renderer renderer, CountDownLatch latch) {
		this.view = view;
		this.renderer = renderer;
		this.latch = latch;
		
		this.width = view.getWidth();
		this.height = view.getHeight();
		
		Integer out = new Reflect(view).field("mEGLContextClientVersion")
				.out(Integer.class);
		if ( out != null ) {
			this.glVersion = out.intValue();
		} else {
			this.glVersion = -1;
			this.takeScreenshot = false;
		}
	}

	@Override
	/*
	 * (non-Javadoc)
	 * @see android.opengl.GLSurfaceView.Renderer#onSurfaceCreated(javax.microedition.khronos.opengles.GL10, javax.microedition.khronos.egl.EGLConfig)
	 */
	
	public void onSurfaceCreated(GL10 gl, EGLConfig config) {
		renderer.onSurfaceCreated(gl, config);
	}

	@Override
	/*
	 * (non-Javadoc)
	 * @see android.opengl.GLSurfaceView.Renderer#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)
	 */
	
	public void onSurfaceChanged(GL10 gl, int width, int height) {
		this.width = width;
		this.height = height;
		renderer.onSurfaceChanged(gl, width, height);
	}

	@Override
	/*
	 * (non-Javadoc)
	 * @see android.opengl.GLSurfaceView.Renderer#onDrawFrame(javax.microedition.khronos.opengles.GL10)
	 */
	
	public void onDrawFrame(GL10 gl) {
		renderer.onDrawFrame(gl);
		if (takeScreenshot) {
			Bitmap screenshot = null;

			if (glVersion >= 2) {
				screenshot = savePixels(0, 0, width, height);
			} else {
				screenshot = savePixels(0, 0, width, height, gl);
			}

			new Reflect(view).field("mDrawingCache").type(View.class)
					.in(screenshot);
			latch.countDown();
			takeScreenshot = false;
		}
	}

	/**
	 * Tell the wrapper to take a screen shot 
	 */
	
	public void setTakeScreenshot() {
		takeScreenshot = true;
	}

	/**
	 * Set the count down latch 
	 */

	public void setLatch(CountDownLatch latch) {
		this.latch = latch;
	}

	/**
	 * Extract the bitmap from OpenGL 
	 * 
	 * @param x the start column
	 * @param y the start line
	 * @param w the width of the bitmap
	 * @param h the height of the bitmap
	 */
	
	private Bitmap savePixels(int x, int y, int w, int h) {
		int b[] = new int[w * (y + h)];
		int bt[] = new int[w * h];
		IntBuffer ib = IntBuffer.wrap(b);
		ib.position(0);
		GLES20.glReadPixels(x, 0, w, y + h, GLES20.GL_RGBA,
				GLES20.GL_UNSIGNED_BYTE, ib);

		for (int i = 0, k = 0; i < h; i++, k++) {
			// remember, that OpenGL bitmap is incompatible with Android bitmap
			// and so, some correction need.
			for (int j = 0; j < w; j++) {
				int pix = b[i * w + j];
				int pb = (pix >> 16) & 0xff;
				int pr = (pix << 16) & 0x00ff0000;
				int pix1 = (pix & 0xff00ff00) | pr | pb;
				bt[(h - k - 1) * w + j] = pix1;
			}
		}

		Bitmap sb = Bitmap.createBitmap(bt, w, h, Bitmap.Config.ARGB_8888);
		return sb;
	}

	/**
	 * Extract the bitmap from OpenGL 
	 * 
	 * @param x the start column
	 * @param y the start line
	 * @param w the width of the bitmap
	 * @param h the height of the bitmap
	 * @param gl the current GL reference
	 */
	
	private static Bitmap savePixels(int x, int y, int w, int h, GL10 gl) {
		int b[] = new int[w * (y + h)];
		int bt[] = new int[w * h];
		IntBuffer ib = IntBuffer.wrap(b);
		ib.position(0);
		gl.glReadPixels(x, 0, w, y + h, GL10.GL_RGBA, GL10.GL_UNSIGNED_BYTE, ib);

		for (int i = 0, k = 0; i < h; i++, k++) {
			// remember, that OpenGL bitmap is incompatible with Android bitmap
			// and so, some correction need.
			for (int j = 0; j < w; j++) {
				int pix = b[i * w + j];
				int pb = (pix >> 16) & 0xff;
				int pr = (pix << 16) & 0x00ff0000;
				int pix1 = (pix & 0xff00ff00) | pr | pb;
				bt[(h - k - 1) * w + j] = pix1;
			}
		}

		Bitmap sb = Bitmap.createBitmap(bt, w, h, Bitmap.Config.ARGB_8888);
		return sb;
	}

}

@#$
package com.robotium.solo;

import junit.framework.Assert;
import android.app.Activity;
import android.app.Instrumentation;
import android.content.Context;
import android.view.View;
import android.widget.TextView;


/**
 * Contains various get methods. Examples are: getView(int id),
 * getView(Class<T> classToFilterBy, int index).
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class Getter {

	private final Instrumentation instrumentation;
	private final ActivityUtils activityUtils;
	private final Waiter waiter;
	private final int TIMEOUT = 1000;

	/**
	 * Constructs this object.
	 * 
	 * @param inst the {@code Instrumentation} instance
	 * @param viewFetcher the {@code ViewFetcher} instance
	 * @param waiter the {@code Waiter} instance
	 */

	public Getter(Instrumentation instrumentation, ActivityUtils activityUtils, Waiter waiter){
		this.instrumentation = instrumentation;
		this.activityUtils = activityUtils;
		this.waiter = waiter;
	}


	/**
	 * Returns a {@code View} with a certain index, from the list of current {@code View}s of the specified type.
	 *
	 * @param classToFilterBy which {@code View}s to choose from
	 * @param index choose among all instances of this type, e.g. {@code Button.class} or {@code EditText.class}
	 * @return a {@code View} with a certain index, from the list of current {@code View}s of the specified type
	 */

	public <T extends View> T getView(Class<T> classToFilterBy, int index) {
		return waiter.waitForAndGetView(index, classToFilterBy);
	}

	/**
	 * Returns a {@code View} that shows a given text, from the list of current {@code View}s of the specified type.
	 *
	 * @param classToFilterBy which {@code View}s to choose from
	 * @param text the text that the view shows
	 * @param onlyVisible {@code true} if only visible texts on the screen should be returned
	 * @return a {@code View} showing a given text, from the list of current {@code View}s of the specified type
	 */

	public <T extends TextView> T getView(Class<T> classToFilterBy, String text, boolean onlyVisible) {

		T viewToReturn = (T) waiter.waitForText(classToFilterBy, text, 0, Timeout.getSmallTimeout(), false, onlyVisible, false);

		if(viewToReturn == null)
			Assert.fail(classToFilterBy.getSimpleName() + " with text: '" + text + "' is not found!");

		return viewToReturn;
	}

	/**
	 * Returns a localized string
	 * 
	 * @param id the resource ID for the string
	 * @return the localized string
	 */

	public String getString(int id)
	{
		Activity activity = activityUtils.getCurrentActivity(false);
		return activity.getString(id);
	}

	/**
	 * Returns a localized string
	 * 
	 * @param id the resource ID for the string
	 * @return the localized string
	 */

	public String getString(String id)
	{
		Context targetContext = instrumentation.getTargetContext(); 
		String packageName = targetContext.getPackageName(); 
		int viewId = targetContext.getResources().getIdentifier(id, "string", packageName);
		if(viewId == 0){
			viewId = targetContext.getResources().getIdentifier(id, "string", "android");
		}
		return getString(viewId);		
	}
	
	/**
	 * Returns a {@code View} with a given id.
	 * 
	 * @param id the R.id of the {@code View} to be returned
	 * @param index the index of the {@link View}. {@code 0} if only one is available
	 * @param timeout the timeout in milliseconds
	 * @return a {@code View} with a given id
	 */

	public View getView(int id, int index, int timeout){
		final Activity activity = activityUtils.getCurrentActivity(false);
		View viewToReturn = null;

		if(index < 1){
			index = 0;
			viewToReturn = activity.findViewById(id);
		}

		if (viewToReturn != null) {
			return viewToReturn;
		}

		return waiter.waitForView(id, index, timeout);
	}

	/**
	 * Returns a {@code View} with a given id.
	 * 
	 * @param id the R.id of the {@code View} to be returned
	 * @param index the index of the {@link View}. {@code 0} if only one is available
	 * @return a {@code View} with a given id
	 */

	public View getView(int id, int index){
		return getView(id, index, 0);
	}

	/**
	 * Returns a {@code View} with a given id.
	 * 
	 * @param id the id of the {@link View} to return
	 * @param index the index of the {@link View}. {@code 0} if only one is available
	 * @return a {@code View} with a given id
	 */

	public View getView(String id, int index){
		View viewToReturn = null;
		Context targetContext = instrumentation.getTargetContext(); 
		String packageName = targetContext.getPackageName(); 
		int viewId = targetContext.getResources().getIdentifier(id, "id", packageName);

		if(viewId != 0){
			viewToReturn = getView(viewId, index, TIMEOUT); 
		}
		
		if(viewToReturn == null){
			int androidViewId = targetContext.getResources().getIdentifier(id, "id", "android");
			if(androidViewId != 0){
				viewToReturn = getView(androidViewId, index, TIMEOUT);
			}
		}

		if(viewToReturn != null){
			return viewToReturn;
		}
		return getView(viewId, index); 
	}
}

@#$
package com.robotium.solo;

import android.widget.EditText;
import android.widget.Spinner;
import junit.framework.Assert;
import android.app.Instrumentation;
import android.view.KeyEvent;
import android.view.inputmethod.EditorInfo;

/**
 * Contains press methods. Examples are pressMenuItem(),
 * pressSpinnerItem().
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class Presser{

	private final Clicker clicker;
	private final Instrumentation inst;
	private final Sleeper sleeper;
	private final Waiter waiter;
	private final DialogUtils dialogUtils;
	private final ViewFetcher viewFetcher;


	/**
	 * Constructs this object.
	 *
	 * @param viewFetcher the {@code ViewFetcher} instance
	 * @param clicker the {@code Clicker} instance
	 * @param inst the {@code Instrumentation} instance
	 * @param sleeper the {@code Sleeper} instance
	 * @param waiter the {@code Waiter} instance
	 * @param dialogUtils the {@code DialogUtils} instance
	 */

	public Presser(ViewFetcher viewFetcher, Clicker clicker, Instrumentation inst, Sleeper sleeper, Waiter waiter, DialogUtils dialogUtils) {
		this.viewFetcher = viewFetcher;
		this.clicker = clicker;
		this.inst = inst;
		this.sleeper = sleeper;
		this.waiter = waiter;
		this.dialogUtils = dialogUtils;
	}


	/**
	 * Presses a {@link android.view.MenuItem} with a given index. Index {@code 0} is the first item in the
	 * first row, Index {@code 3} is the first item in the second row and
	 * index {@code 5} is the first item in the third row.
	 *
	 * @param index the index of the {@code MenuItem} to be pressed
	 */

	public void pressMenuItem(int index){
		pressMenuItem(index, 3);
	}

	/**
	 * Presses a {@link android.view.MenuItem} with a given index. Supports three rows with a given amount
	 * of items. If itemsPerRow equals 5 then index 0 is the first item in the first row, 
	 * index 5 is the first item in the second row and index 10 is the first item in the third row.
	 * 
	 * @param index the index of the {@code MenuItem} to be pressed
	 * @param itemsPerRow the amount of menu items there are per row.   
	 */

	public void pressMenuItem(int index, int itemsPerRow) {	
		int[] row = new int[4];
		for(int i = 1; i <=3; i++)
			row[i] = itemsPerRow*i;

		sleeper.sleep();
		try{
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_MENU);
			dialogUtils.waitForDialogToOpen(Timeout.getSmallTimeout(), true);
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_UP);
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_UP);
		}catch(SecurityException e){
			Assert.fail("Can not press the menu!");
		}
		if (index < row[1]) {
			for (int i = 0; i < index; i++) {
				sleeper.sleepMini();
				inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_RIGHT);
			}
		} else if (index >= row[1] && index < row[2]) {
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);	

			for (int i = row[1]; i < index; i++) {
				sleeper.sleepMini();
				inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_RIGHT);
			}
		} else if (index >= row[2]) {
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);	
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);	

			for (int i = row[2]; i < index; i++) {
				sleeper.sleepMini();
				inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_RIGHT);
			}
		}

		try{
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_ENTER);
		}catch (SecurityException ignored) {}
	}
	
	/**
	 * Presses the soft keyboard search/next button.
	 * 
	 * @param search true if search button should be pressed otherwise next is pressed
	 *  
	 */

	public void pressSoftKeyboardSearchOrNextButton(final boolean search){
		final EditText freshestEditText = viewFetcher.getFreshestView(viewFetcher.getCurrentViews(EditText.class, true));
		if(freshestEditText != null){
			inst.runOnMainSync(new Runnable()
			{
				public void run()
				{
					if(search){
						freshestEditText.onEditorAction(EditorInfo.IME_ACTION_SEARCH); 
					}
					else {
						freshestEditText.onEditorAction(EditorInfo.IME_ACTION_NEXT); 	
					}
				}
			});
		}
	}

	/**
	 * Presses on a {@link android.widget.Spinner} (drop-down menu) item.
	 *
	 * @param spinnerIndex the index of the {@code Spinner} menu to be used
	 * @param itemIndex the index of the {@code Spinner} item to be pressed relative to the currently selected item.
	 * A Negative number moves up on the {@code Spinner}, positive moves down
	 */

	public void pressSpinnerItem(int spinnerIndex, int itemIndex)
	{	
		clicker.clickOnScreen(waiter.waitForAndGetView(spinnerIndex, Spinner.class));
		dialogUtils.waitForDialogToOpen(Timeout.getSmallTimeout(), true);

		try{
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
		}catch(SecurityException ignored){}

		boolean countingUp = true;
		if(itemIndex < 0){
			countingUp = false;
			itemIndex *= -1;
		}
		for(int i = 0; i < itemIndex; i++)
		{
			sleeper.sleepMini();
			if(countingUp){
				try{
					inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);
				}catch(SecurityException ignored){}
			}else{
				try{
					inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_UP);
				}catch(SecurityException ignored){}
			}
		}
		try{
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_ENTER);
		}catch(SecurityException ignored){}
	}
}

@#$
package com.robotium.solo;

import java.lang.reflect.Field;

/**
 * A reflection utility class.  
 * 
 * @author Per-Erik Bergman, bergman@uncle.se
 * 
 */

class Reflect {
	private Object object;

	/**
	 * Constructs this object 
	 * 
	 * @param object the object to reflect on
	 */
	
	public Reflect(Object object) {
		if (object == null)
			throw new IllegalArgumentException("Object can not be null.");
		this.object = object;
	}

	/**
	 * Get a field from the object 
	 * 
	 * @param name the name of the field
	 * 
	 * @return a field reference
	 */
	
	public FieldRf field(String name) {
		return new FieldRf(object, name);
	}

	/**
	 * A field reference.  
	 */
	public class FieldRf {
		private Class<?> clazz;
		private Object object;
		private String name;

		/**
		 * Constructs this object 
		 * 
		 * @param object the object to reflect on
		 * @param name the name of the field
		 */
		
		public FieldRf(Object object, String name) {
			this.object = object;
			this.name = name;
		}

		/**
		 * Constructs this object 
		 * 
		 * @param outclazz the output type
		 *
		 * @return <T> T
		 */
		
		public <T> T out(Class<T> outclazz) {
			Field field = getField();
			Object obj = getValue(field);
			return outclazz.cast(obj);
		}

		/**
		 * Set a value to a field 
		 * 
		 * @param value the value to set
		 */
		
		public void in(Object value) {
			Field field = getField();
			try {
				field.set(object, value);
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			}
		}

		/**
		 * Set the class type 
		 * 
		 * @param clazz the type
		 *
		 * @return a field reference
		 */
		
		public FieldRf type(Class<?> clazz) {
			this.clazz = clazz;
			return this;
		}

		private Field getField() {
			if (clazz == null) {
				clazz = object.getClass();
			}

			Field field = null;
			try {
				field = clazz.getDeclaredField(name);
				field.setAccessible(true);
			} catch (NoSuchFieldException ignored) {}
			return field;
		}

		private Object getValue(Field field) {
			if (field == null) {
				return null;
			}
			Object obj = null;
			try {
				obj = field.get(object);
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			}
			return obj;
		}
	}

}

@#$
package com.robotium.solo;

import android.content.Context;
import android.widget.TextView;

/**
 * Used to create a TextView object that is based on a web element. Contains the web element text and location.  
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class RobotiumTextView extends TextView {
	private int locationX = 0;
	private int locationY = 0;

	/**
	 * Constructs this object
	 * 
	 * @param context the given context
	 */
	
	public RobotiumTextView(Context context){
		super(context);
	}
	
	/**
	 * Constructs this object 
	 * 
	 * @param context the given context
	 * @param text the given text to be set
	 */
	
	public RobotiumTextView(Context context, String text, int locationX, int locationY) {
		super(context);
		this.setText(text);
		setLocationX(locationX);
		setLocationY(locationY);
	}

	/**
	 * Returns the location on screen of the {@code TextView} that is based on a web element
	 */
	
	@Override
	public void getLocationOnScreen(int[] location) {

		location[0] = locationX;
		location[1] = locationY;
	}
	
	/**
	 * Sets the X location of the TextView
	 * 
	 * @param locationX the X location of the {@code TextView}
	 */
	
	public void setLocationX(int locationX){
		this.locationX = locationX;
	}
	
	
	/**
	 * Sets the Y location
	 * 
	 * @param locationY the Y location of the {@code TextView}
	 */
	
	public void setLocationY(int locationY){
		this.locationY = locationY;
	}

}

@#$
package com.robotium.solo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import android.view.View;
import android.widget.TextView;

/**
 * Contains utility methods. Examples are: removeInvisibleViews(Iterable<T> viewList),
 * filterViews(Class<T> classToFilterBy, Iterable<?> viewList), sortViewsByLocationOnScreen(List<? extends View> views).
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

public class RobotiumUtils {


	/**
	 * Removes invisible Views.
	 * 
	 * @param viewList an Iterable with Views that is being checked for invisible Views
	 * @return a filtered Iterable with no invisible Views
	 */

	public static <T extends View> ArrayList<T> removeInvisibleViews(Iterable<T> viewList) {
		ArrayList<T> tmpViewList = new ArrayList<T>();
		for (T view : viewList) {
			if (view != null && view.isShown()) {
				tmpViewList.add(view);
			}
		}
		return tmpViewList;
	}

	/**
	 * Filters Views based on the given class type.
	 * 
	 * @param classToFilterBy the class to filter
	 * @param viewList the Iterable to filter from
	 * @return an ArrayList with filtered views
	 */

	public static <T> ArrayList<T> filterViews(Class<T> classToFilterBy, Iterable<?> viewList) {
		ArrayList<T> filteredViews = new ArrayList<T>();
		for (Object view : viewList) {
			if (view != null && classToFilterBy.isAssignableFrom(view.getClass())) {
				filteredViews.add(classToFilterBy.cast(view));
			}
		}
		viewList = null;
		return filteredViews;
	}

	/**
	 * Filters all Views not within the given set.
	 *
	 * @param classSet contains all classes that are ok to pass the filter
	 * @param viewList the Iterable to filter form
	 * @return an ArrayList with filtered views
	 */

	public static ArrayList<View> filterViewsToSet(Class<View> classSet[], Iterable<View> viewList) {
		ArrayList<View> filteredViews = new ArrayList<View>();
		for (View view : viewList) {
			if (view == null)
				continue;
			for (Class<View> filter : classSet) {
				if (filter.isAssignableFrom(view.getClass())) {
					filteredViews.add(view);
					break;
				}
			}
		}
		return filteredViews;
	}

	/**
	 * Orders Views by their location on-screen.
	 * 
	 * @param views The views to sort
	 * @see ViewLocationComparator
	 */

	public static void sortViewsByLocationOnScreen(List<? extends View> views) {
		Collections.sort(views, new ViewLocationComparator());
	}

	/**
	 * Orders Views by their location on-screen.
	 * 
	 * @param views The views to sort
	 * @param yAxisFirst Whether the y-axis should be compared before the x-axis
	 * @see ViewLocationComparator
	 */

	public static void sortViewsByLocationOnScreen(List<? extends View> views, boolean yAxisFirst) {
		Collections.sort(views, new ViewLocationComparator(yAxisFirst));
	}

	/**
	 * Checks if a View matches a certain string and returns the amount of total matches.
	 * 
	 * @param regex the regex to match
	 * @param view the view to check
	 * @param uniqueTextViews set of views that have matched
	 * @return number of total matches
	 */

	public static int getNumberOfMatches(String regex, TextView view, Set<TextView> uniqueTextViews){
		if(view == null) {
			return uniqueTextViews.size();
		}
		
		Pattern pattern = null;
		try{
			pattern = Pattern.compile(regex);
		}catch(PatternSyntaxException e){
			pattern = Pattern.compile(regex, Pattern.LITERAL);
		}
		
		Matcher matcher = pattern.matcher(view.getText().toString());
		
		if (matcher.find()){
			uniqueTextViews.add(view);
		}
		
		if (view.getError() != null){
			matcher = pattern.matcher(view.getError().toString());
			if (matcher.find()){
				uniqueTextViews.add(view);
			}
		}	
		if (view.getText().toString().equals("") && view.getHint() != null){
			matcher = pattern.matcher(view.getHint().toString());
			if (matcher.find()){
				uniqueTextViews.add(view);
			}
		}	
		return uniqueTextViews.size();		
	}

	/**
	 * Filters a collection of Views and returns a list that contains only Views
	 * with text that matches a specified regular expression.
	 * 
	 * @param views The collection of views to scan
	 * @param regex The text pattern to search for
	 * @return A list of views whose text matches the given regex
	 */

	public static <T extends TextView> List<T> filterViewsByText(Iterable<T> views, String regex) {
		return filterViewsByText(views, Pattern.compile(regex));
	}

	/**
	 * Filters a collection of Views and returns a list that contains only Views
	 * with text that matches a specified regular expression.
	 * 
	 * @param views The collection of views to scan
	 * @param regex The text pattern to search for
	 * @return A list of views whose text matches the given regex
	 */

	public static <T extends TextView> List<T> filterViewsByText(Iterable<T> views, Pattern regex) {
		final ArrayList<T> filteredViews = new ArrayList<T>();
		for (T view : views) {
			if (view != null && regex.matcher(view.getText()).matches()) {
				filteredViews.add(view);
			}
		}
		return filteredViews;
	}
}

@#$
package com.robotium.solo;

import java.util.List;
import android.app.Instrumentation;
import android.graphics.Bitmap;
import android.os.Message;
import android.view.View;
import android.webkit.ConsoleMessage;
import android.webkit.GeolocationPermissions;
import android.webkit.JsPromptResult;
import android.webkit.JsResult;
import android.webkit.ValueCallback;
import android.webkit.WebChromeClient;
import android.webkit.WebStorage;
import android.webkit.WebView;

/**
 * WebChromeClient used to get information on web elements by injections of JavaScript. 
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class RobotiumWebClient extends WebChromeClient{
	WebElementCreator webElementCreator;
	private Instrumentation inst;
	private WebChromeClient robotiumWebClient;
	private WebChromeClient originalWebChromeClient = null;


	/**
	 * Constructs this object.
	 *
	 * @param instrumentation the {@code Instrumentation} instance
	 * @param webElementCreator the {@code WebElementCreator} instance
	 */

	public RobotiumWebClient(Instrumentation inst, WebElementCreator webElementCreator){
		this.inst = inst;
		this.webElementCreator = webElementCreator;
		robotiumWebClient = this;
	}

	/**
	 * Enables JavaScript in the given {@code WebViews} objects.
	 * 
	 * @param webViews the {@code WebView} objects to enable JavaScript in
	 */

	public void enableJavascriptAndSetRobotiumWebClient(List<WebView> webViews, WebChromeClient originalWebChromeClient){
		this.originalWebChromeClient = originalWebChromeClient;

		for(final WebView webView : webViews){

			if(webView != null){ 
				inst.runOnMainSync(new Runnable() {
					public void run() {
						webView.getSettings().setJavaScriptEnabled(true);
						webView.setWebChromeClient(robotiumWebClient);

					}
				});
			}
		}
	}

	/**
	 * Overrides onJsPrompt in order to create {@code WebElement} objects based on the web elements attributes prompted by the injections of JavaScript
	 */

	@Override
	public boolean onJsPrompt(WebView view, String url, String message,	String defaultValue, JsPromptResult r) {

		if(message != null && (message.contains(";,") || message.contains("robotium-finished"))){

			if(message.equals("robotium-finished")){
				webElementCreator.setFinished(true);
			}
			else{
				webElementCreator.createWebElementAndAddInList(message, view);
			}
			r.confirm();
			return true;
		}
		else {
			if(originalWebChromeClient != null) {
				return originalWebChromeClient.onJsPrompt(view, url, message, defaultValue, r); 
			}
			return true;
		}

	}

	@Override
	public Bitmap getDefaultVideoPoster() {
		if (originalWebChromeClient != null) {
			return originalWebChromeClient.getDefaultVideoPoster();
		} 
		return null;
	}

	@Override
	public View getVideoLoadingProgressView() {
		if (originalWebChromeClient != null) {
			return originalWebChromeClient.getVideoLoadingProgressView();
		} 
		return null;
	}

	@Override
	public void getVisitedHistory(ValueCallback<String[]> callback) {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.getVisitedHistory(callback);
		} 
	}

	@Override
	public void onCloseWindow(WebView window) {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onCloseWindow(window);
		} 
	}

	@Override
	public void onConsoleMessage(String message, int lineNumber, String sourceID) {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onConsoleMessage(message, lineNumber, sourceID);
		}
	}

	@Override
	public boolean onConsoleMessage(ConsoleMessage consoleMessage) {       
		if (originalWebChromeClient != null) {
			return originalWebChromeClient.onConsoleMessage(consoleMessage);
		} 
		return true;
	}

	@Override
	public boolean onCreateWindow(WebView view, boolean isDialog, boolean isUserGesture, Message resultMsg) {
		if (originalWebChromeClient != null) {
			return originalWebChromeClient.onCreateWindow(view, isDialog, isUserGesture, resultMsg);
		} 
		return true;
	}

	@Override
	public void onExceededDatabaseQuota(String url, String databaseIdentifier, long quota,
			long estimatedDatabaseSize, long totalQuota, WebStorage.QuotaUpdater quotaUpdater) {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onExceededDatabaseQuota(url, databaseIdentifier, quota, estimatedDatabaseSize, totalQuota, quotaUpdater);
		} 
	}

	@Override
	public void onGeolocationPermissionsHidePrompt() {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onGeolocationPermissionsHidePrompt();
		} 
	}

	@Override
	public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onGeolocationPermissionsShowPrompt(origin, callback);
		} 
	}

	@Override
	public void onHideCustomView() {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onHideCustomView();
		} 
	}

	@Override
	public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
		if (originalWebChromeClient != null) {
			return originalWebChromeClient.onJsAlert(view, url, message, result);
		} 
		return true;
	}

	@Override
	public boolean onJsBeforeUnload(WebView view, String url, String message, JsResult result) {
		if (originalWebChromeClient.onJsBeforeUnload(view, url, message, result)) {
			return originalWebChromeClient.onJsBeforeUnload(view, url, message, result);
		}
		return true;
	}

	@Override
	public boolean onJsConfirm(WebView view, String url, String message, JsResult result) {
		if (originalWebChromeClient != null) {
			return originalWebChromeClient.onJsConfirm(view, url, message, result);
		} 
		return true;
	}

	@Override
	public boolean onJsTimeout() {
		if (originalWebChromeClient != null) {
			return originalWebChromeClient.onJsTimeout();
		} 
		return true;
	}

	@Override
	public void onProgressChanged(WebView view, int newProgress) {
		if (originalWebChromeClient != null) {            
			originalWebChromeClient.onProgressChanged(view, newProgress);
		} 
	}

	@Override
	public void onReachedMaxAppCacheSize(long requiredStorage, long quota, WebStorage.QuotaUpdater quotaUpdater) {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onReachedMaxAppCacheSize(requiredStorage, quota, quotaUpdater);
		} 
	}

	@Override
	public void onReceivedIcon(WebView view, Bitmap icon) {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onReceivedIcon(view, icon);
		} 
	}

	@Override
	public void onReceivedTitle(WebView view, String title) {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onReceivedTitle(view, title);
		} 
	}

	@Override
	public void onReceivedTouchIconUrl(WebView view, String url, boolean precomposed) {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onReceivedTouchIconUrl(view, url, precomposed);
		} 
	}

	@Override
	public void onRequestFocus(WebView view) {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onRequestFocus(view);
		}
	}

	@Override
	public void onShowCustomView(View view, WebChromeClient.CustomViewCallback callback) {
		if (originalWebChromeClient != null) {
			originalWebChromeClient.onShowCustomView(view, callback);
		} 
	}
}

@#$
package com.robotium.solo;

import android.app.Instrumentation;
import android.graphics.PointF;
import android.os.SystemClock;
import android.view.InputDevice;
import android.view.MotionEvent;
import android.view.MotionEvent.PointerCoords;
import android.view.MotionEvent.PointerProperties;

class Rotator
{
	private final Instrumentation _instrument;
	private static final int EVENT_TIME_INTERVAL_MS = 10;
	public static final int LARGE = 0;
	public static final int SMALL = 1;

	public Rotator(Instrumentation inst)
	{
		this._instrument = inst;
	}

	public void generateRotateGesture(int size, PointF center1, PointF center2)
	{
		double incrementFactor = 0;
		float startX1 = center1.x;
		float startY1 = center1.y;
		float startX2 = center2.x;
		float startY2 = center2.y;

		long downTime = SystemClock.uptimeMillis();
		long eventTime = SystemClock.uptimeMillis();

		// pointer 1
		float x1 = startX1;
		float y1 = startY1;

		// pointer 2
		float x2 = startX2;
		float y2 = startY2;

		PointerCoords[] pointerCoords = new PointerCoords[2];
		PointerCoords pc1 = new PointerCoords();
		PointerCoords pc2 = new PointerCoords();
		pc1.x = x1;
		pc1.y = y1;
		pc1.pressure = 1;
		pc1.size = 1;
		pc2.x = x2;
		pc2.y = y2;
		pc2.pressure = 1;
		pc2.size = 1;
		pointerCoords[0] = pc1;
		pointerCoords[1] = pc2;

		PointerProperties[] pointerProperties = new PointerProperties[2];
		PointerProperties pp1 = new PointerProperties();
		PointerProperties pp2 = new PointerProperties();
		pp1.id = 0;
		pp1.toolType = MotionEvent.TOOL_TYPE_FINGER;
		pp2.id = 1;
		pp2.toolType = MotionEvent.TOOL_TYPE_FINGER;
		pointerProperties[0] = pp1;
		pointerProperties[1] = pp2;

		MotionEvent event;
		// send the initial touches
		event = MotionEvent.obtain(downTime, eventTime,
				MotionEvent.ACTION_DOWN, 1, pointerProperties, pointerCoords,
				0, 0, // metaState, buttonState
				1, // x precision
				1, // y precision
				0, 0, // deviceId, edgeFlags
				InputDevice.SOURCE_TOUCHSCREEN, 0); // source, flags
		_instrument.sendPointerSync(event);

		event = MotionEvent.obtain(downTime, eventTime,
				MotionEvent.ACTION_POINTER_DOWN
				+ (pp2.id << MotionEvent.ACTION_POINTER_INDEX_SHIFT),
				2, pointerProperties, pointerCoords, 0, 0, 1, 1, 0, 0,
				InputDevice.SOURCE_TOUCHSCREEN, 0);
		_instrument.sendPointerSync(event);

		switch(size)
		{
		case 0:
		{
			incrementFactor = 0.01;
		}
		break;
		case 1:
		{
			incrementFactor = 0.1;
		}
		break;
		}
		for (double i = 0; i < Math.PI; i += incrementFactor)
		{
			eventTime += EVENT_TIME_INTERVAL_MS;
			pointerCoords[0].x += Math.cos(i);
			pointerCoords[0].y += Math.sin(i);
			pointerCoords[1].x += Math.cos(i + Math.PI);
			pointerCoords[1].y += Math.sin(i + Math.PI);

			event = MotionEvent.obtain(downTime, eventTime,
					MotionEvent.ACTION_MOVE, 2, pointerProperties,
					pointerCoords, 0, 0, 1, 1, 0, 0,
					InputDevice.SOURCE_TOUCHSCREEN, 0);
			_instrument.sendPointerSync(event);
		}

		// and remove them fingers from the screen
		eventTime += EVENT_TIME_INTERVAL_MS;
		event = MotionEvent.obtain(downTime, eventTime,
				MotionEvent.ACTION_POINTER_UP
				+ (pp2.id << MotionEvent.ACTION_POINTER_INDEX_SHIFT),
				2, pointerProperties, pointerCoords, 0, 0, 1, 1, 0, 0,
				InputDevice.SOURCE_TOUCHSCREEN, 0);
		_instrument.sendPointerSync(event);

		eventTime += EVENT_TIME_INTERVAL_MS;
		event = MotionEvent.obtain(downTime, eventTime, MotionEvent.ACTION_UP,
				1, pointerProperties, pointerCoords, 0, 0, 1, 1, 0, 0,
				InputDevice.SOURCE_TOUCHSCREEN, 0);
		_instrument.sendPointerSync(event);
	}
}

@#$
package com.robotium.solo;

import java.io.File;
import java.io.FileOutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import com.robotium.solo.Solo.Config;
import com.robotium.solo.Solo.Config.ScreenshotFileType;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Picture;
import android.opengl.GLSurfaceView;
import android.opengl.GLSurfaceView.Renderer;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Message;
import android.os.SystemClock;
import android.util.Log;
import android.view.View;
import android.webkit.WebView;

/**
 * Contains screenshot methods like: takeScreenshot(final View, final String name), startScreenshotSequence(final String name, final int quality, final int frameDelay, final int maxFrames), 
 * stopScreenshotSequence().
 * 
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class ScreenshotTaker {

	private static final long TIMEOUT_SCREENSHOT_MUTEX = TimeUnit.SECONDS.toMillis(2);
	private final Object screenshotMutex = new Object();
	private final Config config;
	private final ActivityUtils activityUtils;
	private final String LOG_TAG = "Robotium";
	private ScreenshotSequenceThread screenshotSequenceThread = null;
	private HandlerThread screenShotSaverThread = null;
	private ScreenShotSaver screenShotSaver = null;
	private final ViewFetcher viewFetcher;
	private final Sleeper sleeper;


	/**
	 * Constructs this object.
	 * 
	 * @param config the {@code Config} instance
	 * @param activityUtils the {@code ActivityUtils} instance
	 * @param viewFetcher the {@code ViewFetcher} instance
	 * @param sleeper the {@code Sleeper} instance
	 * 
	 */
	ScreenshotTaker(Config config, ActivityUtils activityUtils, ViewFetcher viewFetcher, Sleeper sleeper) {
		this.config = config;
		this.activityUtils = activityUtils;
		this.viewFetcher = viewFetcher;
		this.sleeper = sleeper;
	}

	/**
	 * Takes a screenshot and saves it in the {@link Config} objects save path.  
	 * Requires write permission (android.permission.WRITE_EXTERNAL_STORAGE) in AndroidManifest.xml of the application under test.
	 * 
	 * @param name the name to give the screenshot image
	 * @param quality the compression rate. From 0 (compress for lowest size) to 100 (compress for maximum quality).
	 */
	public void takeScreenshot(final String name, final int quality) {
		View decorView = getScreenshotView();
		if(decorView == null) 
			return;

		initScreenShotSaver();
		ScreenshotRunnable runnable = new ScreenshotRunnable(decorView, name, quality);

		synchronized (screenshotMutex) {
			activityUtils.getCurrentActivity(false).runOnUiThread(runnable);
			try {
				screenshotMutex.wait(TIMEOUT_SCREENSHOT_MUTEX);
			} catch (InterruptedException ignored) {
			}
		}
	}

	/**
	 * Takes a screenshot sequence and saves the images with the name prefix in the {@link Config} objects save path.  
	 *
	 * The name prefix is appended with "_" + sequence_number for each image in the sequence,
	 * where numbering starts at 0.  
	 *
	 * Requires write permission (android.permission.WRITE_EXTERNAL_STORAGE) in the 
	 * AndroidManifest.xml of the application under test.
	 *
	 * Taking a screenshot will take on the order of 40-100 milliseconds of time on the 
	 * main UI thread.  Therefore it is possible to mess up the timing of tests if
	 * the frameDelay value is set too small.
	 *
	 * At present multiple simultaneous screenshot sequences are not supported.  
	 * This method will throw an exception if stopScreenshotSequence() has not been
	 * called to finish any prior sequences.
	 *
	 * @param name the name prefix to give the screenshot
	 * @param quality the compression rate. From 0 (compress for lowest size) to 100 (compress for maximum quality)
	 * @param frameDelay the time in milliseconds to wait between each frame
	 * @param maxFrames the maximum number of frames that will comprise this sequence
	 *
	 */
	public void startScreenshotSequence(final String name, final int quality, final int frameDelay, final int maxFrames) {
		initScreenShotSaver();

		if(screenshotSequenceThread != null) {
			throw new RuntimeException("only one screenshot sequence is supported at a time");
		}

		screenshotSequenceThread = new ScreenshotSequenceThread(name, quality, frameDelay, maxFrames);

		screenshotSequenceThread.start();
	}

	/**
	 * Causes a screenshot sequence to end.
	 * 
	 * If this method is not called to end a sequence and a prior sequence is still in 
	 * progress, startScreenshotSequence() will throw an exception.
	 */
	public void stopScreenshotSequence() {
		if(screenshotSequenceThread != null) {
			screenshotSequenceThread.interrupt();
			screenshotSequenceThread = null;
		}
	}

	/**
	 * Gets the proper view to use for a screenshot.  
	 */
	private View getScreenshotView() {
		View decorView = viewFetcher.getRecentDecorView(viewFetcher.getWindowDecorViews());
		final long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();

		while (decorView == null) {	

			final boolean timedOut = SystemClock.uptimeMillis() > endTime;

			if (timedOut){
				return null;
			}
			sleeper.sleepMini();
			decorView = viewFetcher.getRecentDecorView(viewFetcher.getWindowDecorViews());
		}
		wrapAllGLViews(decorView);

		return decorView;
	}

	/**
	 * Extract and wrap the all OpenGL ES Renderer.
	 */
	private void wrapAllGLViews(View decorView) {
		ArrayList<GLSurfaceView> currentViews = viewFetcher.getCurrentViews(GLSurfaceView.class, true, decorView);
		final CountDownLatch latch = new CountDownLatch(currentViews.size());

		for (GLSurfaceView glView : currentViews) {
			Object renderContainer = new Reflect(glView).field("mGLThread")
					.type(GLSurfaceView.class).out(Object.class);

			Renderer renderer = new Reflect(renderContainer).field("mRenderer").out(Renderer.class);

			if (renderer == null) {
				renderer = new Reflect(glView).field("mRenderer").out(Renderer.class);
				renderContainer = glView;
			}  
			if (renderer == null) {
				latch.countDown();
				continue;
			}
			if (renderer instanceof GLRenderWrapper) {
				GLRenderWrapper wrapper = (GLRenderWrapper) renderer;
				wrapper.setTakeScreenshot();
				wrapper.setLatch(latch);
			} else {
				GLRenderWrapper wrapper = new GLRenderWrapper(glView, renderer, latch);
				new Reflect(renderContainer).field("mRenderer").in(wrapper);
			}
		}

		try {
			latch.await();
		} catch (InterruptedException ex) {
			ex.printStackTrace();
		}
	}


	/**
	 * Returns a bitmap of a given WebView.
	 *  
	 * @param webView the webView to save a bitmap from
	 * @return a bitmap of the given web view
	 * 
	 */

	private Bitmap getBitmapOfWebView(final WebView webView){
		Picture picture = webView.capturePicture();
		Bitmap b = Bitmap.createBitmap( picture.getWidth(), picture.getHeight(), Bitmap.Config.ARGB_8888);
		Canvas c = new Canvas(b);
		picture.draw(c);
		return b;
	}

	/**
	 * Returns a bitmap of a given View.
	 * 
	 * @param view the view to save a bitmap from
	 * @return a bitmap of the given view
	 * 
	 */

	private Bitmap getBitmapOfView(final View view){
		view.destroyDrawingCache();
		view.buildDrawingCache(false);
		Bitmap orig = view.getDrawingCache();
		Bitmap.Config config = null;

		if(orig == null) {
			return null;
		}

		config = orig.getConfig();

		if(config == null) {
			config = Bitmap.Config.ARGB_8888;
		}
		Bitmap b = orig.copy(config, false);
		orig.recycle();
		view.destroyDrawingCache();
		return b; 
	}

	/**
	 * Returns a proper filename depending on if name is given or not.
	 * 
	 * @param name the given name
	 * @return a proper filename depedning on if a name is given or not
	 * 
	 */

	private String getFileName(final String name){
		SimpleDateFormat sdf = new SimpleDateFormat("ddMMyy-hhmmss");
		String fileName = null;
		if(name == null){
			if(config.screenshotFileType == ScreenshotFileType.JPEG){
				fileName = sdf.format( new Date()).toString()+ ".jpg";
			}
			else{
				fileName = sdf.format( new Date()).toString()+ ".png";	
			}
		}
		else {
			if(config.screenshotFileType == ScreenshotFileType.JPEG){
				fileName = name + ".jpg";
			}
			else {
				fileName = name + ".png";	
			}
		}
		return fileName;
	}

	/**
	 * This method initializes the aysnc screenshot saving logic
	 */
	private void initScreenShotSaver() {
		if(screenShotSaverThread == null || screenShotSaver == null) {
			screenShotSaverThread = new HandlerThread("ScreenShotSaver");
			screenShotSaverThread.start();
			screenShotSaver = new ScreenShotSaver(screenShotSaverThread);
		}
	}

	/** 
	 * This is the thread which causes a screenshot sequence to happen
	 * in parallel with testing.
	 */
	private class ScreenshotSequenceThread extends Thread {
		private int seqno = 0;

		private String name;
		private int quality;
		private int frameDelay;
		private int maxFrames;

		private boolean keepRunning = true;

		public ScreenshotSequenceThread(String _name, int _quality, int _frameDelay, int _maxFrames) {
			name = _name;
			quality = _quality; 
			frameDelay = _frameDelay;
			maxFrames = _maxFrames;
		}

		public void run() {
			while(seqno < maxFrames) {
				if(!keepRunning || Thread.interrupted()) break;
				doScreenshot();
				seqno++;
				try {
					Thread.sleep(frameDelay);
				} catch (InterruptedException e) {
				}
			}
			screenshotSequenceThread = null;
		}

		public void doScreenshot() {
			View v = getScreenshotView();
			if(v == null) keepRunning = false;
			String final_name = name+"_"+seqno;
			ScreenshotRunnable r = new ScreenshotRunnable(v, final_name, quality);
			Log.d(LOG_TAG, "taking screenshot "+final_name);
			activityUtils.getCurrentActivity(false).runOnUiThread(r);
		}

		public void interrupt() {
			keepRunning = false;
			super.interrupt();
		}
	}

	/**
	 * Here we have a Runnable which is responsible for taking the actual screenshot,
	 * and then posting the bitmap to a Handler which will save it.
	 *
	 * This Runnable is run on the UI thread.
	 */
	private class ScreenshotRunnable implements Runnable {

		private View view;
		private String name;
		private int quality;

		public ScreenshotRunnable(final View _view, final String _name, final int _quality) {
			view = _view;
			name = _name;
			quality = _quality;
		}

		public void run() {
			if(view !=null){
				Bitmap  b;

				if(view instanceof WebView){
					b = getBitmapOfWebView((WebView) view);
				}
				else{
					b = getBitmapOfView(view);
				}
				if(b != null) {
					screenShotSaver.saveBitmap(b, name, quality);
					b = null;
					// Return here so that the screenshotMutex is not unlocked,
					// since this is handled by save bitmap
					return;
				}
				else
					Log.d(LOG_TAG, "NULL BITMAP!!");
			}

			// Make sure the screenshotMutex is unlocked
			synchronized (screenshotMutex) {
				screenshotMutex.notify();
			}
		}
	}

	/**
	 * This class is a Handler which deals with saving the screenshots on a separate thread.
	 *
	 * The screenshot logic by necessity has to run on the ui thread.  However, in practice
	 * it seems that saving a screenshot (with quality 100) takes approx twice as long
	 * as taking it in the first place. 
	 *
	 * Saving the screenshots in a separate thread like this will thus make the screenshot
	 * process approx 3x faster as far as the main thread is concerned.
	 *
	 */
	private class ScreenShotSaver extends Handler {
		public ScreenShotSaver(HandlerThread thread) {
			super(thread.getLooper());
		}

		/**
		 * This method posts a Bitmap with meta-data to the Handler queue.
		 *
		 * @param bitmap the bitmap to save
		 * @param name the name of the file
		 * @param quality the compression rate. From 0 (compress for lowest size) to 100 (compress for maximum quality).
		 */
		public void saveBitmap(Bitmap bitmap, String name, int quality) {
			Message message = this.obtainMessage();
			message.arg1 = quality;
			message.obj = bitmap;
			message.getData().putString("name", name);
			this.sendMessage(message);
		}

		/**
		 * Here we process the Handler queue and save the bitmaps.
		 *
		 * @param message A Message containing the bitmap to save, and some metadata.
		 */
		public void handleMessage(Message message) {
			synchronized (screenshotMutex) {
				String name = message.getData().getString("name");
				int quality = message.arg1;
				Bitmap b = (Bitmap)message.obj;
				if(b != null) {
					saveFile(name, b, quality);
					b.recycle();
				}
				else {
					Log.d(LOG_TAG, "NULL BITMAP!!");
				}

				screenshotMutex.notify();
			}
		}

		/**
		 * Saves a file.
		 * 
		 * @param name the name of the file
		 * @param b the bitmap to save
		 * @param quality the compression rate. From 0 (compress for lowest size) to 100 (compress for maximum quality).
		 * 
		 */
		private void saveFile(String name, Bitmap b, int quality){
			FileOutputStream fos = null;
			String fileName = getFileName(name);

			File directory = new File(config.screenshotSavePath);
			directory.mkdir();

			File fileToSave = new File(directory,fileName);
			try {
				fos = new FileOutputStream(fileToSave);
				if(config.screenshotFileType == ScreenshotFileType.JPEG){
					if (b.compress(Bitmap.CompressFormat.JPEG, quality, fos) == false){
						Log.d(LOG_TAG, "Compress/Write failed");
					}
				}
				else{
					if (b.compress(Bitmap.CompressFormat.PNG, quality, fos) == false){
						Log.d(LOG_TAG, "Compress/Write failed");
					}
				}
				fos.flush();
				fos.close();
			} catch (Exception e) {
				Log.d(LOG_TAG, "Can't save the screenshot! Requires write permission (android.permission.WRITE_EXTERNAL_STORAGE) in AndroidManifest.xml of the application under test.");
				e.printStackTrace();
			}
		}
	}
}

@#$
package com.robotium.solo;

import java.util.ArrayList;
import com.robotium.solo.Solo.Config;
import junit.framework.Assert;
import android.app.Instrumentation;
import android.os.SystemClock;
import android.view.MotionEvent;
import android.view.View;
import android.webkit.WebView;
import android.widget.AbsListView;
import android.widget.GridView;
import android.widget.ListView;
import android.widget.ScrollView;


/**
 * Contains scroll methods. Examples are scrollDown(), scrollUpList(),
 * scrollToSide().
 *
 * @author Renas Reda, renas.reda@robotium.com
 *
 */

class Scroller {

	public static final int DOWN = 0;
	public static final int UP = 1;
	public enum Side {LEFT, RIGHT}
	private boolean canScroll = false;
	private final Instrumentation inst;
	private final ActivityUtils activityUtils;
	private final ViewFetcher viewFetcher;
	private final Sleeper sleeper;
	private final Config config;


	/**
	 * Constructs this object.
	 *
	 * @param inst the {@code Instrumentation} instance
	 * @param activityUtils the {@code ActivityUtils} instance
	 * @param viewFetcher the {@code ViewFetcher} instance
	 * @param sleeper the {@code Sleeper} instance
	 */

	public Scroller(Config config, Instrumentation inst, ActivityUtils activityUtils, ViewFetcher viewFetcher, Sleeper sleeper) {
		this.config = config;
		this.inst = inst;
		this.activityUtils = activityUtils;
		this.viewFetcher = viewFetcher;
		this.sleeper = sleeper;
	}


	/**
	 * Simulate touching a specific location and dragging to a new location.
	 *
	 * This method was copied from {@code TouchUtils.java} in the Android Open Source Project, and modified here.
	 *
	 * @param fromX X coordinate of the initial touch, in screen coordinates
	 * @param toX Xcoordinate of the drag destination, in screen coordinates
	 * @param fromY X coordinate of the initial touch, in screen coordinates
	 * @param toY Y coordinate of the drag destination, in screen coordinates
	 * @param stepCount How many move steps to include in the drag
	 */

	public void drag(float fromX, float toX, float fromY, float toY,
			int stepCount) {
		long downTime = SystemClock.uptimeMillis();
		long eventTime = SystemClock.uptimeMillis();
		float y = fromY;
		float x = fromX;
		float yStep = (toY - fromY) / stepCount;
		float xStep = (toX - fromX) / stepCount;
		MotionEvent event = MotionEvent.obtain(downTime, eventTime,MotionEvent.ACTION_DOWN, fromX, fromY, 0);
		try {
			inst.sendPointerSync(event);
		} catch (SecurityException ignored) {}
		for (int i = 0; i < stepCount; ++i) {
			y += yStep;
			x += xStep;
			eventTime = SystemClock.uptimeMillis();
			event = MotionEvent.obtain(downTime, eventTime,MotionEvent.ACTION_MOVE, x, y, 0);
			try {
				inst.sendPointerSync(event);
			} catch (SecurityException ignored) {}
		}
		eventTime = SystemClock.uptimeMillis();
		event = MotionEvent.obtain(downTime, eventTime, MotionEvent.ACTION_UP,toX, toY, 0);
		try {
			inst.sendPointerSync(event);
		} catch (SecurityException ignored) {}
	}


	/**
	 * Scrolls a ScrollView.
	 *
	 * @param direction the direction to be scrolled
	 * @return {@code true} if scrolling occurred, false if it did not
	 */

	private boolean scrollScrollView(final ScrollView view, int direction){

		if(view == null){
			return false;
		}

		int height = view.getHeight();
		height--;
		int scrollTo = -1;

		if (direction == DOWN) {
			scrollTo = height;
		}

		else if (direction == UP) {
			scrollTo = -height;
		}

		int originalY = view.getScrollY();
		final int scrollAmount = scrollTo;
		inst.runOnMainSync(new Runnable(){
			public void run(){
				view.scrollBy(0, scrollAmount);
			}
		});

		if (originalY == view.getScrollY()) {
			return false;
		}
		else{
			return true;
		}
	}

	/**
	 * Scrolls a ScrollView to top or bottom.
	 *
	 * @param direction the direction to be scrolled
	 */

	private void scrollScrollViewAllTheWay(final ScrollView view, final int direction) {
		while(scrollScrollView(view, direction));
	}

	/**
	 * Scrolls up or down.
	 *
	 * @param direction the direction in which to scroll
	 * @return {@code true} if more scrolling can be done
	 */

	public boolean scroll(int direction) {
		return scroll(direction, false);
	}

	/**
	 * Scrolls down.
	 *
	 * @return {@code true} if more scrolling can be done
	 */

	public boolean scrollDown() {
		if(!config.shouldScroll) {
			return false;
		}
		return scroll(Scroller.DOWN);
	}

	/**
	 * Scrolls up and down.
	 *
	 * @param direction the direction in which to scroll
	 * @param allTheWay <code>true</code> if the view should be scrolled to the beginning or end,
	 *                  <code>false</code> to scroll one page up or down.
	 * @return {@code true} if more scrolling can be done
	 */

	public boolean scroll(int direction, boolean allTheWay) {
		final ArrayList<View> viewList = RobotiumUtils.
				removeInvisibleViews(viewFetcher.getAllViews(true));
		@SuppressWarnings("unchecked")
		ArrayList<View> views = RobotiumUtils.filterViewsToSet(new Class[] { ListView.class,
				ScrollView.class, GridView.class, WebView.class}, viewList);
		View view = viewFetcher.getFreshestView(views);
		
		if (view == null)
		{
			return false;
		}

		if (view instanceof AbsListView) {
			return scrollList((AbsListView)view, direction, allTheWay);
		}

		if (view instanceof ScrollView) {
			if (allTheWay) {
				scrollScrollViewAllTheWay((ScrollView) view, direction);
				return false;
			} else {
				return scrollScrollView((ScrollView)view, direction);
			}
		}
		if(view instanceof WebView){
			return scrollWebView((WebView)view, direction, allTheWay);
		}
		return false;
	}
	
	/**
	 * Scrolls a WebView.
	 * 
	 * @param webView the WebView to scroll
	 * @param direction the direction to scroll
	 * @param allTheWay {@code true} to scroll the view all the way up or down, {@code false} to scroll one page up or down                          or down.
	 * @return {@code true} if more scrolling can be done
	 */
	
	public boolean scrollWebView(final WebView webView, int direction, final boolean allTheWay){

		if (direction == DOWN) {
			inst.runOnMainSync(new Runnable(){
				public void run(){
					canScroll =  webView.pageDown(allTheWay);
				}
			});
		}
		if(direction == UP){
			inst.runOnMainSync(new Runnable(){
				public void run(){
					canScroll =  webView.pageUp(allTheWay);
				}
			});
		}
		return canScroll;
	}

	/**
	 * Scrolls a list.
	 *
	 * @param absListView the list to be scrolled
	 * @param direction the direction to be scrolled
	 * @param allTheWay {@code true} to scroll the view all the way up or down, {@code false} to scroll one page up or down
	 * @return {@code true} if more scrolling can be done
	 */

	public <T extends AbsListView> boolean scrollList(T absListView, int direction, boolean allTheWay) {

		if(absListView == null){
			return false;
		}

		if (direction == DOWN) {
			
			int listCount = absListView.getCount();
			int lastVisiblePosition = absListView.getLastVisiblePosition();
			
			if (allTheWay) {
				scrollListToLine(absListView, listCount-1);
				return false;
			}

			if (lastVisiblePosition >= listCount - 1) {
				if(lastVisiblePosition > 0){
					scrollListToLine(absListView, lastVisiblePosition);
				}
				return false;
			}
			
			int firstVisiblePosition = absListView.getFirstVisiblePosition();
			

			if(firstVisiblePosition != lastVisiblePosition)
				scrollListToLine(absListView, lastVisiblePosition);

			else
				scrollListToLine(absListView, firstVisiblePosition + 1);

		} else if (direction == UP) {
			int firstVisiblePosition = absListView.getFirstVisiblePosition();
			
			if (allTheWay || firstVisiblePosition < 2) {
				scrollListToLine(absListView, 0);
				return false;
			}
			int lastVisiblePosition = absListView.getLastVisiblePosition();

			final int lines = lastVisiblePosition - firstVisiblePosition;
			
			int lineToScrollTo = firstVisiblePosition - lines;

			if(lineToScrollTo == lastVisiblePosition)
				lineToScrollTo--;

			if(lineToScrollTo < 0)
				lineToScrollTo = 0;

			scrollListToLine(absListView, lineToScrollTo);
		}
		sleeper.sleep();
		return true;
	}


	/**
	 * Scroll the list to a given line
	 *
	 * @param view the {@link AbsListView} to scroll
	 * @param line the line to scroll to
	 */

	public <T extends AbsListView> void scrollListToLine(final T view, final int line){
		if(view == null)
			Assert.fail("AbsListView is null!");

		final int lineToMoveTo;
		if(view instanceof GridView) {
			lineToMoveTo = line+1;
		}
		else {
			lineToMoveTo = line;
		}
		
		inst.runOnMainSync(new Runnable(){
			public void run(){
				view.setSelection(lineToMoveTo);
			}
		});
	}


	/**
	 * Scrolls horizontally.
	 *
	 * @param side the side to which to scroll; {@link Side#RIGHT} or {@link Side#LEFT}
	 * @param scrollPosition the position to scroll to, from 0 to 1 where 1 is all the way. Example is: 0.55.
	 * @param stepCount how many move steps to include in the scroll. Less steps results in a faster scroll
	 */

	@SuppressWarnings("deprecation")
	public void scrollToSide(Side side, float scrollPosition, int stepCount) {
		int screenHeight = activityUtils.getCurrentActivity().getWindowManager().getDefaultDisplay()
				.getHeight();
		int screenWidth = activityUtils.getCurrentActivity(false).getWindowManager().getDefaultDisplay()
				.getWidth();
		float x = screenWidth * scrollPosition;
		float y = screenHeight / 2.0f;
		if (side == Side.LEFT)
			drag(70, x, y, y, stepCount);
		else if (side == Side.RIGHT)
			drag(x, 0, y, y, stepCount);
	}

	/**
	 * Scrolls view horizontally.
	 *
	 * @param view the view to scroll
	 * @param side the side to which to scroll; {@link Side#RIGHT} or {@link Side#LEFT}
	 * @param scrollPosition the position to scroll to, from 0 to 1 where 1 is all the way. Example is: 0.55.
	 * @param stepCount how many move steps to include in the scroll. Less steps results in a faster scroll
	 */

	public void scrollViewToSide(View view, Side side, float scrollPosition, int stepCount) {
		int[] corners = new int[2];
		view.getLocationOnScreen(corners);
		int viewHeight = view.getHeight();
		int viewWidth = view.getWidth();
		float x = corners[0] + viewWidth * scrollPosition;
		float y = corners[1] + viewHeight / 2.0f;
		if (side == Side.LEFT)
			drag(corners[0], x, y, y, stepCount);
		else if (side == Side.RIGHT)
			drag(x, corners[0], y, y, stepCount);
	}

}

@#$
package com.robotium.solo;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Callable;
import android.os.SystemClock;
import android.util.Log;
import android.view.View;
import android.widget.TextView;


/**
 * Contains various search methods. Examples are: searchForEditTextWithTimeout(),
 * searchForTextWithTimeout(), searchForButtonWithTimeout().
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class Searcher {

	private final ViewFetcher viewFetcher;
	private final WebUtils webUtils;
	private final Scroller scroller;
	private final Sleeper sleeper;
	private final String LOG_TAG = "Robotium";
	Set<TextView> uniqueTextViews;
	List<WebElement> webElements;
	private int numberOfUniqueViews;
	private final int TIMEOUT = 5000;


	/**
	 * Constructs this object.
	 *
	 * @param viewFetcher the {@code ViewFetcher} instance
	 * @param webUtils the {@code WebUtils} instance
	 * @param scroller the {@code Scroller} instance
	 * @param sleeper the {@code Sleeper} instance.
	 */

	public Searcher(ViewFetcher viewFetcher, WebUtils webUtils, Scroller scroller, Sleeper sleeper) {
		this.viewFetcher = viewFetcher;
		this.webUtils = webUtils;
		this.scroller = scroller;
		this.sleeper = sleeper;
		webElements = new ArrayList<WebElement>();
		uniqueTextViews = new HashSet<TextView>();
	}


	/**
	 * Searches for a {@code View} with the given regex string and returns {@code true} if the
	 * searched {@code Button} is found a given number of times. Will automatically scroll when needed.
	 *
	 * @param viewClass what kind of {@code View} to search for, e.g. {@code Button.class} or {@code TextView.class}
	 * @param regex the text to search for. The parameter <strong>will</strong> be interpreted as a regular expression.
	 * @param expectedMinimumNumberOfMatches the minimum number of matches expected to be found. {@code 0} matches means that one or more
	 * matches are expected to be found
	 * @param scroll whether scrolling should be performed
	 * @param onlyVisible {@code true} if only texts visible on the screen should be searched
	 * 
	 * @return {@code true} if a {@code View} of the specified class with the given text is found a given number of
	 * times, and {@code false} if it is not found
	 */

	public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean onlyVisible) {
		final long endTime = SystemClock.uptimeMillis() + TIMEOUT;

		TextView foundAnyMatchingView = null;

		while (SystemClock.uptimeMillis() < endTime) {
			sleeper.sleep();
			foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, 0, scroll, onlyVisible);
			if (foundAnyMatchingView !=null){
				return true;
			}
		}
		return false;
	}


	/**
	 * Searches for a {@code View} with the given regex string and returns {@code true} if the
	 * searched {@code View} is found a given number of times.
	 *
	 * @param viewClass what kind of {@code View} to search for, e.g. {@code Button.class} or {@code TextView.class}
	 * @param regex the text to search for. The parameter <strong>will</strong> be interpreted as a regular expression.
	 * @param expectedMinimumNumberOfMatches the minimum number of matches expected to be found. {@code 0} matches means that one or more
	 * matches are expected to be found.
	 * @param timeout the amount of time in milliseconds to wait
	 * @param scroll whether scrolling should be performed
	 * @param onlyVisible {@code true} if only texts visible on the screen should be searched
	 * 
	 * @return {@code true} if a view of the specified class with the given text is found a given number of times.
	 * {@code false} if it is not found.
	 */

	public <T extends TextView> T searchFor(final Class<T> viewClass, final String regex, int expectedMinimumNumberOfMatches, final long timeout, final boolean scroll, final boolean onlyVisible) {
		if(expectedMinimumNumberOfMatches < 1) {
			expectedMinimumNumberOfMatches = 1;
		}

		final Callable<Collection<T>> viewFetcherCallback = new Callable<Collection<T>>() {
			@SuppressWarnings("unchecked")
			public Collection<T> call() throws Exception {
				sleeper.sleep();
	
				ArrayList<T> viewsToReturn = viewFetcher.getCurrentViews(viewClass, true);

				if(onlyVisible){
					viewsToReturn = RobotiumUtils.removeInvisibleViews(viewsToReturn);
				}
		
				if(viewClass.isAssignableFrom(TextView.class)) {
					viewsToReturn.addAll((Collection<? extends T>) webUtils.getTextViewsFromWebView());
				}
				return viewsToReturn;
			}
		};

		try {
			return searchFor(viewFetcherCallback, regex, expectedMinimumNumberOfMatches, timeout, scroll);
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Searches for a view class.
	 * 
	 * @param uniqueViews the set of unique views
	 * @param viewClass the view class to search for
	 * @param index the index of the view class
	 * @return true if view class if found a given number of times
	 */

	public <T extends View> boolean searchFor(Set<T> uniqueViews, Class<T> viewClass, final int index) {
		ArrayList<T> allViews = RobotiumUtils.removeInvisibleViews(viewFetcher.getCurrentViews(viewClass, true));

		int uniqueViewsFound = (getNumberOfUniqueViews(uniqueViews, allViews));

		if(uniqueViewsFound > 0 && index < uniqueViewsFound) {
			return true;
		}

		if(uniqueViewsFound > 0 && index == 0) {
			return true;
		}
		return false;
	}

	/**
	 * Searches for a given view.
	 * 
	 * @param view the view to search
	 * @param scroll true if scrolling should be performed
	 * @return true if view is found
	 */

	public <T extends View> boolean searchFor(View view) {
		ArrayList<View> views = viewFetcher.getAllViews(true);
		for(View v : views){
			if(v.equals(view)){
				return true;
			}
		}
		return false;
	}

	/**
	 * Searches for a {@code View} with the given regex string and returns {@code true} if the
	 * searched {@code View} is found a given number of times. Will not scroll, because the caller needs to find new
	 * {@code View}s to evaluate after scrolling, and call this method again.
	 *
	 * @param viewFetcherCallback callback which should return an updated collection of views to search
	 * @param regex the text to search for. The parameter <strong>will</strong> be interpreted as a regular expression.
	 * @param expectedMinimumNumberOfMatches the minimum number of matches expected to be found. {@code 0} matches means that one or more
	 * matches are expected to be found.
	 * @param timeout the amount of time in milliseconds to wait
	 * @param scroll whether scrolling should be performed
	 * 
	 * @return {@code true} if a view of the specified class with the given text is found a given number of times.
	 * {@code false} if it is not found.
	 *
	 * @throws Exception not really, it's just the signature of {@code Callable}
	 */

	public <T extends TextView> T searchFor(Callable<Collection<T>> viewFetcherCallback, String regex, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) throws Exception {
		final long endTime = SystemClock.uptimeMillis() + timeout;	
		Collection<T> views;

		while (true) {
			final boolean timedOut = timeout > 0 && SystemClock.uptimeMillis() > endTime;

			if(timedOut){
				logMatchesFound(regex);
				return null;
			}

			views = viewFetcherCallback.call();

			for(T view : views){
				if (RobotiumUtils.getNumberOfMatches(regex, view, uniqueTextViews) == expectedMinimumNumberOfMatches) {
					uniqueTextViews.clear();
					return view;
				}
			}
			if(scroll && !scroller.scrollDown()){
				logMatchesFound(regex);
				return null; 
			}
			if(!scroll){
				logMatchesFound(regex);
				return null; 
			}
		}
	}

	/**
	 * Searches for a web element.
	 * 
	 * @param by the By object e.g. By.id("id");
	 * @param minimumNumberOfMatches the minimum number of matches that are expected to be shown. {@code 0} means any number of matches
	 * @return the web element or null if not found
	 */

	public WebElement searchForWebElement(final By by, int minimumNumberOfMatches){

		if(minimumNumberOfMatches < 1){
			minimumNumberOfMatches = 1;
		}

		List<WebElement> viewsFromScreen = webUtils.getWebElements(by, true);
		addViewsToList (webElements, viewsFromScreen);

		return getViewFromList(webElements, minimumNumberOfMatches);
	}

	/**
	 * Adds views to a given list.
	 * 
	 * @param allWebElements the list of all views
	 * @param webTextViewsOnScreen the list of views shown on screen
	 */

	private void addViewsToList(List<WebElement> allWebElements, List<WebElement> webElementsOnScreen){

		int[] xyViewFromSet = new int[2];
		int[] xyViewFromScreen = new int[2];

		for(WebElement textFromScreen : webElementsOnScreen){
			boolean foundView = false;
			textFromScreen.getLocationOnScreen(xyViewFromScreen);

			for(WebElement textFromList : allWebElements){
				textFromList.getLocationOnScreen(xyViewFromSet);

				if(textFromScreen.getText().equals(textFromList.getText()) && xyViewFromScreen[0] == xyViewFromSet[0] && xyViewFromScreen[1] == xyViewFromSet[1]) {
					foundView = true;
				}
			}

			if(!foundView){
				allWebElements.add(textFromScreen);
			}
		}

	}

	/**
	 * Returns a text view with a given match.
	 * 
	 * @param webElements the list of views
	 * @param match the match of the view to return
	 * @return the view with a given match
	 */

	private WebElement getViewFromList(List<WebElement> webElements, int match){

		WebElement webElementToReturn = null;

		if(webElements.size() >= match){

			try{
				webElementToReturn = webElements.get(--match);
			}catch(Exception ignored){}
		}
		if(webElementToReturn != null)
			webElements.clear();

		return webElementToReturn;
	}

	/**
	 * Returns the number of unique views. 
	 * 
	 * @param uniqueViews the set of unique views
	 * @param views the list of all views
	 * @return number of unique views
	 */

	public <T extends View> int getNumberOfUniqueViews(Set<T>uniqueViews, ArrayList<T> views){
		for(int i = 0; i < views.size(); i++){
			uniqueViews.add(views.get(i));
		}
		numberOfUniqueViews = uniqueViews.size();
		return numberOfUniqueViews;
	}

	/**
	 * Returns the number of unique views.
	 * 
	 * @return the number of unique views
	 */

	public int getNumberOfUniqueViews(){
		return numberOfUniqueViews;
	}

	/**
	 * Logs a (searchFor failed) message.
	 *  
	 * @param regex the search string to log
	 */

	public void logMatchesFound(String regex){
		if (uniqueTextViews.size() > 0) {
			Log.d(LOG_TAG, " There are only " + uniqueTextViews.size() + " matches of '" + regex + "'");
		}
		else if(webElements.size() > 0){
			Log.d(LOG_TAG, " There are only " + webElements.size() + " matches of '" + regex + "'");
		}
		uniqueTextViews.clear();
		webElements.clear();
	}
}

@#$
package com.robotium.solo;


import junit.framework.Assert;
import android.app.Instrumentation;
import android.view.KeyEvent;

/**
 * Contains send key event methods. Examples are:
 * sendKeyCode(), goBack()
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class Sender {

	private final Instrumentation inst;
	private final Sleeper sleeper;

	/**
	 * Constructs this object.
	 * 
	 * @param inst the {@code Instrumentation} instance
	 * @param sleeper the {@code Sleeper} instance
	 */

	Sender(Instrumentation inst, Sleeper sleeper) {
		this.inst = inst;
		this.sleeper = sleeper;
	}

	/**
	 * Tells Robotium to send a key code: Right, Left, Up, Down, Enter or other.
	 * 
	 * @param keycode the key code to be sent. Use {@link KeyEvent#KEYCODE_ENTER}, {@link KeyEvent#KEYCODE_MENU}, {@link KeyEvent#KEYCODE_DEL}, {@link KeyEvent#KEYCODE_DPAD_RIGHT} and so on
	 */

	public void sendKeyCode(int keycode)
	{
		sleeper.sleep();
		try{
			inst.sendCharacterSync(keycode);
		}catch(SecurityException e){
			Assert.fail("Can not complete action! ("+(e != null ? e.getClass().getName()+": "+e.getMessage() : "null")+")");
		}
	}

	/**
	 * Simulates pressing the hardware back key.
	 */

	public void goBack() {
		sleeper.sleep();
		try {
			inst.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);
			sleeper.sleep();
		} catch (Throwable ignored) {}
	}
}

@#$
package com.robotium.solo;

import android.view.View;
import android.widget.DatePicker;
import android.widget.ProgressBar;
import android.widget.SlidingDrawer;
import android.widget.TimePicker;


/**
 * Contains set methods. Examples are setDatePicker(),
 * setTimePicker().
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class Setter{

	private final int CLOSED = 0;
	private final int OPENED = 1;
	private final ActivityUtils activityUtils;
	private final Getter getter;
	private final Clicker clicker;
	private final Waiter waiter;

	/**
	 * Constructs this object.
	 *
	 * @param activityUtils the {@code ActivityUtils} instance
	 * @param getter the {@code Getter} instance
	 * @param clicker the {@code Clicker} instance
	 * @param waiter the {@code Waiter} instance
	 */

	public Setter(ActivityUtils activityUtils, Getter getter, Clicker clicker, Waiter waiter) {
		this.activityUtils = activityUtils;
		this.getter = getter;
		this.clicker = clicker;
		this.waiter = waiter;
	}


	/**
	 * Sets the date in a given {@link DatePicker}.
	 *
	 * @param datePicker the {@code DatePicker} object.
	 * @param year the year e.g. 2011
	 * @param monthOfYear the month which is starting from zero e.g. 03
	 * @param dayOfMonth the day e.g. 10
	 */

	public void setDatePicker(final DatePicker datePicker, final int year, final int monthOfYear, final int dayOfMonth) {
		if(datePicker != null){

			activityUtils.getCurrentActivity(false).runOnUiThread(new Runnable()
			{
				public void run()
				{
					try{
						datePicker.updateDate(year, monthOfYear, dayOfMonth);
					}catch (Exception ignored){}
				}
			});
		}
	}


	/**
	 * Sets the time in a given {@link TimePicker}.
	 *
	 * @param timePicker the {@code TimePicker} object.
	 * @param hour the hour e.g. 15
	 * @param minute the minute e.g. 30
	 */

	public void setTimePicker(final TimePicker timePicker, final int hour, final int minute) {
		if(timePicker != null){

			activityUtils.getCurrentActivity(false).runOnUiThread(new Runnable()
			{
				public void run()
				{
					try{
						timePicker.setCurrentHour(hour);
						timePicker.setCurrentMinute(minute);
					}catch (Exception ignored){}
				}
			});
		}
	}


	/**
	 * Sets the progress of a given {@link ProgressBar}. Examples are SeekBar and RatingBar.
	 * @param progressBar the {@code ProgressBar}
	 * @param progress the progress that the {@code ProgressBar} should be set to
	 */

	public void setProgressBar(final ProgressBar progressBar,final int progress) {
		if(progressBar != null){

			activityUtils.getCurrentActivity(false).runOnUiThread(new Runnable()
			{
				public void run()
				{
					try{
						progressBar.setProgress(progress);
					}catch (Exception ignored){}
				}
			});
		}
	}


	/**
	 * Sets the status of a given SlidingDrawer. Examples are Solo.CLOSED and Solo.OPENED.
	 *
	 * @param slidingDrawer the {@link SlidingDrawer}
	 * @param status the status that the {@link SlidingDrawer} should be set to
	 */

	public void setSlidingDrawer(final SlidingDrawer slidingDrawer, final int status){
		if(slidingDrawer != null){

			activityUtils.getCurrentActivity(false).runOnUiThread(new Runnable()
			{
				public void run()
				{
					try{
						switch (status) {
						case CLOSED:
							slidingDrawer.close();
							break;
						case OPENED:
							slidingDrawer.open();
							break;
						}
					}catch (Exception ignored){}
				}
			});
		}

	}

	/**
	 * Sets the status of the NavigationDrawer. Examples are Solo.CLOSED and Solo.OPENED.
	 *
	 * @param status the status that the {@link NavigationDrawer} should be set to
	 */

	public void setNavigationDrawer(final int status){
		final View homeView = getter.getView("home", 0);
		final View leftDrawer = getter.getView("left_drawer", 0);
		
		try{
			switch (status) {
			
			case CLOSED:
				if(leftDrawer != null && homeView != null && leftDrawer.isShown()){
					clicker.clickOnScreen(homeView);
				}
				break;
				
			case OPENED:
				if(leftDrawer != null && homeView != null &&  !leftDrawer.isShown()){
					clicker.clickOnScreen(homeView);

					Condition condition = new Condition() {

						@Override
						public boolean isSatisfied() {
							return leftDrawer.isShown();
						}
					};
					waiter.waitForCondition(condition, Timeout.getSmallTimeout());
				}
				break;
			}
		}catch (Exception ignored){}
	}
}

@#$
package com.robotium.solo;

class Sleeper {

	private final int PAUSE = 500;
	private final int MINIPAUSE = 300;

	/**
	 * Sleeps the current thread for a default pause length.
	 */

	public void sleep() {
        sleep(PAUSE);
	}


	/**
	 * Sleeps the current thread for a default mini pause length.
	 */

	public void sleepMini() {
        sleep(MINIPAUSE);
	}


	/**
	 * Sleeps the current thread for <code>time</code> milliseconds.
	 *
	 * @param time the length of the sleep in milliseconds
	 */

	public void sleep(int time) {
		try {
			Thread.sleep(time);
		} catch (InterruptedException ignored) {}
	}

}

@#$
package com.robotium.solo;

import java.lang.reflect.Method;
import java.util.ArrayList;
import junit.framework.Assert;
import android.app.Activity;
import android.app.Instrumentation;
import android.content.pm.ActivityInfo;
import android.graphics.PointF;
import android.os.Environment;
import android.view.KeyEvent;
import android.view.View;
import android.view.WindowManager;
import android.webkit.WebView;
import android.widget.AbsListView;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CheckedTextView;
import android.widget.CompoundButton;
import android.widget.DatePicker;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.ProgressBar;
import android.widget.RadioButton;
import android.widget.ScrollView;
import android.widget.SlidingDrawer;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.ListView;
import android.widget.TimePicker;
import android.widget.ToggleButton;
import android.app.Instrumentation.ActivityMonitor;

/**
 * Main class for development of Robotium tests.  
 * Robotium has full support for Views, WebViews, Activities, Dialogs, Menus and Context Menus. 
 * <br>
 * Robotium can be used in conjunction with Android test classes like 
 * ActivityInstrumentationTestCase2 and SingleLaunchActivityTestCase. 
 * 
 *
 *
 *
 * @author Renas Reda, renas.reda@robotium.com
 */

public class Solo {

	protected final Asserter asserter;
	protected final ViewFetcher viewFetcher;
	protected final Checker checker;
	protected final Clicker clicker;
	protected final Presser presser;
	protected final Searcher searcher;
	protected final ActivityUtils activityUtils;
	protected final DialogUtils dialogUtils;
	protected final TextEnterer textEnterer;
	protected final Rotator rotator;
	protected final Scroller scroller;
	protected final Sleeper sleeper;
	protected final Swiper swiper;
	protected final Tapper tapper;
	protected final Waiter waiter;
	protected final Setter setter;
	protected final Getter getter;
	protected final WebUtils webUtils;
	protected final Sender sender;
	protected final ScreenshotTaker screenshotTaker;
	protected final Instrumentation instrumentation;
	protected final Zoomer zoomer;
	protected String webUrl = null;
	private final Config config;
	public final static int LANDSCAPE = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;   // 0
	public final static int PORTRAIT = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;     // 1
	public final static int RIGHT = KeyEvent.KEYCODE_DPAD_RIGHT;
	public final static int LEFT = KeyEvent.KEYCODE_DPAD_LEFT;
	public final static int UP = KeyEvent.KEYCODE_DPAD_UP;
	public final static int DOWN = KeyEvent.KEYCODE_DPAD_DOWN;
	public final static int ENTER = KeyEvent.KEYCODE_ENTER;
	public final static int MENU = KeyEvent.KEYCODE_MENU;
	public final static int DELETE = KeyEvent.KEYCODE_DEL;
	public final static int CLOSED = 0;
	public final static int OPENED = 1;

	/**
	 * Constructor that takes the Instrumentation object and the start Activity.
	 *
	 * @param instrumentation the {@link Instrumentation} instance
	 * @param activity the start {@link Activity} or {@code null}
	 * if no Activity is specified
	 */

	public Solo(Instrumentation instrumentation, Activity activity) {
		this(new Config(), instrumentation, activity);	
	}

	/**
	 * Constructor that takes the Instrumentation and Config objects.
	 *
	 * @param instrumentation the {@link Instrumentation} instance
	 * @param config the {@link Config} instance 
	 */

	public Solo(Instrumentation instrumentation, Config config) {
		this(config, instrumentation, null);	
	}
	
	/**
	 * Constructor that takes the Instrumentation, Config and Activity objects.
	 *
	 * @param instrumentation the {@link Instrumentation} instance
	 * @param config the {@link Config} instance 
	 * @param activity the start {@link Activity} or {@code null}
	 * if no Activity is specified
	 */

	public Solo(Instrumentation instrumentation, Config config, Activity activity) {
		this(config, instrumentation, activity);	
	}

	/**
	 * Private constructor.
	 * 
	 * @param config the {@link Config} instance. If {@code null} one will be created. 
	 * @param instrumentation the {@link Instrumentation} instance
	 * @param activity the start {@link Activity} or {@code null}
	 * if no Activity is specified
	 */

	private Solo(Config config, Instrumentation instrumentation, Activity activity) {
		this.config = (config == null) ? new Config(): config;
		this.instrumentation = instrumentation;
		this.sleeper = new Sleeper();
		this.sender = new Sender(instrumentation, sleeper);
		this.activityUtils = new ActivityUtils(instrumentation, activity, sleeper);
		this.viewFetcher = new ViewFetcher(activityUtils);
		this.screenshotTaker = new ScreenshotTaker(config, activityUtils, viewFetcher, sleeper);
		this.dialogUtils = new DialogUtils(activityUtils, viewFetcher, sleeper);
		this.webUtils = new WebUtils(config, instrumentation,activityUtils,viewFetcher, sleeper);
		this.scroller = new Scroller(config, instrumentation, activityUtils, viewFetcher, sleeper);
		this.searcher = new Searcher(viewFetcher, webUtils, scroller, sleeper);
		this.waiter = new Waiter(activityUtils, viewFetcher, searcher,scroller, sleeper);
		this.getter = new Getter(instrumentation, activityUtils, waiter);
		this.clicker = new Clicker(activityUtils, viewFetcher,sender, instrumentation, sleeper, waiter, webUtils, dialogUtils);
		this.setter = new Setter(activityUtils, getter, clicker, waiter);
		this.asserter = new Asserter(activityUtils, waiter);
		this.checker = new Checker(viewFetcher, waiter);
		this.zoomer = new Zoomer(instrumentation);
		this.swiper = new Swiper(instrumentation);
		this.tapper =  new Tapper(instrumentation);
		this.rotator = new Rotator(instrumentation);
		this.presser = new Presser(viewFetcher, clicker, instrumentation, sleeper, waiter, dialogUtils);
		this.textEnterer = new TextEnterer(instrumentation, clicker, dialogUtils);
		initialize();
	}

	/**
	 * Config class used to set the scroll behaviour, default timeouts, screenshot filetype and screenshot save path.
	 * <br> <br>
	 * Example of usage:
	 * <pre>
	 *  public void setUp() throws Exception {
	 *	Config config = new Config();
	 *	config.screenshotFileType = ScreenshotFileType.PNG;
	 *	config.screenshotSavePath = Environment.getExternalStorageDirectory() + "/Robotium/";
	 *	config.shouldScroll = false;
	 *	solo = new Solo(getInstrumentation(), config);
	 *	getActivity();
	 * }
	 * </pre>
	 * 
	 * @author Renas Reda, renas.reda@robotium.com
	 */

	public static class Config {

		/**
		 * The timeout length of the get, is, set, assert, enter and click methods. Default length is 10 000 milliseconds.
		 */
		public int timeout_small = 10000;

		/**
		 * The timeout length of the waitFor methods. Default length is 20 000 milliseconds.
		 */
		public int timeout_large = 20000;

		/**
		 * The screenshot save path. Default save path is /sdcard/Robotium-Screenshots/.
		 */
		public String screenshotSavePath = Environment.getExternalStorageDirectory() + "/Robotium-Screenshots/";

		/**
		 * The screenshot file type, JPEG or PNG. Use ScreenshotFileType.JPEG or ScreenshotFileType.PNG. Default file type is JPEG. 
		 */
		public ScreenshotFileType screenshotFileType = ScreenshotFileType.JPEG;

		/**
		 * Set to true if the get, is, set, enter, type and click methods should scroll. Default value is true.
		 */
		public boolean shouldScroll = true;	

		/**
		 * Set to true if JavaScript should be used to click WebElements. Default value is false. 
		 */
		public boolean useJavaScriptToClickWebElements = false;

		/**
		 * The screenshot file type, JPEG or PNG.
		 * 
		 * @author Renas Reda, renas.reda@robotium.com
		 *
		 */
		public enum ScreenshotFileType {
			JPEG, PNG
		}
	}

	/**
	 * Constructor that takes the instrumentation object.
	 *
	 * @param instrumentation the {@link Instrumentation} instance
	 */

	public Solo(Instrumentation instrumentation) {
		this(new Config(), instrumentation, null);
	}

	/**
	 * Returns the ActivityMonitor used by Robotium.
	 * 
	 * @return the ActivityMonitor used by Robotium
	 */

	public ActivityMonitor getActivityMonitor(){
		return activityUtils.getActivityMonitor();
	}

	/**
	 * Returns the Config used by Robotium.
	 * 
	 * @return the Config used by Robotium
	 */

	public Config getConfig(){
		return config;
	}
	
	/**
	 * Returns an ArrayList of all the View objects located in the focused 
	 * Activity or Dialog.
	 *
	 * @return an {@code ArrayList} of the {@link View} objects located in the focused window
	 */

	public ArrayList<View> getViews() {
		try {
			return viewFetcher.getViews(null, false);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Returns an ArrayList of the View objects contained in the parent View.
	 *
	 * @param parent the parent view from which to return the views
	 * @return an {@code ArrayList} of the {@link View} objects contained in the specified {@code View}
	 */

	public ArrayList<View> getViews(View parent) {
		try {
			return viewFetcher.getViews(parent, false);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Returns the absolute top parent View of the specified View.
	 *
	 * @param view the {@link View} whose top parent is requested
	 * @return the top parent {@link View}
	 */	

	public View getTopParent(View view) {
		View topParent = viewFetcher.getTopParent(view);
		return topParent;
	}

	/**
	 * Waits for the specified text to appear. Default timeout is 20 seconds. 
	 * 
	 * @param text the text to wait for, specified as a regular expression
	 * @return {@code true} if text is displayed and {@code false} if it is not displayed before the timeout
	 */

	public boolean waitForText(String text) {
		return (waiter.waitForText(text) != null);
	}

	/**
	 * Waits for the specified text to appear. 
	 * 
	 * @param text the text to wait for, specified as a regular expression
	 * @param minimumNumberOfMatches the minimum number of matches that are expected to be found. {@code 0} means any number of matches
	 * @param timeout the the amount of time in milliseconds to wait 
	 * @return {@code true} if text is displayed and {@code false} if it is not displayed before the timeout
	 */

	public boolean waitForText(String text, int minimumNumberOfMatches, long timeout) {
		return (waiter.waitForText(text, minimumNumberOfMatches, timeout) != null);
	}

	/**
	 * Waits for the specified text to appear. 
	 * 
	 * @param text the text to wait for, specified as a regular expression
	 * @param minimumNumberOfMatches the minimum number of matches that are expected to be found. {@code 0} means any number of matches
	 * @param timeout the the amount of time in milliseconds to wait
	 * @param scroll {@code true} if scrolling should be performed
	 * @return {@code true} if text is displayed and {@code false} if it is not displayed before the timeout
	 */

	public boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) {
		return (waiter.waitForText(text, minimumNumberOfMatches, timeout, scroll) != null);
	}

	/**
	 * Waits for the specified text to appear. 
	 * 
	 * @param text the text to wait for, specified as a regular expression
	 * @param minimumNumberOfMatches the minimum number of matches that are expected to be found. {@code 0} means any number of matches
	 * @param timeout the the amount of time in milliseconds to wait
	 * @param scroll {@code true} if scrolling should be performed
	 * @param onlyVisible {@code true} if only visible text views should be waited for
	 * @return {@code true} if text is displayed and {@code false} if it is not displayed before the timeout
	 */

	public boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll, boolean onlyVisible) {
		return (waiter.waitForText(text, minimumNumberOfMatches, timeout, scroll, onlyVisible, true) != null);
	}

	/**
	 * Waits for a View matching the specified resource id. Default timeout is 20 seconds. 
	 * 
	 * @param id the R.id of the {@link View} to wait for
	 * @return {@code true} if the {@link View} is displayed and {@code false} if it is not displayed before the timeout
	 */

	public boolean waitForView(int id){
		return waitForView(id, 0, Timeout.getLargeTimeout(), true);
	}

	/**
	 * Waits for a View matching the specified resource id. 
	 * 
	 * @param id the R.id of the {@link View} to wait for
	 * @param minimumNumberOfMatches the minimum number of matches that are expected to be found. {@code 0} means any number of matches
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if the {@link View} is displayed and {@code false} if it is not displayed before the timeout
	 */

	public boolean waitForView(int id, int minimumNumberOfMatches, int timeout){
		return waitForView(id, minimumNumberOfMatches, timeout, true);
	}

	/**
	 * Waits for a View matching the specified resource id. 
	 * 
	 * @param id the R.id of the {@link View} to wait for
	 * @param minimumNumberOfMatches the minimum number of matches that are expected to be found. {@code 0} means any number of matches
	 * @param timeout the amount of time in milliseconds to wait
	 * @param scroll {@code true} if scrolling should be performed
	 * @return {@code true} if the {@link View} is displayed and {@code false} if it is not displayed before the timeout
	 */

	public boolean waitForView(int id, int minimumNumberOfMatches, int timeout, boolean scroll){
		int index = minimumNumberOfMatches-1;

		if(index < 1)
			index = 0;

		return (waiter.waitForView(id, index, timeout, scroll) != null);
	}

	/**
	 * Waits for a View matching the specified class. Default timeout is 20 seconds. 
	 * 
	 * @param viewClass the {@link View} class to wait for
	 * @return {@code true} if the {@link View} is displayed and {@code false} if it is not displayed before the timeout
	 */

	public <T extends View> boolean waitForView(final Class<T> viewClass){

		return waiter.waitForView(viewClass, 0, Timeout.getLargeTimeout(), true);
	}

	/**
	 * Waits for the specified View. Default timeout is 20 seconds. 
	 * 
	 * @param view the {@link View} object to wait for
	 * @return {@code true} if the {@link View} is displayed and {@code false} if it is not displayed before the timeout
	 */

	public <T extends View> boolean waitForView(View view){
		return waiter.waitForView(view);
	}

	/**
	 * Waits for the specified View. 
	 * 
	 * @param view the {@link View} object to wait for
	 * @param timeout the amount of time in milliseconds to wait
	 * @param scroll {@code true} if scrolling should be performed
	 * @return {@code true} if the {@link View} is displayed and {@code false} if it is not displayed before the timeout
	 */

	public <T extends View> boolean waitForView(View view, int timeout, boolean scroll){
		boolean checkIsShown = false;

		if(!scroll){
			checkIsShown = true;
		}
		
		View viewToWaitFor = waiter.waitForView(view, timeout, scroll, checkIsShown);
		
		if(viewToWaitFor != null)
			return true;
		
		return false;
	}

	/**
	 * Waits for a View matching the specified class.
	 * 
	 * @param viewClass the {@link View} class to wait for
	 * @param minimumNumberOfMatches the minimum number of matches that are expected to be found. {@code 0} means any number of matches
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if the {@link View} is displayed and {@code false} if it is not displayed before the timeout
	 */

	public <T extends View> boolean waitForView(final Class<T> viewClass, final int minimumNumberOfMatches, final int timeout){
		int index = minimumNumberOfMatches-1;

		if(index < 1)
			index = 0;

		return waiter.waitForView(viewClass, index, timeout, true);
	}

	/**
	 * Waits for a View matching the specified class.
	 * 
	 * @param viewClass the {@link View} class to wait for
	 * @param minimumNumberOfMatches the minimum number of matches that are expected to be found. {@code 0} means any number of matches
	 * @param timeout the amount of time in milliseconds to wait
	 * @param scroll {@code true} if scrolling should be performed
	 * @return {@code true} if the {@link View} is displayed and {@code false} if it is not displayed before the timeout
	 */

	public <T extends View> boolean waitForView(final Class<T> viewClass, final int minimumNumberOfMatches, final int timeout,final boolean scroll){
		int index = minimumNumberOfMatches-1;

		if(index < 1)
			index = 0;

		return waiter.waitForView(viewClass, index, timeout, scroll);
	}

	/**
	 * Waits for a WebElement matching the specified By object. Default timeout is 20 seconds. 
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 * @return {@code true} if the {@link WebElement} is displayed and {@code false} if it is not displayed before the timeout
	 */

	public boolean waitForWebElement(By by){
		return (waiter.waitForWebElement(by, 0, Timeout.getLargeTimeout(), true) != null);
	}

	/**
	 * Waits for a WebElement matching the specified By object.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 * @param timeout the the amount of time in milliseconds to wait 
	 * @param scroll {@code true} if scrolling should be performed
	 * @return {@code true} if the {@link WebElement} is displayed and {@code false} if it is not displayed before the timeout
	 */

	public boolean waitForWebElement(By by, int timeout, boolean scroll){
		return (waiter.waitForWebElement(by, 0, timeout, scroll) != null);
	}

	/**
	 * Waits for a WebElement matching the specified By object.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 * @param minimumNumberOfMatches the minimum number of matches that are expected to be found. {@code 0} means any number of matches
	 * @param timeout the the amount of time in milliseconds to wait 
	 * @param scroll {@code true} if scrolling should be performed
	 * @return {@code true} if the {@link WebElement} is displayed and {@code false} if it is not displayed before the timeout
	 */

	public boolean waitForWebElement(By by, int minimumNumberOfMatches, int timeout, boolean scroll){
		return (waiter.waitForWebElement(by, minimumNumberOfMatches, timeout, scroll) != null);
	}

	/**
	 * Waits for a condition to be satisfied.
	 * 
	 * @param condition the condition to wait for
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if condition is satisfied and {@code false} if it is not satisfied before the timeout
	 */

	public boolean waitForCondition(Condition condition, final int timeout){
		return waiter.waitForCondition(condition, timeout);
	}

	/**
	 * Searches for a text in the EditText objects currently displayed and returns true if found. Will automatically scroll when needed.
	 *
	 * @param text the text to search for
	 * @return {@code true} if an {@link EditText} displaying the specified text is found or {@code false} if it is not found
	 */

	public boolean searchEditText(String text) {
		return searcher.searchWithTimeoutFor(EditText.class, text, 1, true, false);
	}


	/**
	 * Searches for a Button displaying the specified text and returns {@code true} if at least one Button
	 * is found. Will automatically scroll when needed. 
	 *
	 * @param text the text to search for. The parameter will be interpreted as a regular expression
	 * @return {@code true} if a {@link Button} displaying the specified text is found and {@code false} if it is not found
	 */

	public boolean searchButton(String text) {
		return searcher.searchWithTimeoutFor(Button.class, text, 0, true, false);
	}

	/**
	 * Searches for a Button displaying the specified text and returns {@code true} if at least one Button
	 * is found. Will automatically scroll when needed. 
	 *
	 * @param text the text to search for. The parameter will be interpreted as a regular expression
	 * @param onlyVisible {@code true} if only {@link Button} visible on the screen should be searched
	 * @return {@code true} if a {@link Button} displaying the specified text is found and {@code false} if it is not found
	 */

	public boolean searchButton(String text, boolean onlyVisible) {
		return searcher.searchWithTimeoutFor(Button.class, text, 0, true, onlyVisible);
	}

	/**
	 * Searches for a ToggleButton displaying the specified text and returns {@code true} if at least one ToggleButton
	 * is found. Will automatically scroll when needed. 
	 *
	 * @param text the text to search for. The parameter will be interpreted as a regular expression
	 * @return {@code true} if a {@link ToggleButton} displaying the specified text is found and {@code false} if it is not found
	 */

	public boolean searchToggleButton(String text) {
		return searcher.searchWithTimeoutFor(ToggleButton.class, text, 0, true, false);
	}

	/**
	 * Searches for a Button displaying the specified text and returns {@code true} if the
	 * searched Button is found a specified number of times. Will automatically scroll when needed.
	 * 
	 * @param text the text to search for. The parameter will be interpreted as a regular expression
	 * @param minimumNumberOfMatches the minimum number of matches expected to be found. {@code 0} matches means that one or more
	 * matches are expected to be found
	 * @return {@code true} if a {@link Button} displaying the specified text is found a specified number of times and {@code false}
	 * if it is not found
	 */

	public boolean searchButton(String text, int minimumNumberOfMatches) {
		return searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, false);
	}

	/**
	 * Searches for a Button displaying the specified text and returns {@code true} if the
	 * searched Button is found a specified number of times. Will automatically scroll when needed.
	 * 
	 * @param text the text to search for. The parameter will be interpreted as a regular expression
	 * @param minimumNumberOfMatches the minimum number of matches expected to be found. {@code 0} matches means that one or more
	 * matches are expected to be found
	 * @param onlyVisible {@code true} if only {@link Button} visible on the screen should be searched
	 * @return {@code true} if a {@link Button} displaying the specified text is found a specified number of times and {@code false}
	 * if it is not found 
	 */

	public boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) {
		return searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible);
	}

	/**
	 * Searches for a ToggleButton displaying the specified text and returns {@code true} if the
	 * searched ToggleButton is found a specified number of times. Will automatically scroll when needed.
	 * 
	 * @param text the text to search for. The parameter will be interpreted as a regular expression
	 * @param minimumNumberOfMatches the minimum number of matches expected to be found. {@code 0} matches means that one or more
	 * matches are expected to be found
	 * @return {@code true} if a {@link ToggleButton} displaying the specified text is found a specified number of times and {@code false}
	 * if it is not found 
	 */

	public boolean searchToggleButton(String text, int minimumNumberOfMatches) {
		return searcher.searchWithTimeoutFor(ToggleButton.class, text, minimumNumberOfMatches, true, false);
	}

	/**
	 * Searches for the specified text and returns {@code true} if at least one item
	 * is found displaying the expected text. Will automatically scroll when needed. 
	 *
	 * @param text the text to search for. The parameter will be interpreted as a regular expression
	 * @return {@code true} if the search string is found and {@code false} if it is not found
	 */

	public boolean searchText(String text) {
		return searcher.searchWithTimeoutFor(TextView.class, text, 0, true, false);
	}

	/**
	 * Searches for the specified text and returns {@code true} if at least one item
	 * is found displaying the expected text. Will automatically scroll when needed. 
	 *
	 * @param text the text to search for. The parameter will be interpreted as a regular expression
	 * @param onlyVisible {@code true} if only texts visible on the screen should be searched
	 * @return {@code true} if the search string is found and {@code false} if it is not found
	 */

	public boolean searchText(String text, boolean onlyVisible) {
		return searcher.searchWithTimeoutFor(TextView.class, text, 0, true, onlyVisible);
	}

	/**
	 * Searches for the specified text and returns {@code true} if the searched text is found a specified
	 * number of times. Will automatically scroll when needed. 
	 * 
	 * @param text the text to search for. The parameter will be interpreted as a regular expression
	 * @param minimumNumberOfMatches the minimum number of matches expected to be found. {@code 0} matches means that one or more
	 * matches are expected to be found
	 * @return {@code true} if text is found a specified number of times and {@code false} if the text
	 * is not found 
	 */

	public boolean searchText(String text, int minimumNumberOfMatches) {
		return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, true, false);
	}

	/**
	 * Searches for the specified text and returns {@code true} if the searched text is found a specified
	 * number of times.
	 * 
	 * @param text the text to search for. The parameter will be interpreted as a regular expression.
	 * @param minimumNumberOfMatches the minimum number of matches expected to be found. {@code 0} matches means that one or more
	 * matches are expected to be found
	 * @param scroll {@code true} if scrolling should be performed
	 * @return {@code true} if text is found a specified number of times and {@code false} if the text
	 * is not found 
	 */

	public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) {
		return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, false);
	}

	/**
	 * Searches for the specified text and returns {@code true} if the searched text is found a specified
	 * number of times.
	 * 
	 * @param text the text to search for. The parameter will be interpreted as a regular expression.
	 * @param minimumNumberOfMatches the minimum number of matches expected to be found. {@code 0} matches means that one or more
	 * matches are expected to be found
	 * @param scroll {@code true} if scrolling should be performed
	 * @param onlyVisible {@code true} if only texts visible on the screen should be searched
	 * @return {@code true} if text is found a specified number of times and {@code false} if the text
	 * is not found 
	 */

	public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll, boolean onlyVisible) {
		return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, onlyVisible);
	}

	/**
	 * Sets the Orientation (Landscape/Portrait) for the current Activity.
	 * 
	 * @param orientation the orientation to set. <code>Solo.</code>{@link #LANDSCAPE} for landscape or
	 * <code>Solo.</code>{@link #PORTRAIT} for portrait.
	 */

	public void setActivityOrientation(int orientation)
	{
		activityUtils.setActivityOrientation(orientation);
	}

	/**
	 * Returns the current Activity.
	 *
	 * @return the current Activity
	 */

	public Activity getCurrentActivity() {
		return activityUtils.getCurrentActivity(false);
	}

	/**
	 * Asserts that the Activity matching the specified name is active.
	 * 
	 * @param message the message to display if the assert fails
	 * @param name the name of the {@link Activity} that is expected to be active. Example is: {@code "MyActivity"}
	 */

	public void assertCurrentActivity(String message, String name)
	{	
		asserter.assertCurrentActivity(message, name);
	}

	/**
	 * Asserts that the Activity matching the specified class is active.
	 * 
	 * @param message the message to display if the assert fails
	 * @param activityClass the class of the Activity that is expected to be active. Example is: {@code MyActivity.class}
	 */

	@SuppressWarnings("unchecked")
	public void assertCurrentActivity(String message, @SuppressWarnings("rawtypes") Class activityClass)
	{
		asserter.assertCurrentActivity(message, activityClass);

	}

	/**
	 * Asserts that the Activity matching the specified name is active, with the possibility to
	 * verify that the expected Activity is a new instance of the Activity.
	 * 
	 * @param message the message to display if the assert fails
	 * @param name the name of the Activity that is expected to be active. Example is: {@code "MyActivity"}
	 * @param isNewInstance {@code true} if the expected {@link Activity} is a new instance of the {@link Activity}
	 */

	public void assertCurrentActivity(String message, String name, boolean isNewInstance)
	{
		asserter.assertCurrentActivity(message, name, isNewInstance);
	}

	/**
	 * Asserts that the Activity matching the specified class is active, with the possibility to
	 * verify that the expected Activity is a new instance of the Activity.
	 * 
	 * @param message the message to display if the assert fails
	 * @param activityClass the class of the Activity that is expected to be active. Example is: {@code MyActivity.class}
	 * @param isNewInstance {@code true} if the expected {@link Activity} is a new instance of the {@link Activity}
	 */

	@SuppressWarnings("unchecked")
	public void assertCurrentActivity(String message, @SuppressWarnings("rawtypes") Class activityClass,
			boolean isNewInstance) {
		asserter.assertCurrentActivity(message, activityClass, isNewInstance);
	}	

	/**
	 * Asserts that the available memory is not considered low by the system.
	 */

	public void assertMemoryNotLow()
	{
		asserter.assertMemoryNotLow();
	}

	/**
	 * Waits for a Dialog to open. Default timeout is 20 seconds.
	 * 
	 * @return {@code true} if the {@link android.app.Dialog} is opened before the timeout and {@code false} if it is not opened
	 */

	public boolean waitForDialogToOpen() {
		return dialogUtils.waitForDialogToOpen(Timeout.getLargeTimeout(), true);
	}

	/**
	 * Waits for a Dialog to close. Default timeout is 20 seconds.
	 * 
	 * @return {@code true} if the {@link android.app.Dialog} is closed before the timeout and {@code false} if it is not closed
	 */

	public boolean waitForDialogToClose() {
		return dialogUtils.waitForDialogToClose(Timeout.getLargeTimeout());
	}

	/**
	 * Waits for a Dialog to open.
	 * 
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if the {@link android.app.Dialog} is opened before the timeout and {@code false} if it is not opened
	 */

	public boolean waitForDialogToOpen(long timeout) {
		return dialogUtils.waitForDialogToOpen(timeout, true);
	}

	/**
	 * Waits for a Dialog to close.
	 * 
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if the {@link android.app.Dialog} is closed before the timeout and {@code false} if it is not closed
	 */

	public boolean waitForDialogToClose(long timeout) {
		return dialogUtils.waitForDialogToClose(timeout);
	}


	/**
	 * Simulates pressing the hardware back key.
	 */

	public void goBack()
	{
		hideSoftKeyboard();
		sender.goBack();
	}

	/**
	 * Clicks the specified coordinates.
	 *
	 * @param x the x coordinate
	 * @param y the y coordinate
	 */

	public void clickOnScreen(float x, float y) {
		sleeper.sleep();
		clicker.clickOnScreen(x, y, null);
	}

	/**
	 * Clicks the specified coordinates rapidly a specified number of times. Requires API level >= 14.
	 *
	 * @param x the x coordinate
	 * @param y the y coordinate
	 * @param numberOfClicks the number of clicks to perform
	 */

	public void clickOnScreen(float x, float y, int numberOfClicks) {
		if (android.os.Build.VERSION.SDK_INT < 14){
			throw new RuntimeException("clickOnScreen(float x, float y, int numberOfClicks) requires API level >= 14");

		}
		tapper.generateTapGesture(numberOfClicks, new PointF(x, y));
	}

	/**
	 * Long clicks the specified coordinates.
	 *
	 * @param x the x coordinate
	 * @param y the y coordinate
	 */

	public void clickLongOnScreen(float x, float y) {
		clicker.clickLongOnScreen(x, y, 0, null);
	}

	/**
	 * Long clicks the specified coordinates for a specified amount of time.
	 *
	 * @param x the x coordinate
	 * @param y the y coordinate
	 * @param time the amount of time to long click
	 */

	public void clickLongOnScreen(float x, float y, int time) {
		clicker.clickLongOnScreen(x, y, time, null);
	}


	/**
	 * Clicks a Button displaying the specified text. Will automatically scroll when needed. 
	 *
	 * @param text the text displayed by the {@link Button}. The parameter will be interpreted as a regular expression
	 */

	public void clickOnButton(String text) {
		clicker.clickOn(Button.class, text);

	}

	/**
	 * Clicks an ImageButton matching the specified index.
	 *
	 * @param index the index of the {@link ImageButton} to click. 0 if only one is available
	 */

	public void clickOnImageButton(int index) {
		clicker.clickOn(ImageButton.class, index);
	}

	/**
	 * Clicks a ToggleButton displaying the specified text.
	 * 
	 * @param text the text displayed by the {@link ToggleButton}. The parameter will be interpreted as a regular expression
	 */

	public void clickOnToggleButton(String text) {
		clicker.clickOn(ToggleButton.class, text);
	}

	/**
	 * Clicks a MenuItem displaying the specified text.
	 * 
	 * @param text the text displayed by the MenuItem. The parameter will be interpreted as a regular expression
	 */

	public void clickOnMenuItem(String text)
	{	
		clicker.clickOnMenuItem(text);
	}

	/**
	 * Clicks a MenuItem displaying the specified text.
	 * 
	 * @param text the text displayed by the MenuItem. The parameter will be interpreted as a regular expression
	 * @param subMenu {@code true} if the menu item could be located in a sub menu
	 */

	public void clickOnMenuItem(String text, boolean subMenu)
	{
		clicker.clickOnMenuItem(text, subMenu);
	}

	/**
	 * Clicks the specified WebElement.
	 * 
	 * @param webElement the WebElement to click
	 */

	public void clickOnWebElement(WebElement webElement){
		if(webElement == null)
			Assert.fail("WebElement is null and can therefore not be clicked!");

		clicker.clickOnScreen(webElement.getLocationX(), webElement.getLocationY(), null);
	}

	/**
	 * Clicks a WebElement matching the specified By object.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 */

	public void clickOnWebElement(By by){
		clickOnWebElement(by, 0, true);
	}

	/**
	 * Clicks a WebElement matching the specified By object.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 * @param match if multiple objects match, this determines which one to click
	 */

	public void clickOnWebElement(By by, int match){
		clickOnWebElement(by, match, true);
	}

	/**
	 * Clicks a WebElement matching the specified By object.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 * @param match if multiple objects match, this determines which one to click
	 * @param scroll {@code true} if scrolling should be performed
	 */

	public void clickOnWebElement(By by, int match, boolean scroll){
		clicker.clickOnWebElement(by, match, scroll, config.useJavaScriptToClickWebElements);
	}

	/**
	 * Presses a MenuItem matching the specified index. Index {@code 0} is the first item in the
	 * first row, Index {@code 3} is the first item in the second row and
	 * index {@code 6} is the first item in the third row.
	 * 
	 * @param index the index of the {@link android.view.MenuItem} to press
	 */

	public void pressMenuItem(int index) {	
		presser.pressMenuItem(index);
	}

	/**
	 * Presses a MenuItem matching the specified index. Supports three rows with a specified amount
	 * of items. If itemsPerRow equals 5 then index 0 is the first item in the first row, 
	 * index 5 is the first item in the second row and index 10 is the first item in the third row.
	 * 
	 * @param index the index of the {@link android.view.MenuItem} to press
	 * @param itemsPerRow the amount of menu items there are per row   
	 */

	public void pressMenuItem(int index, int itemsPerRow) {	
		presser.pressMenuItem(index, itemsPerRow);
	}

	/**
	 * Presses the soft keyboard next button. 
	 */

	public void pressSoftKeyboardNextButton(){
		presser.pressSoftKeyboardSearchOrNextButton(false);
	}
	
	/**
	 * Presses the soft keyboard search button. 
	 */

	public void pressSoftKeyboardSearchButton(){
		presser.pressSoftKeyboardSearchOrNextButton(true);
	}

	/**
	 * Presses a Spinner (drop-down menu) item.
	 * 
	 * @param spinnerIndex the index of the {@link Spinner} menu to use
	 * @param itemIndex the index of the {@link Spinner} item to press relative to the currently selected item. 
	 * A Negative number moves up on the {@link Spinner}, positive moves down 
	 */

	public void pressSpinnerItem(int spinnerIndex, int itemIndex)
	{
		presser.pressSpinnerItem(spinnerIndex, itemIndex);
	} 

	/**
	 * Clicks the specified View.
	 *
	 * @param view the {@link View} to click
	 */

	public void clickOnView(View view) {
		view = waiter.waitForView(view, Timeout.getSmallTimeout());
		clicker.clickOnScreen(view);
	}

	/**
	 * Clicks the specified View.
	 * 
	 * @param view the {@link View} to click
	 * @param immediately {@code true} if View should be clicked without any wait
	 */

	public void clickOnView(View view, boolean immediately){
		if(immediately)
			clicker.clickOnScreen(view);
		else{
			view = waiter.waitForView(view, Timeout.getSmallTimeout());
			clicker.clickOnScreen(view);
		}
	}

	/**
	 * Long clicks the specified View.
	 *
	 * @param view the {@link View} to long click
	 */

	public void clickLongOnView(View view) {
		view = waiter.waitForView(view, Timeout.getSmallTimeout());
		clicker.clickOnScreen(view, true, 0);

	}	

	/**
	 * Long clicks the specified View for a specified amount of time.
	 *
	 * @param view the {@link View} to long click
	 * @param time the amount of time to long click
	 */

	public void clickLongOnView(View view, int time) {
		clicker.clickOnScreen(view, true, time);

	}

	/**
	 * Clicks a View or WebElement displaying the specified
	 * text. Will automatically scroll when needed. 
	 *
	 * @param text the text to click. The parameter will be interpreted as a regular expression
	 */

	public void clickOnText(String text) {
		clicker.clickOnText(text, false, 1, true, 0);
	}

	/**
	 * Clicks a View or WebElement displaying the specified text. Will automatically scroll when needed.
	 *
	 * @param text the text to click. The parameter will be interpreted as a regular expression
	 * @param match if multiple objects match the text, this determines which one to click
	 */	

	public void clickOnText(String text, int match) {
		clicker.clickOnText(text, false, match, true, 0);
	}

	/**
	 * Clicks a View or WebElement displaying the specified text.
	 *
	 * @param text the text to click. The parameter will be interpreted as a regular expression
	 * @param match if multiple objects match the text, this determines which one to click
	 * @param scroll {@code true} if scrolling should be performed
	 */

	public void clickOnText(String text, int match, boolean scroll) {
		clicker.clickOnText(text, false, match, scroll, 0);
	}

	/**
	 * Long clicks a View or WebElement displaying the specified text. Will automatically scroll when needed. 
	 *
	 * @param text the text to click. The parameter will be interpreted as a regular expression
	 */

	public void clickLongOnText(String text)
	{
		clicker.clickOnText(text, true, 1, true, 0);
	}

	/**
	 * Long clicks a View or WebElement displaying the specified text. Will automatically scroll when needed.
	 *
	 * @param text the text to click. The parameter will be interpreted as a regular expression
	 * @param match if multiple objects match the text, this determines which one to click
	 */

	public void clickLongOnText(String text, int match)
	{
		clicker.clickOnText(text, true, match, true, 0);
	}

	/**
	 * Long clicks a View or WebElement displaying the specified text.
	 *
	 * @param text the text to click. The parameter will be interpreted as a regular expression
	 * @param match if multiple objects match the text, this determines which one to click
	 * @param scroll {@code true} if scrolling should be performed
	 */

	public void clickLongOnText(String text, int match, boolean scroll)
	{
		clicker.clickOnText(text, true, match, scroll, 0);
	}

	/**
	 * Long clicks a View or WebElement displaying the specified text. 
	 *
	 * @param text the text to click. The parameter will be interpreted as a regular expression
	 * @param match if multiple objects match the text, this determines which one to click
	 * @param time the amount of time to long click 
	 */

	public void clickLongOnText(String text, int match, int time)
	{
		clicker.clickOnText(text, true, match, true, time);
	}

	/**
	 * Long clicks a View displaying the specified text and then selects
	 * an item from the context menu that appears. Will automatically scroll when needed. 
	 *
	 * @param text the text to click. The parameter will be interpreted as a regular expression
	 * @param index the index of the menu item to press. {@code 0} if only one is available
	 */

	public void clickLongOnTextAndPress(String text, int index) {
		clicker.clickLongOnTextAndPress(text, index);
	}

	/**
	 * Clicks a Button matching the specified index.
	 *
	 * @param index the index of the {@link Button} to click. {@code 0} if only one is available
	 */

	public void clickOnButton(int index) {
		clicker.clickOn(Button.class, index);
	}

	/**
	 * Clicks a RadioButton matching the specified index.
	 *
	 * @param index the index of the {@link RadioButton} to click. {@code 0} if only one is available
	 */	

	public void clickOnRadioButton(int index) {
		clicker.clickOn(RadioButton.class, index);
	}

	/**
	 * Clicks a CheckBox matching the specified index.
	 *
	 * @param index the index of the {@link CheckBox} to click. {@code 0} if only one is available
	 */	

	public void clickOnCheckBox(int index) {
		clicker.clickOn(CheckBox.class, index);
	}

	/**
	 * Clicks an EditText matching the specified index.
	 *
	 * @param index the index of the {@link EditText} to click. {@code 0} if only one is available
	 */

	public void clickOnEditText(int index) {
		clicker.clickOn(EditText.class, index);
	}

	/**
	 * Clicks the specified list line and returns an ArrayList of the TextView objects that
	 * the list line is displaying. Will use the first ListView it finds.
	 * 
	 * @param line the line to click
	 * @return an {@code ArrayList} of the {@link TextView} objects located in the list line
	 */

	public ArrayList<TextView> clickInList(int line) {
		return clicker.clickInList(line);
	}

	/**
	 * Clicks the specified list line in the ListView matching the specified index and 
	 * returns an ArrayList of the TextView objects that the list line is displaying.
	 * 
	 * @param line the line to click
	 * @param index the index of the list. {@code 0} if only one is available
	 * @return an {@code ArrayList} of the {@link TextView} objects located in the list line
	 */

	public ArrayList<TextView> clickInList(int line, int index) {
		return clicker.clickInList(line, index, false, 0);
	}

	/**
	 * Long clicks the specified list line and returns an ArrayList of the TextView objects that
	 * the list line is displaying. Will use the first ListView it finds.
	 * 
	 * @param line the line to click
	 * @return an {@code ArrayList} of the {@link TextView} objects located in the list line
	 */

	public ArrayList<TextView> clickLongInList(int line){
		return clicker.clickInList(line, 0, true, 0);
	}

	/**
	 * Long clicks the specified list line in the ListView matching the specified index and 
	 * returns an ArrayList of the TextView objects that the list line is displaying.
	 * 
	 * @param line the line to click
	 * @param index the index of the list. {@code 0} if only one is available
	 * @return an {@code ArrayList} of the {@link TextView} objects located in the list line
	 */

	public ArrayList<TextView> clickLongInList(int line, int index){
		return clicker.clickInList(line, index, true, 0);
	}

	/**
	 * Long clicks the specified list line in the ListView matching the specified index and 
	 * returns an ArrayList of the TextView objects that the list line is displaying.
	 * 
	 * @param line the line to click
	 * @param index the index of the list. {@code 0} if only one is available
	 * @param time the amount of time to long click
	 * @return an {@code ArrayList} of the {@link TextView} objects located in the list line
	 */

	public ArrayList<TextView> clickLongInList(int line, int index, int time){
		return clicker.clickInList(line, index, true, time);
	}

	/**
	 * Clicks an ActionBarItem matching the specified resource id.
	 * 
	 * @param id the R.id of the ActionBar item to click
	 */

	public void clickOnActionBarItem(int id){
		clicker.clickOnActionBarItem(id);
	}

	/**
	 * Clicks an ActionBar Home/Up button.
	 */

	public void clickOnActionBarHomeButton() {
		clicker.clickOnActionBarHomeButton();
	}

	/**
	 * Simulate touching the specified location and dragging it to a new location.
	 *
	 *
	 * @param fromX X coordinate of the initial touch, in screen coordinates
	 * @param toX X coordinate of the drag destination, in screen coordinates
	 * @param fromY Y coordinate of the initial touch, in screen coordinates
	 * @param toY Y coordinate of the drag destination, in screen coordinates
	 * @param stepCount how many move steps to include in the drag. Less steps results in a faster drag
	 */

	public void drag(float fromX, float toX, float fromY, float toY, 
			int stepCount) {
		dialogUtils.hideSoftKeyboard(null, false, true);
		scroller.drag(fromX, toX, fromY, toY, stepCount);
	}

	/**
	 * Scrolls down the screen.
	 *
	 * @return {@code true} if more scrolling can be performed and {@code false} if it is at the end of
	 * the screen
	 */

	@SuppressWarnings("unchecked")
	public boolean scrollDown() {
		waiter.waitForViews(true, AbsListView.class, ScrollView.class, WebView.class);
		return scroller.scroll(Scroller.DOWN);
	}

	/**
	 * Scrolls to the bottom of the screen.
	 */

	@SuppressWarnings("unchecked")
	public void scrollToBottom() {
		waiter.waitForViews(true, AbsListView.class, ScrollView.class, WebView.class);
		scroller.scroll(Scroller.DOWN, true);
	}


	/**
	 * Scrolls up the screen.
	 *
	 * @return {@code true} if more scrolling can be performed and {@code false} if it is at the top of
	 * the screen 
	 */

	@SuppressWarnings("unchecked")
	public boolean scrollUp(){
		waiter.waitForViews(true, AbsListView.class, ScrollView.class, WebView.class);
		return scroller.scroll(Scroller.UP);
	}

	/**
	 * Scrolls to the top of the screen.
	 */	

	@SuppressWarnings("unchecked")
	public void scrollToTop() {
		waiter.waitForViews(true, AbsListView.class, ScrollView.class, WebView.class);
		scroller.scroll(Scroller.UP, true);
	}

	/**
	 * Scrolls down the specified AbsListView.
	 * 
	 * @param list the {@link AbsListView} to scroll
	 * @return {@code true} if more scrolling can be performed
	 */

	public boolean scrollDownList(AbsListView list) {
		return scroller.scrollList(list, Scroller.DOWN, false);
	}

	/**
	 * Scrolls to the bottom of the specified AbsListView.
	 *
	 * @param list the {@link AbsListView} to scroll
	 * @return {@code true} if more scrolling can be performed
	 */

	public boolean scrollListToBottom(AbsListView list) {
		return scroller.scrollList(list, Scroller.DOWN, true);
	}

	/**
	 * Scrolls up the specified AbsListView.
	 * 
	 * @param list the {@link AbsListView} to scroll
	 * @return {@code true} if more scrolling can be performed
	 */

	public boolean scrollUpList(AbsListView list) {
		return scroller.scrollList(list, Scroller.UP, false);
	}

	/**
	 * Scrolls to the top of the specified AbsListView.
	 *
	 * @param list the {@link AbsListView} to scroll
	 * @return {@code true} if more scrolling can be performed
	 */

	public boolean scrollListToTop(AbsListView list) {
		return scroller.scrollList(list, Scroller.UP, true);
	}

	/**
	 * Scrolls down a ListView matching the specified index.
	 * 
	 * @param index the index of the {@link ListView} to scroll. {@code 0} if only one list is available
	 * @return {@code true} if more scrolling can be performed
	 */

	public boolean scrollDownList(int index) {
		return scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.DOWN, false);
	}

	/**
	 * Scrolls a ListView matching the specified index to the bottom.
	 *
	 * @param index the index of the {@link ListView} to scroll. {@code 0} if only one list is available
	 * @return {@code true} if more scrolling can be performed
	 */

	public boolean scrollListToBottom(int index) {
		return scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.DOWN, true);
	}

	/**
	 * Scrolls up a ListView matching the specified index.
	 * 
	 * @param index the index of the {@link ListView} to scroll. {@code 0} if only one list is available
	 * @return {@code true} if more scrolling can be performed
	 */

	public boolean scrollUpList(int index) {
		return scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.UP, false);
	}

	/**
	 * Scrolls a ListView matching the specified index to the top.
	 *
	 * @param index the index of the {@link ListView} to scroll. {@code 0} if only one list is available
	 * @return {@code true} if more scrolling can be performed
	 */

	public boolean scrollListToTop(int index) {
		return scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.UP, true);
	}

	/**
	 * Scroll the specified AbsListView to the specified line. 
	 *
	 * @param absListView the {@link AbsListView} to scroll
	 * @param line the line to scroll to
	 */	

	public void scrollListToLine(AbsListView absListView, int line){
		scroller.scrollListToLine(absListView, line);
	}

	/**
	 * Scroll a AbsListView matching the specified index to the specified line. 
	 *
	 * @param index the index of the {@link AbsListView} to scroll
	 * @param line the line to scroll to
	 */

	public void scrollListToLine(int index, int line){
		scroller.scrollListToLine(waiter.waitForAndGetView(index, AbsListView.class), line);
	}
	
	/**
	 * Scrolls horizontally.
	 *
	 * @param side the side to scroll; {@link #RIGHT} or {@link #LEFT}
	 * @param scrollPosition the position to scroll to, from 0 to 1 where 1 is all the way. Example is: 0.60
	 * @param stepCount how many move steps to include in the scroll. Less steps results in a faster scroll
	 */

	public void scrollToSide(int side, float scrollPosition, int stepCount) {
		switch (side){
		case RIGHT: scroller.scrollToSide(Scroller.Side.RIGHT, scrollPosition, stepCount); break;
		case LEFT:  scroller.scrollToSide(Scroller.Side.LEFT, scrollPosition, stepCount);  break;
		}
	}

	/**
	 * Scrolls horizontally.
	 *
	 * @param side the side to scroll; {@link #RIGHT} or {@link #LEFT}
	 * @param scrollPosition the position to scroll to, from 0 to 1 where 1 is all the way. Example is: 0.60
	 */

	public void scrollToSide(int side, float scrollPosition) {
		scrollToSide(side, scrollPosition, 20);
	}

	/**
	 * Scrolls horizontally.
	 *
	 * @param side the side to scroll; {@link #RIGHT} or {@link #LEFT}
	 */

	public void scrollToSide(int side) {
		scrollToSide(side, 0.75F);
	}
	
	/**
	 * Scrolls a View horizontally.
	 *
	 * @param view the View to scroll
	 * @param side the side to scroll; {@link #RIGHT} or {@link #LEFT}
	 * @param scrollPosition the position to scroll to, from 0 to 1 where 1 is all the way. Example is: 0.60
	 * @param stepCount how many move steps to include in the scroll. Less steps results in a faster scroll
	 */

	public void scrollViewToSide(View view, int side, float scrollPosition, int stepCount) {
		waitForView(view);
		sleeper.sleep();
		switch (side){
		case RIGHT: scroller.scrollViewToSide(view, Scroller.Side.RIGHT, scrollPosition, stepCount); break;
		case LEFT:  scroller.scrollViewToSide(view, Scroller.Side.LEFT, scrollPosition, stepCount);  break;
		}
	}

	/**
	 * Scrolls a View horizontally.
	 *
	 * @param view the View to scroll
	 * @param side the side to scroll; {@link #RIGHT} or {@link #LEFT}
	 * @param scrollPosition the position to scroll to, from 0 to 1 where 1 is all the way. Example is: 0.60
	 */

	public void scrollViewToSide(View view, int side, float scrollPosition) {
		scrollViewToSide(view, side, scrollPosition, 20);
	}

	/**
	 * Scrolls a View horizontally.
	 *
	 * @param view the View to scroll
	 * @param side the side to scroll; {@link #RIGHT} or {@link #LEFT}
	 */

	public void scrollViewToSide(View view, int side) {
		scrollViewToSide(view, side, 0.70F);
	}

	/**
	 * Zooms in or out if startPoint1 and startPoint2 are larger or smaller then endPoint1 and endPoint2. Requires API level >= 14.
	 * 
	 * @param startPoint1 First "finger" down on the screen
	 * @param startPoint2 Second "finger" down on the screen
	 * @param endPoint1 Corresponding ending point of startPoint1
	 * @param endPoint2 Corresponding ending point of startPoint2
	 */

	public void pinchToZoom(PointF startPoint1, PointF startPoint2, PointF endPoint1, PointF endPoint2)
	{
		if (android.os.Build.VERSION.SDK_INT < 14){
			throw new RuntimeException("pinchToZoom() requires API level >= 14");
		}
		zoomer.generateZoomGesture(startPoint1, startPoint2, endPoint1, endPoint2);
	}

	/**
	 * Swipes with two fingers in a linear path determined by starting and ending points. Requires API level >= 14.
	 * 
	 * @param startPoint1 First "finger" down on the screen
	 * @param startPoint2 Second "finger" down on the screen
	 * @param endPoint1 Corresponding ending point of startPoint1
	 * @param endPoint2 Corresponding ending point of startPoint2
	 */

	public void swipe(PointF startPoint1, PointF startPoint2, PointF endPoint1, PointF endPoint2)
	{
		if (android.os.Build.VERSION.SDK_INT < 14){
			throw new RuntimeException("swipe() requires API level >= 14");
		}
		swiper.generateSwipeGesture(startPoint1, startPoint2, endPoint1,
				endPoint2);
	}

	/**
	 * Draws two semi-circles at the specified centers. Both circles are larger than rotateSmall(). Requires API level >= 14.
	 * 
	 * @param center1 Center of semi-circle drawn from [0, Pi]
	 * @param center2 Center of semi-circle drawn from [Pi, 3*Pi]
	 */

	public void rotateLarge(PointF center1, PointF center2)
	{
		if (android.os.Build.VERSION.SDK_INT < 14){
			throw new RuntimeException("rotateLarge(PointF center1, PointF center2) requires API level >= 14");
		}
		rotator.generateRotateGesture(Rotator.LARGE, center1, center2);
	}

	/**
	 * Draws two semi-circles at the specified centers. Both circles are smaller than rotateLarge(). Requires API level >= 14.
	 * 
	 * @param center1 Center of semi-circle drawn from [0, Pi]
	 * @param center2 Center of semi-circle drawn from [Pi, 3*Pi]
	 */	

	public void rotateSmall(PointF center1, PointF center2)
	{
		if (android.os.Build.VERSION.SDK_INT < 14){
			throw new RuntimeException("rotateSmall(PointF center1, PointF center2) requires API level >= 14");
		}
		rotator.generateRotateGesture(Rotator.SMALL, center1, center2);
	}

	/**
	 * Sets the date in a DatePicker matching the specified index.
	 *
	 * @param index the index of the {@link DatePicker}. {@code 0} if only one is available
	 * @param year the year e.g. 2011
	 * @param monthOfYear the month which starts from zero e.g. 0 for January
	 * @param dayOfMonth the day e.g. 10
	 */

	public void setDatePicker(int index, int year, int monthOfYear, int dayOfMonth) {
		setDatePicker(waiter.waitForAndGetView(index, DatePicker.class), year, monthOfYear, dayOfMonth);
	}

	/**
	 * Sets the date in the specified DatePicker.
	 *
	 * @param datePicker the {@link DatePicker} object
	 * @param year the year e.g. 2011
	 * @param monthOfYear the month which starts from zero e.g. 03 for April
	 * @param dayOfMonth the day e.g. 10
	 */

	public void setDatePicker(DatePicker datePicker, int year, int monthOfYear, int dayOfMonth) {
		datePicker = (DatePicker) waiter.waitForView(datePicker, Timeout.getSmallTimeout());
		setter.setDatePicker(datePicker, year, monthOfYear, dayOfMonth);
	}

	/**
	 * Sets the time in a TimePicker matching the specified index.
	 *
	 * @param index the index of the {@link TimePicker}. {@code 0} if only one is available
	 * @param hour the hour e.g. 15
	 * @param minute the minute e.g. 30
	 */

	public void setTimePicker(int index, int hour, int minute) {		
		setTimePicker(waiter.waitForAndGetView(index, TimePicker.class), hour, minute);
	}

	/**
	 * Sets the time in the specified TimePicker.
	 *
	 * @param timePicker the {@link TimePicker} object
	 * @param hour the hour e.g. 15
	 * @param minute the minute e.g. 30
	 */

	public void setTimePicker(TimePicker timePicker, int hour, int minute) {
		timePicker = (TimePicker) waiter.waitForView(timePicker, Timeout.getSmallTimeout());
		setter.setTimePicker(timePicker, hour, minute);
	}

	/**
	 * Sets the progress of a ProgressBar matching the specified index. Examples of ProgressBars are: {@link android.widget.SeekBar} and {@link android.widget.RatingBar}.
	 *
	 * @param index the index of the {@link ProgressBar}
	 * @param progress the progress to set the {@link ProgressBar} 
	 */

	public void setProgressBar(int index, int progress){
		setProgressBar(waiter.waitForAndGetView(index, ProgressBar.class), progress);
	}

	/**
	 * Sets the progress of the specified ProgressBar. Examples of ProgressBars are: {@link android.widget.SeekBar} and {@link android.widget.RatingBar}.
	 *
	 * @param progressBar the {@link ProgressBar}
	 * @param progress the progress to set the {@link ProgressBar} 
	 */

	public void setProgressBar(ProgressBar progressBar, int progress){
		progressBar = (ProgressBar) waiter.waitForView(progressBar, Timeout.getSmallTimeout());
		setter.setProgressBar(progressBar, progress);
	}
	
	/**
	 * Sets the status of the NavigationDrawer. Examples of status are: {@code Solo.CLOSED} and {@code Solo.OPENED}.
	 *
	 * @param status the status that the {@link NavigationDrawer} should be set to
	 */

	public void setNavigationDrawer(final int status){
		setter.setNavigationDrawer(status);
	}

	/**
	 * Sets the status of a SlidingDrawer matching the specified index. Examples of status are: {@code Solo.CLOSED} and {@code Solo.OPENED}.
	 *
	 * @param index the index of the {@link SlidingDrawer}
	 * @param status the status to set the {@link SlidingDrawer} 
	 */

	public void setSlidingDrawer(int index, int status){
		setSlidingDrawer(waiter.waitForAndGetView(index, SlidingDrawer.class), status);
	}

	/**
	 * Sets the status of the specified SlidingDrawer. Examples of status are: {@code Solo.CLOSED} and {@code Solo.OPENED}.
	 *
	 * @param slidingDrawer the {@link SlidingDrawer}
	 * @param status the status to set the {@link SlidingDrawer} 
	 */

	@SuppressWarnings("deprecation")
	public void setSlidingDrawer(SlidingDrawer slidingDrawer, int status){
		slidingDrawer = (SlidingDrawer) waiter.waitForView(slidingDrawer, Timeout.getSmallTimeout());
		setter.setSlidingDrawer(slidingDrawer, status);
	}

	/**
	 * Enters text in an EditText matching the specified index.
	 *
	 * @param index the index of the {@link EditText}. {@code 0} if only one is available
	 * @param text the text to enter in the {@link EditText} field
	 */

	public void enterText(int index, String text) {
		textEnterer.setEditText(waiter.waitForAndGetView(index, EditText.class), text);		
	}

	/**
	 * Enters text in the specified EditText.
	 *
	 * @param editText the {@link EditText} to enter text in
	 * @param text the text to enter in the {@link EditText} field
	 */

	public void enterText(EditText editText, String text) {
		editText = (EditText) waiter.waitForView(editText, Timeout.getSmallTimeout());
		textEnterer.setEditText(editText, text);		
	}

	/**
	 * Enters text in a WebElement matching the specified By object.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 * @param text the text to enter in the {@link WebElement} field
	 */

	public void enterTextInWebElement(By by, String text){
		if(waiter.waitForWebElement(by, 0, Timeout.getSmallTimeout(), false) == null) {
			Assert.fail("WebElement with " + webUtils.splitNameByUpperCase(by.getClass().getSimpleName()) + ": '" + by.getValue() + "' is not found!");
		}
		webUtils.enterTextIntoWebElement(by, text);
	}

	/**
	 * Types text in an EditText matching the specified index.
	 *
	 * @param index the index of the {@link EditText}. {@code 0} if only one is available
	 * @param text the text to type in the {@link EditText} field
	 */

	public void typeText(int index, String text) {
		textEnterer.typeText(waiter.waitForAndGetView(index, EditText.class), text);		
	}

	/**
	 * Types text in the specified EditText.
	 *
	 * @param editText the {@link EditText} to type text in
	 * @param text the text to type in the {@link EditText} field
	 */

	public void typeText(EditText editText, String text) {
		editText = (EditText) waiter.waitForView(editText, Timeout.getSmallTimeout());
		textEnterer.typeText(editText, text);		
	}

	/**
	 * Types text in a WebElement matching the specified By object.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 * @param text the text to enter in the {@link WebElement} field
	 */

	public void typeTextInWebElement(By by, String text){
		typeTextInWebElement(by, text, 0);
	}

	/**
	 * Types text in a WebElement matching the specified By object.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 * @param text the text to enter in the {@link WebElement} field
	 * @param match if multiple objects match, this determines which one will be typed in
	 */

	public void typeTextInWebElement(By by, String text, int match){
		clicker.clickOnWebElement(by, match, true, false);
		dialogUtils.hideSoftKeyboard(null, true, true);
		instrumentation.sendStringSync(text);
	}

	/**
	 * Types text in the specified WebElement.
	 * 
	 * @param webElement the WebElement to type text in
	 * @param text the text to enter in the {@link WebElement} field
	 */

	public void typeTextInWebElement(WebElement webElement, String text){
		clickOnWebElement(webElement);
		dialogUtils.hideSoftKeyboard(null, true, true);
		instrumentation.sendStringSync(text);
	}

	/**
	 * Clears the value of an EditText.
	 * 
	 * @param index the index of the {@link EditText} to clear. 0 if only one is available
	 */

	public void clearEditText(int index) {
		textEnterer.setEditText(waiter.waitForAndGetView(index, EditText.class), "");
	}

	/**
	 * Clears the value of an EditText.
	 * 
	 * @param editText the {@link EditText} to clear
	 */

	public void clearEditText(EditText editText) {
		editText = (EditText) waiter.waitForView(editText, Timeout.getSmallTimeout());
		textEnterer.setEditText(editText, "");	
	}

	/**
	 * Clears text in a WebElement matching the specified By object.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 */

	public void clearTextInWebElement(By by){
		webUtils.enterTextIntoWebElement(by, "");
	}

	/**
	 * Clicks an ImageView matching the specified index.
	 *
	 * @param index the index of the {@link ImageView} to click. {@code 0} if only one is available
	 */

	public void clickOnImage(int index) {
		clicker.clickOn(ImageView.class, index);
	}

	/**
	 * Returns an EditText matching the specified index.
	 *
	 * @param index the index of the {@link EditText}. {@code 0} if only one is available
	 * @return an {@link EditText} matching the specified index
	 */

	public EditText getEditText(int index) {
		return getter.getView(EditText.class, index);
	}

	/**
	 * Returns a Button matching the specified index.
	 *
	 * @param index the index of the {@link Button}. {@code 0} if only one is available
	 * @return a {@link Button} matching the specified index
	 */

	public Button getButton(int index) {
		return getter.getView(Button.class, index);
	}

	/**
	 * Returns a TextView matching the specified index.
	 *
	 * @param index the index of the {@link TextView}. {@code 0} if only one is available
	 * @return a {@link TextView} matching the specified index
	 */

	public TextView getText(int index) {
		return getter.getView(TextView.class, index);
	}

	/**
	 * Returns an ImageView matching the specified index.
	 *
	 * @param index the index of the {@link ImageView}. {@code 0} if only one is available
	 * @return an {@link ImageView} matching the specified index
	 */

	public ImageView getImage(int index) {
		return getter.getView(ImageView.class, index);
	}

	/**
	 * Returns an ImageButton matching the specified index.
	 *
	 * @param index the index of the {@link ImageButton}. {@code 0} if only one is available
	 * @return the {@link ImageButton} matching the specified index
	 */

	public ImageButton getImageButton(int index) {
		return getter.getView(ImageButton.class, index);
	}

	/**
	 * Returns a TextView displaying the specified text. 
	 * 
	 * @param text the text that is displayed, specified as a regular expression
	 * @return the {@link TextView} displaying the specified text
	 */

	public TextView getText(String text)
	{
		return getter.getView(TextView.class, text, false);
	}

	/**
	 * Returns a TextView displaying the specified text. 
	 * 
	 * @param text the text that is displayed, specified as a regular expression
	 * @param onlyVisible {@code true} if only visible texts on the screen should be returned
	 * @return the {@link TextView} displaying the specified text
	 */

	public TextView getText(String text, boolean onlyVisible)
	{
		return getter.getView(TextView.class, text, onlyVisible);
	}

	/**
	 * Returns a Button displaying the specified text.
	 * 
	 * @param text the text that is displayed, specified as a regular expression
	 * @return the {@link Button} displaying the specified text
	 */

	public Button getButton(String text)
	{
		return getter.getView(Button.class, text, false);
	}

	/**
	 * Returns a Button displaying the specified text.
	 * 
	 * @param text the text that is displayed, specified as a regular expression
	 * @param onlyVisible {@code true} if only visible buttons on the screen should be returned
	 * @return the {@link Button} displaying the specified text
	 */

	public Button getButton(String text, boolean onlyVisible)
	{
		return getter.getView(Button.class, text, onlyVisible);
	}

	/**
	 * Returns an EditText displaying the specified text.
	 * 
	 * @param text the text that is displayed, specified as a regular expression
	 * @return the {@link EditText} displaying the specified text
	 */

	public EditText getEditText(String text)
	{
		return getter.getView(EditText.class, text, false);
	}

	/**
	 * Returns an EditText displaying the specified text.
	 * 
	 * @param text the text that is displayed, specified as a regular expression
	 * @param onlyVisible {@code true} if only visible EditTexts on the screen should be returned
	 * @return the {@link EditText} displaying the specified text
	 */

	public EditText getEditText(String text, boolean onlyVisible)
	{
		return getter.getView(EditText.class, text, onlyVisible);
	}

	/**
	 * Returns a View matching the specified resource id. 
	 * 
	 * @param id the R.id of the {@link View} to return
	 * @return a {@link View} matching the specified id 
	 */

	public View getView(int id){
		return getView(id, 0);
	}

	/**
	 * Returns a View matching the specified resource id and index. 
	 * 
	 * @param id the R.id of the {@link View} to return
	 * @param index the index of the {@link View}. {@code 0} if only one is available
	 * @return a {@link View} matching the specified id and index
	 */

	public View getView(int id, int index){
		View viewToReturn = getter.getView(id, index);

		if(viewToReturn == null) {
			int match = index + 1;
			if(match > 1){
				Assert.fail(match + " Views with id: '" + id + "' are not found!");
			}
			else {
				Assert.fail("View with id: '" + id + "' is not found!");
			}
		}
		return viewToReturn;
	}

	/**
	 * Returns a View matching the specified resource id. 
	 * 
	 * @param id the id of the {@link View} to return
	 * @return a {@link View} matching the specified id
	 */

	public View getView(String id){
		return getView(id, 0);
	}

	/**
	 * Returns a View matching the specified resource id and index. 
	 * 
	 * @param id the id of the {@link View} to return
	 * @param index the index of the {@link View}. {@code 0} if only one is available
	 * @return a {@link View} matching the specified id and index
	 */

	public View getView(String id, int index){
		View viewToReturn = getter.getView(id, index);

		if(viewToReturn == null) {
			int match = index + 1;
			if(match > 1){
				Assert.fail(match + " Views with id: '" + id + "' are not found!");
			}
			else {
				Assert.fail("View with id: '" + id + "' is not found!");
			}
		}
		return viewToReturn;
	}

	/**
	 * Returns a View matching the specified class and index. 
	 * 
	 * @param viewClass the class of the requested view
	 * @param index the index of the {@link View}. {@code 0} if only one is available
	 * @return a {@link View} matching the specified class and index 
	 */

	public <T extends View> T getView(Class<T> viewClass, int index){
		return waiter.waitForAndGetView(index, viewClass);
	}

	/**
	 * Returns a WebElement matching the specified By object and index.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 * @param index the index of the {@link WebElement}. {@code 0} if only one is available
	 * @return a {@link WebElement} matching the specified index
	 */

	public WebElement getWebElement(By by, int index){
		int match = index + 1;
		WebElement webElement = waiter.waitForWebElement(by, match, Timeout.getSmallTimeout(), true);

		if(webElement == null) {
			if(match > 1){
				Assert.fail(match + " WebElements with " + webUtils.splitNameByUpperCase(by.getClass().getSimpleName()) + ": '" + by.getValue() + "' are not found!");
			}
			else {
				Assert.fail("WebElement with " + webUtils.splitNameByUpperCase(by.getClass().getSimpleName()) + ": '" + by.getValue() + "' is not found!");
			}
		}
		return webElement;
	}

	/**
	 * Returns the current web page URL.
	 * 
	 * @return the current web page URL
	 */

	public String getWebUrl() {
		final WebView webView = waiter.waitForAndGetView(0, WebView.class);

		if(webView == null)
			Assert.fail("WebView is not found!");

		instrumentation.runOnMainSync(new Runnable() {
			public void run() {
				webUrl = webView.getUrl();
			}
		});
		return webUrl;
	}

	/**
	 * Returns an ArrayList of the Views currently displayed in the focused Activity or Dialog.
	 *
	 * @return an {@code ArrayList} of the {@link View} objects currently displayed in the
	 * focused window
	 */	

	public ArrayList<View> getCurrentViews() {
		return viewFetcher.getViews(null, true);
	}

	/**
	 * Returns an ArrayList of Views matching the specified class located in the focused Activity or Dialog.
	 *
	 * @param classToFilterBy return all instances of this class. Examples are: {@code Button.class} or {@code ListView.class}
	 * @return an {@code ArrayList} of {@code View}s matching the specified {@code Class} located in the current {@code Activity}
	 */

	public <T extends View> ArrayList<T> getCurrentViews(Class<T> classToFilterBy) {
		return viewFetcher.getCurrentViews(classToFilterBy, true);
	}

	/**
	 * Returns an ArrayList of Views matching the specified class located in the focused Activity or Dialog.
	 *
	 * @param classToFilterBy return all instances of this class. Examples are: {@code Button.class} or {@code ListView.class}
	 * @param includeSubclasses include instances of the subclasses in the {@code ArrayList} that will be returned
	 * @return an {@code ArrayList} of {@code View}s matching the specified {@code Class} located in the current {@code Activity}
	 */

	public <T extends View> ArrayList<T> getCurrentViews(Class<T> classToFilterBy, boolean includeSubclasses) {
		return viewFetcher.getCurrentViews(classToFilterBy, includeSubclasses);
	}

	/**
	 * Returns an ArrayList of Views matching the specified class located under the specified parent.
	 *
	 * @param classToFilterBy return all instances of this class. Examples are: {@code Button.class} or {@code ListView.class}
	 * @param parent the parent {@code View} for where to start the traversal
	 * @return an {@code ArrayList} of {@code View}s matching the specified {@code Class} located under the specified {@code parent}
	 */

	public <T extends View> ArrayList<T> getCurrentViews(Class<T> classToFilterBy, View parent) {
		return viewFetcher.getCurrentViews(classToFilterBy, true, parent);
	}

	/**
	 * Returns an ArrayList of Views matching the specified class located under the specified parent.
	 *
	 * @param classToFilterBy return all instances of this class. Examples are: {@code Button.class} or {@code ListView.class}
	 * @param includeSubclasses include instances of subclasses in the {@code ArrayList} that will be returned
	 * @param parent the parent {@code View} for where to start the traversal
	 * @return an {@code ArrayList} of {@code View}s matching the specified {@code Class} located under the specified {@code parent}
	 */
	public <T extends View> ArrayList<T> getCurrentViews(Class<T> classToFilterBy, boolean includeSubclasses, View parent) {
		return viewFetcher.getCurrentViews(classToFilterBy, includeSubclasses, parent);
	}
	
	/**
	 * Returns an ArrayList of all the WebElements displayed in the active WebView.
	 * 
	 * @return an {@code ArrayList} of all the {@link WebElement} objects currently displayed in the active WebView
	 */	

	public ArrayList<WebElement> getWebElements(){
		return webUtils.getWebElements(false);
	}

	/**
	 * Returns an ArrayList of all the WebElements displayed in the active WebView matching the specified By object.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 * @return an {@code ArrayList} of all the {@link WebElement} objects displayed in the active WebView 
	 */	

	public ArrayList<WebElement> getWebElements(By by){
		return webUtils.getWebElements(by, false);
	}

	/**
	 * Returns an ArrayList of the currently displayed WebElements in the active WebView.
	 * 
	 * @return an {@code ArrayList} of the {@link WebElement} objects displayed in the active WebView
	 */	

	public ArrayList<WebElement> getCurrentWebElements(){
		return webUtils.getWebElements(true);
	}

	/**
	 * Returns an ArrayList of the currently displayed WebElements in the active WebView matching the specified By object.
	 * 
	 * @param by the By object. Examples are: {@code By.id("id")} and {@code By.name("name")}
	 * @return an {@code ArrayList} of the {@link WebElement} objects currently displayed in the active WebView 
	 */	

	public ArrayList<WebElement> getCurrentWebElements(By by){
		return webUtils.getWebElements(by, true);
	}

	/**
	 * Checks if a RadioButton matching the specified index is checked.
	 *
	 * @param index of the {@link RadioButton} to check. {@code 0} if only one is available
	 * @return {@code true} if {@link RadioButton} is checked and {@code false} if it is not checked
	 */	

	public boolean isRadioButtonChecked(int index)
	{
		return checker.isButtonChecked(RadioButton.class, index);
	}

	/**
	 * Checks if a RadioButton displaying the specified text is checked.
	 *
	 * @param text the text that the {@link RadioButton} displays, specified as a regular expression
	 * @return {@code true} if a {@link RadioButton} matching the specified text is checked and {@code false} if it is not checked
	 */

	public boolean isRadioButtonChecked(String text)
	{
		return checker.isButtonChecked(RadioButton.class, text);
	}

	/**
	 * Checks if a CheckBox matching the specified index is checked.
	 * 
	 * @param index of the {@link CheckBox} to check. {@code 0} if only one is available
	 * @return {@code true} if {@link CheckBox} is checked and {@code false} if it is not checked
	 */	

	public boolean isCheckBoxChecked(int index)
	{
		return checker.isButtonChecked(CheckBox.class, index);
	}

	/**
	 * Checks if a ToggleButton displaying the specified text is checked.
	 *
	 * @param text the text that the {@link ToggleButton} displays, specified as a regular expression
	 * @return {@code true} if a {@link ToggleButton} matching the specified text is checked and {@code false} if it is not checked
	 */

	public boolean isToggleButtonChecked(String text)
	{
		return checker.isButtonChecked(ToggleButton.class, text);
	}

	/**
	 * Checks if a ToggleButton matching the specified index is checked.
	 * 
	 * @param index of the {@link ToggleButton} to check. {@code 0} if only one is available
	 * @return {@code true} if {@link ToggleButton} is checked and {@code false} if it is not checked
	 */

	public boolean isToggleButtonChecked(int index)
	{
		return checker.isButtonChecked(ToggleButton.class, index);
	}

	/**
	 * Checks if a CheckBox displaying the specified text is checked.
	 *
	 * @param text the text that the {@link CheckBox} displays, specified as a regular expression
	 * @return {@code true} if a {@link CheckBox} displaying the specified text is checked and {@code false} if it is not checked
	 */

	public boolean isCheckBoxChecked(String text)
	{
		return checker.isButtonChecked(CheckBox.class, text);
	}

	/**
	 * Checks if the specified text is checked.
	 *
	 * @param text the text that the {@link CheckedTextView} or {@link CompoundButton} objects display, specified as a regular expression
	 * @return {@code true} if the specified text is checked and {@code false} if it is not checked
	 */

	@SuppressWarnings("unchecked")
	public boolean isTextChecked(String text){
		waiter.waitForViews(false, CheckedTextView.class, CompoundButton.class);

		if(viewFetcher.getCurrentViews(CheckedTextView.class, true).size() > 0 && checker.isCheckedTextChecked(text))
			return true;

		if(viewFetcher.getCurrentViews(CompoundButton.class, true).size() > 0 && checker.isButtonChecked(CompoundButton.class, text))
			return true;

		return false;
	}

	/**
	 * Checks if the specified text is selected in any Spinner located in the current screen.
	 *
	 * @param text the text that is expected to be selected, specified as a regular expression
	 * @return {@code true} if the specified text is selected in any {@link Spinner} and false if it is not
	 */

	public boolean isSpinnerTextSelected(String text)
	{
		return checker.isSpinnerTextSelected(text);
	}

	/**
	 * Checks if the specified text is selected in a Spinner matching the specified index. 
	 *
	 * @param index the index of the spinner to check. {@code 0} if only one spinner is available
	 * @param text the text that is expected to be selected, specified as a regular expression
	 * @return {@code true} if the specified text is selected in the specified {@link Spinner} and false if it is not
	 */

	public boolean isSpinnerTextSelected(int index, String text)
	{
		return checker.isSpinnerTextSelected(index, text);
	}

	/**
	 * Hides the soft keyboard.
	 */

	public void hideSoftKeyboard() {
		dialogUtils.hideSoftKeyboard(null, true, false);
	}

	/**
	 * Unlocks the lock screen.
	 */

	public void unlockScreen(){
		instrumentation.runOnMainSync(new Runnable() {
			@Override
			public void run() {
				activityUtils.getCurrentActivity(false).getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
			}
		});
	}

	/**
	 * Sends a key: Right, Left, Up, Down, Enter, Menu or Delete.
	 * 
	 * @param key the key to be sent. Use {@code Solo.}{@link #RIGHT}, {@link #LEFT}, {@link #UP}, {@link #DOWN}, 
	 * {@link #ENTER}, {@link #MENU}, {@link #DELETE}
	 */

	public void sendKey(int key)
	{
		sender.sendKeyCode(key);
	}

	/**
	 * Returns to an Activity matching the specified name.
	 *
	 * @param name the name of the {@link Activity} to return to. Example is: {@code "MyActivity"}
	 */

	public void goBackToActivity(String name) {
		activityUtils.goBackToActivity(name);
	}

	/**
	 * Waits for an Activity matching the specified name. Default timeout is 20 seconds. 
	 *
	 * @param name the name of the {@code Activity} to wait for. Example is: {@code "MyActivity"}
	 * @return {@code true} if {@code Activity} appears before the timeout and {@code false} if it does not
	 */

	public boolean waitForActivity(String name){
		return waiter.waitForActivity(name, Timeout.getLargeTimeout());
	}

	/**
	 * Waits for an Activity matching the specified name.
	 *
	 * @param name the name of the {@link Activity} to wait for. Example is: {@code "MyActivity"}
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if {@link Activity} appears before the timeout and {@code false} if it does not
	 */

	public boolean waitForActivity(String name, int timeout)
	{
		return waiter.waitForActivity(name, timeout);
	}

	/**
	 * Waits for an Activity matching the specified class. Default timeout is 20 seconds.
	 *
	 * @param activityClass the class of the {@code Activity} to wait for. Example is: {@code MyActivity.class}
	 * @return {@code true} if {@code Activity} appears before the timeout and {@code false} if it does not
	 */

	public boolean waitForActivity(Class<? extends Activity> activityClass){
		return waiter.waitForActivity(activityClass, Timeout.getLargeTimeout());
	}

	/**
	 * Waits for an Activity matching the specified class.
	 *
	 * @param activityClass the class of the {@code Activity} to wait for. Example is: {@code MyActivity.class}
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if {@link Activity} appears before the timeout and {@code false} if it does not
	 */

	public boolean waitForActivity(Class<? extends Activity> activityClass, int timeout)
	{
		return waiter.waitForActivity(activityClass, timeout);
	}


	/**
	 * Wait for the activity stack to be empty.
	 * 
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if activity stack is empty before the timeout and {@code false} if it is not
	 */

	public boolean waitForEmptyActivityStack(int timeout)
	{
		return waiter.waitForCondition(
				new Condition(){
					@Override
					public boolean isSatisfied() {
						return activityUtils.isActivityStackEmpty();
					}
				}, timeout);
	}

	/**
	 * Waits for a Fragment matching the specified tag. Default timeout is 20 seconds.
	 * 
	 * @param tag the name of the tag	
	 * @return {@code true} if fragment appears and {@code false} if it does not appear before the timeout
	 */	

	public boolean waitForFragmentByTag(String tag){
		return waiter.waitForFragment(tag, 0, Timeout.getLargeTimeout());
	}

	/**
	 * Waits for a Fragment matching the specified tag.
	 * 
	 * @param tag the name of the tag	
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if fragment appears and {@code false} if it does not appear before the timeout
	 */	

	public boolean waitForFragmentByTag(String tag, int timeout){
		return waiter.waitForFragment(tag, 0, timeout);
	}

	/**
	 * Waits for a Fragment matching the specified resource id. Default timeout is 20 seconds.
	 * 
	 * @param id the R.id of the fragment	
	 * @return {@code true} if fragment appears and {@code false} if it does not appear before the timeout
	 */

	public boolean waitForFragmentById(int id){
		return waiter.waitForFragment(null, id, Timeout.getLargeTimeout());
	}

	/**
	 * Waits for a Fragment matching the specified resource id.
	 * 
	 * @param id the R.id of the fragment	
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if fragment appears and {@code false} if it does not appear before the timeout
	 */

	public boolean waitForFragmentById(int id, int timeout){
		return waiter.waitForFragment(null, id, timeout);
	}

	/**
	 * Waits for the specified log message to appear. Default timeout is 20 seconds.
	 * Requires read logs permission (android.permission.READ_LOGS) in AndroidManifest.xml of the application under test.
	 * 
	 * @param logMessage the log message to wait for
	 * @return {@code true} if log message appears and {@code false} if it does not appear before the timeout
	 * 
	 * @see clearLog()
	 */

	public boolean waitForLogMessage(String logMessage){
		return waiter.waitForLogMessage(logMessage, Timeout.getLargeTimeout());
	}

	/**
	 * Waits for the specified log message to appear.
	 * Requires read logs permission (android.permission.READ_LOGS) in AndroidManifest.xml of the application under test.
	 * 
	 * @param logMessage the log message to wait for
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if log message appears and {@code false} if it does not appear before the timeout
	 * 
	 * @see clearLog()
	 */

	public boolean waitForLogMessage(String logMessage, int timeout){
		return waiter.waitForLogMessage(logMessage, timeout);
	}

	/**
	 * Clears the log.
	 */

	public void clearLog(){
		waiter.clearLog();
	}

	/**
	 * Returns a localized String matching the specified resource id.
	 * 
	 * @param id the R.id of the String
	 * @return the localized String
	 */

	public String getString(int id)
	{
		return getter.getString(id);
	}

	/**
	 * Returns a localized String matching the specified resource id.
	 * 
	 * @param id the id of the String
	 * @return the localized String
	 */

	public String getString(String id)
	{
		return getter.getString(id);
	}

	/**
	 * Robotium will sleep for the specified time.
	 * 
	 * @param time the time in milliseconds that Robotium should sleep 
	 */	

	public void sleep(int time)
	{
		sleeper.sleep(time);
	}

	/**
	 *
	 * Finalizes the Solo object and removes the ActivityMonitor.
	 * 
	 * @see #finishOpenedActivities() finishOpenedActivities() to close the activities that have been active
	 */    	

	public void finalize() throws Throwable {
		activityUtils.finalize();
	}

	/**
	 * The Activities that are alive are finished. Usually used in tearDown().
	 */

	public void finishOpenedActivities(){
		activityUtils.finishOpenedActivities();
	}

	/**
	 * Takes a screenshot and saves it in the {@link Config} objects save path (default set to: /sdcard/Robotium-Screenshots/).
	 * Requires write permission (android.permission.WRITE_EXTERNAL_STORAGE) in AndroidManifest.xml of the application under test.
	 */

	public void takeScreenshot(){
		takeScreenshot(null);
	}

	/**
	 * Takes a screenshot and saves it with the specified name in the {@link Config} objects save path (default set to: /sdcard/Robotium-Screenshots/).
	 * Requires write permission (android.permission.WRITE_EXTERNAL_STORAGE) in AndroidManifest.xml of the application under test.
	 *
	 * @param name the name to give the screenshot
	 */

	public void takeScreenshot(String name){
		takeScreenshot(name, 100);
	}

	/**
	 * Takes a screenshot and saves the image with the specified name in the {@link Config} objects save path (default set to: /sdcard/Robotium-Screenshots/).
	 * Requires write permission (android.permission.WRITE_EXTERNAL_STORAGE) in AndroidManifest.xml of the application under test.
	 *
	 * @param name the name to give the screenshot
	 * @param quality the compression rate. From 0 (compress for lowest size) to 100 (compress for maximum quality)
	 */

	public void takeScreenshot(String name, int quality){
		screenshotTaker.takeScreenshot(name, quality);
	}

	/**
	 * Takes a screenshot sequence and saves the images with the specified name prefix in the {@link Config} objects save path (default set to: /sdcard/Robotium-Screenshots/).
	 *
	 * The name prefix is appended with "_" + sequence_number for each image in the sequence,
	 * where numbering starts at 0.  
	 *
	 * Requires write permission (android.permission.WRITE_EXTERNAL_STORAGE) in AndroidManifest.xml of the application under test.
	 *
	 * At present multiple simultaneous screenshot sequences are not supported.  
	 * This method will throw an exception if stopScreenshotSequence() has not been
	 * called to finish any prior sequences.
	 * Calling this method is equivalend to calling startScreenshotSequence(name, 80, 400, 100);
	 *
	 * @param name the name prefix to give the screenshot
	 */

	public void startScreenshotSequence(String name) {
		startScreenshotSequence(name, 
				80, // quality
				400, // 400 ms frame delay
				100); // max frames
	}

	/**
	 * Takes a screenshot sequence and saves the images with the specified name prefix in the {@link Config} objects save path (default set to: /sdcard/Robotium-Screenshots/).
	 *
	 * The name prefix is appended with "_" + sequence_number for each image in the sequence,
	 * where numbering starts at 0.  
	 *
	 * Requires write permission (android.permission.WRITE_EXTERNAL_STORAGE) in the 
	 * AndroidManifest.xml of the application under test.
	 *
	 * Taking a screenshot will take on the order of 40-100 milliseconds of time on the 
	 * main UI thread.  Therefore it is possible to mess up the timing of tests if
	 * the frameDelay value is set too small.
	 *
	 * At present multiple simultaneous screenshot sequences are not supported.  
	 * This method will throw an exception if stopScreenshotSequence() has not been
	 * called to finish any prior sequences.
	 *
	 * @param name the name prefix to give the screenshot
	 * @param quality the compression rate. From 0 (compress for lowest size) to 100 (compress for maximum quality)
	 * @param frameDelay the time in milliseconds to wait between each frame
	 * @param maxFrames the maximum number of frames that will comprise this sequence
	 */

	public void startScreenshotSequence(String name, int quality, int frameDelay, int maxFrames) {
		screenshotTaker.startScreenshotSequence(name, quality, frameDelay, maxFrames);
	}

	/**
	 * Causes a screenshot sequence to end.
	 * 
	 * If this method is not called to end a sequence and a prior sequence is still in 
	 * progress, startScreenshotSequence() will throw an exception.
	 */

	public void stopScreenshotSequence() {
		screenshotTaker.stopScreenshotSequence();
	}


	/**
	 * Initialize timeout using 'adb shell setprop' or use setLargeTimeout() and setSmallTimeout(). Will fall back to the default values set by {@link Config}.
	 */

	private void initialize(){
		Timeout.setLargeTimeout(initializeTimeout("solo_large_timeout", config.timeout_large));
		Timeout.setSmallTimeout(initializeTimeout("solo_small_timeout", config.timeout_small));
	}

	/**
	 * Parse a timeout value set using adb shell.
	 *
	 * There are two options to set the timeout. Set it using adb shell (requires root access):
	 * <br><br>
	 * 'adb shell setprop solo_large_timeout milliseconds' 
	 * <br>  
	 * 'adb shell setprop solo_small_timeout milliseconds'
	 * <br>
	 * Example: adb shell setprop solo_small_timeout 10000
	 * <br><br>
	 * Set the values directly using setLargeTimeout() and setSmallTimeout
	 *
	 * @param property name of the property to read the timeout from
	 * @param defaultValue default value for the timeout
	 * @return timeout in milliseconds 
	 */

	@SuppressWarnings({ "rawtypes", "unchecked" })
	private static int initializeTimeout(String property, int defaultValue) {
		try {
			Class clazz = Class.forName("android.os.SystemProperties");
			Method method = clazz.getDeclaredMethod("get", String.class);
			String value = (String) method.invoke(null, property);
			return Integer.parseInt(value);
		} catch (Exception e) {
			return defaultValue;
		}
	}
}


@#$
package com.robotium.solo;

import android.app.Instrumentation;
import android.graphics.PointF;
import android.os.SystemClock;
import android.view.MotionEvent;
import android.view.MotionEvent.PointerCoords;
import android.view.MotionEvent.PointerProperties;

class Swiper
{
    private final Instrumentation _instrument;
    public static final int GESTURE_DURATION_MS = 1000;
    public static final int EVENT_TIME_INTERVAL_MS = 10;

    public Swiper(Instrumentation inst)
    {
        this._instrument = inst;
    }

	public void generateSwipeGesture(PointF startPoint1, PointF startPoint2,
            PointF endPoint1, PointF endPoint2)
    {

        long downTime = SystemClock.uptimeMillis();
        long eventTime = SystemClock.uptimeMillis();

        float startX1 = startPoint1.x;
        float startY1 = startPoint1.y;
        float startX2 = startPoint2.x;
        float startY2 = startPoint2.y;

        float endX1 = endPoint1.x;
        float endY1 = endPoint1.y;
        float endX2 = endPoint2.x;
        float endY2 = endPoint2.y;

        // pointer 1
        float x1 = startX1;
        float y1 = startY1;

        // pointer 2
        float x2 = startX2;
        float y2 = startY2;

        PointerCoords[] pointerCoords = new PointerCoords[2];
        PointerCoords pc1 = new PointerCoords();
        PointerCoords pc2 = new PointerCoords();
        pc1.x = x1;
        pc1.y = y1;
        pc1.pressure = 1;
        pc1.size = 1;
        pc2.x = x2;
        pc2.y = y2;
        pc2.pressure = 1;
        pc2.size = 1;
        pointerCoords[0] = pc1;
        pointerCoords[1] = pc2;

        PointerProperties[] pointerProperties = new PointerProperties[2];
        PointerProperties pp1 = new PointerProperties();
        PointerProperties pp2 = new PointerProperties();
        pp1.id = 0;
        pp1.toolType = MotionEvent.TOOL_TYPE_FINGER;
        pp2.id = 1;
        pp2.toolType = MotionEvent.TOOL_TYPE_FINGER;
        pointerProperties[0] = pp1;
        pointerProperties[1] = pp2;

        MotionEvent event;
        // send the initial touches
        event = MotionEvent.obtain(downTime, eventTime,
                MotionEvent.ACTION_DOWN, 1, pointerProperties, pointerCoords,
                0, 0, // metaState, buttonState
                1, // x precision
                1, // y precision
                0, 0, 0, 0); // deviceId, edgeFlags, source, flags
        _instrument.sendPointerSync(event);

        event = MotionEvent.obtain(downTime, eventTime,
                MotionEvent.ACTION_POINTER_DOWN
                        + (pp2.id << MotionEvent.ACTION_POINTER_INDEX_SHIFT),
                2, pointerProperties, pointerCoords, 0, 0, 1, 1, 0, 0, 0, 0);
        _instrument.sendPointerSync(event);

        int numMoves = GESTURE_DURATION_MS / EVENT_TIME_INTERVAL_MS;

        float stepX1 = (endX1 - startX1) / numMoves;
        float stepY1 = (endY1 - startY1) / numMoves;
        float stepX2 = (endX2 - startX2) / numMoves;
        float stepY2 = (endY2 - startY2) / numMoves;

        // send the zoom
        for (int i = 0; i < numMoves; i++)
        {
            eventTime += EVENT_TIME_INTERVAL_MS;
            pointerCoords[0].x += stepX1;
            pointerCoords[0].y += stepY1;
            pointerCoords[1].x += stepX2;
            pointerCoords[1].y += stepY2;

            event = MotionEvent.obtain(downTime, eventTime,
                    MotionEvent.ACTION_MOVE, 2, pointerProperties,
                    pointerCoords, 0, 0, 1, 1, 0, 0, 0, 0);
            _instrument.sendPointerSync(event);
        }
    }
}

@#$
package com.robotium.solo;

import android.app.Instrumentation;
import android.graphics.PointF;
import android.os.SystemClock;
import android.view.InputDevice;
import android.view.MotionEvent;
import android.view.MotionEvent.PointerCoords;
import android.view.MotionEvent.PointerProperties;

class Tapper
{
    private final Instrumentation _instrument;
    public static final int GESTURE_DURATION_MS = 1000;
    public static final int EVENT_TIME_INTERVAL_MS = 10;

    public Tapper(Instrumentation inst)
    {
        this._instrument = inst;
    }

	public void generateTapGesture(int numTaps, PointF... points)
    {
        MotionEvent event;

        long downTime = SystemClock.uptimeMillis();
        long eventTime = SystemClock.uptimeMillis();

        // pointer 1
        float x1 = points[0].x;
        float y1 = points[0].y;

        float x2 = 0;
        float y2 = 0;
        if (points.length == 2)
        {
            // pointer 2
            x2 = points[1].x;
            y2 = points[1].y;
        }

        PointerCoords[] pointerCoords = new PointerCoords[points.length];
        PointerCoords pc1 = new PointerCoords();
        pc1.x = x1;
        pc1.y = y1;
        pc1.pressure = 1;
        pc1.size = 1;
        pointerCoords[0] = pc1;
        PointerCoords pc2 = new PointerCoords();
        if (points.length == 2)
        {
            pc2.x = x2;
            pc2.y = y2;
            pc2.pressure = 1;
            pc2.size = 1;
            pointerCoords[1] = pc2;
        }

        PointerProperties[] pointerProperties = new PointerProperties[points.length];
        PointerProperties pp1 = new PointerProperties();
        pp1.id = 0;
        pp1.toolType = MotionEvent.TOOL_TYPE_FINGER;
        pointerProperties[0] = pp1;
        PointerProperties pp2 = new PointerProperties();
        if (points.length == 2)
        {
            pp2.id = 1;
            pp2.toolType = MotionEvent.TOOL_TYPE_FINGER;
            pointerProperties[1] = pp2;
        }

        int i = 0;
        while (i != numTaps)
        {
            event = MotionEvent.obtain(downTime, eventTime,
                    MotionEvent.ACTION_DOWN, points.length, pointerProperties,
                    pointerCoords, 0, 0, 1, 1, 0, 0,
                    InputDevice.SOURCE_TOUCHSCREEN, 0);
            _instrument.sendPointerSync(event);

            if (points.length == 2)
            {
                event = MotionEvent
                        .obtain(downTime,
                                eventTime,
                                MotionEvent.ACTION_POINTER_DOWN
                                        + (pp2.id << MotionEvent.ACTION_POINTER_INDEX_SHIFT),
                                points.length, pointerProperties,
                                pointerCoords, 0, 0, 1, 1, 0, 0,
                                InputDevice.SOURCE_TOUCHSCREEN, 0);
                _instrument.sendPointerSync(event);

                eventTime += EVENT_TIME_INTERVAL_MS;
                event = MotionEvent
                        .obtain(downTime,
                                eventTime,
                                MotionEvent.ACTION_POINTER_UP
                                        + (pp2.id << MotionEvent.ACTION_POINTER_INDEX_SHIFT),
                                points.length, pointerProperties,
                                pointerCoords, 0, 0, 1, 1, 0, 0,
                                InputDevice.SOURCE_TOUCHSCREEN, 0);
                _instrument.sendPointerSync(event);
            }

            eventTime += EVENT_TIME_INTERVAL_MS;
            event = MotionEvent.obtain(downTime, eventTime,
                    MotionEvent.ACTION_UP, points.length, pointerProperties,
                    pointerCoords, 0, 0, 1, 1, 0, 0,
                    InputDevice.SOURCE_TOUCHSCREEN, 0);
            _instrument.sendPointerSync(event);

            i++;
        }
    }
}

@#$
package com.robotium.solo;

import junit.framework.Assert;
import android.app.Instrumentation;
import android.text.InputType;
import android.widget.EditText;


/**
 * Contains setEditText() to enter text into text fields.
 * 
 * @author Renas Reda, renas.reda@robotium.com
 *
 */

class TextEnterer{

	private final Instrumentation inst;
	private final Clicker clicker;
	private final DialogUtils dialogUtils;

	/**
	 * Constructs this object.
	 * 
	 * @param inst the {@code Instrumentation} instance
	 * @param clicker the {@code Clicker} instance
	 * @param dialogUtils the {@code DialogUtils} instance
	 * 
	 */

	public TextEnterer(Instrumentation inst, Clicker clicker, DialogUtils dialogUtils) {
		this.inst = inst;
		this.clicker = clicker;
		this.dialogUtils = dialogUtils;
	}

	/**
	 * Sets an {@code EditText} text
	 * 
	 * @param index the index of the {@code EditText} 
	 * @param text the text that should be set
	 */

	public void setEditText(final EditText editText, final String text) {
		if(editText != null){
			final String previousText = editText.getText().toString();
	
			inst.runOnMainSync(new Runnable()
			{
				public void run()
				{
					editText.setInputType(InputType.TYPE_NULL); 
					editText.performClick();
					dialogUtils.hideSoftKeyboard(editText, false, false);
					if(text.equals(""))
						editText.setText(text);
					else{
						editText.setText(previousText + text);
						editText.setCursorVisible(false);
					}
				}
			});
		}
	}
	
	/**
	 * Types text in an {@code EditText} 
	 * 
	 * @param index the index of the {@code EditText} 
	 * @param text the text that should be typed
	 */

	public void typeText(final EditText editText, final String text){
		if(editText != null){
			inst.runOnMainSync(new Runnable()
			{
				public void run()
				{
					editText.setInputType(InputType.TYPE_NULL);
				}
			});
			clicker.clickOnScreen(editText, false, 0);
			dialogUtils.hideSoftKeyboard(editText, true, true);

			boolean successfull = false;
			int retry = 0;

			while(!successfull && retry < 10) {

				try{
					inst.sendStringSync(text);
					successfull = true;
				}catch(SecurityException e){
					dialogUtils.hideSoftKeyboard(editText, true, true);
					retry++;
				}
			}
			if(!successfull) {
				Assert.fail("Text can not be typed!");
			}
		}
	}
}

@#$
package com.robotium.solo;

import com.robotium.solo.Solo.Config;




/**
 * Used to get and set the default timeout lengths of the various Solo methods. 
 * 
 * @author Renas Reda, renas.reda@robotium.com
 *
 */

public class Timeout{

	private static int largeTimeout;
	private static int smallTimeout;

	
	/**
	 * Sets the default timeout length of the waitFor methods. Will fall back to the default values set by {@link Config}.
	 * <br><br>
	 * Timeout can also be set through adb shell (requires root access):
	 * <br><br>
	 * 'adb shell setprop solo_large_timeout milliseconds' 
	 * 
	 * @param milliseconds the default timeout length of the waitFor methods
	 * 
	 */
	public static void setLargeTimeout(int milliseconds){
		largeTimeout = milliseconds;
	}

	/**
	 * Sets the default timeout length of the get, is, set, assert, enter, type and click methods. Will fall back to the default values set by {@link Config}.
	 * <br><br>
	 * Timeout can also be set through adb shell (requires root access):
	 * <br><br>
	 * 'adb shell setprop solo_small_timeout milliseconds' 
	 * 
	 * @param milliseconds the default timeout length of the get, is, set, assert, enter and click methods
	 * 
	 */
	public static void setSmallTimeout(int milliseconds){
		smallTimeout = milliseconds;
	}

	/**
	 * Gets the default timeout length of the waitFor methods. 
	 * 
	 * @return the timeout length in milliseconds
	 * 
	 */
	public static int getLargeTimeout(){
		return largeTimeout;
	}

	/**
	 * Gets the default timeout length of the get, is, set, assert, enter, type and click methods. 
	 * 
	 * @return the timeout length in milliseconds
	 * 
	 */
	public static int getSmallTimeout(){
		return smallTimeout;
	}
}

@#$
package com.robotium.solo;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewParent;
import android.webkit.WebView;

/**
 * Contains view methods. Examples are getViews(),
 * getCurrentTextViews(), getCurrentImageViews().
 *
 * @author Renas Reda, renas.reda@robotium.com
 *
 */

class ViewFetcher {

	private final ActivityUtils activityUtils;
	private String windowManagerString;

	/**
	 * Constructs this object.
	 *
	 * @param activityUtils the {@code ActivityUtils} instance
	 *
	 */

	public ViewFetcher(ActivityUtils activityUtils) {
		this.activityUtils = activityUtils;
		setWindowManagerString();
	}


	/**
	 * Returns the absolute top parent {@code View} in for a given {@code View}.
	 *
	 * @param view the {@code View} whose top parent is requested
	 * @return the top parent {@code View}
	 */

	public View getTopParent(View view) {
		final ViewParent viewParent = view.getParent();
		if (viewParent != null
				&& viewParent instanceof android.view.View) {
			return getTopParent((View) viewParent);
		} else {
			return view;
		}
	}


	/**
	 * Returns the scroll or list parent view
	 *
	 * @param view the view who's parent should be returned
	 * @return the parent scroll view, list view or null
	 */

	public View getScrollOrListParent(View view) {

		if (!(view instanceof android.widget.AbsListView) && !(view instanceof android.widget.ScrollView) && !(view instanceof WebView)) {
			try{
				return getScrollOrListParent((View) view.getParent());
			}catch(Exception e){
				return null;
			}
		} else {
			return view;
		}
	}

	/**
	 * Returns views from the shown DecorViews.
	 *
	 * @param onlySufficientlyVisible if only sufficiently visible views should be returned
	 * @return all the views contained in the DecorViews
	 */

	public ArrayList<View> getAllViews(boolean onlySufficientlyVisible) {
		final View[] views = getWindowDecorViews();
		final ArrayList<View> allViews = new ArrayList<View>();
		final View[] nonDecorViews = getNonDecorViews(views);
		View view = null;

		if(nonDecorViews != null){
			for(int i = 0; i < nonDecorViews.length; i++){
				view = nonDecorViews[i];
				try {
					addChildren(allViews, (ViewGroup)view, onlySufficientlyVisible);
				} catch (Exception ignored) {}
				if(view != null) allViews.add(view);
			}
		}

		if (views != null && views.length > 0) {
			view = getRecentDecorView(views);
			try {
				addChildren(allViews, (ViewGroup)view, onlySufficientlyVisible);
			} catch (Exception ignored) {}

			if(view != null) allViews.add(view);
		}

		return allViews;
	}

	/**
	 * Returns the most recent DecorView
	 *
	 * @param views the views to check
	 * @return the most recent DecorView
	 */

	public final View getRecentDecorView(View[] views) {
		if(views == null)
			return null;

		final View[] decorViews = new View[views.length];
		int i = 0;
		View view;

		for (int j = 0; j < views.length; j++) {
			view = views[j];
			if (view != null){ 
				String nameOfClass = view.getClass().getName();
				if(nameOfClass.equals("com.android.internal.policy.impl.PhoneWindow$DecorView") || nameOfClass
						.equals("com.android.internal.policy.impl.MultiPhoneWindow$MultiPhoneDecorView")) {
					decorViews[i] = view;
					i++;
				}
			}
		}
		return getRecentContainer(decorViews);
	}

	/**
	 * Returns the most recent view container
	 *
	 * @param views the views to check
	 * @return the most recent view container
	 */

	private final View getRecentContainer(View[] views) {
		View container = null;
		long drawingTime = 0;
		View view;

		for(int i = 0; i < views.length; i++){
			view = views[i];
			if (view != null && view.isShown() && view.hasWindowFocus() && view.getDrawingTime() > drawingTime) {
				container = view;
				drawingTime = view.getDrawingTime();
			}
		}
		return container;
	}

	/**
	 * Returns all views that are non DecorViews
	 *
	 * @param views the views to check
	 * @return the non DecorViews
	 */

	private final View[] getNonDecorViews(View[] views) {
		View[] decorViews = null;

		if(views != null) {
			decorViews = new View[views.length];

			int i = 0;
			View view;

			for (int j = 0; j < views.length; j++) {
				view = views[j];
				if (view != null && !(view.getClass().getName()
						.equals("com.android.internal.policy.impl.PhoneWindow$DecorView"))) {
					decorViews[i] = view;
					i++;
				}
			}
		}
		return decorViews;
	}



	/**
	 * Extracts all {@code View}s located in the currently active {@code Activity}, recursively.
	 *
	 * @param parent the {@code View} whose children should be returned, or {@code null} for all
	 * @param onlySufficientlyVisible if only sufficiently visible views should be returned
	 * @return all {@code View}s located in the currently active {@code Activity}, never {@code null}
	 */

	public ArrayList<View> getViews(View parent, boolean onlySufficientlyVisible) {
		final ArrayList<View> views = new ArrayList<View>();
		final View parentToUse;

		if (parent == null){
			return getAllViews(onlySufficientlyVisible);
		}else{
			parentToUse = parent;

			views.add(parentToUse);

			if (parentToUse instanceof ViewGroup) {
				addChildren(views, (ViewGroup) parentToUse, onlySufficientlyVisible);
			}
		}
		return views;
	}

	/**
	 * Adds all children of {@code viewGroup} (recursively) into {@code views}.
	 *
	 * @param views an {@code ArrayList} of {@code View}s
	 * @param viewGroup the {@code ViewGroup} to extract children from
	 * @param onlySufficientlyVisible if only sufficiently visible views should be returned
	 */

	private void addChildren(ArrayList<View> views, ViewGroup viewGroup, boolean onlySufficientlyVisible) {
		if(viewGroup != null){
			for (int i = 0; i < viewGroup.getChildCount(); i++) {
				final View child = viewGroup.getChildAt(i);

				if(onlySufficientlyVisible && isViewSufficientlyShown(child))
					views.add(child);

				else if(!onlySufficientlyVisible)
					views.add(child);

				if (child instanceof ViewGroup) {
					addChildren(views, (ViewGroup) child, onlySufficientlyVisible);
				}
			}
		}
	}

	/**
	 * Returns true if the view is sufficiently shown
	 *
	 * @param view the view to check
	 * @return true if the view is sufficiently shown
	 */

	public final boolean isViewSufficientlyShown(View view){
		final int[] xyView = new int[2];
		final int[] xyParent = new int[2];

		if(view == null)
			return false;

		final float viewHeight = view.getHeight();
		final View parent = getScrollOrListParent(view);
		view.getLocationOnScreen(xyView);

		if(parent == null){
			xyParent[1] = 0;
		}
		else{
			parent.getLocationOnScreen(xyParent);
		}

		if(xyView[1] + (viewHeight/2.0f) > getScrollListWindowHeight(view))
			return false;

		else if(xyView[1] + (viewHeight/2.0f) < xyParent[1])
			return false;

		return true;
	}

	/**
	 * Returns the height of the scroll or list view parent
	 * @param view the view who's parents height should be returned
	 * @return the height of the scroll or list view parent
	 */

	@SuppressWarnings("deprecation")
	public float getScrollListWindowHeight(View view) {
		final int[] xyParent = new int[2];
		View parent = getScrollOrListParent(view);
		final float windowHeight;
		if(parent == null){
			windowHeight = activityUtils.getCurrentActivity(false).getWindowManager()
					.getDefaultDisplay().getHeight();
		}
		else{
			parent.getLocationOnScreen(xyParent);
			windowHeight = xyParent[1] + parent.getHeight();
		}
		parent = null;
		return windowHeight;
	}


	/**
	 * Returns an {@code ArrayList} of {@code View}s of the specified {@code Class} located in the current
	 * {@code Activity}.
	 *
	 * @param classToFilterBy return all instances of this class, e.g. {@code Button.class} or {@code GridView.class}
	 * @param includeSubclasses include instances of the subclasses in the {@code ArrayList} that will be returned
	 * @return an {@code ArrayList} of {@code View}s of the specified {@code Class} located in the current {@code Activity}
	 */

	public <T extends View> ArrayList<T> getCurrentViews(Class<T> classToFilterBy, boolean includeSubclasses) {
		return getCurrentViews(classToFilterBy, includeSubclasses, null);
	}

	/**
	 * Returns an {@code ArrayList} of {@code View}s of the specified {@code Class} located under the specified {@code parent}.
	 *
	 * @param classToFilterBy return all instances of this class, e.g. {@code Button.class} or {@code GridView.class}
	 * @param includeSubclasses include instances of subclasses in {@code ArrayList} that will be returned
	 * @param parent the parent {@code View} for where to start the traversal
	 * @return an {@code ArrayList} of {@code View}s of the specified {@code Class} located under the specified {@code parent}
	 */

	public <T extends View> ArrayList<T> getCurrentViews(Class<T> classToFilterBy, boolean includeSubclasses, View parent) {
		ArrayList<T> filteredViews = new ArrayList<T>();
		List<View> allViews = getViews(parent, true);
		for(View view : allViews){
			if (view == null) {
				continue;
			}
			Class<? extends View> classOfView = view.getClass();
			if (includeSubclasses && classToFilterBy.isAssignableFrom(classOfView) || !includeSubclasses && classToFilterBy == classOfView) {
				filteredViews.add(classToFilterBy.cast(view));
			}
		}
		allViews = null;
		return filteredViews;
	}


	/**
	 * Tries to guess which view is the most likely to be interesting. Returns
	 * the most recently drawn view, which presumably will be the one that the
	 * user was most recently interacting with.
	 *
	 * @param views A list of potentially interesting views, likely a collection
	 *            of views from a set of types, such as [{@link Button},
	 *            {@link TextView}] or [{@link ScrollView}, {@link ListView}]
	 * @param index the index of the view
	 * @return most recently drawn view, or null if no views were passed 
	 */

	public final <T extends View> T getFreshestView(ArrayList<T> views){
		final int[] locationOnScreen = new int[2];
		T viewToReturn = null;
		long drawingTime = 0;
		if(views == null){
			return null;
		}
		for(T view : views){

			view.getLocationOnScreen(locationOnScreen);

			if (locationOnScreen[0] < 0 ) 
				continue;

			if(view.getDrawingTime() > drawingTime && view.getHeight() > 0){
				drawingTime = view.getDrawingTime();
				viewToReturn = view;
			}
		}
		views = null;
		return viewToReturn;
	}

	/**
	 * Returns an identical View to the one specified.
	 * 
	 * @param view the view to find
	 * @return identical view of the specified view
	 */

	public View getIdenticalView(View view) {
		if(view == null){
			return null;
		}
		View viewToReturn = null;
		List<? extends View> visibleViews = RobotiumUtils.removeInvisibleViews(getCurrentViews(view.getClass(), true));

		for(View v : visibleViews){
			if(areViewsIdentical(v, view)){
				viewToReturn = v;
				break;
			}
		}
		return viewToReturn;
	}

	/**
	 * Compares if the specified views are identical. This is used instead of View.compare 
	 * as it always returns false in cases where the View tree is refreshed.  
	 * 
	 * @param firstView the first view
	 * @param secondView the second view
	 * @return true if views are equal
	 */

	private boolean areViewsIdentical(View firstView, View secondView){

		if(firstView.getId() != secondView.getId() || !firstView.getClass().isAssignableFrom(secondView.getClass())){
			return false;
		}

		if(!isSamePlacementInRespectiveTree(firstView, secondView)){
			return false;
		}

		if (firstView.getParent() != null && firstView.getParent() instanceof View && 
				secondView.getParent() != null && secondView.getParent() instanceof View) {

			return areViewsIdentical((View) firstView.getParent(), (View) secondView.getParent());
		} else {
			return true;
		}
	}

	/**
	 * Compares if two views have the same placement in their respective trees. 
	 * 
	 * @param firstView the first view to compare
	 * @param secondView the second view to compare
	 * @return true if equal placement and false if not
	 */

	private boolean isSamePlacementInRespectiveTree(View firstView, View secondView){

		if(getObjectPlacementNumber(firstView) == getObjectPlacementNumber(secondView)){
			return true;
		}
		return false;
	}

	/**
	 * Returns the placement number of the specified view relative to its parent.
	 * 
	 * @param view the view to check placement number
	 * @return the object placement number of the specified view 
	 */

	private int getObjectPlacementNumber(View view){
		final ArrayList<View> allViewsFirst = new ArrayList<View>();
		int numberOrder = 0;
		try{
			ViewParent parent = view.getParent();
			if(parent instanceof ViewGroup){
				addChildren(allViewsFirst, (ViewGroup) parent, true);
			}

			for(View v : allViewsFirst){
				numberOrder++;
				if(v.equals(view)){
					break;
				}
			}
		}catch(Exception ignored){}
		return numberOrder;
	}

	private static Class<?> windowManager;
	static{
		try {
			String windowManagerClassName;
			if (android.os.Build.VERSION.SDK_INT >= 17) {
				windowManagerClassName = "android.view.WindowManagerGlobal";
			} else {
				windowManagerClassName = "android.view.WindowManagerImpl"; 
			}
			windowManager = Class.forName(windowManagerClassName);

		} catch (ClassNotFoundException e) {
			throw new RuntimeException(e);
		} catch (SecurityException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Returns the WindorDecorViews shown on the screen.
	 * 
	 * @return the WindorDecorViews shown on the screen
	 */

	@SuppressWarnings("unchecked")
	public View[] getWindowDecorViews()
	{

		Field viewsField;
		Field instanceField;
		try {
			viewsField = windowManager.getDeclaredField("mViews");
			instanceField = windowManager.getDeclaredField(windowManagerString);
			viewsField.setAccessible(true);
			instanceField.setAccessible(true);
			Object instance = instanceField.get(null);
			View[] result;
			if (android.os.Build.VERSION.SDK_INT >= 19) {
				result = ((ArrayList<View>) viewsField.get(instance)).toArray(new View[0]);
			} else {
				result = (View[]) viewsField.get(instance);
			}
			return result;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * Sets the window manager string.
	 */
	private void setWindowManagerString(){

		if (android.os.Build.VERSION.SDK_INT >= 17) {
			windowManagerString = "sDefaultWindowManager";

		} else if(android.os.Build.VERSION.SDK_INT >= 13) {
			windowManagerString = "sWindowManager";

		} else {
			windowManagerString = "mWindowManager";
		}
	}


}
@#$
package com.robotium.solo;

import android.view.View;
import java.util.Comparator;

/**
 * Orders {@link View}s by their location on-screen.
 * 
 */

class ViewLocationComparator implements Comparator<View> {

	private final int a[] = new int[2];
	private final int b[] = new int[2];
	private final int axis1, axis2;

	public ViewLocationComparator() {
		this(true);
	}

	/**
	 * @param yAxisFirst Whether the y-axis should be compared before the x-axis.
	 */

	public ViewLocationComparator(boolean yAxisFirst) {
		this.axis1 = yAxisFirst ? 1 : 0;
		this.axis2 = yAxisFirst ? 0 : 1;
	}

	public int compare(View lhs, View rhs) {
		lhs.getLocationOnScreen(a);
		rhs.getLocationOnScreen(b);

		if (a[axis1] != b[axis1]) {
			return a[axis1] < b[axis1] ? -1 : 1;
		}
		if (a[axis2] < b[axis2]) {
			return -1;
		}
		return a[axis2] == b[axis2] ? 0 : 1;
	}
}

@#$
package com.robotium.solo;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import junit.framework.Assert;
import android.app.Activity;
import android.os.SystemClock;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.view.View;
import android.widget.TextView;


/**
 * Contains various wait methods. Examples are: waitForText(),
 * waitForView().
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class Waiter {

	private final ActivityUtils activityUtils;
	private final ViewFetcher viewFetcher;
	private final Searcher searcher;
	private final Scroller scroller;
	private final Sleeper sleeper;
	private final int MINISLEEP = 20;


	/**
	 * Constructs this object.
	 *
	 * @param activityUtils the {@code ActivityUtils} instance
	 * @param viewFetcher the {@code ViewFetcher} instance
	 * @param searcher the {@code Searcher} instance
	 * @param scroller the {@code Scroller} instance
	 * @param sleeper the {@code Sleeper} instance
	 */

	public Waiter(ActivityUtils activityUtils, ViewFetcher viewFetcher, Searcher searcher, Scroller scroller, Sleeper sleeper){
		this.activityUtils = activityUtils;
		this.viewFetcher = viewFetcher;
		this.searcher = searcher;
		this.scroller = scroller;
		this.sleeper = sleeper;
	}

	/**
	 * Waits for the given {@link Activity}.
	 *
	 * @param name the name of the {@code Activity} to wait for e.g. {@code "MyActivity"}
	 * @return {@code true} if {@code Activity} appears before the timeout and {@code false} if it does not
	 *
	 */

	public boolean waitForActivity(String name){
		return waitForActivity(name, Timeout.getSmallTimeout());
	}

	/**
	 * Waits for the given {@link Activity}.
	 *
	 * @param name the name of the {@code Activity} to wait for e.g. {@code "MyActivity"}
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if {@code Activity} appears before the timeout and {@code false} if it does not
	 *
	 */

	public boolean waitForActivity(String name, int timeout){
		Activity currentActivity = activityUtils.getCurrentActivity(false, false);
		final long endTime = SystemClock.uptimeMillis() + timeout;

		while(SystemClock.uptimeMillis() < endTime){
			if(currentActivity != null && currentActivity.getClass().getSimpleName().equals(name)) {
				return true;
			}
			
			if(activityUtils.getCurrentActivityName().contains(name)){
				return true;
			}

			sleeper.sleep(MINISLEEP);
			currentActivity = activityUtils.getCurrentActivity(false, false);
		}
		return false;
	}

	/**
	 * Waits for the given {@link Activity}.
	 *
	 * @param activityClass the class of the {@code Activity} to wait for
	 * @return {@code true} if {@code Activity} appears before the timeout and {@code false} if it does not
	 *
	 */

	public boolean waitForActivity(Class<? extends Activity> activityClass){
		return waitForActivity(activityClass, Timeout.getSmallTimeout());
	}

	/**
	 * Waits for the given {@link Activity}.
	 *
	 * @param activityClass the class of the {@code Activity} to wait for
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if {@code Activity} appears before the timeout and {@code false} if it does not
	 *
	 */

	public boolean waitForActivity(Class<? extends Activity> activityClass, int timeout){
		Activity currentActivity = activityUtils.getCurrentActivity(false, false);
		final long endTime = SystemClock.uptimeMillis() + timeout;

		while(SystemClock.uptimeMillis() < endTime){
			if(currentActivity != null && currentActivity.getClass().equals(activityClass)) {
				return true;
			}

			sleeper.sleep(MINISLEEP);
			currentActivity = activityUtils.getCurrentActivity(false, false);
		}
		return false;
	}

	/**
	 * Waits for a view to be shown.
	 * 
	 * @param viewClass the {@code View} class to wait for
	 * @param index the index of the view that is expected to be shown
	 * @param sleep true if should sleep
	 * @param scroll {@code true} if scrolling should be performed
	 * @return {@code true} if view is shown and {@code false} if it is not shown before the timeout
	 */

	public <T extends View> boolean waitForView(final Class<T> viewClass, final int index, boolean sleep, boolean scroll){
		Set<T> uniqueViews = new HashSet<T>();
		boolean foundMatchingView;

		while(true){

			if(sleep)
				sleeper.sleep();

			foundMatchingView = searcher.searchFor(uniqueViews, viewClass, index);

			if(foundMatchingView)
				return true;

			if(scroll && !scroller.scrollDown())
				return false;

			if(!scroll)
				return false;
		}
	}

	/**
	 * Waits for a view to be shown.
	 * 
	 * @param viewClass the {@code View} class to wait for
	 * @param index the index of the view that is expected to be shown. 
	 * @param timeout the amount of time in milliseconds to wait
	 * @param scroll {@code true} if scrolling should be performed
	 * @return {@code true} if view is shown and {@code false} if it is not shown before the timeout
	 */

	public <T extends View> boolean waitForView(final Class<T> viewClass, final int index, final int timeout, final boolean scroll){
		Set<T> uniqueViews = new HashSet<T>();
		final long endTime = SystemClock.uptimeMillis() + timeout;
		boolean foundMatchingView;

		while (SystemClock.uptimeMillis() < endTime) {
			sleeper.sleep();

			foundMatchingView =  searcher.searchFor(uniqueViews, viewClass, index);

			if(foundMatchingView)
				return true;

			if(scroll) 
				scroller.scrollDown();
		}
		return false;
	}



	/**
	 * Waits for two views to be shown.
	 *
	 * @param scrollMethod {@code true} if it's a method used for scrolling
	 * @param classes the classes to wait for 
	 * @return {@code true} if any of the views are shown and {@code false} if none of the views are shown before the timeout
	 */

	public <T extends View> boolean  waitForViews(boolean scrollMethod, Class<? extends T>... classes) {
		final long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();

		while (SystemClock.uptimeMillis() < endTime) {

			for (Class<? extends T> classToWaitFor : classes) {
				if (waitForView(classToWaitFor, 0, false, false)) {
					return true;
				}
			}
			if(scrollMethod){
				scroller.scroll(Scroller.DOWN);
			}
			else {
				scroller.scrollDown();
			}
			sleeper.sleep();
		}
		return false;
	}

	/**
	 * Waits for a given view. Default timeout is 20 seconds.
	 * 
	 * @param view the view to wait for
	 * @return {@code true} if view is shown and {@code false} if it is not shown before the timeout
	 */

	public boolean waitForView(View view){
		View viewToWaitFor = waitForView(view, Timeout.getLargeTimeout(), true, true);
		if(viewToWaitFor != null) {
			return true;
		}
		
		return false;
		
	}

	/**
	 * Waits for a given view. 
	 * 
	 * @param view the view to wait for
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if view is shown and {@code false} if it is not shown before the timeout
	 */

	public View waitForView(View view, int timeout){
		return waitForView(view, timeout, true, true);
	}

	/**
	 * Waits for a given view.
	 * 
	 * @param view the view to wait for
	 * @param timeout the amount of time in milliseconds to wait
	 * @param scroll {@code true} if scrolling should be performed
	 * @param checkIsShown {@code true} if view.isShown() should be used
	 * @return {@code true} if view is shown and {@code false} if it is not shown before the timeout
	 */

	public View waitForView(View view, int timeout, boolean scroll, boolean checkIsShown){
		long endTime = SystemClock.uptimeMillis() + timeout;
		int retry = 0;
		
		if(view == null)
			return null;

		while (SystemClock.uptimeMillis() < endTime) {

			final boolean foundAnyMatchingView = searcher.searchFor(view);

			if(checkIsShown && foundAnyMatchingView && !view.isShown()){
				sleeper.sleepMini();
				retry++;
			
				View identicalView = viewFetcher.getIdenticalView(view);
				if(identicalView != null && !view.equals(identicalView)){
					view = identicalView;
				}
	
				if(retry > 5){
					return view;
				}
				continue;
			}

			if (foundAnyMatchingView){
				return view;
			}

			if(scroll) 
				scroller.scrollDown();

			sleeper.sleep();

		}
		return view;
	}

	/**
	 * Waits for a certain view.
	 * 
	 * @param view the id of the view to wait for
	 * @param index the index of the {@link View}. {@code 0} if only one is available
	 * @param timeout the timeout in milliseconds
	 * @return the specified View
	 */

	public View waitForView(int id, int index, int timeout){
		if(timeout == 0){
			timeout = Timeout.getSmallTimeout();
		}
		return waitForView(id, index, timeout, false);
	}

	/**
	 * Waits for a certain view.
	 * 
	 * @param view the id of the view to wait for
	 * @param index the index of the {@link View}. {@code 0} if only one is available
	 * @return the specified View
	 */

	public View waitForView(int id, int index, int timeout, boolean scroll){
		Set<View> uniqueViewsMatchingId = new HashSet<View>();
		long endTime = SystemClock.uptimeMillis() + timeout;

		while (SystemClock.uptimeMillis() <= endTime) {
			sleeper.sleep();

			for (View view : viewFetcher.getAllViews(false)) {
				Integer idOfView = Integer.valueOf(view.getId());

				if (idOfView.equals(id)) {
					uniqueViewsMatchingId.add(view);

					if(uniqueViewsMatchingId.size() > index) {
						return view;
					}
				}
			}
			if(scroll) 
				scroller.scrollDown();
		}
		return null;
	}

	/**
	 * Waits for a web element.
	 * 
	 * @param by the By object. Examples are By.id("id") and By.name("name")
	 * @param minimumNumberOfMatches the minimum number of matches that are expected to be shown. {@code 0} means any number of matches
	 * @param timeout the the amount of time in milliseconds to wait 
	 * @param scroll {@code true} if scrolling should be performed 
	 */

	public WebElement waitForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){
		final long endTime = SystemClock.uptimeMillis() + timeout;

		while (true) {	

			final boolean timedOut = SystemClock.uptimeMillis() > endTime;

			if (timedOut){
				searcher.logMatchesFound(by.getValue());
				return null;
			}
			sleeper.sleep();

			WebElement webElementToReturn = searcher.searchForWebElement(by, minimumNumberOfMatches); 

			if(webElementToReturn != null)
				return webElementToReturn;

			if(scroll) {
				scroller.scrollDown();
			}
		}
	}


	/**
	 * Waits for a condition to be satisfied.
	 * 
	 * @param condition the condition to wait for
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if condition is satisfied and {@code false} if it is not satisfied before the timeout
	 */
	public boolean waitForCondition(Condition condition, int timeout){
		final long endTime = SystemClock.uptimeMillis() + timeout;

		while (true) {
			final boolean timedOut = SystemClock.uptimeMillis() > endTime;
			if (timedOut){
				return false;
			}

			sleeper.sleep();

			if (condition.isSatisfied()){
				return true;
			}
		}
	}

	/**
	 * Waits for a text to be shown. Default timeout is 20 seconds.
	 *
	 * @param text the text that needs to be shown, specified as a regular expression
	 * @return {@code true} if text is found and {@code false} if it is not found before the timeout
	 */

	public TextView waitForText(String text) {
		return waitForText(text, 0, Timeout.getLargeTimeout(), true);
	}

	/**
	 * Waits for a text to be shown.
	 *
	 * @param text the text that needs to be shown, specified as a regular expression
	 * @param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown. {@code 0} means any number of matches
	 * @param timeout the amount of time in milliseconds to wait
	 * @return {@code true} if text is found and {@code false} if it is not found before the timeout
	 */

	public TextView waitForText(String text, int expectedMinimumNumberOfMatches, long timeout)
	{
		return waitForText(text, expectedMinimumNumberOfMatches, timeout, true);
	}

	/**
	 * Waits for a text to be shown.
	 *
	 * @param text the text that needs to be shown, specified as a regular expression
	 * @param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown. {@code 0} means any number of matches
	 * @param timeout the amount of time in milliseconds to wait
	 * @param scroll {@code true} if scrolling should be performed
	 * @return {@code true} if text is found and {@code false} if it is not found before the timeout
	 */

	public TextView waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) {
		return waitForText(TextView.class, text, expectedMinimumNumberOfMatches, timeout, scroll, false, true);	
	}

	/**
	 * Waits for a text to be shown.
	 *
	 * @param classToFilterBy the class to filter by
	 * @param text the text that needs to be shown, specified as a regular expression
	 * @param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown. {@code 0} means any number of matches
	 * @param timeout the amount of time in milliseconds to wait
	 * @param scroll {@code true} if scrolling should be performed
	 * @return {@code true} if text is found and {@code false} if it is not found before the timeout
	 */

	public <T extends TextView> T waitForText(Class<T> classToFilterBy, String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) {
		return waitForText(classToFilterBy, text, expectedMinimumNumberOfMatches, timeout, scroll, false, true);	
	}

	/**
	 * Waits for a text to be shown.
	 *
	 * @param text the text that needs to be shown, specified as a regular expression.
	 * @param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown. {@code 0} means any number of matches
	 * @param timeout the amount of time in milliseconds to wait
	 * @param scroll {@code true} if scrolling should be performed
	 * @param onlyVisible {@code true} if only visible text views should be waited for
	 * @param hardStoppage {@code true} if search is to be stopped when timeout expires
	 * @return {@code true} if text is found and {@code false} if it is not found before the timeout
	 */

	public TextView waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll, boolean onlyVisible, boolean hardStoppage) {
		return waitForText(TextView.class, text, expectedMinimumNumberOfMatches, timeout, scroll, onlyVisible, hardStoppage);
	}

	/**
	 * Waits for a text to be shown.
	 *
	 * @param classToFilterBy the class to filter by
	 * @param text the text that needs to be shown, specified as a regular expression.
	 * @param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown. {@code 0} means any number of matches
	 * @param timeout the amount of time in milliseconds to wait
	 * @param scroll {@code true} if scrolling should be performed
	 * @param onlyVisible {@code true} if only visible text views should be waited for
	 * @param hardStoppage {@code true} if search is to be stopped when timeout expires
	 * @return {@code true} if text is found and {@code false} if it is not found before the timeout
	 */

	public <T extends TextView> T waitForText(Class<T> classToFilterBy, String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll, boolean onlyVisible, boolean hardStoppage) {
		final long endTime = SystemClock.uptimeMillis() + timeout;

		while (true) {
			final boolean timedOut = SystemClock.uptimeMillis() > endTime;
			if (timedOut){
				return null;
			}

			sleeper.sleep();

			if(!hardStoppage)
				timeout = 0;

			final T textViewToReturn = searcher.searchFor(classToFilterBy, text, expectedMinimumNumberOfMatches, timeout, scroll, onlyVisible);

			if (textViewToReturn != null ){
				return textViewToReturn;
			}
		}
	}

	/**
	 * Waits for and returns a View.
	 * 
	 * @param index the index of the view
	 * @param classToFilterby the class to filter
	 * @return the specified View
	 */

	public <T extends View> T waitForAndGetView(int index, Class<T> classToFilterBy){
		long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();
		while (SystemClock.uptimeMillis() <= endTime && !waitForView(classToFilterBy, index, true, true));
		int numberOfUniqueViews = searcher.getNumberOfUniqueViews();
		ArrayList<T> views = RobotiumUtils.removeInvisibleViews(viewFetcher.getCurrentViews(classToFilterBy, true));

		if(views.size() < numberOfUniqueViews){
			int newIndex = index - (numberOfUniqueViews - views.size());
			if(newIndex >= 0)
				index = newIndex;
		}

		T view = null;
		try{
			view = views.get(index);
		}catch (IndexOutOfBoundsException exception) {
			int match = index + 1;
			if(match > 1) {
				Assert.fail(match + " " + classToFilterBy.getSimpleName() +"s" + " are not found!");
			}
			else {
				Assert.fail(classToFilterBy.getSimpleName() + " is not found!");
			}
		}
		views = null;
		return view;
	}

	/**
	 * Waits for a Fragment with a given tag or id to appear.
	 * 
	 * @param tag the name of the tag or null if no tag	
	 * @param id the id of the tag
	 * @param timeout the amount of time in milliseconds to wait
	 * @return true if fragment appears and false if it does not appear before the timeout
	 */

	public boolean waitForFragment(String tag, int id, int timeout){
		long endTime = SystemClock.uptimeMillis() + timeout;
		while (SystemClock.uptimeMillis() <= endTime) {

			if(getSupportFragment(tag, id) != null)
				return true;

			if(getFragment(tag, id) != null)
				return true;
		}
		return false;
	}

	/**
	 * Returns a SupportFragment with a given tag or id.
	 * 
	 * @param tag the tag of the SupportFragment or null if no tag
	 * @param id the id of the SupportFragment
	 * @return a SupportFragment with a given tag or id
	 */

	private Fragment getSupportFragment(String tag, int id){
		FragmentActivity fragmentActivity = null;

		try{
			fragmentActivity = (FragmentActivity) activityUtils.getCurrentActivity(false);
		}catch (Throwable ignored) {}

		if(fragmentActivity != null){
			try{
				if(tag == null)
					return fragmentActivity.getSupportFragmentManager().findFragmentById(id);
				else
					return fragmentActivity.getSupportFragmentManager().findFragmentByTag(tag);
			}catch (NoSuchMethodError ignored) {}
		}
		return null;
	}

	/**
	 * Waits for a log message to appear.
	 * Requires read logs permission (android.permission.READ_LOGS) in AndroidManifest.xml of the application under test.
	 * 
	 * @param logMessage the log message to wait for
	 * @param timeout the amount of time in milliseconds to wait
	 * @return true if log message appears and false if it does not appear before the timeout
	 */

	public boolean waitForLogMessage(String logMessage, int timeout){
		StringBuilder stringBuilder = new StringBuilder();

		long endTime = SystemClock.uptimeMillis() + timeout;
		while (SystemClock.uptimeMillis() <= endTime) {

			if(getLog(stringBuilder).lastIndexOf(logMessage) != -1){
				return true;
			}
			sleeper.sleep();
		}
		return false;
	}

	/**
	 * Returns the log in the given stringBuilder. 
	 * 
	 * @param stringBuilder the StringBuilder object to return the log in
	 * @return the log
	 */

	private StringBuilder getLog(StringBuilder stringBuilder) {
		Process p = null;
		BufferedReader reader = null;
		String line = null;  

		try {
			// read output from logcat
			p = Runtime.getRuntime().exec("logcat -d");
			reader = new BufferedReader(  
					new InputStreamReader(p.getInputStream())); 

			stringBuilder.setLength(0);
			while ((line = reader.readLine()) != null) {  
				stringBuilder.append(line); 
			}
			reader.close();

			// read error from logcat
			StringBuilder errorLog = new StringBuilder();
			reader = new BufferedReader(new InputStreamReader(
					p.getErrorStream()));
			errorLog.append("logcat returns error: ");
			while ((line = reader.readLine()) != null) {
				errorLog.append(line);
			}
			reader.close();

			// Exception would be thrown if we get exitValue without waiting for the process
			// to finish
			p.waitFor();

			// if exit value of logcat is non-zero, it means error
			if (p.exitValue() != 0) {
				destroy(p, reader);

				throw new Exception(errorLog.toString());
			}

		} catch (IOException e) {
			e.printStackTrace();
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}
		destroy(p, reader);
		return stringBuilder;
	}

	/**
	 * Clears the log.
	 */

	public void clearLog(){
		Process p = null;
		try {
			p = Runtime.getRuntime().exec("logcat -c");
		}catch(IOException e){
			e.printStackTrace();
		}
	}

	/**
	 * Destroys the process and closes the BufferedReader.
	 * 
	 * @param p the process to destroy
	 * @param reader the BufferedReader to close
	 */

	private void destroy(Process p, BufferedReader reader){
		p.destroy();
		try {
			reader.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Returns a Fragment with a given tag or id.
	 * 
	 * @param tag the tag of the Fragment or null if no tag
	 * @param id the id of the Fragment
	 * @return a SupportFragment with a given tag or id
	 */

	private android.app.Fragment getFragment(String tag, int id){

		try{
			if(tag == null)
				return activityUtils.getCurrentActivity().getFragmentManager().findFragmentById(id);
			else
				return activityUtils.getCurrentActivity().getFragmentManager().findFragmentByTag(tag);
		}catch (Throwable ignored) {}

		return null;
	}
}

@#$
package com.robotium.solo;

import java.util.Hashtable;

/**
 * Represents an element shown in a WebView.  
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

public class WebElement {
	
	private int locationX = 0;
	private int locationY = 0;
	private String id;
	private String text;
	private String name;
	private String className;
	private String tagName;
	private Hashtable<String, String> attributes;
	

	/**
	 * Constructs this object. 
	 * 
	 * @param webId the given web id
	 * @param textContent the given text to be set
	 * @param name the given name to be set
	 * @param className the given class name to set
	 * @param tagName the given tag name to be set
	 * @param attributes the attributes to set
	 */

	public WebElement(String webId, String textContent, String name, String className, String tagName, Hashtable<String, String> attributes) {

		this.setId(webId);
		this.setTextContent(textContent);
		this.setName(name);
		this.setClassName(className);
		this.setTagName(tagName);
		this.setAttributes(attributes);
	}

	/**
	 * Returns the WebElements location on screen.
	 */

	public void getLocationOnScreen(int[] location) {

		location[0] = locationX;
		location[1] = locationY;
	}

	/**
	 * Sets the X location.
	 * 
	 * @param locationX the X location of the {@code WebElement}
	 */

	public void setLocationX(int locationX){
		this.locationX = locationX;
	}

	/**
	 * Sets the Y location.
	 * 
	 * @param locationY the Y location of the {@code WebElement}
	 */

	public void setLocationY(int locationY){
		this.locationY = locationY;
	}

	/**
	 * Returns the X location.
	 * 
	 * @return the X location
	 */

	public int getLocationX(){
		return this.locationX;
	}

	/**
	 * Returns the Y location.
	 * 
	 * @return the Y location
	 */

	public int getLocationY(){
		return this.locationY;
	}

	/**
	 * Returns the id.
	 * 
	 * @return the id
	 */

	public String getId() {
		return id;
	}

	/**
	 * Sets the id.
	 * 
	 * @param id the id to set
	 */

	public void setId(String id) {
		this.id = id;
	}

	/**
	 * Returns the name.
	 * 
	 * @return the name
	 */

	public String getName() {
		return name;
	}

	/**
	 * Sets the name.
	 * 
	 * @param name the name to set
	 */

	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Returns the class name.
	 * 
	 * @return the class name
	 */

	public String getClassName() {
		return className;
	}

	/**
	 * Sets the class name.
	 * 
	 * @param className the class name to set
	 */

	public void setClassName(String className) {
		this.className = className;
	}

	/**
	 * Returns the tag name.
	 * 
	 * @return the tag name
	 */

	public String getTagName() {
		return tagName;
	}

	/**
	 * Sets the tag name.
	 * 
	 * @param tagName the tag name to set
	 */

	public void setTagName(String tagName) {
		this.tagName = tagName;
	}

	/**
	 * Returns the text content.
	 * 
	 * @return the text content
	 */

	public String getText() {
		return text;
	}

	/**
	 * Sets the text content.
	 * 
	 * @param textContent the text content to set
	 */
	
	public void setTextContent(String textContent) {
		this.text = textContent;
	}

	/**
	 * Returns the value for the specified attribute.
	 * 
	 * @return the value for the specified attribute
	 */

	public String getAttribute(String attributeName) {
		if (attributeName != null){
			return this.attributes.get(attributeName);
		}
		
		return null;
	}

	/**
	 * Sets the attributes.
	 * 
	 * @param attributes the attributes to set
	 */
	
	public void setAttributes(Hashtable<String,String> attributes) {
		this.attributes = attributes;
	}

}

@#$
package com.robotium.solo;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import android.os.SystemClock;
import android.webkit.WebView;

/**
 * Contains TextView related methods. Examples are:
 * getTextViewsFromWebViews(), createTextViewAndAddInList().
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class WebElementCreator {

	private List<WebElement> webElements;
	private Sleeper sleeper;
	private boolean isFinished = false;

	/**
	 * Constructs this object.
	 * 
	 * @param sleeper the {@code Sleeper} instance
	 * 
	 */

	public WebElementCreator(Sleeper sleeper){
		this.sleeper = sleeper;
		webElements = new CopyOnWriteArrayList<WebElement>();
	}

	/**
	 * Prepares for start of creating {@code TextView} objects based on web elements 
	 */

	public void prepareForStart(){
		setFinished(false);
		webElements.clear();
	}

	/**
	 * Returns an {@code ArrayList} of {@code TextView} objects based on the web elements shown
	 * 
	 * @return an {@code ArrayList} of {@code TextView} objects based on the web elements shown
	 */

	public ArrayList<WebElement> getWebElementsFromWebViews(){
		waitForWebElementsToBeCreated();
		return new ArrayList<WebElement>(webElements);
	}

	/**
	 * Returns true if all {@code TextView} objects based on web elements have been created
	 * 
	 * @return true if all {@code TextView} objects based on web elements have been created
	 */

	public boolean isFinished(){
		return isFinished;
	}


	/**
	 * Set to true if all {@code TextView} objects have been created
	 * 
	 * @param isFinished true if all {@code TextView} objects have been created
	 */

	public void setFinished(boolean isFinished){
		this.isFinished = isFinished;
	}

	/**
	 * Creates a {@ WebElement} object from the given text and {@code WebView}
	 * 
	 * @param webData the data of the web element 
	 * @param webView the {@code WebView} the text is shown in
	 */

	public void createWebElementAndAddInList(String webData, WebView webView){

		WebElement webElement = createWebElementAndSetLocation(webData, webView);

		if((webElement!=null)) 
			webElements.add(webElement);
	}

	/**
	 * Sets the location of a {@code WebElement} 
	 * 
	 * @param webElement the {@code TextView} object to set location 
	 * @param webView the {@code WebView} the text is shown in
	 * @param x the x location to set
	 * @param y the y location to set
	 * @param width the width to set
	 * @param height the height to set
	 */

	private void setLocation(WebElement webElement, WebView webView, int x, int y, int width, int height ){
		float scale = webView.getScale();
		int[] locationOfWebViewXY = new int[2];
		webView.getLocationOnScreen(locationOfWebViewXY);

		int locationX = (int) (locationOfWebViewXY[0] + (x + (Math.floor(width / 2))) * scale);
		int locationY = (int) (locationOfWebViewXY[1] + (y + (Math.floor(height / 2))) * scale);

		webElement.setLocationX(locationX);
		webElement.setLocationY(locationY);
	}

	/**
	 * Creates a {@code WebView} object 
	 * 
	 * @param information the data of the web element
	 * @param webView the web view the text is shown in
	 * 
	 * @return a {@code WebElement} object with a given text and location
	 */

	private WebElement createWebElementAndSetLocation(String information, WebView webView){
		String[] data = information.split(";,");
		String[] elements = null;
		int x = 0;
		int y = 0;
		int width = 0;
		int height = 0;
		Hashtable<String, String> attributes = new Hashtable<String, String>();
		try{
			x = Math.round(Float.valueOf(data[5]));
			y = Math.round(Float.valueOf(data[6]));
			width = Math.round(Float.valueOf(data[7]));
			height = Math.round(Float.valueOf(data[8]));	
			elements = data[9].split("\\#\\$");
		}catch(Exception ignored){}

		if(elements != null) {
			for (int index = 0; index < elements.length; index++){
				String[] element = elements[index].split("::");
				if (element.length > 1) {
					attributes.put(element[0], element[1]);
				} else {
					attributes.put(element[0], element[0]);
				}
			}
		}

		WebElement webElement = null;

		try{
			webElement = new WebElement(data[0], data[1], data[2], data[3], data[4], attributes);
			setLocation(webElement, webView, x, y, width, height);
		}catch(Exception ignored) {}

		return webElement;
	}

	/**
	 * Waits for {@code WebElement} objects to be created
	 * 
	 * @return true if successfully created before timout
	 */

	private boolean waitForWebElementsToBeCreated(){
		final long endTime = SystemClock.uptimeMillis() + 5000;

		while(SystemClock.uptimeMillis() < endTime){

			if(isFinished){
				return true;
			}

			sleeper.sleepMini();
		}
		return false;
	}

}

@#$
package com.robotium.solo;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import com.robotium.solo.Solo.Config;
import android.app.Instrumentation;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.widget.TextView;


/**
 * Contains web related methods. Examples are:
 * enterTextIntoWebElement(), getWebTexts(), getWebElements().
 * 
 * @author Renas Reda, renas.reda@robotium.com
 * 
 */

class WebUtils {

	private ViewFetcher viewFetcher;
	private Instrumentation inst;
	private ActivityUtils activityUtils;
	RobotiumWebClient robotiumWebCLient;
	WebElementCreator webElementCreator;
	WebChromeClient originalWebChromeClient = null;
	private Config config;


	/**
	 * Constructs this object.
	 * 
	 * @param config the {@code Config} instance
	 * @param instrumentation the {@code Instrumentation} instance
	 * @param activityUtils the {@code ActivityUtils} instance
	 * @param viewFetcher the {@code ViewFetcher} instance
	 */

	public WebUtils(Config config, Instrumentation instrumentation, ActivityUtils activityUtils, ViewFetcher viewFetcher, Sleeper sleeper){
		this.config = config;
		this.inst = instrumentation;
		this.activityUtils = activityUtils;
		this.viewFetcher = viewFetcher;
		webElementCreator = new WebElementCreator(sleeper);
		robotiumWebCLient = new RobotiumWebClient(instrumentation, webElementCreator);
	}

	/**
	 * Returns {@code TextView} objects based on web elements shown in the present WebViews
	 * 
	 * @param onlyFromVisibleWebViews true if only from visible WebViews
	 * @return an {@code ArrayList} of {@code TextViews}s created from the present {@code WebView}s 
	 */

	public ArrayList<TextView> getTextViewsFromWebView(){
		boolean javaScriptWasExecuted = executeJavaScriptFunction("allTexts();");	

		return createAndReturnTextViewsFromWebElements(javaScriptWasExecuted);	
	}

	/**
	 * Creates and returns TextView objects based on WebElements
	 * 
	 * @return an ArrayList with TextViews
	 */

	private ArrayList <TextView> createAndReturnTextViewsFromWebElements(boolean javaScriptWasExecuted){
		ArrayList<TextView> webElementsAsTextViews = new ArrayList<TextView>();

		if(javaScriptWasExecuted){
			for(WebElement webElement : webElementCreator.getWebElementsFromWebViews()){
				if(isWebElementSufficientlyShown(webElement)){
					RobotiumTextView textView = new RobotiumTextView(inst.getContext(), webElement.getText(), webElement.getLocationX(), webElement.getLocationY());
					webElementsAsTextViews.add(textView);
				}
			}	
		}
		return webElementsAsTextViews;		
	}

	/**
	 * Returns an ArrayList of WebElements currently shown in the active WebView.
	 * 
	 * @param onlySufficientlyVisible true if only sufficiently visible {@link WebElement} objects should be returned
	 * @return an {@code ArrayList} of the {@link WebElement} objects shown in the active WebView
	 */

	public ArrayList<WebElement> getWebElements(boolean onlySufficientlyVisible){
		boolean javaScriptWasExecuted = executeJavaScriptFunction("allWebElements();");
		
		return getWebElements(javaScriptWasExecuted, onlySufficientlyVisible);
	}

	/**
	 * Returns an ArrayList of WebElements of the specified By object currently shown in the active WebView.
	 * 
	 * @param by the By object. Examples are By.id("id") and By.name("name")
	 * @param onlySufficientlyVisible true if only sufficiently visible {@link WebElement} objects should be returned
	 * @return an {@code ArrayList} of the {@link WebElement} objects currently shown in the active WebView 
	 */

	public ArrayList<WebElement> getWebElements(final By by, boolean onlySufficientlyVisbile){
		boolean javaScriptWasExecuted = executeJavaScript(by, false);
		
		if(config.useJavaScriptToClickWebElements){
			if(!javaScriptWasExecuted){
				return new ArrayList<WebElement>();
			}
			return webElementCreator.getWebElementsFromWebViews();
		}

		return getWebElements(javaScriptWasExecuted, onlySufficientlyVisbile);
	}

	/**
	 * Returns the sufficiently shown WebElements
	 * 
	 * @param javaScriptWasExecuted true if JavaScript was executed
	 * @param onlySufficientlyVisible true if only sufficiently visible {@link WebElement} objects should be returned
	 * @return the sufficiently shown WebElements
	 */

	private ArrayList<WebElement> getWebElements(boolean javaScriptWasExecuted, boolean onlySufficientlyVisbile){
		ArrayList<WebElement> webElements = new ArrayList<WebElement>();

		if(javaScriptWasExecuted){
			for(WebElement webElement : webElementCreator.getWebElementsFromWebViews()){
				if(!onlySufficientlyVisbile){
					webElements.add(webElement);
				}
				else if(isWebElementSufficientlyShown(webElement)){
					webElements.add(webElement);
				}
			}
		}
		return webElements;
	}

	/**
	 * Prepares for start of JavaScript execution
	 * 
	 * @return the JavaScript as a String
	 */

	private String prepareForStartOfJavascriptExecution(){
		webElementCreator.prepareForStart();

		WebChromeClient currentWebChromeClient = getCurrentWebChromeClient();

		if(currentWebChromeClient != null && !currentWebChromeClient.getClass().isAssignableFrom(RobotiumWebClient.class)){
			originalWebChromeClient = getCurrentWebChromeClient();	
		}

		robotiumWebCLient.enableJavascriptAndSetRobotiumWebClient(viewFetcher.getCurrentViews(WebView.class, true), originalWebChromeClient);
		return getJavaScriptAsString();
	}
	
	/**
	 * Returns the current WebChromeClient through reflection
	 * 
	 * @return the current WebChromeClient
	 * 
	 */

	private WebChromeClient getCurrentWebChromeClient(){
		WebChromeClient currentWebChromeClient = null;

		Object currentWebView = viewFetcher.getFreshestView(viewFetcher.getCurrentViews(WebView.class, true));

		if (android.os.Build.VERSION.SDK_INT >= 16) {
			try{
				currentWebView = new Reflect(currentWebView).field("mProvider").out(Object.class);
			}catch(IllegalArgumentException ignored) {}
		}

		try{
			if (android.os.Build.VERSION.SDK_INT >= 19) {
				Object mClientAdapter = new Reflect(currentWebView).field("mContentsClientAdapter").out(Object.class);
				currentWebChromeClient = new Reflect(mClientAdapter).field("mWebChromeClient").out(WebChromeClient.class);
			}
			else {
				Object mCallbackProxy = new Reflect(currentWebView).field("mCallbackProxy").out(Object.class);
				currentWebChromeClient = new Reflect(mCallbackProxy).field("mWebChromeClient").out(WebChromeClient.class);
			}
		}catch(Exception ignored){}

		return currentWebChromeClient;
	}

	/**
	 * Enters text into a web element using the given By method
	 * 
	 * @param by the By object e.g. By.id("id");
	 * @param text the text to enter
	 */

	public void enterTextIntoWebElement(final By by, final String text){
		if(by instanceof By.Id){
			executeJavaScriptFunction("enterTextById(\""+by.getValue()+"\", \""+text+"\");");
		}
		else if(by instanceof By.Xpath){
			executeJavaScriptFunction("enterTextByXpath(\""+by.getValue()+"\", \""+text+"\");");
		}
		else if(by instanceof By.CssSelector){
			executeJavaScriptFunction("enterTextByCssSelector(\""+by.getValue()+"\", \""+text+"\");");
		}
		else if(by instanceof By.Name){
			executeJavaScriptFunction("enterTextByName(\""+by.getValue()+"\", \""+text+"\");");
		}
		else if(by instanceof By.ClassName){
			executeJavaScriptFunction("enterTextByClassName(\""+by.getValue()+"\", \""+text+"\");");
		}
		else if(by instanceof By.Text){
			executeJavaScriptFunction("enterTextByTextContent(\""+by.getValue()+"\", \""+text+"\");");
		}
		else if(by instanceof By.TagName){
			executeJavaScriptFunction("enterTextByTagName(\""+by.getValue()+"\", \""+text+"\");");
		}
	}

	/**
	 * Executes JavaScript determined by the given By object
	 * 
	 * @param by the By object e.g. By.id("id");
	 * @param shouldClick true if click should be performed
	 * @return true if JavaScript function was executed
	 */

	public boolean executeJavaScript(final By by, boolean shouldClick){
		if(by instanceof By.Id){
			return executeJavaScriptFunction("id(\""+by.getValue()+"\", \"" + String.valueOf(shouldClick) + "\");");
		}
		else if(by instanceof By.Xpath){
			return executeJavaScriptFunction("xpath(\""+by.getValue()+"\", \"" + String.valueOf(shouldClick) + "\");");
		}
		else if(by instanceof By.CssSelector){
			return executeJavaScriptFunction("cssSelector(\""+by.getValue()+"\", \"" + String.valueOf(shouldClick) + "\");");
		}
		else if(by instanceof By.Name){
			return executeJavaScriptFunction("name(\""+by.getValue()+"\", \"" + String.valueOf(shouldClick) + "\");");
		}
		else if(by instanceof By.ClassName){
			return executeJavaScriptFunction("className(\""+by.getValue()+"\", \"" + String.valueOf(shouldClick) + "\");");
		}
		else if(by instanceof By.Text){
			return executeJavaScriptFunction("textContent(\""+by.getValue()+"\", \"" + String.valueOf(shouldClick) + "\");");
		}
		else if(by instanceof By.TagName){
			return executeJavaScriptFunction("tagName(\""+by.getValue()+"\", \"" + String.valueOf(shouldClick) + "\");");
		}
		return false;
	}

	/**
	 * Executes the given JavaScript function
	 * 
	 * @param function the function as a String
	 * @return true if JavaScript function was executed
	 */

	private boolean executeJavaScriptFunction(final String function){
		final WebView webView = viewFetcher.getFreshestView(viewFetcher.getCurrentViews(WebView.class, true));

		if(webView == null){
			return false;
		}

		final String javaScript = prepareForStartOfJavascriptExecution();

		activityUtils.getCurrentActivity(false).runOnUiThread(new Runnable() {
			public void run() {
				if(webView != null){
					webView.loadUrl("javascript:" + javaScript + function);
				}
			}
		});
		return true;
	}

	/**
	 * Returns true if the view is sufficiently shown
	 *
	 * @param view the view to check
	 * @return true if the view is sufficiently shown
	 */

	public final boolean isWebElementSufficientlyShown(WebElement webElement){
		final WebView webView = viewFetcher.getFreshestView(viewFetcher.getCurrentViews(WebView.class, true));
		final int[] xyWebView = new int[2];

		if(webView != null && webElement != null){
			webView.getLocationOnScreen(xyWebView);

			if(xyWebView[1] + webView.getHeight() > webElement.getLocationY())
				return true;
		}
		return false;
	}
	
	/**
	 * Splits a name by upper case.
	 * 
	 * @param name the name to split
	 * @return a String with the split name
	 * 
	 */

	public String splitNameByUpperCase(String name) {
		String [] texts = name.split("(?=\\p{Upper})");
		StringBuilder stringToReturn = new StringBuilder();

		for(String string : texts){

			if(stringToReturn.length() > 0) {
				stringToReturn.append(" " + string.toLowerCase());
			}
			else {
				stringToReturn.append(string.toLowerCase());
			}
		}
		return stringToReturn.toString();
	}

	/**
	 * Returns the JavaScript file RobotiumWeb.js as a String
	 *  
	 * @return the JavaScript file RobotiumWeb.js as a {@code String} 
	 */

	private String getJavaScriptAsString() {
		InputStream fis = getClass().getResourceAsStream("RobotiumWeb.js");
		StringBuffer javaScript = new StringBuffer();

		try {
			BufferedReader input =  new BufferedReader(new InputStreamReader(fis));
			String line = null;
			while (( line = input.readLine()) != null){
				javaScript.append(line);
				javaScript.append("\n");
			}
			input.close();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return javaScript.toString();
	}
}
@#$
package com.robotium.solo;

import android.app.Instrumentation;
import android.os.SystemClock;
import android.view.MotionEvent;
import android.view.MotionEvent.PointerProperties;
import android.view.MotionEvent.PointerCoords;
import android.graphics.PointF;


class Zoomer {
	
	private final Instrumentation _instrument;
	public static final int GESTURE_DURATION_MS = 1000;
    public static final int EVENT_TIME_INTERVAL_MS = 10;
	
	public Zoomer(Instrumentation inst)
	{
		this._instrument = inst;
	}

	public void generateZoomGesture(PointF startPoint1, PointF startPoint2, PointF endPoint1, PointF endPoint2) 
	{

		 long downTime = SystemClock.uptimeMillis();
         long eventTime = SystemClock.uptimeMillis();

         float startX1 = startPoint1.x;
         float startY1 = startPoint1.y;
         float startX2 = startPoint2.x;
         float startY2 = startPoint2.y;

         float endX1 = endPoint1.x;
         float endY1 = endPoint1.y;
         float endX2 = endPoint2.x;
         float endY2 = endPoint2.y;

         //pointer 1
         float x1 = startX1;
         float y1 = startY1;

         //pointer 2
         float x2 = startX2;
         float y2 = startY2; 

         PointerCoords[] pointerCoords = new PointerCoords[2];
         PointerCoords pc1 = new PointerCoords();
         PointerCoords pc2 = new PointerCoords();
         pc1.x = x1;
         pc1.y = y1;
         pc1.pressure = 1;
         pc1.size = 1;
         pc2.x = x2;
         pc2.y = y2;
         pc2.pressure = 1;
         pc2.size = 1;
         pointerCoords[0] = pc1;
         pointerCoords[1] = pc2;

         PointerProperties[] pointerProperties = new PointerProperties[2];
         PointerProperties pp1 = new PointerProperties();
         PointerProperties pp2 = new PointerProperties();
         pp1.id = 0;
         pp1.toolType = MotionEvent.TOOL_TYPE_FINGER;
         pp2.id = 1;
         pp2.toolType = MotionEvent.TOOL_TYPE_FINGER;
         pointerProperties[0] = pp1;
         pointerProperties[1] = pp2;

         MotionEvent event;
         // send the initial touches
         event = MotionEvent.obtain( downTime,
                                     eventTime,
                                     MotionEvent.ACTION_DOWN,
                                     1,
                                     pointerProperties,
                                     pointerCoords,
                                     0, 0, // metaState, buttonState
                                     1, // x precision
                                     1, // y precision
                                     0, 0, 0, 0 ); // deviceId, edgeFlags, source, flags
         _instrument.sendPointerSync(event);

         event = MotionEvent.obtain( downTime,
                                     eventTime,
                                     MotionEvent.ACTION_POINTER_DOWN + (pp2.id << MotionEvent.ACTION_POINTER_INDEX_SHIFT),
                                     2,
                                     pointerProperties,
                                     pointerCoords,
                                     0, 0,
                                     1,
                                     1,
                                     0, 0, 0, 0 );
         _instrument.sendPointerSync(event);

         int numMoves = GESTURE_DURATION_MS / EVENT_TIME_INTERVAL_MS;

         float stepX1 = (endX1 - startX1) / numMoves;
         float stepY1 = (endY1 - startY1) / numMoves;
         float stepX2 = (endX2 - startX2) / numMoves;
         float stepY2 = (endY2 - startY2) / numMoves;

         // send the zoom
         for (int i = 0; i < numMoves; i++)
         {
             eventTime += EVENT_TIME_INTERVAL_MS;
             pointerCoords[0].x += stepX1;
             pointerCoords[0].y += stepY1;
             pointerCoords[1].x += stepX2;
             pointerCoords[1].y += stepY2;

             event = MotionEvent.obtain( downTime,
                                         eventTime,
                                         MotionEvent.ACTION_MOVE,
                                         2,
                                         pointerProperties,
                                         pointerCoords,
                                         0, 0,
                                         1,
                                         1,
                                         0, 0, 0, 0 );
             _instrument.sendPointerSync(event);
         }
	}
}

@#$
