package com.mikhaellopez.circularimageview;

import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Bitmap;
import android.graphics.BitmapShader;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Shader;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
import android.widget.ImageView;

public class CircularImageView extends ImageView {
	private int borderWidth;
	private int canvasSize;
	private Bitmap image;
	private Paint paint;
	private Paint paintBorder;

	public CircularImageView(final Context context) {
		this(context, null);
	}

	public CircularImageView(Context context, AttributeSet attrs) {
		this(context, attrs, R.attr.circularImageViewStyle);
	}

	public CircularImageView(Context context, AttributeSet attrs, int defStyle) {
		super(context, attrs, defStyle);

		// init paint
		paint = new Paint();
		paint.setAntiAlias(true);

		paintBorder = new Paint();
		paintBorder.setAntiAlias(true);

		// load the styled attributes and set their properties
		TypedArray attributes = context.obtainStyledAttributes(attrs, R.styleable.CircularImageView, defStyle, 0);

		if(attributes.getBoolean(R.styleable.CircularImageView_border, true)) {
			int defaultBorderSize = (int) (4 * getContext().getResources().getDisplayMetrics().density + 0.5f);
			setBorderWidth(attributes.getDimensionPixelOffset(R.styleable.CircularImageView_border_width, defaultBorderSize));
			setBorderColor(attributes.getColor(R.styleable.CircularImageView_border_color, Color.WHITE));
		}

		if(attributes.getBoolean(R.styleable.CircularImageView_shadow, false))
			addShadow();
	}

	public void setBorderWidth(int borderWidth) {
		this.borderWidth = borderWidth;
		this.requestLayout();
		this.invalidate();
	}

	public void setBorderColor(int borderColor) {
		if (paintBorder != null)
			paintBorder.setColor(borderColor);
		this.invalidate();
	}

	public void addShadow() {
		setLayerType(LAYER_TYPE_SOFTWARE, paintBorder);
		paintBorder.setShadowLayer(4.0f, 0.0f, 2.0f, Color.BLACK);
	}

	@Override
	public void onDraw(Canvas canvas) {
		// load the bitmap
		image = drawableToBitmap(getDrawable());

		// init shader
		if (image != null) {

			canvasSize = canvas.getWidth();
			if(canvas.getHeight()<canvasSize)
				canvasSize = canvas.getHeight();

			BitmapShader shader = new BitmapShader(Bitmap.createScaledBitmap(image, canvasSize, canvasSize, false), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
			paint.setShader(shader);

			// circleCenter is the x or y of the view's center
			// radius is the radius in pixels of the cirle to be drawn
			// paint contains the shader that will texture the shape
			int circleCenter = (canvasSize - (borderWidth * 2)) / 2;
			canvas.drawCircle(circleCenter + borderWidth, circleCenter + borderWidth, ((canvasSize - (borderWidth * 2)) / 2) + borderWidth - 4.0f, paintBorder);
			canvas.drawCircle(circleCenter + borderWidth, circleCenter + borderWidth, ((canvasSize - (borderWidth * 2)) / 2) - 4.0f, paint);
		}
	}

	@Override
	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
		int width = measureWidth(widthMeasureSpec);
		int height = measureHeight(heightMeasureSpec);
		setMeasuredDimension(width, height);
	}

	private int measureWidth(int measureSpec) {
		int result = 0;
		int specMode = MeasureSpec.getMode(measureSpec);
		int specSize = MeasureSpec.getSize(measureSpec);

		if (specMode == MeasureSpec.EXACTLY) {
			// The parent has determined an exact size for the child.
			result = specSize;
		} else if (specMode == MeasureSpec.AT_MOST) {
			// The child can be as large as it wants up to the specified size.
			result = specSize;
		} else {
			// The parent has not imposed any constraint on the child.
			result = canvasSize;
		}

		return result;
	}

	private int measureHeight(int measureSpecHeight) {
		int result = 0;
		int specMode = MeasureSpec.getMode(measureSpecHeight);
		int specSize = MeasureSpec.getSize(measureSpecHeight);

		if (specMode == MeasureSpec.EXACTLY) {
			// We were told how big to be
			result = specSize;
		} else if (specMode == MeasureSpec.AT_MOST) {
			// The child can be as large as it wants up to the specified size.
			result = specSize;
		} else {
			// Measure the text (beware: ascent is a negative number)
			result = canvasSize;
		}

		return (result + 2);
	}

	public Bitmap drawableToBitmap(Drawable drawable) {
		if (drawable == null) {
			return null;
		} else if (drawable instanceof BitmapDrawable) {
			return ((BitmapDrawable) drawable).getBitmap();
		}

        int width = drawable.getIntrinsicWidth();
        int height = drawable.getIntrinsicHeight();

        if (width < 1)
            width = convertToPx(80);
        if (height < 1)
            height = convertToPx(80);

		Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(bitmap);
		drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
		drawable.draw(canvas);

		return bitmap;
	}

    public int convertToPx(int dp) {
        // Get the screen's density scale
        final float scale = getResources().getDisplayMetrics().density;
        // Convert the dps to pixels, based on density scale
        return (int) (dp * scale + 0.5f);
    }

}
@#$
package com.mobeta.android.dslv;

import android.graphics.Point;
import android.view.GestureDetector;
import android.view.HapticFeedbackConstants;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;
import android.widget.AdapterView;

/**
 * Class that starts and stops item drags on a {@link DragSortListView}
 * based on touch gestures. This class also inherits from
 * {@link SimpleFloatViewManager}, which provides basic float View
 * creation.
 *
 * An instance of this class is meant to be passed to the methods
 * {@link DragSortListView#setTouchListener()} and
 * {@link DragSortListView#setFloatViewManager()} of your
 * {@link DragSortListView} instance.
 */
public class DragSortController extends SimpleFloatViewManager implements View.OnTouchListener, GestureDetector.OnGestureListener {

    /**
     * Drag init mode enum.
     */
    public static final int ON_DOWN = 0;
    public static final int ON_DRAG = 1;
    public static final int ON_LONG_PRESS = 2;

    private int mDragInitMode = ON_DOWN;

    private boolean mSortEnabled = true;

    /**
     * Remove mode enum.
     */
    public static final int CLICK_REMOVE = 0;
    public static final int FLING_REMOVE = 1;

    /**
     * The current remove mode.
     */
    private int mRemoveMode;

    private boolean mRemoveEnabled = false;
    private boolean mIsRemoving = false;

    private GestureDetector mDetector;

    private GestureDetector mFlingRemoveDetector;

    private int mTouchSlop;

    public static final int MISS = -1;

    private int mHitPos = MISS;
    private int mFlingHitPos = MISS;

    private int mClickRemoveHitPos = MISS;

    private int[] mTempLoc = new int[2];

    private int mItemX;
    private int mItemY;

    private int mCurrX;
    private int mCurrY;

    private boolean mDragging = false;

    private float mFlingSpeed = 500f;

    private int mDragHandleId;

    private int mClickRemoveId;

    private int mFlingHandleId;
    private boolean mCanDrag;

    private DragSortListView mDslv;
    private int mPositionX;

    /**
     * Calls {@link #DragSortController(DragSortListView, int)} with a
     * 0 drag handle id, FLING_RIGHT_REMOVE remove mode,
     * and ON_DOWN drag init. By default, sorting is enabled, and
     * removal is disabled.
     *
     * @param dslv The DSLV instance
     */
    public DragSortController(DragSortListView dslv) {
        this(dslv, 0, ON_DOWN, FLING_REMOVE);
    }

    public DragSortController(DragSortListView dslv, int dragHandleId, int dragInitMode, int removeMode) {
        this(dslv, dragHandleId, dragInitMode, removeMode, 0);
    }

    public DragSortController(DragSortListView dslv, int dragHandleId, int dragInitMode, int removeMode, int clickRemoveId) {
        this(dslv, dragHandleId, dragInitMode, removeMode, clickRemoveId, 0);
    }

    /**
     * By default, sorting is enabled, and removal is disabled.
     *
     * @param dslv The DSLV instance
     * @param dragHandleId The resource id of the View that represents
     * the drag handle in a list item.
     */
    public DragSortController(DragSortListView dslv, int dragHandleId, int dragInitMode,
            int removeMode, int clickRemoveId, int flingHandleId) {
        super(dslv);
        mDslv = dslv;
        mDetector = new GestureDetector(dslv.getContext(), this);
        mFlingRemoveDetector = new GestureDetector(dslv.getContext(), mFlingRemoveListener);
        mFlingRemoveDetector.setIsLongpressEnabled(false);
        mTouchSlop = ViewConfiguration.get(dslv.getContext()).getScaledTouchSlop();
        mDragHandleId = dragHandleId;
        mClickRemoveId = clickRemoveId;
        mFlingHandleId = flingHandleId;
        setRemoveMode(removeMode);
        setDragInitMode(dragInitMode);
    }


    public int getDragInitMode() {
        return mDragInitMode;
    }

    /**
     * Set how a drag is initiated. Needs to be one of
     * {@link ON_DOWN}, {@link ON_DRAG}, or {@link ON_LONG_PRESS}.
     *
     * @param mode The drag init mode.
     */
    public void setDragInitMode(int mode) {
        mDragInitMode = mode;
    }

    /**
     * Enable/Disable list item sorting. Disabling is useful if only item
     * removal is desired. Prevents drags in the vertical direction.
     *
     * @param enabled Set <code>true</code> to enable list
     * item sorting.
     */
    public void setSortEnabled(boolean enabled) {
        mSortEnabled = enabled;
    }

    public boolean isSortEnabled() {
        return mSortEnabled;
    }

    /**
     * One of {@link CLICK_REMOVE}, {@link FLING_RIGHT_REMOVE},
     * {@link FLING_LEFT_REMOVE},
     * {@link SLIDE_RIGHT_REMOVE}, or {@link SLIDE_LEFT_REMOVE}.
     */
    public void setRemoveMode(int mode) {
        mRemoveMode = mode;
    }

    public int getRemoveMode() {
        return mRemoveMode;
    }

    /**
     * Enable/Disable item removal without affecting remove mode.
     */
    public void setRemoveEnabled(boolean enabled) {
        mRemoveEnabled = enabled;
    }

    public boolean isRemoveEnabled() {
        return mRemoveEnabled;
    }

    /**
     * Set the resource id for the View that represents the drag
     * handle in a list item.
     *
     * @param id An android resource id.
     */
    public void setDragHandleId(int id) {
        mDragHandleId = id;
    }

    /**
     * Set the resource id for the View that represents the fling
     * handle in a list item.
     *
     * @param id An android resource id.
     */
    public void setFlingHandleId(int id) {
        mFlingHandleId = id;
    }

    /**
     * Set the resource id for the View that represents click
     * removal button.
     *
     * @param id An android resource id.
     */
    public void setClickRemoveId(int id) {
        mClickRemoveId = id;
    }

    /**
     * Sets flags to restrict certain motions of the floating View
     * based on DragSortController settings (such as remove mode).
     * Starts the drag on the DragSortListView.
     *
     * @param position The list item position (includes headers).
     * @param deltaX Touch x-coord minus left edge of floating View.
     * @param deltaY Touch y-coord minus top edge of floating View.
     *
     * @return True if drag started, false otherwise.
     */
    public boolean startDrag(int position, int deltaX, int deltaY) {

        int dragFlags = 0;
        if (mSortEnabled && !mIsRemoving) {
            dragFlags |= DragSortListView.DRAG_POS_Y | DragSortListView.DRAG_NEG_Y;
        }
        if (mRemoveEnabled && mIsRemoving) {
            dragFlags |= DragSortListView.DRAG_POS_X;
            dragFlags |= DragSortListView.DRAG_NEG_X;
        }

        mDragging = mDslv.startDrag(position - mDslv.getHeaderViewsCount(), dragFlags, deltaX,
                deltaY);
        return mDragging;
    }

    @Override
    public boolean onTouch(View v, MotionEvent ev) {
        if (!mDslv.isDragEnabled() || mDslv.listViewIntercepted()) {
            return false;
        }

        mDetector.onTouchEvent(ev);
        if (mRemoveEnabled && mDragging && mRemoveMode == FLING_REMOVE) {
            mFlingRemoveDetector.onTouchEvent(ev);
        }

        int action = ev.getAction() & MotionEvent.ACTION_MASK;
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mCurrX = (int) ev.getX();
                mCurrY = (int) ev.getY();
                break;
            case MotionEvent.ACTION_UP:
                if (mRemoveEnabled && mIsRemoving) {
                    int x = mPositionX >= 0 ? mPositionX : -mPositionX;
                    int removePoint = mDslv.getWidth() / 2;
                    if (x > removePoint) {
                        mDslv.stopDragWithVelocity(true, 0);
                    }
                }
            case MotionEvent.ACTION_CANCEL:
                mIsRemoving = false;
                mDragging = false;
                break;
        }

        return false;
    }

    /**
     * Overrides to provide fading when slide removal is enabled.
     */
    @Override
    public void onDragFloatView(View floatView, Point position, Point touch) {

        if (mRemoveEnabled && mIsRemoving) {
            mPositionX = position.x;
        }
    }

    /**
     * Get the position to start dragging based on the ACTION_DOWN
     * MotionEvent. This function simply calls
     * {@link #dragHandleHitPosition(MotionEvent)}. Override
     * to change drag handle behavior;
     * this function is called internally when an ACTION_DOWN
     * event is detected.
     *
     * @param ev The ACTION_DOWN MotionEvent.
     *
     * @return The list position to drag if a drag-init gesture is
     * detected; MISS if unsuccessful.
     */
    public int startDragPosition(MotionEvent ev) {
        return dragHandleHitPosition(ev);
    }

    public int startFlingPosition(MotionEvent ev) {
        return mRemoveMode == FLING_REMOVE ? flingHandleHitPosition(ev) : MISS;
    }

    /**
     * Checks for the touch of an item's drag handle (specified by
     * {@link #setDragHandleId(int)}), and returns that item's position
     * if a drag handle touch was detected.
     *
     * @param ev The ACTION_DOWN MotionEvent.

     * @return The list position of the item whose drag handle was
     * touched; MISS if unsuccessful.
     */
    public int dragHandleHitPosition(MotionEvent ev) {
        return viewIdHitPosition(ev, mDragHandleId);
    }

    public int flingHandleHitPosition(MotionEvent ev) {
        return viewIdHitPosition(ev, mFlingHandleId);
    }

    public int viewIdHitPosition(MotionEvent ev, int id) {
        final int x = (int) ev.getX();
        final int y = (int) ev.getY();

        int touchPos = mDslv.pointToPosition(x, y); // includes headers/footers

        final int numHeaders = mDslv.getHeaderViewsCount();
        final int numFooters = mDslv.getFooterViewsCount();
        final int count = mDslv.getCount();

        // Log.d("mobeta", "touch down on position " + itemnum);
        // We're only interested if the touch was on an
        // item that's not a header or footer.
        if (touchPos != AdapterView.INVALID_POSITION && touchPos >= numHeaders
                && touchPos < (count - numFooters)) {
            final View item = mDslv.getChildAt(touchPos - mDslv.getFirstVisiblePosition());
            final int rawX = (int) ev.getRawX();
            final int rawY = (int) ev.getRawY();

            View dragBox = id == 0 ? item : (View) item.findViewById(id);
            if (dragBox != null) {
                dragBox.getLocationOnScreen(mTempLoc);

                if (rawX > mTempLoc[0] && rawY > mTempLoc[1] &&
                        rawX < mTempLoc[0] + dragBox.getWidth() &&
                        rawY < mTempLoc[1] + dragBox.getHeight()) {

                    mItemX = item.getLeft();
                    mItemY = item.getTop();

                    return touchPos;
                }
            }
        }

        return MISS;
    }

    @Override
    public boolean onDown(MotionEvent ev) {
        if (mRemoveEnabled && mRemoveMode == CLICK_REMOVE) {
            mClickRemoveHitPos = viewIdHitPosition(ev, mClickRemoveId);
        }

        mHitPos = startDragPosition(ev);
        if (mHitPos != MISS && mDragInitMode == ON_DOWN) {
            startDrag(mHitPos, (int) ev.getX() - mItemX, (int) ev.getY() - mItemY);
        }

        mIsRemoving = false;
        mCanDrag = true;
        mPositionX = 0;
        mFlingHitPos = startFlingPosition(ev);

        return true;
    }

    @Override
    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {

        final int x1 = (int) e1.getX();
        final int y1 = (int) e1.getY();
        final int x2 = (int) e2.getX();
        final int y2 = (int) e2.getY();
        final int deltaX = x2 - mItemX;
        final int deltaY = y2 - mItemY;

        if (mCanDrag && !mDragging && (mHitPos != MISS || mFlingHitPos != MISS)) {
            if (mHitPos != MISS) {
                if (mDragInitMode == ON_DRAG && Math.abs(y2 - y1) > mTouchSlop && mSortEnabled) {
                    startDrag(mHitPos, deltaX, deltaY);
                }
                else if (mDragInitMode != ON_DOWN && Math.abs(x2 - x1) > mTouchSlop && mRemoveEnabled)
                {
                    mIsRemoving = true;
                    startDrag(mFlingHitPos, deltaX, deltaY);
                }
            } else if (mFlingHitPos != MISS) {
                if (Math.abs(x2 - x1) > mTouchSlop && mRemoveEnabled) {
                    mIsRemoving = true;
                    startDrag(mFlingHitPos, deltaX, deltaY);
                } else if (Math.abs(y2 - y1) > mTouchSlop) {
                    mCanDrag = false; // if started to scroll the list then
                                      // don't allow sorting nor fling-removing
                }
            }
        }
        // return whatever
        return false;
    }

    @Override
    public void onLongPress(MotionEvent e) {
        // Log.d("mobeta", "lift listener long pressed");
        if (mHitPos != MISS && mDragInitMode == ON_LONG_PRESS) {
            mDslv.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
            startDrag(mHitPos, mCurrX - mItemX, mCurrY - mItemY);
        }
    }

    // complete the OnGestureListener interface
    @Override
    public final boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
        return false;
    }

    // complete the OnGestureListener interface
    @Override
    public boolean onSingleTapUp(MotionEvent ev) {
        if (mRemoveEnabled && mRemoveMode == CLICK_REMOVE) {
            if (mClickRemoveHitPos != MISS) {
                mDslv.removeItem(mClickRemoveHitPos - mDslv.getHeaderViewsCount());
            }
        }
        return true;
    }

    // complete the OnGestureListener interface
    @Override
    public void onShowPress(MotionEvent ev) {
        // do nothing
    }

    private GestureDetector.OnGestureListener mFlingRemoveListener =
            new GestureDetector.SimpleOnGestureListener() {
                @Override
                public final boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,
                        float velocityY) {
                    // Log.d("mobeta", "on fling remove called");
                    if (mRemoveEnabled && mIsRemoving) {
                        int w = mDslv.getWidth();
                        int minPos = w / 5;
                        if (velocityX > mFlingSpeed) {
                            if (mPositionX > -minPos) {
                                mDslv.stopDragWithVelocity(true, velocityX);
                            }
                        } else if (velocityX < -mFlingSpeed) {
                            if (mPositionX < minPos) {
                                mDslv.stopDragWithVelocity(true, velocityX);
                            }
                        }
                        mIsRemoving = false;
                    }
                    return false;
                }
            };

}

@#$
package com.mobeta.android.dslv;

import java.util.ArrayList;

import android.content.Context;
import android.database.Cursor;
import android.util.SparseIntArray;
import android.view.View;
import android.view.ViewGroup;
import android.support.v4.widget.CursorAdapter;


/**
 * A subclass of {@link android.widget.CursorAdapter} that provides
 * reordering of the elements in the Cursor based on completed
 * drag-sort operations. The reordering is a simple mapping of
 * list positions into Cursor positions (the Cursor is unchanged).
 * To persist changes made by drag-sorts, one can retrieve the
 * mapping with the {@link #getCursorPositions()} method, which
 * returns the reordered list of Cursor positions.
 *
 * An instance of this class is passed
 * to {@link DragSortListView#setAdapter(ListAdapter)} and, since
 * this class implements the {@link DragSortListView.DragSortListener}
 * interface, it is automatically set as the DragSortListener for
 * the DragSortListView instance.
 */
public abstract class DragSortCursorAdapter extends CursorAdapter implements DragSortListView.DragSortListener {

    public static final int REMOVED = -1;

    /**
     * Key is ListView position, value is Cursor position
     */
    private SparseIntArray mListMapping = new SparseIntArray();

    private ArrayList<Integer> mRemovedCursorPositions = new ArrayList<Integer>();
    
    public DragSortCursorAdapter(Context context, Cursor c) {
        super(context, c);
    }

    public DragSortCursorAdapter(Context context, Cursor c, boolean autoRequery) {
        super(context, c, autoRequery);
    }

    public DragSortCursorAdapter(Context context, Cursor c, int flags) {
        super(context, c, flags);
    }

    /**
     * Swaps Cursor and clears list-Cursor mapping.
     *
     * @see android.widget.CursorAdapter#swapCursor(android.database.Cursor)
     */
    @Override
    public Cursor swapCursor(Cursor newCursor) {
        Cursor old = super.swapCursor(newCursor);
        resetMappings();
        return old;
    }

    /**
     * Changes Cursor and clears list-Cursor mapping.
     *
     * @see android.widget.CursorAdapter#changeCursor(android.database.Cursor)
     */
    @Override
    public void changeCursor(Cursor cursor) {
        super.changeCursor(cursor);
        resetMappings();
    }

    /**
     * Resets list-cursor mapping.
     */
    public void reset() {
        resetMappings();
        notifyDataSetChanged();
    }

    private void resetMappings() {
        mListMapping.clear();
        mRemovedCursorPositions.clear();
    }

    @Override
    public Object getItem(int position) {
        return super.getItem(mListMapping.get(position, position));
    }

    @Override
    public long getItemId(int position) {
        return super.getItemId(mListMapping.get(position, position));
    }

    @Override
    public View getDropDownView(int position, View convertView, ViewGroup parent) {
        return super.getDropDownView(mListMapping.get(position, position), convertView, parent);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        return super.getView(mListMapping.get(position, position), convertView, parent);
    }

    /**
     * On drop, this updates the mapping between Cursor positions
     * and ListView positions. The Cursor is unchanged. Retrieve
     * the current mapping with {@link getCursorPositions()}.
     *
     * @see DragSortListView.DropListener#drop(int, int)
     */
    @Override
    public void drop(int from, int to) {
        if (from != to) {
            int cursorFrom = mListMapping.get(from, from);

            if (from > to) {
                for (int i = from; i > to; --i) {
                    mListMapping.put(i, mListMapping.get(i - 1, i - 1));
                }
            } else {
                for (int i = from; i < to; ++i) {
                    mListMapping.put(i, mListMapping.get(i + 1, i + 1));
                }
            }
            mListMapping.put(to, cursorFrom);

            cleanMapping();        
            notifyDataSetChanged();
        }
    }

    /**
     * On remove, this updates the mapping between Cursor positions
     * and ListView positions. The Cursor is unchanged. Retrieve
     * the current mapping with {@link getCursorPositions()}.
     *
     * @see DragSortListView.RemoveListener#remove(int)
     */
    @Override
    public void remove(int which) {
        int cursorPos = mListMapping.get(which, which);
        if (!mRemovedCursorPositions.contains(cursorPos)) {
            mRemovedCursorPositions.add(cursorPos);
        }

        int newCount = getCount();
        for (int i = which; i < newCount; ++i) {
            mListMapping.put(i, mListMapping.get(i + 1, i + 1));
        }

        mListMapping.delete(newCount);

        cleanMapping();
        notifyDataSetChanged();
    }

    /**
     * Does nothing. Just completes DragSortListener interface.
     */
    @Override
    public void drag(int from, int to) {
        // do nothing
    }

    /**
     * Remove unnecessary mappings from sparse array.
     */
    private void cleanMapping() {
        ArrayList<Integer> toRemove = new ArrayList<Integer>();

        int size = mListMapping.size();
        for (int i = 0; i < size; ++i) {
            if (mListMapping.keyAt(i) == mListMapping.valueAt(i)) {
                toRemove.add(mListMapping.keyAt(i));
            }
        }

        size = toRemove.size();
        for (int i = 0; i < size; ++i) {
            mListMapping.delete(toRemove.get(i));
        }
    }

    @Override
    public int getCount() {
        return super.getCount() - mRemovedCursorPositions.size();
    }

    /**
     * Get the Cursor position mapped to by the provided list position
     * (given all previously handled drag-sort
     * operations).
     *
     * @param position List position
     *
     * @return The mapped-to Cursor position
     */
    public int getCursorPosition(int position) {
        return mListMapping.get(position, position);
    }

    /**
     * Get the current order of Cursor positions presented by the
     * list.
     */
    public ArrayList<Integer> getCursorPositions() {
        ArrayList<Integer> result = new ArrayList<Integer>();

        for (int i = 0; i < getCount(); ++i) {
            result.add(mListMapping.get(i, i));
        }

        return result;
    }

    /**
     * Get the list position mapped to by the provided Cursor position.
     * If the provided Cursor position has been removed by a drag-sort,
     * this returns {@link #REMOVED}.
     *
     * @param cursorPosition A Cursor position
     * @return The mapped-to list position or REMOVED
     */
    public int getListPosition(int cursorPosition) {
        if (mRemovedCursorPositions.contains(cursorPosition)) {
            return REMOVED;
        }

        int index = mListMapping.indexOfValue(cursorPosition);
        if (index < 0) {
            return cursorPosition;
        } else {
            return mListMapping.keyAt(index);
        }
    }


}

@#$
package com.mobeta.android.dslv;

import android.content.Context;
import android.view.Gravity;
import android.view.View;
import android.view.View.MeasureSpec;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.util.Log;

/**
 * Lightweight ViewGroup that wraps list items obtained from user's
 * ListAdapter. ItemView expects a single child that has a definite
 * height (i.e. the child's layout height is not MATCH_PARENT).
 * The width of
 * ItemView will always match the width of its child (that is,
 * the width MeasureSpec given to ItemView is passed directly
 * to the child, and the ItemView measured width is set to the
 * child's measured width). The height of ItemView can be anything;
 * the 
 * 
 *
 * The purpose of this class is to optimize slide
 * shuffle animations.
 */
public class DragSortItemView extends ViewGroup {

    private int mGravity = Gravity.TOP;

    public DragSortItemView(Context context) {
        super(context);

        // always init with standard ListView layout params
        setLayoutParams(new AbsListView.LayoutParams(
                ViewGroup.LayoutParams.FILL_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT));

        //setClipChildren(true);
    }

    public void setGravity(int gravity) {
        mGravity = gravity;
    }

    public int getGravity() {
        return mGravity;
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        final View child = getChildAt(0);

        if (child == null) {
            return;
        }

        if (mGravity == Gravity.TOP) {
            child.layout(0, 0, getMeasuredWidth(), child.getMeasuredHeight());
        } else {
            child.layout(0, getMeasuredHeight() - child.getMeasuredHeight(), getMeasuredWidth(), getMeasuredHeight());
        }
    }

    /**
     * 
     */
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        
        int height = MeasureSpec.getSize(heightMeasureSpec);
        int width = MeasureSpec.getSize(widthMeasureSpec);

        int heightMode = MeasureSpec.getMode(heightMeasureSpec);

        final View child = getChildAt(0);
        if (child == null) {
            setMeasuredDimension(0, width);
            return;
        }

        if (child.isLayoutRequested()) {
            // Always let child be as tall as it wants.
            measureChild(child, widthMeasureSpec,
                    MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
        }

        if (heightMode == MeasureSpec.UNSPECIFIED) {
            ViewGroup.LayoutParams lp = getLayoutParams();

            if (lp.height > 0) {
                height = lp.height;
            } else {
                height = child.getMeasuredHeight();
            }
        }

        setMeasuredDimension(width, height);
    }

}

@#$
package com.mobeta.android.dslv;

import android.content.Context;
import android.view.Gravity;
import android.view.View;
import android.view.View.MeasureSpec;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.widget.Checkable;
import android.util.Log;

/**
 * Lightweight ViewGroup that wraps list items obtained from user's
 * ListAdapter. ItemView expects a single child that has a definite
 * height (i.e. the child's layout height is not MATCH_PARENT).
 * The width of
 * ItemView will always match the width of its child (that is,
 * the width MeasureSpec given to ItemView is passed directly
 * to the child, and the ItemView measured width is set to the
 * child's measured width). The height of ItemView can be anything;
 * the 
 * 
 *
 * The purpose of this class is to optimize slide
 * shuffle animations.
 */
public class DragSortItemViewCheckable extends DragSortItemView implements Checkable {

    public DragSortItemViewCheckable(Context context) {
        super(context);
    }

    @Override
    public boolean isChecked() {
        View child = getChildAt(0);
        if (child instanceof Checkable)
            return ((Checkable) child).isChecked();
        else
            return false;
    }

    @Override
    public void setChecked(boolean checked) {
        View child = getChildAt(0);
        if (child instanceof Checkable)
            ((Checkable) child).setChecked(checked);
    }

    @Override
    public void toggle() {
        View child = getChildAt(0);
        if (child instanceof Checkable)
            ((Checkable) child).toggle();
    }
}

@#$
/*
 * DragSortListView.
 *
 * A subclass of the Android ListView component that enables drag
 * and drop re-ordering of list items.
 *
 * Copyright 2012 Carl Bauer
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.mobeta.android.dslv;

import android.content.Context;
import android.content.res.TypedArray;
import android.database.DataSetObserver;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Point;
import android.graphics.drawable.Drawable;
import android.os.Environment;
import android.os.SystemClock;
import android.util.AttributeSet;
import android.util.Log;
import android.util.SparseBooleanArray;
import android.util.SparseIntArray;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.widget.BaseAdapter;
import android.widget.Checkable;
import android.widget.ListAdapter;
import android.widget.ListView;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

/**
 * ListView subclass that mediates drag and drop resorting of items.
 * 
 * 
 * @author heycosmo
 *
 */
public class DragSortListView extends ListView {
    
    
    /**
     * The View that floats above the ListView and represents
     * the dragged item.
     */
    private View mFloatView;

    /**
     * The float View location. First based on touch location
     * and given deltaX and deltaY. Then restricted by callback
     * to FloatViewManager.onDragFloatView(). Finally restricted
     * by bounds of DSLV.
     */
    private Point mFloatLoc = new Point();

    private Point mTouchLoc = new Point();

    /**
     * The middle (in the y-direction) of the floating View.
     */
    private int mFloatViewMid;

    /**
     * Flag to make sure float View isn't measured twice
     */
    private boolean mFloatViewOnMeasured = false;

    /**
     * Watch the Adapter for data changes. Cancel a drag if
     * coincident with a change.
     */ 
    private DataSetObserver mObserver;

    /**
     * Transparency for the floating View (XML attribute).
     */
    private float mFloatAlpha = 1.0f;
    private float mCurrFloatAlpha = 1.0f;

    /**
     * While drag-sorting, the current position of the floating
     * View. If dropped, the dragged item will land in this position.
     */
    private int mFloatPos;

    /**
     * The first expanded ListView position that helps represent
     * the drop slot tracking the floating View.
     */
    private int mFirstExpPos;

    /**
     * The second expanded ListView position that helps represent
     * the drop slot tracking the floating View. This can equal
     * mFirstExpPos if there is no slide shuffle occurring; otherwise
     * it is equal to mFirstExpPos + 1.
     */
    private int mSecondExpPos;

    /**
     * Flag set if slide shuffling is enabled.
     */
    private boolean mAnimate = false;

    /**
     * The user dragged from this position.
     */
    private int mSrcPos;

    /**
     * Offset (in x) within the dragged item at which the user
     * picked it up (or first touched down with the digitalis).
     */
    private int mDragDeltaX;

    /**
     * Offset (in y) within the dragged item at which the user
     * picked it up (or first touched down with the digitalis).
     */
    private int mDragDeltaY;


    /**
     * The difference (in x) between screen coordinates and coordinates
     * in this view.
     */
    private int mOffsetX;

    /**
     * The difference (in y) between screen coordinates and coordinates
     * in this view.
     */
    private int mOffsetY;

    /**
     * A listener that receives callbacks whenever the floating View
     * hovers over a new position.
     */
    private DragListener mDragListener;

    /**
     * A listener that receives a callback when the floating View
     * is dropped.
     */
    private DropListener mDropListener;

    /**
     * A listener that receives a callback when the floating View
     * (or more precisely the originally dragged item) is removed
     * by one of the provided gestures.
     */
    private RemoveListener mRemoveListener;

    /**
     * Enable/Disable item dragging
     * 
     * @attr name dslv:drag_enabled
     */
    private boolean mDragEnabled = true;

    /**
     * Drag state enum.
     */
    private final static int IDLE = 0;
    private final static int REMOVING = 1;
    private final static int DROPPING = 2;
    private final static int STOPPED = 3;
    private final static int DRAGGING = 4;

    private int mDragState = IDLE;

    /**
     * Height in pixels to which the originally dragged item
     * is collapsed during a drag-sort. Currently, this value
     * must be greater than zero.
     */
    private int mItemHeightCollapsed = 1;

    /**
     * Height of the floating View. Stored for the purpose of
     * providing the tracking drop slot.
     */
    private int mFloatViewHeight;

    /**
     * Convenience member. See above.
     */
    private int mFloatViewHeightHalf;

    /**
     * Save the given width spec for use in measuring children
     */
    private int mWidthMeasureSpec = 0;

    /**
     * Sample Views ultimately used for calculating the height
     * of ListView items that are off-screen.
     */
    private View[] mSampleViewTypes = new View[1];

    /**
     * Drag-scroll encapsulator!
     */
    private DragScroller mDragScroller;

    /**
     * Determines the start of the upward drag-scroll region
     * at the top of the ListView. Specified by a fraction
     * of the ListView height, thus screen resolution agnostic.
     */
    private float mDragUpScrollStartFrac = 1.0f / 3.0f;

    /**
     * Determines the start of the downward drag-scroll region
     * at the bottom of the ListView. Specified by a fraction
     * of the ListView height, thus screen resolution agnostic.
     */
    private float mDragDownScrollStartFrac = 1.0f / 3.0f;

    /**
     * The following are calculated from the above fracs.
     */
    private int mUpScrollStartY;
    private int mDownScrollStartY;
    private float mDownScrollStartYF;
    private float mUpScrollStartYF;

    /**
     * Calculated from above above and current ListView height.
     */
    private float mDragUpScrollHeight;

    /**
     * Calculated from above above and current ListView height.
     */
    private float mDragDownScrollHeight;

    /**
     * Maximum drag-scroll speed in pixels per ms. Only used with
     * default linear drag-scroll profile.
     */
    private float mMaxScrollSpeed = 0.5f;

    /**
     * Defines the scroll speed during a drag-scroll. User can
     * provide their own; this default is a simple linear profile
     * where scroll speed increases linearly as the floating View
     * nears the top/bottom of the ListView.
     */
    private DragScrollProfile mScrollProfile = new DragScrollProfile() {
        @Override
        public float getSpeed(float w, long t) {
            return mMaxScrollSpeed * w;
        }
    };

    /**
     * Current touch x.
     */
    private int mX;

    /**
     * Current touch y.
     */
    private int mY;

    /**
     * Last touch x.
     */
    private int mLastX;

    /**
     * Last touch y.
     */
    private int mLastY;

    /**
     * The touch y-coord at which drag started
     */
    private int mDragStartY;

    /**
     * Drag flag bit. Floating View can move in the positive
     * x direction.
     */
    public final static int DRAG_POS_X = 0x1;

    /**
     * Drag flag bit. Floating View can move in the negative
     * x direction.
     */
    public final static int DRAG_NEG_X = 0x2;

    /**
     * Drag flag bit. Floating View can move in the positive
     * y direction. This is subtle. What this actually means is
     * that, if enabled, the floating View can be dragged below its starting
     * position. Remove in favor of upper-bounding item position?
     */
    public final static int DRAG_POS_Y = 0x4;

    /**
     * Drag flag bit. Floating View can move in the negative
     * y direction. This is subtle. What this actually means is
     * that the floating View can be dragged above its starting
     * position. Remove in favor of lower-bounding item position?
     */
    public final static int DRAG_NEG_Y = 0x8;

    /**
     * Flags that determine limits on the motion of the
     * floating View. See flags above.
     */
    private int mDragFlags = 0;

    /**
     * Last call to an on*TouchEvent was a call to
     * onInterceptTouchEvent.
     */
    private boolean mLastCallWasIntercept = false;

    /**
     * A touch event is in progress.
     */
    private boolean mInTouchEvent = false;

    /**
     * Let the user customize the floating View.
     */
    private FloatViewManager mFloatViewManager = null;

    /**
     * Given to ListView to cancel its action when a drag-sort
     * begins.
     */
    private MotionEvent mCancelEvent;

    /**
     * Enum telling where to cancel the ListView action when a
     * drag-sort begins
     */
    private static final int NO_CANCEL = 0;
    private static final int ON_TOUCH_EVENT = 1;
    private static final int ON_INTERCEPT_TOUCH_EVENT = 2;

    /**
     * Where to cancel the ListView action when a
     * drag-sort begins
     */ 
    private int mCancelMethod = NO_CANCEL;

    /**
     * Determines when a slide shuffle animation starts. That is,
     * defines how close to the edge of the drop slot the floating
     * View must be to initiate the slide.
     */
    private float mSlideRegionFrac = 0.25f;

    /**
     * Number between 0 and 1 indicating the relative location of
     * a sliding item (only used if drag-sort animations
     * are turned on). Nearly 1 means the item is 
     * at the top of the slide region (nearly full blank item
     * is directly below).
     */
    private float mSlideFrac = 0.0f;

    /**
     * Wraps the user-provided ListAdapter. This is used to wrap each
     * item View given by the user inside another View (currenly
     * a RelativeLayout) which
     * expands and collapses to simulate the item shuffling.
     */
    private AdapterWrapper mAdapterWrapper;

    /**
     * Turn on custom debugger.
     */
    private boolean mTrackDragSort = false;

    /**
     * Debugging class.
     */
    private DragSortTracker mDragSortTracker;

    /**
     * Needed for adjusting item heights from within layoutChildren
     */
    private boolean mBlockLayoutRequests = false;

    /**
     * Set to true when a down event happens during drag sort;
     * for example, when drag finish animations are
     * playing.
     */
    private boolean mIgnoreTouchEvent = false;

    /**
     * Caches DragSortItemView child heights. Sometimes DSLV has to
     * know the height of an offscreen item. Since ListView virtualizes
     * these, DSLV must get the item from the ListAdapter to obtain
     * its height. That process can be expensive, but often the same
     * offscreen item will be requested many times in a row. Once an
     * offscreen item height is calculated, we cache it in this guy.
     * Actually, we cache the height of the child of the
     * DragSortItemView since the item height changes often during a
     * drag-sort.
     */
    private static final int sCacheSize = 3;
    private HeightCache mChildHeightCache = new HeightCache(sCacheSize);

    private RemoveAnimator mRemoveAnimator;

    private LiftAnimator mLiftAnimator;

    private DropAnimator mDropAnimator;

    private boolean mUseRemoveVelocity;
    private float mRemoveVelocityX = 0;

    public DragSortListView(Context context, AttributeSet attrs) {
        super(context, attrs);

        int defaultDuration = 150;
        int removeAnimDuration = defaultDuration; // ms
        int dropAnimDuration = defaultDuration; // ms

        if (attrs != null) {
            TypedArray a = getContext().obtainStyledAttributes(attrs,
                    R.styleable.DragSortListView, 0, 0);

            mItemHeightCollapsed = Math.max(1, a.getDimensionPixelSize(
                    R.styleable.DragSortListView_collapsed_height, 1));

            mTrackDragSort = a.getBoolean(
                    R.styleable.DragSortListView_track_drag_sort, false);

            if (mTrackDragSort) {
                mDragSortTracker = new DragSortTracker();
            }

            // alpha between 0 and 255, 0=transparent, 255=opaque
            mFloatAlpha = a.getFloat(R.styleable.DragSortListView_float_alpha, mFloatAlpha);
            mCurrFloatAlpha = mFloatAlpha;

            mDragEnabled = a.getBoolean(R.styleable.DragSortListView_drag_enabled, mDragEnabled);

            mSlideRegionFrac = Math.max(0.0f,
                    Math.min(1.0f, 1.0f - a.getFloat(
                            R.styleable.DragSortListView_slide_shuffle_speed,
                            0.75f)));

            mAnimate = mSlideRegionFrac > 0.0f;

            float frac = a.getFloat(
                    R.styleable.DragSortListView_drag_scroll_start,
                    mDragUpScrollStartFrac);

            setDragScrollStart(frac);

            mMaxScrollSpeed = a.getFloat(
                    R.styleable.DragSortListView_max_drag_scroll_speed,
                    mMaxScrollSpeed);

            removeAnimDuration = a.getInt(
                    R.styleable.DragSortListView_remove_animation_duration,
                    removeAnimDuration);

            dropAnimDuration = a.getInt(
                    R.styleable.DragSortListView_drop_animation_duration,
                    dropAnimDuration);

            boolean useDefault = a.getBoolean(
                    R.styleable.DragSortListView_use_default_controller,
                    true);

            if (useDefault) {
                boolean removeEnabled = a.getBoolean(
                        R.styleable.DragSortListView_remove_enabled,
                        false);
                int removeMode = a.getInt(
                        R.styleable.DragSortListView_remove_mode,
                        DragSortController.FLING_REMOVE);
                boolean sortEnabled = a.getBoolean(
                        R.styleable.DragSortListView_sort_enabled,
                        true);
                int dragInitMode = a.getInt(
                        R.styleable.DragSortListView_drag_start_mode,
                        DragSortController.ON_DOWN);
                int dragHandleId = a.getResourceId(
                        R.styleable.DragSortListView_drag_handle_id,
                        0);
                int flingHandleId = a.getResourceId(
                        R.styleable.DragSortListView_fling_handle_id,
                        0);
                int clickRemoveId = a.getResourceId(
                        R.styleable.DragSortListView_click_remove_id,
                        0);
                int bgColor = a.getColor(
                        R.styleable.DragSortListView_float_background_color,
                        Color.BLACK);

                DragSortController controller = new DragSortController(
                        this, dragHandleId, dragInitMode, removeMode,
                        clickRemoveId, flingHandleId);
                controller.setRemoveEnabled(removeEnabled);
                controller.setSortEnabled(sortEnabled);
                controller.setBackgroundColor(bgColor);

                mFloatViewManager = controller;
                setOnTouchListener(controller);
            }

            a.recycle();
        }

        mDragScroller = new DragScroller();

        float smoothness = 0.5f;
        if (removeAnimDuration > 0) {
            mRemoveAnimator = new RemoveAnimator(smoothness, removeAnimDuration);
        }
        // mLiftAnimator = new LiftAnimator(smoothness, 100);
        if (dropAnimDuration > 0) {
            mDropAnimator = new DropAnimator(smoothness, dropAnimDuration);
        }

        mCancelEvent = MotionEvent.obtain(0, 0, MotionEvent.ACTION_CANCEL, 0f, 0f, 0f, 0f, 0, 0f,
                0f, 0, 0);

        // construct the dataset observer
        mObserver = new DataSetObserver() {
            private void cancel() {
                if (mDragState == DRAGGING) {
                    cancelDrag();
                }
            }

            @Override
            public void onChanged() {
                cancel();
            }

            @Override
            public void onInvalidated() {
                cancel();
            }
        };
    }

    /**
     * Usually called from a FloatViewManager. The float alpha
     * will be reset to the xml-defined value every time a drag
     * is stopped.
     */
    public void setFloatAlpha(float alpha) {
        mCurrFloatAlpha = alpha;
    }

    public float getFloatAlpha() {
        return mCurrFloatAlpha;
    }

    /**
     * Set maximum drag scroll speed in positions/second. Only applies
     * if using default ScrollSpeedProfile.
     * 
     * @param max Maximum scroll speed.
     */
    public void setMaxScrollSpeed(float max) {
        mMaxScrollSpeed = max;
    }

    /**
     * For each DragSortListView Listener interface implemented by
     * <code>adapter</code>, this method calls the appropriate
     * set*Listener method with <code>adapter</code> as the argument.
     * 
     * @param adapter The ListAdapter providing data to back
     * DragSortListView.
     *
     * @see android.widget.ListView#setAdapter(android.widget.ListAdapter)
     */
    @Override
    public void setAdapter(ListAdapter adapter) {
        if (adapter != null) {
            mAdapterWrapper = new AdapterWrapper(adapter);
            adapter.registerDataSetObserver(mObserver);

            if (adapter instanceof DropListener) {
                setDropListener((DropListener) adapter);
            }
            if (adapter instanceof DragListener) {
                setDragListener((DragListener) adapter);
            }
            if (adapter instanceof RemoveListener) {
                setRemoveListener((RemoveListener) adapter);
            }
        } else {
            mAdapterWrapper = null;
        }

        super.setAdapter(mAdapterWrapper);
    }

    /**
     * As opposed to {@link ListView#getAdapter()}, which returns
     * a heavily wrapped ListAdapter (DragSortListView wraps the
     * input ListAdapter {\emph and} ListView wraps the wrapped one).
     *
     * @return The ListAdapter set as the argument of {@link setAdapter()}
     */
    public ListAdapter getInputAdapter() {
        if (mAdapterWrapper == null) {
            return null;
        } else {
            return mAdapterWrapper.getAdapter();
        }
    }

    private class AdapterWrapper extends BaseAdapter {
        private ListAdapter mAdapter;

        public AdapterWrapper(ListAdapter adapter) {
            super();
            mAdapter = adapter;
            
            mAdapter.registerDataSetObserver(new DataSetObserver() {
                public void onChanged() {
                    notifyDataSetChanged();
                }

                public void onInvalidated() {
                    notifyDataSetInvalidated();
                }
            });
        }

        public ListAdapter getAdapter() {
            return mAdapter;
        }

        @Override
        public long getItemId(int position) {
            return mAdapter.getItemId(position);
        }

        @Override
        public Object getItem(int position) {
            return mAdapter.getItem(position);
        }

        @Override
        public int getCount() {
            return mAdapter.getCount();
        }

        @Override
        public boolean areAllItemsEnabled() {
            return mAdapter.areAllItemsEnabled();
        }

        @Override
        public boolean isEnabled(int position) {
            return mAdapter.isEnabled(position);
        }
        
        @Override
        public int getItemViewType(int position) {
            return mAdapter.getItemViewType(position);
        }

        @Override
        public int getViewTypeCount() {
            return mAdapter.getViewTypeCount();
        }
        
        @Override
        public boolean hasStableIds() {
            return mAdapter.hasStableIds();
        }
        
        @Override
        public boolean isEmpty() {
            return mAdapter.isEmpty();
        }


        @Override
        public View getView(int position, View convertView, ViewGroup parent) {

            DragSortItemView v;
            View child;
            // Log.d("mobeta",
            // "getView: position="+position+" convertView="+convertView);
            if (convertView != null) {
                v = (DragSortItemView) convertView;
                View oldChild = v.getChildAt(0);

                child = mAdapter.getView(position, oldChild, DragSortListView.this);
                if (child != oldChild) {
                    // shouldn't get here if user is reusing convertViews
                    // properly
                    if (oldChild != null) {
                        v.removeViewAt(0);
                    }
                    v.addView(child);
                }
            } else {
                child = mAdapter.getView(position, null, DragSortListView.this);
                if (child instanceof Checkable) {
                    v = new DragSortItemViewCheckable(getContext());
                } else {
                    v = new DragSortItemView(getContext());
                }
                v.setLayoutParams(new AbsListView.LayoutParams(
                        ViewGroup.LayoutParams.FILL_PARENT,
                        ViewGroup.LayoutParams.WRAP_CONTENT));
                v.addView(child);
            }

            // Set the correct item height given drag state; passed
            // View needs to be measured if measurement is required.
            adjustItem(position + getHeaderViewsCount(), v, true);

            return v;
        }
    }

    private void drawDivider(int expPosition, Canvas canvas) {

        final Drawable divider = getDivider();
        final int dividerHeight = getDividerHeight();
        // Log.d("mobeta", "div="+divider+" divH="+dividerHeight);

        if (divider != null && dividerHeight != 0) {
            final ViewGroup expItem = (ViewGroup) getChildAt(expPosition
                    - getFirstVisiblePosition());
            if (expItem != null) {
                final int l = getPaddingLeft();
                final int r = getWidth() - getPaddingRight();
                final int t;
                final int b;

                final int childHeight = expItem.getChildAt(0).getHeight();

                if (expPosition > mSrcPos) {
                    t = expItem.getTop() + childHeight;
                    b = t + dividerHeight;
                } else {
                    b = expItem.getBottom() - childHeight;
                    t = b - dividerHeight;
                }
                // Log.d("mobeta", "l="+l+" t="+t+" r="+r+" b="+b);

                // Have to clip to support ColorDrawable on <= Gingerbread
                canvas.save();
                canvas.clipRect(l, t, r, b);
                divider.setBounds(l, t, r, b);
                divider.draw(canvas);
                canvas.restore();
            }
        }
    }

    @Override
    protected void dispatchDraw(Canvas canvas) {
        super.dispatchDraw(canvas);

        if (mDragState != IDLE) {
            // draw the divider over the expanded item
            if (mFirstExpPos != mSrcPos) {
                drawDivider(mFirstExpPos, canvas);
            }
            if (mSecondExpPos != mFirstExpPos && mSecondExpPos != mSrcPos) {
                drawDivider(mSecondExpPos, canvas);
            }
        }

        if (mFloatView != null) {
            // draw the float view over everything
            final int w = mFloatView.getWidth();
            final int h = mFloatView.getHeight();

            int x = mFloatLoc.x;

            int width = getWidth();
            if (x < 0)
                x = -x;
            float alphaMod;
            if (x < width) {
                alphaMod = ((float) (width - x)) / ((float) width);
                alphaMod *= alphaMod;
            } else {
                alphaMod = 0;
            }

            final int alpha = (int) (255f * mCurrFloatAlpha * alphaMod);

            canvas.save();
            // Log.d("mobeta", "clip rect bounds: " + canvas.getClipBounds());
            canvas.translate(mFloatLoc.x, mFloatLoc.y);
            canvas.clipRect(0, 0, w, h);

            // Log.d("mobeta", "clip rect bounds: " + canvas.getClipBounds());
            canvas.saveLayerAlpha(0, 0, w, h, alpha, Canvas.ALL_SAVE_FLAG);
            mFloatView.draw(canvas);
            canvas.restore();
            canvas.restore();
        }
    }

    private int getItemHeight(int position) {
        View v = getChildAt(position - getFirstVisiblePosition());

        if (v != null) {
            // item is onscreen, just get the height of the View
            return v.getHeight();
        } else {
            // item is offscreen. get child height and calculate
            // item height based on current shuffle state
            return calcItemHeight(position, getChildHeight(position));
        }
    }

    private void printPosData() {
        Log.d("mobeta", "mSrcPos=" + mSrcPos + " mFirstExpPos=" + mFirstExpPos + " mSecondExpPos="
                + mSecondExpPos);
    }

    private class HeightCache {

        private SparseIntArray mMap;
        private ArrayList<Integer> mOrder;
        private int mMaxSize;

        public HeightCache(int size) {
            mMap = new SparseIntArray(size);
            mOrder = new ArrayList<Integer>(size);
            mMaxSize = size;
        }

        /**
         * Add item height at position if doesn't already exist.
         */
        public void add(int position, int height) {
            int currHeight = mMap.get(position, -1);
            if (currHeight != height) {
                if (currHeight == -1) {
                    if (mMap.size() == mMaxSize) {
                        // remove oldest entry
                        mMap.delete(mOrder.remove(0));
                    }
                } else {
                    // move position to newest slot
                    mOrder.remove((Integer) position);
                }
                mMap.put(position, height);
                mOrder.add(position);
            }
        }

        public int get(int position) {
            return mMap.get(position, -1);
        }

        public void clear() {
            mMap.clear();
            mOrder.clear();
        }

    }

    /**
     * Get the shuffle edge for item at position when top of
     * item is at y-coord top. Assumes that current item heights
     * are consistent with current float view location and
     * thus expanded positions and slide fraction. i.e. Should not be
     * called between update of expanded positions/slide fraction
     * and layoutChildren.
     *
     * @param position 
     * @param top
     * @param height Height of item at position. If -1, this function
     * calculates this height.
     *
     * @return Shuffle line between position-1 and position (for
     * the given view of the list; that is, for when top of item at
     * position has y-coord of given `top`). If
     * floating View (treated as horizontal line) is dropped
     * immediately above this line, it lands in position-1. If
     * dropped immediately below this line, it lands in position.
     */
    private int getShuffleEdge(int position, int top) {

        final int numHeaders = getHeaderViewsCount();
        final int numFooters = getFooterViewsCount();

        // shuffle edges are defined between items that can be
        // dragged; there are N-1 of them if there are N draggable
        // items.

        if (position <= numHeaders || (position >= getCount() - numFooters)) {
            return top;
        }

        int divHeight = getDividerHeight();

        int edge;

        int maxBlankHeight = mFloatViewHeight - mItemHeightCollapsed;
        int childHeight = getChildHeight(position);
        int itemHeight = getItemHeight(position);

        // first calculate top of item given that floating View is
        // centered over src position
        int otop = top;
        if (mSecondExpPos <= mSrcPos) {
            // items are expanded on and/or above the source position

            if (position == mSecondExpPos && mFirstExpPos != mSecondExpPos) {
                if (position == mSrcPos) {
                    otop = top + itemHeight - mFloatViewHeight;
                } else {
                    int blankHeight = itemHeight - childHeight;
                    otop = top + blankHeight - maxBlankHeight;
                }
            } else if (position > mSecondExpPos && position <= mSrcPos) {
                otop = top - maxBlankHeight;
            }

        } else {
            // items are expanded on and/or below the source position

            if (position > mSrcPos && position <= mFirstExpPos) {
                otop = top + maxBlankHeight;
            } else if (position == mSecondExpPos && mFirstExpPos != mSecondExpPos) {
                int blankHeight = itemHeight - childHeight;
                otop = top + blankHeight;
            }
        }

        // otop is set
        if (position <= mSrcPos) {
            edge = otop + (mFloatViewHeight - divHeight - getChildHeight(position - 1)) / 2;
        } else {
            edge = otop + (childHeight - divHeight - mFloatViewHeight) / 2;
        }

        return edge;
    }

    private boolean updatePositions() {

        final int first = getFirstVisiblePosition();
        int startPos = mFirstExpPos;
        View startView = getChildAt(startPos - first);

        if (startView == null) {
            startPos = first + getChildCount() / 2;
            startView = getChildAt(startPos - first);
        }
        int startTop = startView.getTop();

        int itemHeight = startView.getHeight();

        int edge = getShuffleEdge(startPos, startTop);
        int lastEdge = edge;

        int divHeight = getDividerHeight();

        // Log.d("mobeta", "float mid="+mFloatViewMid);

        int itemPos = startPos;
        int itemTop = startTop;
        if (mFloatViewMid < edge) {
            // scanning up for float position
            // Log.d("mobeta", "    edge="+edge);
            while (itemPos >= 0) {
                itemPos--;
                itemHeight = getItemHeight(itemPos);

                if (itemPos == 0) {
                    edge = itemTop - divHeight - itemHeight;
                    break;
                }

                itemTop -= itemHeight + divHeight;
                edge = getShuffleEdge(itemPos, itemTop);
                // Log.d("mobeta", "    edge="+edge);

                if (mFloatViewMid >= edge) {
                    break;
                }

                lastEdge = edge;
            }
        } else {
            // scanning down for float position
            // Log.d("mobeta", "    edge="+edge);
            final int count = getCount();
            while (itemPos < count) {
                if (itemPos == count - 1) {
                    edge = itemTop + divHeight + itemHeight;
                    break;
                }

                itemTop += divHeight + itemHeight;
                itemHeight = getItemHeight(itemPos + 1);
                edge = getShuffleEdge(itemPos + 1, itemTop);
                // Log.d("mobeta", "    edge="+edge);

                // test for hit
                if (mFloatViewMid < edge) {
                    break;
                }

                lastEdge = edge;
                itemPos++;
            }
        }

        final int numHeaders = getHeaderViewsCount();
        final int numFooters = getFooterViewsCount();

        boolean updated = false;

        int oldFirstExpPos = mFirstExpPos;
        int oldSecondExpPos = mSecondExpPos;
        float oldSlideFrac = mSlideFrac;

        if (mAnimate) {
            int edgeToEdge = Math.abs(edge - lastEdge);

            int edgeTop, edgeBottom;
            if (mFloatViewMid < edge) {
                edgeBottom = edge;
                edgeTop = lastEdge;
            } else {
                edgeTop = edge;
                edgeBottom = lastEdge;
            }
            // Log.d("mobeta", "edgeTop="+edgeTop+" edgeBot="+edgeBottom);

            int slideRgnHeight = (int) (0.5f * mSlideRegionFrac * edgeToEdge);
            float slideRgnHeightF = (float) slideRgnHeight;
            int slideEdgeTop = edgeTop + slideRgnHeight;
            int slideEdgeBottom = edgeBottom - slideRgnHeight;

            // Three regions
            if (mFloatViewMid < slideEdgeTop) {
                mFirstExpPos = itemPos - 1;
                mSecondExpPos = itemPos;
                mSlideFrac = 0.5f * ((float) (slideEdgeTop - mFloatViewMid)) / slideRgnHeightF;
                // Log.d("mobeta",
                // "firstExp="+mFirstExpPos+" secExp="+mSecondExpPos+" slideFrac="+mSlideFrac);
            } else if (mFloatViewMid < slideEdgeBottom) {
                mFirstExpPos = itemPos;
                mSecondExpPos = itemPos;
            } else {
                mFirstExpPos = itemPos;
                mSecondExpPos = itemPos + 1;
                mSlideFrac = 0.5f * (1.0f + ((float) (edgeBottom - mFloatViewMid))
                        / slideRgnHeightF);
                // Log.d("mobeta",
                // "firstExp="+mFirstExpPos+" secExp="+mSecondExpPos+" slideFrac="+mSlideFrac);
            }

        } else {
            mFirstExpPos = itemPos;
            mSecondExpPos = itemPos;
        }

        // correct for headers and footers
        if (mFirstExpPos < numHeaders) {
            itemPos = numHeaders;
            mFirstExpPos = itemPos;
            mSecondExpPos = itemPos;
        } else if (mSecondExpPos >= getCount() - numFooters) {
            itemPos = getCount() - numFooters - 1;
            mFirstExpPos = itemPos;
            mSecondExpPos = itemPos;
        }

        if (mFirstExpPos != oldFirstExpPos || mSecondExpPos != oldSecondExpPos
                || mSlideFrac != oldSlideFrac) {
            updated = true;
        }

        if (itemPos != mFloatPos) {
            if (mDragListener != null) {
                mDragListener.drag(mFloatPos - numHeaders, itemPos - numHeaders);
            }

            mFloatPos = itemPos;
            updated = true;
        }

        return updated;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (mTrackDragSort) {
            mDragSortTracker.appendState();
        }
    }

    private class SmoothAnimator implements Runnable {
        protected long mStartTime;

        private float mDurationF;

        private float mAlpha;
        private float mA, mB, mC, mD;

        private boolean mCanceled;

        public SmoothAnimator(float smoothness, int duration) {
            mAlpha = smoothness;
            mDurationF = (float) duration;
            mA = mD = 1f / (2f * mAlpha * (1f - mAlpha));
            mB = mAlpha / (2f * (mAlpha - 1f));
            mC = 1f / (1f - mAlpha);
        }

        public float transform(float frac) {
            if (frac < mAlpha) {
                return mA * frac * frac;
            } else if (frac < 1f - mAlpha) {
                return mB + mC * frac;
            } else {
                return 1f - mD * (frac - 1f) * (frac - 1f);
            }
        }

        public void start() {
            mStartTime = SystemClock.uptimeMillis();
            mCanceled = false;
            onStart();
            post(this);
        }

        public void cancel() {
            mCanceled = true;
        }

        public void onStart() {
            // stub
        }

        public void onUpdate(float frac, float smoothFrac) {
            // stub
        }

        public void onStop() {
            // stub
        }

        @Override
        public void run() {
            if (mCanceled) {
                return;
            }

            float fraction = ((float) (SystemClock.uptimeMillis() - mStartTime)) / mDurationF;

            if (fraction >= 1f) {
                onUpdate(1f, 1f);
                onStop();
            } else {
                onUpdate(fraction, transform(fraction));
                post(this);
            }
        }
    }

    /**
     * Centers floating View under touch point.
     */
    private class LiftAnimator extends SmoothAnimator {

        private float mInitDragDeltaY;
        private float mFinalDragDeltaY;

        public LiftAnimator(float smoothness, int duration) {
            super(smoothness, duration);
        }

        @Override
        public void onStart() {
            mInitDragDeltaY = mDragDeltaY;
            mFinalDragDeltaY = mFloatViewHeightHalf;
        }

        @Override
        public void onUpdate(float frac, float smoothFrac) {
            if (mDragState != DRAGGING) {
                cancel();
            } else {
                mDragDeltaY = (int) (smoothFrac * mFinalDragDeltaY + (1f - smoothFrac)
                        * mInitDragDeltaY);
                mFloatLoc.y = mY - mDragDeltaY;
                doDragFloatView(true);
            }
        }
    }

    /**
     * Centers floating View over drop slot before destroying.
     */
    private class DropAnimator extends SmoothAnimator {

        private int mDropPos;
        private int srcPos;
        private float mInitDeltaY;
        private float mInitDeltaX;

        public DropAnimator(float smoothness, int duration) {
            super(smoothness, duration);
        }

        @Override
        public void onStart() {
            mDropPos = mFloatPos;
            srcPos = mSrcPos;
            mDragState = DROPPING;
            mInitDeltaY = mFloatLoc.y - getTargetY();
            mInitDeltaX = mFloatLoc.x - getPaddingLeft();
        }

        private int getTargetY() {
            final int first = getFirstVisiblePosition();
            final int otherAdjust = (mItemHeightCollapsed + getDividerHeight()) / 2;
            View v = getChildAt(mDropPos - first);
            int targetY = -1;
            if (v != null) {
                if (mDropPos == srcPos) {
                    targetY = v.getTop();
                } else if (mDropPos < srcPos) {
                    // expanded down
                    targetY = v.getTop() - otherAdjust;
                } else {
                    // expanded up
                    targetY = v.getBottom() + otherAdjust - mFloatViewHeight;
                }
            } else {
                // drop position is not on screen?? no animation
                cancel();
            }

            return targetY;
        }

        @Override
        public void onUpdate(float frac, float smoothFrac) {
            final int targetY = getTargetY();
            final int targetX = getPaddingLeft();
            final float deltaY = mFloatLoc.y - targetY;
            final float deltaX = mFloatLoc.x - targetX;
            final float f = 1f - smoothFrac;
            if (f < Math.abs(deltaY / mInitDeltaY) || f < Math.abs(deltaX / mInitDeltaX)) {
                mFloatLoc.y = targetY + (int) (mInitDeltaY * f);
                mFloatLoc.x = getPaddingLeft() + (int) (mInitDeltaX * f);
                doDragFloatView(true);
            }
        }

        @Override
        public void onStop() {
            dropFloatView();
        }

    }

    /**
     * Collapses expanded items.
     */
    private class RemoveAnimator extends SmoothAnimator {

        private float mFloatLocX;
        private float mFirstStartBlank;
        private float mSecondStartBlank;

        private int mFirstChildHeight = -1;
        private int mSecondChildHeight = -1;

        private int mFirstPos;
        private int mSecondPos;
        private int srcPos;

        public RemoveAnimator(float smoothness, int duration) {
            super(smoothness, duration);
        }

        @Override
        public void onStart() {
            mFirstChildHeight = -1;
            mSecondChildHeight = -1;
            mFirstPos = mFirstExpPos;
            mSecondPos = mSecondExpPos;
            srcPos = mSrcPos;
            mDragState = REMOVING;

            mFloatLocX = mFloatLoc.x;
            if (mUseRemoveVelocity) {
                float minVelocity = 2f * getWidth();
                if (mRemoveVelocityX == 0) {
                    mRemoveVelocityX = (mFloatLocX < 0 ? -1 : 1) * minVelocity;
                } else {
                    minVelocity *= 2;
                    if (mRemoveVelocityX < 0 && mRemoveVelocityX > -minVelocity)
                        mRemoveVelocityX = -minVelocity;
                    else if (mRemoveVelocityX > 0 && mRemoveVelocityX < minVelocity)
                        mRemoveVelocityX = minVelocity;
                }
            } else {
                destroyFloatView();
            }
        }

        @Override
        public void onUpdate(float frac, float smoothFrac) {
            float f = 1f - smoothFrac;

            final int firstVis = getFirstVisiblePosition();
            View item = getChildAt(mFirstPos - firstVis);
            ViewGroup.LayoutParams lp;
            int blank;

            if (mUseRemoveVelocity) {
                float dt = (float) (SystemClock.uptimeMillis() - mStartTime) / 1000;
                if (dt == 0)
                    return;
                float dx = mRemoveVelocityX * dt;
                int w = getWidth();
                mRemoveVelocityX += (mRemoveVelocityX > 0 ? 1 : -1) * dt * w;
                mFloatLocX += dx;
                mFloatLoc.x = (int) mFloatLocX;
                if (mFloatLocX < w && mFloatLocX > -w) {
                    mStartTime = SystemClock.uptimeMillis();
                    doDragFloatView(true);
                    return;
                }
            }

            if (item != null) {
                if (mFirstChildHeight == -1) {
                    mFirstChildHeight = getChildHeight(mFirstPos, item, false);
                    mFirstStartBlank = (float) (item.getHeight() - mFirstChildHeight);
                }
                blank = Math.max((int) (f * mFirstStartBlank), 1);
                lp = item.getLayoutParams();
                lp.height = mFirstChildHeight + blank;
                item.setLayoutParams(lp);
            }
            if (mSecondPos != mFirstPos) {
                item = getChildAt(mSecondPos - firstVis);
                if (item != null) {
                    if (mSecondChildHeight == -1) {
                        mSecondChildHeight = getChildHeight(mSecondPos, item, false);
                        mSecondStartBlank = (float) (item.getHeight() - mSecondChildHeight);
                    }
                    blank = Math.max((int) (f * mSecondStartBlank), 1);
                    lp = item.getLayoutParams();
                    lp.height = mSecondChildHeight + blank;
                    item.setLayoutParams(lp);
                }
            }
        }

        @Override
        public void onStop() {
            doRemoveItem();
        }
    }

    public void removeItem(int which) {

        mUseRemoveVelocity = false;
        removeItem(which, 0);
    }

    /**
     * Removes an item from the list and animates the removal.
     *
     * @param which Position to remove (NOTE: headers/footers ignored!
     * this is a position in your input ListAdapter).
     * @param velocityX 
     */
    public void removeItem(int which, float velocityX) {
        if (mDragState == IDLE || mDragState == DRAGGING) {

            if (mDragState == IDLE) {
                // called from outside drag-sort
                mSrcPos = getHeaderViewsCount() + which;
                mFirstExpPos = mSrcPos;
                mSecondExpPos = mSrcPos;
                mFloatPos = mSrcPos;
                View v = getChildAt(mSrcPos - getFirstVisiblePosition());
                if (v != null) {
                    v.setVisibility(View.INVISIBLE);
                }
            }

            mDragState = REMOVING;
            mRemoveVelocityX = velocityX;

            if (mInTouchEvent) {
                switch (mCancelMethod) {
                    case ON_TOUCH_EVENT:
                        super.onTouchEvent(mCancelEvent);
                        break;
                    case ON_INTERCEPT_TOUCH_EVENT:
                        super.onInterceptTouchEvent(mCancelEvent);
                        break;
                }
            }

            if (mRemoveAnimator != null) {
                mRemoveAnimator.start();
            } else {
                doRemoveItem(which);
            }
        }
    }

    /**
     * Move an item, bypassing the drag-sort process. Simply calls
     * through to {@link DropListener#drop(int, int)}.
     * 
     * @param from Position to move (NOTE: headers/footers ignored!
     * this is a position in your input ListAdapter).
     * @param to Target position (NOTE: headers/footers ignored!
     * this is a position in your input ListAdapter).
     */
    public void moveItem(int from, int to) {
        if (mDropListener != null) {
            final int count = getInputAdapter().getCount();
            if (from >= 0 && from < count && to >= 0 && to < count) {
                mDropListener.drop(from, to);
            }
        }
    }

    /**
     * Cancel a drag. Calls {@link #stopDrag(boolean, boolean)} with
     * <code>true</code> as the first argument.
     */
    public void cancelDrag() {
        if (mDragState == DRAGGING) {
            mDragScroller.stopScrolling(true);
            destroyFloatView();
            clearPositions();
            adjustAllItems();

            if (mInTouchEvent) {
                mDragState = STOPPED;
            } else {
                mDragState = IDLE;
            }
        }
    }

    private void clearPositions() {
        mSrcPos = -1;
        mFirstExpPos = -1;
        mSecondExpPos = -1;
        mFloatPos = -1;
    }

    private void dropFloatView() {
        // must set to avoid cancelDrag being called from the
        // DataSetObserver
        mDragState = DROPPING;

        if (mDropListener != null && mFloatPos >= 0 && mFloatPos < getCount()) {
            final int numHeaders = getHeaderViewsCount();
            mDropListener.drop(mSrcPos - numHeaders, mFloatPos - numHeaders);
        }

        destroyFloatView();

        adjustOnReorder();
        clearPositions();
        adjustAllItems();

        // now the drag is done
        if (mInTouchEvent) {
            mDragState = STOPPED;
        } else {
            mDragState = IDLE;
        }
    }

    private void doRemoveItem() {
        doRemoveItem(mSrcPos - getHeaderViewsCount());
    }

    /**
     * Removes dragged item from the list. Calls RemoveListener.
     */
    private void doRemoveItem(int which) {
        // must set to avoid cancelDrag being called from the
        // DataSetObserver
        mDragState = REMOVING;

        // end it
        if (mRemoveListener != null) {
            mRemoveListener.remove(which);
        }

        destroyFloatView();

        adjustOnReorder();
        clearPositions();

        // now the drag is done
        if (mInTouchEvent) {
            mDragState = STOPPED;
        } else {
            mDragState = IDLE;
        }
    }

    private void adjustOnReorder() {
        final int firstPos = getFirstVisiblePosition();
        // Log.d("mobeta", "first="+firstPos+" src="+mSrcPos);
        if (mSrcPos < firstPos) {
            // collapsed src item is off screen;
            // adjust the scroll after item heights have been fixed
            View v = getChildAt(0);
            int top = 0;
            if (v != null) {
                top = v.getTop();
            }
            // Log.d("mobeta", "top="+top+" fvh="+mFloatViewHeight);
            setSelectionFromTop(firstPos - 1, top - getPaddingTop());
        }
    }

    /**
     * Stop a drag in progress. Pass <code>true</code> if you would
     * like to remove the dragged item from the list.
     *
     * @param remove Remove the dragged item from the list. Calls
     * a registered RemoveListener, if one exists. Otherwise, calls
     * the DropListener, if one exists.
     *
     * @return True if the stop was successful. False if there is
     * no floating View.
     */
    public boolean stopDrag(boolean remove) {
        mUseRemoveVelocity = false;
        return stopDrag(remove, 0);
    }

    public boolean stopDragWithVelocity(boolean remove, float velocityX) {

        mUseRemoveVelocity = true;
        return stopDrag(remove, velocityX);
    }

    public boolean stopDrag(boolean remove, float velocityX) {
        if (mFloatView != null) {
            mDragScroller.stopScrolling(true);

            if (remove) {
                removeItem(mSrcPos - getHeaderViewsCount(), velocityX);
            } else {
                if (mDropAnimator != null) {
                    mDropAnimator.start();
                } else {
                    dropFloatView();
                }
            }

            if (mTrackDragSort) {
                mDragSortTracker.stopTracking();
            }

            return true;
        } else {
            // stop failed
            return false;
        }
    }

    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        if (mIgnoreTouchEvent) {
            mIgnoreTouchEvent = false;
            return false;
        }

        if (!mDragEnabled) {
            return super.onTouchEvent(ev);
        }

        boolean more = false;

        boolean lastCallWasIntercept = mLastCallWasIntercept;
        mLastCallWasIntercept = false;

        if (!lastCallWasIntercept) {
            saveTouchCoords(ev);
        }

        // if (mFloatView != null) {
        if (mDragState == DRAGGING) {
            onDragTouchEvent(ev);
            more = true; // give us more!
        } else {
            // what if float view is null b/c we dropped in middle
            // of drag touch event?

            // if (mDragState != STOPPED) {
            if (mDragState == IDLE) {
                if (super.onTouchEvent(ev)) {
                    more = true;
                }
            }

            int action = ev.getAction() & MotionEvent.ACTION_MASK;

            switch (action) {
                case MotionEvent.ACTION_CANCEL:
                case MotionEvent.ACTION_UP:
                    doActionUpOrCancel();
                    break;
                default:
                    if (more) {
                        mCancelMethod = ON_TOUCH_EVENT;
                    }
            }
        }

        return more;
    }

    private void doActionUpOrCancel() {
        mCancelMethod = NO_CANCEL;
        mInTouchEvent = false;
        if (mDragState == STOPPED) {
            mDragState = IDLE;
        }
        mCurrFloatAlpha = mFloatAlpha;
        mListViewIntercepted = false;
        mChildHeightCache.clear();
    }

    private void saveTouchCoords(MotionEvent ev) {
        int action = ev.getAction() & MotionEvent.ACTION_MASK;
        if (action != MotionEvent.ACTION_DOWN) {
            mLastX = mX;
            mLastY = mY;
        }
        mX = (int) ev.getX();
        mY = (int) ev.getY();
        if (action == MotionEvent.ACTION_DOWN) {
            mLastX = mX;
            mLastY = mY;
        }
        mOffsetX = (int) ev.getRawX() - mX;
        mOffsetY = (int) ev.getRawY() - mY;
    }

    public boolean listViewIntercepted() {
        return mListViewIntercepted;
    }

    private boolean mListViewIntercepted = false;

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if (!mDragEnabled) {
            return super.onInterceptTouchEvent(ev);
        }

        saveTouchCoords(ev);
        mLastCallWasIntercept = true;

        int action = ev.getAction() & MotionEvent.ACTION_MASK;

        if (action == MotionEvent.ACTION_DOWN) {
            if (mDragState != IDLE) {
                // intercept and ignore
                mIgnoreTouchEvent = true;
                return true;
            }
            mInTouchEvent = true;
        }

        boolean intercept = false;

        // the following deals with calls to super.onInterceptTouchEvent
        if (mFloatView != null) {
            // super's touch event canceled in startDrag
            intercept = true;
        } else {
            if (super.onInterceptTouchEvent(ev)) {
                mListViewIntercepted = true;
                intercept = true;
            }

            switch (action) {
                case MotionEvent.ACTION_CANCEL:
                case MotionEvent.ACTION_UP:
                    doActionUpOrCancel();
                    break;
                default:
                    if (intercept) {
                        mCancelMethod = ON_TOUCH_EVENT;
                    } else {
                        mCancelMethod = ON_INTERCEPT_TOUCH_EVENT;
                    }
            }
        }

        if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
            mInTouchEvent = false;
        }

        return intercept;
    }

    /**
     * Set the width of each drag scroll region by specifying
     * a fraction of the ListView height.
     *
     * @param heightFraction Fraction of ListView height. Capped at
     * 0.5f.
     * 
     */
    public void setDragScrollStart(float heightFraction) {
        setDragScrollStarts(heightFraction, heightFraction);
    }

    /**
     * Set the width of each drag scroll region by specifying
     * a fraction of the ListView height.
     *
     * @param upperFrac Fraction of ListView height for up-scroll bound.
     * Capped at 0.5f.
     * @param lowerFrac Fraction of ListView height for down-scroll bound.
     * Capped at 0.5f.
     * 
     */
    public void setDragScrollStarts(float upperFrac, float lowerFrac) {
        if (lowerFrac > 0.5f) {
            mDragDownScrollStartFrac = 0.5f;
        } else {
            mDragDownScrollStartFrac = lowerFrac;
        }

        if (upperFrac > 0.5f) {
            mDragUpScrollStartFrac = 0.5f;
        } else {
            mDragUpScrollStartFrac = upperFrac;
        }

        if (getHeight() != 0) {
            updateScrollStarts();
        }
    }

    private void continueDrag(int x, int y) {

        // proposed position
        mFloatLoc.x = x - mDragDeltaX;
        mFloatLoc.y = y - mDragDeltaY;

        doDragFloatView(true);

        int minY = Math.min(y, mFloatViewMid + mFloatViewHeightHalf);
        int maxY = Math.max(y, mFloatViewMid - mFloatViewHeightHalf);

        // get the current scroll direction
        int currentScrollDir = mDragScroller.getScrollDir();

        if (minY > mLastY && minY > mDownScrollStartY && currentScrollDir != DragScroller.DOWN) {
            // dragged down, it is below the down scroll start and it is not
            // scrolling up

            if (currentScrollDir != DragScroller.STOP) {
                // moved directly from up scroll to down scroll
                mDragScroller.stopScrolling(true);
            }

            // start scrolling down
            mDragScroller.startScrolling(DragScroller.DOWN);
        } else if (maxY < mLastY && maxY < mUpScrollStartY && currentScrollDir != DragScroller.UP) {
            // dragged up, it is above the up scroll start and it is not
            // scrolling up

            if (currentScrollDir != DragScroller.STOP) {
                // moved directly from down scroll to up scroll
                mDragScroller.stopScrolling(true);
            }

            // start scrolling up
            mDragScroller.startScrolling(DragScroller.UP);
        }
        else if (maxY >= mUpScrollStartY && minY <= mDownScrollStartY
                && mDragScroller.isScrolling()) {
            // not in the upper nor in the lower drag-scroll regions but it is
            // still scrolling

            mDragScroller.stopScrolling(true);
        }
    }

    private void updateScrollStarts() {
        final int padTop = getPaddingTop();
        final int listHeight = getHeight() - padTop - getPaddingBottom();
        float heightF = (float) listHeight;

        mUpScrollStartYF = padTop + mDragUpScrollStartFrac * heightF;
        mDownScrollStartYF = padTop + (1.0f - mDragDownScrollStartFrac) * heightF;

        mUpScrollStartY = (int) mUpScrollStartYF;
        mDownScrollStartY = (int) mDownScrollStartYF;

        mDragUpScrollHeight = mUpScrollStartYF - padTop;
        mDragDownScrollHeight = padTop + listHeight - mDownScrollStartYF;
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        updateScrollStarts();
    }

    private void adjustAllItems() {
        final int first = getFirstVisiblePosition();
        final int last = getLastVisiblePosition();

        int begin = Math.max(0, getHeaderViewsCount() - first);
        int end = Math.min(last - first, getCount() - 1 - getFooterViewsCount() - first);

        for (int i = begin; i <= end; ++i) {
            View v = getChildAt(i);
            if (v != null) {
                adjustItem(first + i, v, false);
            }
        }
    }

    private void adjustItem(int position) {
        View v = getChildAt(position - getFirstVisiblePosition());

        if (v != null) {
            adjustItem(position, v, false);
        }
    }

    /**
     * Sets layout param height, gravity, and visibility  on
     * wrapped item.
     */
    private void adjustItem(int position, View v, boolean invalidChildHeight) {

        // Adjust item height
        ViewGroup.LayoutParams lp = v.getLayoutParams();
        int height;
        if (position != mSrcPos && position != mFirstExpPos && position != mSecondExpPos) {
            height = ViewGroup.LayoutParams.WRAP_CONTENT;
        } else {
            height = calcItemHeight(position, v, invalidChildHeight);
        }

        if (height != lp.height) {
            lp.height = height;
            v.setLayoutParams(lp);
        }

        // Adjust item gravity
        if (position == mFirstExpPos || position == mSecondExpPos) {
            if (position < mSrcPos) {
                ((DragSortItemView) v).setGravity(Gravity.BOTTOM);
            } else if (position > mSrcPos) {
                ((DragSortItemView) v).setGravity(Gravity.TOP);
            }
        }

        // Finally adjust item visibility

        int oldVis = v.getVisibility();
        int vis = View.VISIBLE;

        if (position == mSrcPos && mFloatView != null) {
            vis = View.INVISIBLE;
        }

        if (vis != oldVis) {
            v.setVisibility(vis);
        }
    }

    private int getChildHeight(int position) {
        if (position == mSrcPos) {
            return 0;
        }

        View v = getChildAt(position - getFirstVisiblePosition());

        if (v != null) {
            // item is onscreen, therefore child height is valid,
            // hence the "true"
            return getChildHeight(position, v, false);
        } else {
            // item is offscreen
            // first check cache for child height at this position
            int childHeight = mChildHeightCache.get(position);
            if (childHeight != -1) {
                // Log.d("mobeta", "found child height in cache!");
                return childHeight;
            }

            final ListAdapter adapter = getAdapter();
            int type = adapter.getItemViewType(position);

            // There might be a better place for checking for the following
            final int typeCount = adapter.getViewTypeCount();
            if (typeCount != mSampleViewTypes.length) {
                mSampleViewTypes = new View[typeCount];
            }

            if (type >= 0) {
                if (mSampleViewTypes[type] == null) {
                    v = adapter.getView(position, null, this);
                    mSampleViewTypes[type] = v;
                } else {
                    v = adapter.getView(position, mSampleViewTypes[type], this);
                }
            } else {
                // type is HEADER_OR_FOOTER or IGNORE
                v = adapter.getView(position, null, this);
            }

            // current child height is invalid, hence "true" below
            childHeight = getChildHeight(position, v, true);

            // cache it because this could have been expensive
            mChildHeightCache.add(position, childHeight);

            return childHeight;
        }
    }

    private int getChildHeight(int position, View item, boolean invalidChildHeight) {
        if (position == mSrcPos) {
            return 0;
        }

        View child;
        if (position < getHeaderViewsCount() || position >= getCount() - getFooterViewsCount()) {
            child = item;
        } else {
            child = ((ViewGroup) item).getChildAt(0);
        }

        ViewGroup.LayoutParams lp = child.getLayoutParams();

        if (lp != null) {
            if (lp.height > 0) {
                return lp.height;
            }
        }

        int childHeight = child.getHeight();

        if (childHeight == 0 || invalidChildHeight) {
            measureItem(child);
            childHeight = child.getMeasuredHeight();
        }

        return childHeight;
    }

    private int calcItemHeight(int position, View item, boolean invalidChildHeight) {
        return calcItemHeight(position, getChildHeight(position, item, invalidChildHeight));
    }

    private int calcItemHeight(int position, int childHeight) {

        int divHeight = getDividerHeight();

        boolean isSliding = mAnimate && mFirstExpPos != mSecondExpPos;
        int maxNonSrcBlankHeight = mFloatViewHeight - mItemHeightCollapsed;
        int slideHeight = (int) (mSlideFrac * maxNonSrcBlankHeight);

        int height;

        if (position == mSrcPos) {
            if (mSrcPos == mFirstExpPos) {
                if (isSliding) {
                    height = slideHeight + mItemHeightCollapsed;
                } else {
                    height = mFloatViewHeight;
                }
            } else if (mSrcPos == mSecondExpPos) {
                // if gets here, we know an item is sliding
                height = mFloatViewHeight - slideHeight;
            } else {
                height = mItemHeightCollapsed;
            }
        } else if (position == mFirstExpPos) {
            if (isSliding) {
                height = childHeight + slideHeight;
            } else {
                height = childHeight + maxNonSrcBlankHeight;
            }
        } else if (position == mSecondExpPos) {
            // we know an item is sliding (b/c 2ndPos != 1stPos)
            height = childHeight + maxNonSrcBlankHeight - slideHeight;
        } else {
            height = childHeight;
        }

        return height;
    }

    @Override
    public void requestLayout() {
        if (!mBlockLayoutRequests) {
            super.requestLayout();
        }
    }

    private int adjustScroll(int movePos, View moveItem, int oldFirstExpPos, int oldSecondExpPos) {
        int adjust = 0;

        final int childHeight = getChildHeight(movePos);

        int moveHeightBefore = moveItem.getHeight();
        int moveHeightAfter = calcItemHeight(movePos, childHeight);

        int moveBlankBefore = moveHeightBefore;
        int moveBlankAfter = moveHeightAfter;
        if (movePos != mSrcPos) {
            moveBlankBefore -= childHeight;
            moveBlankAfter -= childHeight;
        }

        int maxBlank = mFloatViewHeight;
        if (mSrcPos != mFirstExpPos && mSrcPos != mSecondExpPos) {
            maxBlank -= mItemHeightCollapsed;
        }

        if (movePos <= oldFirstExpPos) {
            if (movePos > mFirstExpPos) {
                adjust += maxBlank - moveBlankAfter;
            }
        } else if (movePos == oldSecondExpPos) {
            if (movePos <= mFirstExpPos) {
                adjust += moveBlankBefore - maxBlank;
            } else if (movePos == mSecondExpPos) {
                adjust += moveHeightBefore - moveHeightAfter;
            } else {
                adjust += moveBlankBefore;
            }
        } else {
            if (movePos <= mFirstExpPos) {
                adjust -= maxBlank;
            } else if (movePos == mSecondExpPos) {
                adjust -= moveBlankAfter;
            }
        }

        return adjust;
    }

    private void measureItem(View item) {
        ViewGroup.LayoutParams lp = item.getLayoutParams();
        if (lp == null) {
            lp = new AbsListView.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
            item.setLayoutParams(lp);
        }
        int wspec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, getListPaddingLeft()
                + getListPaddingRight(), lp.width);
        int hspec;
        if (lp.height > 0) {
            hspec = MeasureSpec.makeMeasureSpec(lp.height, MeasureSpec.EXACTLY);
        } else {
            hspec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
        }
        item.measure(wspec, hspec);
    }

    private void measureFloatView() {
        if (mFloatView != null) {
            measureItem(mFloatView);
            mFloatViewHeight = mFloatView.getMeasuredHeight();
            mFloatViewHeightHalf = mFloatViewHeight / 2;
        }
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        // Log.d("mobeta", "onMeasure called");
        if (mFloatView != null) {
            if (mFloatView.isLayoutRequested()) {
                measureFloatView();
            }
            mFloatViewOnMeasured = true; // set to false after layout
        }
        mWidthMeasureSpec = widthMeasureSpec;
    }

    @Override
    protected void layoutChildren() {
        super.layoutChildren();

        if (mFloatView != null) {
            if (mFloatView.isLayoutRequested() && !mFloatViewOnMeasured) {
                // Have to measure here when usual android measure
                // pass is skipped. This happens during a drag-sort
                // when layoutChildren is called directly.
                measureFloatView();
            }
            mFloatView.layout(0, 0, mFloatView.getMeasuredWidth(), mFloatView.getMeasuredHeight());
            mFloatViewOnMeasured = false;
        }
    }

    protected boolean onDragTouchEvent(MotionEvent ev) {
        // we are in a drag
        int action = ev.getAction() & MotionEvent.ACTION_MASK;

        switch (ev.getAction() & MotionEvent.ACTION_MASK) {
            case MotionEvent.ACTION_CANCEL:
                if (mDragState == DRAGGING) {
                    cancelDrag();
                }
                doActionUpOrCancel();
                break;
            case MotionEvent.ACTION_UP:
                // Log.d("mobeta", "calling stopDrag from onDragTouchEvent");
                if (mDragState == DRAGGING) {
                    stopDrag(false);
                }
                doActionUpOrCancel();
                break;
            case MotionEvent.ACTION_MOVE:
                continueDrag((int) ev.getX(), (int) ev.getY());
                break;
        }

        return true;
    }

    private boolean mFloatViewInvalidated = false;

    private void invalidateFloatView() {
        mFloatViewInvalidated = true;
    }

    /**
     * Start a drag of item at <code>position</code> using the
     * registered FloatViewManager. Calls through
     * to {@link #startDrag(int,View,int,int,int)} after obtaining
     * the floating View from the FloatViewManager.
     *
     * @param position Item to drag.
     * @param dragFlags Flags that restrict some movements of the
     * floating View. For example, set <code>dragFlags |= 
     * ~{@link #DRAG_NEG_X}</code> to allow dragging the floating
     * View in all directions except off the screen to the left.
     * @param deltaX Offset in x of the touch coordinate from the
     * left edge of the floating View (i.e. touch-x minus float View
     * left).
     * @param deltaY Offset in y of the touch coordinate from the
     * top edge of the floating View (i.e. touch-y minus float View
     * top).
     *
     * @return True if the drag was started, false otherwise. This
     * <code>startDrag</code> will fail if we are not currently in
     * a touch event, there is no registered FloatViewManager,
     * or the FloatViewManager returns a null View.
     */
    public boolean startDrag(int position, int dragFlags, int deltaX, int deltaY) {
        if (!mInTouchEvent || mFloatViewManager == null) {
            return false;
        }

        View v = mFloatViewManager.onCreateFloatView(position);

        if (v == null) {
            return false;
        } else {
            return startDrag(position, v, dragFlags, deltaX, deltaY);
        }

    }

    /**
     * Start a drag of item at <code>position</code> without using
     * a FloatViewManager.
     *
     * @param position Item to drag.
     * @param floatView Floating View.
     * @param dragFlags Flags that restrict some movements of the
     * floating View. For example, set <code>dragFlags |= 
     * ~{@link #DRAG_NEG_X}</code> to allow dragging the floating
     * View in all directions except off the screen to the left.
     * @param deltaX Offset in x of the touch coordinate from the
     * left edge of the floating View (i.e. touch-x minus float View
     * left).
     * @param deltaY Offset in y of the touch coordinate from the
     * top edge of the floating View (i.e. touch-y minus float View
     * top).
     *
     * @return True if the drag was started, false otherwise. This
     * <code>startDrag</code> will fail if we are not currently in
     * a touch event, <code>floatView</code> is null, or there is
     * a drag in progress.
     */
    public boolean startDrag(int position, View floatView, int dragFlags, int deltaX, int deltaY) {
        if (mDragState != IDLE || !mInTouchEvent || mFloatView != null || floatView == null
                || !mDragEnabled) {
            return false;
        }

        if (getParent() != null) {
            getParent().requestDisallowInterceptTouchEvent(true);
        }

        int pos = position + getHeaderViewsCount();
        mFirstExpPos = pos;
        mSecondExpPos = pos;
        mSrcPos = pos;
        mFloatPos = pos;

        // mDragState = dragType;
        mDragState = DRAGGING;
        mDragFlags = 0;
        mDragFlags |= dragFlags;

        mFloatView = floatView;
        measureFloatView(); // sets mFloatViewHeight

        mDragDeltaX = deltaX;
        mDragDeltaY = deltaY;
        mDragStartY = mY;

        // updateFloatView(mX - mDragDeltaX, mY - mDragDeltaY);
        mFloatLoc.x = mX - mDragDeltaX;
        mFloatLoc.y = mY - mDragDeltaY;

        // set src item invisible
        final View srcItem = getChildAt(mSrcPos - getFirstVisiblePosition());

        if (srcItem != null) {
            srcItem.setVisibility(View.INVISIBLE);
        }

        if (mTrackDragSort) {
            mDragSortTracker.startTracking();
        }

        // once float view is created, events are no longer passed
        // to ListView
        switch (mCancelMethod) {
            case ON_TOUCH_EVENT:
                super.onTouchEvent(mCancelEvent);
                break;
            case ON_INTERCEPT_TOUCH_EVENT:
                super.onInterceptTouchEvent(mCancelEvent);
                break;
        }

        requestLayout();

        if (mLiftAnimator != null) {
            mLiftAnimator.start();
        }

        return true;
    }

    private void doDragFloatView(boolean forceInvalidate) {
        int movePos = getFirstVisiblePosition() + getChildCount() / 2;
        View moveItem = getChildAt(getChildCount() / 2);

        if (moveItem == null) {
            return;
        }

        doDragFloatView(movePos, moveItem, forceInvalidate);
    }

    private void doDragFloatView(int movePos, View moveItem, boolean forceInvalidate) {
        mBlockLayoutRequests = true;

        updateFloatView();

        int oldFirstExpPos = mFirstExpPos;
        int oldSecondExpPos = mSecondExpPos;

        boolean updated = updatePositions();

        if (updated) {
            adjustAllItems();
            int scroll = adjustScroll(movePos, moveItem, oldFirstExpPos, oldSecondExpPos);
            // Log.d("mobeta", "  adjust scroll="+scroll);

            setSelectionFromTop(movePos, moveItem.getTop() + scroll - getPaddingTop());
            layoutChildren();
        }

        if (updated || forceInvalidate) {
            invalidate();
        }

        mBlockLayoutRequests = false;
    }

    /**
     * Sets float View location based on suggested values and
     * constraints set in mDragFlags.
     */
    private void updateFloatView() {

        if (mFloatViewManager != null) {
            mTouchLoc.set(mX, mY);
            mFloatViewManager.onDragFloatView(mFloatView, mFloatLoc, mTouchLoc);
        }

        final int floatX = mFloatLoc.x;
        final int floatY = mFloatLoc.y;

        // restrict x motion
        int padLeft = getPaddingLeft();
        if ((mDragFlags & DRAG_POS_X) == 0 && floatX > padLeft) {
            mFloatLoc.x = padLeft;
        } else if ((mDragFlags & DRAG_NEG_X) == 0 && floatX < padLeft) {
            mFloatLoc.x = padLeft;
        }

        // keep floating view from going past bottom of last header view
        final int numHeaders = getHeaderViewsCount();
        final int numFooters = getFooterViewsCount();
        final int firstPos = getFirstVisiblePosition();
        final int lastPos = getLastVisiblePosition();

        // Log.d("mobeta",
        // "nHead="+numHeaders+" nFoot="+numFooters+" first="+firstPos+" last="+lastPos);
        int topLimit = getPaddingTop();
        if (firstPos < numHeaders) {
            topLimit = getChildAt(numHeaders - firstPos - 1).getBottom();
        }
        if ((mDragFlags & DRAG_NEG_Y) == 0) {
            if (firstPos <= mSrcPos) {
                topLimit = Math.max(getChildAt(mSrcPos - firstPos).getTop(), topLimit);
            }
        }
        // bottom limit is top of first footer View or
        // bottom of last item in list
        int bottomLimit = getHeight() - getPaddingBottom();
        if (lastPos >= getCount() - numFooters - 1) {
            bottomLimit = getChildAt(getCount() - numFooters - 1 - firstPos).getBottom();
        }
        if ((mDragFlags & DRAG_POS_Y) == 0) {
            if (lastPos >= mSrcPos) {
                bottomLimit = Math.min(getChildAt(mSrcPos - firstPos).getBottom(), bottomLimit);
            }
        }

        // Log.d("mobeta", "dragView top=" + (y - mDragDeltaY));
        // Log.d("mobeta", "limit=" + limit);
        // Log.d("mobeta", "mDragDeltaY=" + mDragDeltaY);

        if (floatY < topLimit) {
            mFloatLoc.y = topLimit;
        } else if (floatY + mFloatViewHeight > bottomLimit) {
            mFloatLoc.y = bottomLimit - mFloatViewHeight;
        }

        // get y-midpoint of floating view (constrained to ListView bounds)
        mFloatViewMid = mFloatLoc.y + mFloatViewHeightHalf;
    }

    private void destroyFloatView() {
        if (mFloatView != null) {
            mFloatView.setVisibility(GONE);
            if (mFloatViewManager != null) {
                mFloatViewManager.onDestroyFloatView(mFloatView);
            }
            mFloatView = null;
            invalidate();
        }
    }

    /**
     * Interface for customization of the floating View appearance
     * and dragging behavior. Implement
     * your own and pass it to {@link #setFloatViewManager}. If
     * your own is not passed, the default {@link SimpleFloatViewManager}
     * implementation is used.
     */
    public interface FloatViewManager {
        /**
         * Return the floating View for item at <code>position</code>.
         * DragSortListView will measure and layout this View for you,
         * so feel free to just inflate it. You can help DSLV by
         * setting some {@link ViewGroup.LayoutParams} on this View;
         * otherwise it will set some for you (with a width of FILL_PARENT
         * and a height of WRAP_CONTENT).
         *
         * @param position Position of item to drag (NOTE:
         * <code>position</code> excludes header Views; thus, if you
         * want to call {@link ListView#getChildAt(int)}, you will need
         * to add {@link ListView#getHeaderViewsCount()} to the index).
         *
         * @return The View you wish to display as the floating View.
         */
        public View onCreateFloatView(int position);

        /**
         * Called whenever the floating View is dragged. Float View
         * properties can be changed here. Also, the upcoming location
         * of the float View can be altered by setting
         * <code>location.x</code> and <code>location.y</code>.
         *
         * @param floatView The floating View.
         * @param location The location (top-left; relative to DSLV
         * top-left) at which the float
         * View would like to appear, given the current touch location
         * and the offset provided in {@link DragSortListView#startDrag}.
         * @param touch The current touch location (relative to DSLV
         * top-left).
         * @param pendingScroll 
         */
        public void onDragFloatView(View floatView, Point location, Point touch);

        /**
         * Called when the float View is dropped; lets you perform
         * any necessary cleanup. The internal DSLV floating View
         * reference is set to null immediately after this is called.
         *
         * @param floatView The floating View passed to
         * {@link #onCreateFloatView(int)}.
         */
        public void onDestroyFloatView(View floatView);
    }

    public void setFloatViewManager(FloatViewManager manager) {
        mFloatViewManager = manager;
    }

    public void setDragListener(DragListener l) {
        mDragListener = l;
    }

    /**
     * Allows for easy toggling between a DragSortListView
     * and a regular old ListView. If enabled, items are
     * draggable, where the drag init mode determines how
     * items are lifted (see {@link setDragInitMode(int)}).
     * If disabled, items cannot be dragged.
     *
     * @param enabled Set <code>true</code> to enable list
     * item dragging
     */
    public void setDragEnabled(boolean enabled) {
        mDragEnabled = enabled;
    }

    public boolean isDragEnabled() {
        return mDragEnabled;
    }

    /**
     * This better reorder your ListAdapter! DragSortListView does not do this
     * for you; doesn't make sense to. Make sure
     * {@link BaseAdapter#notifyDataSetChanged()} or something like it is called
     * in your implementation. Furthermore, if you have a choiceMode other than
     * none and the ListAdapter does not return true for
     * {@link ListAdapter#hasStableIds()}, you will need to call
     * {@link #moveCheckState(int, int)} to move the check boxes along with the
     * list items.
     * 
     * @param l
     */
    public void setDropListener(DropListener l) {
        mDropListener = l;
    }

    /**
     * Probably a no-brainer, but make sure that your remove listener
     * calls {@link BaseAdapter#notifyDataSetChanged()} or something like it.
     * When an item removal occurs, DragSortListView
     * relies on a redraw of all the items to recover invisible views
     * and such. Strictly speaking, if you remove something, your dataset
     * has changed...
     * 
     * @param l
     */
    public void setRemoveListener(RemoveListener l) {
        mRemoveListener = l;
    }

    public interface DragListener {
        public void drag(int from, int to);
    }

    /**
     * Your implementation of this has to reorder your ListAdapter! 
     * Make sure to call
     * {@link BaseAdapter#notifyDataSetChanged()} or something like it
     * in your implementation.
     * 
     * @author heycosmo
     *
     */
    public interface DropListener {
        public void drop(int from, int to);
    }

    /**
     * Make sure to call
     * {@link BaseAdapter#notifyDataSetChanged()} or something like it
     * in your implementation.
     * 
     * @author heycosmo
     *
     */
    public interface RemoveListener {
        public void remove(int which);
    }

    public interface DragSortListener extends DropListener, DragListener, RemoveListener {
    }

    public void setDragSortListener(DragSortListener l) {
        setDropListener(l);
        setDragListener(l);
        setRemoveListener(l);
    }

    /**
     * Completely custom scroll speed profile. Default increases linearly
     * with position and is constant in time. Create your own by implementing
     * {@link DragSortListView.DragScrollProfile}.
     * 
     * @param ssp
     */
    public void setDragScrollProfile(DragScrollProfile ssp) {
        if (ssp != null) {
            mScrollProfile = ssp;
        }
    }

    /**
     * Use this to move the check state of an item from one position to another
     * in a drop operation. If you have a choiceMode which is not none, this
     * method must be called when the order of items changes in an underlying
     * adapter which does not have stable IDs (see
     * {@link ListAdapter#hasStableIds()}). This is because without IDs, the
     * ListView has no way of knowing which items have moved where, and cannot
     * update the check state accordingly.
     * <p>
     * A word of warning about a "feature" in Android that you may run into when
     * dealing with movable list items: for an adapter that <em>does</em> have
     * stable IDs, ListView will attempt to locate each item based on its ID and
     * move the check state from the item's old position to the new position 
     * which is all fine and good (and removes the need for calling this
     * function), except for the half-baked approach. Apparently to save time in
     * the naive algorithm used, ListView will only search for an ID in the
     * close neighborhood of the old position. If the user moves an item too far
     * (specifically, more than 20 rows away), ListView will give up and just
     * force the item to be unchecked. So if there is a reasonable chance that
     * the user will move items more than 20 rows away from the original
     * position, you may wish to use an adapter with unstable IDs and call this
     * method manually instead.
     * 
     * @param from
     * @param to
     */
    public void moveCheckState(int from, int to) {
        // This method runs in O(n log n) time (n being the number of list
        // items). The bottleneck is the call to AbsListView.setItemChecked,
        // which is O(log n) because of the binary search involved in calling
        // SparseBooleanArray.put().
        //
        // To improve on the average time, we minimize the number of calls to
        // setItemChecked by only calling it for items that actually have a
        // changed state. This is achieved by building a list containing the
        // start and end of the "runs" of checked items, and then moving the
        // runs. Note that moving an item from A to B is essentially a rotation
        // of the range of items in [A, B]. Let's say we have
        // . . U V X Y Z . .
        // and move U after Z. This is equivalent to a rotation one step to the
        // left within the range you are moving across:
        // . . V X Y Z U . .
        //
        // So, to perform the move we enumerate all the runs within the move
        // range, then rotate each run one step to the left or right (depending
        // on move direction). For example, in the list:
        // X X . X X X . X
        // we have two runs. One begins at the last item of the list and wraps
        // around to the beginning, ending at position 1. The second begins at
        // position 3 and ends at position 5. To rotate a run, regardless of
        // length, we only need to set a check mark at one end of the run, and
        // clear a check mark at the other end:
        // X . X X X . X X
        SparseBooleanArray cip = getCheckedItemPositions();
        int rangeStart = from;
        int rangeEnd = to;
        if (to < from) {
            rangeStart = to;
            rangeEnd = from;
        }
        rangeEnd += 1;

        int[] runStart = new int[cip.size()];
        int[] runEnd = new int[cip.size()];
        int runCount = buildRunList(cip, rangeStart, rangeEnd, runStart, runEnd);
        if (runCount == 1 && (runStart[0] == runEnd[0])) {
            // Special case where all items are checked, we can never set any
            // item to false like we do below.
            return;
        }

        if (from < to) {
            for (int i = 0; i != runCount; i++) {
                setItemChecked(rotate(runStart[i], -1, rangeStart, rangeEnd), true);
                setItemChecked(rotate(runEnd[i], -1, rangeStart, rangeEnd), false);
            }

        } else {
            for (int i = 0; i != runCount; i++) {
                setItemChecked(runStart[i], false);
                setItemChecked(runEnd[i], true);
            }
        }
    }

    /**
     * Use this when an item has been deleted, to move the check state of all
     * following items up one step. If you have a choiceMode which is not none,
     * this method must be called when the order of items changes in an
     * underlying adapter which does not have stable IDs (see
     * {@link ListAdapter#hasStableIds()}). This is because without IDs, the
     * ListView has no way of knowing which items have moved where, and cannot
     * update the check state accordingly.
     * 
     * See also further comments on {@link #moveCheckState(int, int)}.
     * 
     * @param position
     */
    public void removeCheckState(int position) {
        SparseBooleanArray cip = getCheckedItemPositions();

        if (cip.size() == 0)
            return;
        int[] runStart = new int[cip.size()];
        int[] runEnd = new int[cip.size()];
        int rangeStart = position;
        int rangeEnd = cip.keyAt(cip.size() - 1) + 1;
        int runCount = buildRunList(cip, rangeStart, rangeEnd, runStart, runEnd);
        for (int i = 0; i != runCount; i++) {
            if (!(runStart[i] == position || (runEnd[i] < runStart[i] && runEnd[i] > position))) {
                // Only set a new check mark in front of this run if it does
                // not contain the deleted position. If it does, we only need
                // to make it one check mark shorter at the end.
                setItemChecked(rotate(runStart[i], -1, rangeStart, rangeEnd), true);
            }
            setItemChecked(rotate(runEnd[i], -1, rangeStart, rangeEnd), false);
        }
    }

    private static int buildRunList(SparseBooleanArray cip, int rangeStart,
            int rangeEnd, int[] runStart, int[] runEnd) {
        int runCount = 0;

        int i = findFirstSetIndex(cip, rangeStart, rangeEnd);
        if (i == -1)
            return 0;

        int position = cip.keyAt(i);
        int currentRunStart = position;
        int currentRunEnd = currentRunStart + 1;
        for (i++; i < cip.size() && (position = cip.keyAt(i)) < rangeEnd; i++) {
            if (!cip.valueAt(i)) // not checked => not interesting
                continue;
            if (position == currentRunEnd) {
                currentRunEnd++;
            } else {
                runStart[runCount] = currentRunStart;
                runEnd[runCount] = currentRunEnd;
                runCount++;
                currentRunStart = position;
                currentRunEnd = position + 1;
            }
        }

        if (currentRunEnd == rangeEnd) {
            // rangeStart and rangeEnd are equivalent positions so to be
            // consistent we translate them to the same integer value. That way
            // we can check whether a run covers the entire range by just
            // checking if the start equals the end position.
            currentRunEnd = rangeStart;
        }
        runStart[runCount] = currentRunStart;
        runEnd[runCount] = currentRunEnd;
        runCount++;

        if (runCount > 1) {
            if (runStart[0] == rangeStart && runEnd[runCount - 1] == rangeStart) {
                // The last run ends at the end of the range, and the first run
                // starts at the beginning of the range. So they are actually
                // part of the same run, except they wrap around the end of the
                // range. To avoid adjacent runs, we need to merge them.
                runStart[0] = runStart[runCount - 1];
                runCount--;
            }
        }
        return runCount;
    }

    private static int rotate(int value, int offset, int lowerBound, int upperBound) {
        int windowSize = upperBound - lowerBound;

        value += offset;
        if (value < lowerBound) {
            value += windowSize;
        } else if (value >= upperBound) {
            value -= windowSize;
        }
        return value;
    }

    private static int findFirstSetIndex(SparseBooleanArray sba, int rangeStart, int rangeEnd) {
        int size = sba.size();
        int i = insertionIndexForKey(sba, rangeStart);
        while (i < size && sba.keyAt(i) < rangeEnd && !sba.valueAt(i))
            i++;
        if (i == size || sba.keyAt(i) >= rangeEnd)
            return -1;
        return i;
    }

    private static int insertionIndexForKey(SparseBooleanArray sba, int key) {
        int low = 0;
        int high = sba.size();
        while (high - low > 0) {
            int middle = (low + high) >> 1;
            if (sba.keyAt(middle) < key)
                low = middle + 1;
            else
                high = middle;
        }
        return low;
    }

    /**
     * Interface for controlling
     * scroll speed as a function of touch position and time. Use
     * {@link DragSortListView#setDragScrollProfile(DragScrollProfile)} to
     * set custom profile.
     * 
     * @author heycosmo
     *
     */
    public interface DragScrollProfile {
        /**
         * Return a scroll speed in pixels/millisecond. Always return a
         * positive number.
         * 
         * @param w Normalized position in scroll region (i.e. w \in [0,1]).
         * Small w typically means slow scrolling.
         * @param t Time (in milliseconds) since start of scroll (handy if you
         * want scroll acceleration).
         * @return Scroll speed at position w and time t in pixels/ms.
         */
        float getSpeed(float w, long t);
    }

    private class DragScroller implements Runnable {

        private boolean mAbort;

        private long mPrevTime;
        private long mCurrTime;

        private int dy;
        private float dt;
        private long tStart;
        private int scrollDir;

        public final static int STOP = -1;
        public final static int UP = 0;
        public final static int DOWN = 1;

        private float mScrollSpeed; // pixels per ms

        private boolean mScrolling = false;

        private int mLastHeader;
        private int mFirstFooter;

        public boolean isScrolling() {
            return mScrolling;
        }

        public int getScrollDir() {
            return mScrolling ? scrollDir : STOP;
        }

        public DragScroller() {
        }

        public void startScrolling(int dir) {
            if (!mScrolling) {
                // Debug.startMethodTracing("dslv-scroll");
                mAbort = false;
                mScrolling = true;
                tStart = SystemClock.uptimeMillis();
                mPrevTime = tStart;
                scrollDir = dir;
                post(this);
            }
        }

        public void stopScrolling(boolean now) {
            if (now) {
                DragSortListView.this.removeCallbacks(this);
                mScrolling = false;
            } else {
                mAbort = true;
            }

            // Debug.stopMethodTracing();
        }

        @Override
        public void run() {
            if (mAbort) {
                mScrolling = false;
                return;
            }

            // Log.d("mobeta", "scroll");

            final int first = getFirstVisiblePosition();
            final int last = getLastVisiblePosition();
            final int count = getCount();
            final int padTop = getPaddingTop();
            final int listHeight = getHeight() - padTop - getPaddingBottom();

            int minY = Math.min(mY, mFloatViewMid + mFloatViewHeightHalf);
            int maxY = Math.max(mY, mFloatViewMid - mFloatViewHeightHalf);

            if (scrollDir == UP) {
                View v = getChildAt(0);
                // Log.d("mobeta", "vtop="+v.getTop()+" padtop="+padTop);
                if (v == null) {
                    mScrolling = false;
                    return;
                } else {
                    if (first == 0 && v.getTop() == padTop) {
                        mScrolling = false;
                        return;
                    }
                }
                mScrollSpeed = mScrollProfile.getSpeed((mUpScrollStartYF - maxY)
                        / mDragUpScrollHeight, mPrevTime);
            } else {
                View v = getChildAt(last - first);
                if (v == null) {
                    mScrolling = false;
                    return;
                } else {
                    if (last == count - 1 && v.getBottom() <= listHeight + padTop) {
                        mScrolling = false;
                        return;
                    }
                }
                mScrollSpeed = -mScrollProfile.getSpeed((minY - mDownScrollStartYF)
                        / mDragDownScrollHeight, mPrevTime);
            }

            mCurrTime = SystemClock.uptimeMillis();
            dt = (float) (mCurrTime - mPrevTime);

            // dy is change in View position of a list item; i.e. positive dy
            // means user is scrolling up (list item moves down the screen,
            // remember
            // y=0 is at top of View).
            dy = (int) Math.round(mScrollSpeed * dt);

            int movePos;
            if (dy >= 0) {
                dy = Math.min(listHeight, dy);
                movePos = first;
            } else {
                dy = Math.max(-listHeight, dy);
                movePos = last;
            }

            final View moveItem = getChildAt(movePos - first);
            int top = moveItem.getTop() + dy;

            if (movePos == 0 && top > padTop) {
                top = padTop;
            }

            // always do scroll
            mBlockLayoutRequests = true;

            setSelectionFromTop(movePos, top - padTop);
            DragSortListView.this.layoutChildren();
            invalidate();

            mBlockLayoutRequests = false;

            // scroll means relative float View movement
            doDragFloatView(movePos, moveItem, false);

            mPrevTime = mCurrTime;
            // Log.d("mobeta", "  updated prevTime="+mPrevTime);

            post(this);
        }
    }

    private class DragSortTracker {
        StringBuilder mBuilder = new StringBuilder();

        File mFile;

        private int mNumInBuffer = 0;
        private int mNumFlushes = 0;

        private boolean mTracking = false;

        public DragSortTracker() {
            File root = Environment.getExternalStorageDirectory();
            mFile = new File(root, "dslv_state.txt");

            if (!mFile.exists()) {
                try {
                    mFile.createNewFile();
                    Log.d("mobeta", "file created");
                } catch (IOException e) {
                    Log.w("mobeta", "Could not create dslv_state.txt");
                    Log.d("mobeta", e.getMessage());
                }
            }

        }

        public void startTracking() {
            mBuilder.append("<DSLVStates>\n");
            mNumFlushes = 0;
            mTracking = true;
        }

        public void appendState() {
            if (!mTracking) {
                return;
            }

            mBuilder.append("<DSLVState>\n");
            final int children = getChildCount();
            final int first = getFirstVisiblePosition();
            mBuilder.append("    <Positions>");
            for (int i = 0; i < children; ++i) {
                mBuilder.append(first + i).append(",");
            }
            mBuilder.append("</Positions>\n");

            mBuilder.append("    <Tops>");
            for (int i = 0; i < children; ++i) {
                mBuilder.append(getChildAt(i).getTop()).append(",");
            }
            mBuilder.append("</Tops>\n");
            mBuilder.append("    <Bottoms>");
            for (int i = 0; i < children; ++i) {
                mBuilder.append(getChildAt(i).getBottom()).append(",");
            }
            mBuilder.append("</Bottoms>\n");

            mBuilder.append("    <FirstExpPos>").append(mFirstExpPos).append("</FirstExpPos>\n");
            mBuilder.append("    <FirstExpBlankHeight>")
                    .append(getItemHeight(mFirstExpPos) - getChildHeight(mFirstExpPos))
                    .append("</FirstExpBlankHeight>\n");
            mBuilder.append("    <SecondExpPos>").append(mSecondExpPos).append("</SecondExpPos>\n");
            mBuilder.append("    <SecondExpBlankHeight>")
                    .append(getItemHeight(mSecondExpPos) - getChildHeight(mSecondExpPos))
                    .append("</SecondExpBlankHeight>\n");
            mBuilder.append("    <SrcPos>").append(mSrcPos).append("</SrcPos>\n");
            mBuilder.append("    <SrcHeight>").append(mFloatViewHeight + getDividerHeight())
                    .append("</SrcHeight>\n");
            mBuilder.append("    <ViewHeight>").append(getHeight()).append("</ViewHeight>\n");
            mBuilder.append("    <LastY>").append(mLastY).append("</LastY>\n");
            mBuilder.append("    <FloatY>").append(mFloatViewMid).append("</FloatY>\n");
            mBuilder.append("    <ShuffleEdges>");
            for (int i = 0; i < children; ++i) {
                mBuilder.append(getShuffleEdge(first + i, getChildAt(i).getTop())).append(",");
            }
            mBuilder.append("</ShuffleEdges>\n");

            mBuilder.append("</DSLVState>\n");
            mNumInBuffer++;

            if (mNumInBuffer > 1000) {
                flush();
                mNumInBuffer = 0;
            }
        }

        public void flush() {
            if (!mTracking) {
                return;
            }

            // save to file on sdcard
            try {
                boolean append = true;
                if (mNumFlushes == 0) {
                    append = false;
                }
                FileWriter writer = new FileWriter(mFile, append);

                writer.write(mBuilder.toString());
                mBuilder.delete(0, mBuilder.length());

                writer.flush();
                writer.close();

                mNumFlushes++;
            } catch (IOException e) {
                // do nothing
            }
        }

        public void stopTracking() {
            if (mTracking) {
                mBuilder.append("</DSLVStates>\n");
                flush();
                mTracking = false;
            }
        }

    }

}

@#$
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.mobeta.android.dslv;

import android.content.Context;
import android.database.Cursor;
import android.view.View;
import android.view.ViewGroup;
import android.view.LayoutInflater;

// taken from v4 rev. 10 ResourceCursorAdapter.java

/**
 * Static library support version of the framework's {@link android.widget.ResourceCursorAdapter}.
 * Used to write apps that run on platforms prior to Android 3.0.  When running
 * on Android 3.0 or above, this implementation is still used; it does not try
 * to switch to the framework's implementation.  See the framework SDK
 * documentation for a class overview.
 */
public abstract class ResourceDragSortCursorAdapter extends DragSortCursorAdapter {
    private int mLayout;

    private int mDropDownLayout;
    
    private LayoutInflater mInflater;
    
    /**
     * Constructor the enables auto-requery.
     *
     * @deprecated This option is discouraged, as it results in Cursor queries
     * being performed on the application's UI thread and thus can cause poor
     * responsiveness or even Application Not Responding errors.  As an alternative,
     * use {@link android.app.LoaderManager} with a {@link android.content.CursorLoader}.
     *
     * @param context The context where the ListView associated with this adapter is running
     * @param layout resource identifier of a layout file that defines the views
     *            for this list item.  Unless you override them later, this will
     *            define both the item views and the drop down views.
     */
    @Deprecated
    public ResourceDragSortCursorAdapter(Context context, int layout, Cursor c) {
        super(context, c);
        mLayout = mDropDownLayout = layout;
        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }
    
    /**
     * Constructor with default behavior as per
     * {@link CursorAdapter#CursorAdapter(Context, Cursor, boolean)}; it is recommended
     * you not use this, but instead {@link #ResourceCursorAdapter(Context, int, Cursor, int)}.
     * When using this constructor, {@link #FLAG_REGISTER_CONTENT_OBSERVER}
     * will always be set.
     *
     * @param context The context where the ListView associated with this adapter is running
     * @param layout resource identifier of a layout file that defines the views
     *            for this list item.  Unless you override them later, this will
     *            define both the item views and the drop down views.
     * @param c The cursor from which to get the data.
     * @param autoRequery If true the adapter will call requery() on the
     *                    cursor whenever it changes so the most recent
     *                    data is always displayed.  Using true here is discouraged.
     */
    public ResourceDragSortCursorAdapter(Context context, int layout, Cursor c, boolean autoRequery) {
        super(context, c, autoRequery);
        mLayout = mDropDownLayout = layout;
        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    /**
     * Standard constructor.
     *
     * @param context The context where the ListView associated with this adapter is running
     * @param layout Resource identifier of a layout file that defines the views
     *            for this list item.  Unless you override them later, this will
     *            define both the item views and the drop down views.
     * @param c The cursor from which to get the data.
     * @param flags Flags used to determine the behavior of the adapter,
     * as per {@link CursorAdapter#CursorAdapter(Context, Cursor, int)}.
     */
    public ResourceDragSortCursorAdapter(Context context, int layout, Cursor c, int flags) {
        super(context, c, flags);
        mLayout = mDropDownLayout = layout;
        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    /**
     * Inflates view(s) from the specified XML file.
     * 
     * @see android.widget.CursorAdapter#newView(android.content.Context,
     *      android.database.Cursor, ViewGroup)
     */
    @Override
    public View newView(Context context, Cursor cursor, ViewGroup parent) {
        return mInflater.inflate(mLayout, parent, false);
    }

    @Override
    public View newDropDownView(Context context, Cursor cursor, ViewGroup parent) {
        return mInflater.inflate(mDropDownLayout, parent, false);
    }

    /**
     * <p>Sets the layout resource of the item views.</p>
     *
     * @param layout the layout resources used to create item views
     */
    public void setViewResource(int layout) {
        mLayout = layout;
    }
    
    /**
     * <p>Sets the layout resource of the drop down views.</p>
     *
     * @param dropDownLayout the layout resources used to create drop down views
     */
    public void setDropDownViewResource(int dropDownLayout) {
        mDropDownLayout = dropDownLayout;
    }
}

@#$
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.mobeta.android.dslv;

import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.view.View;
import android.widget.TextView;
import android.widget.ImageView;

// taken from sdk/sources/android-16/android/widget/SimpleCursorAdapter.java

/**
 * An easy adapter to map columns from a cursor to TextViews or ImageViews
 * defined in an XML file. You can specify which columns you want, which
 * views you want to display the columns, and the XML file that defines
 * the appearance of these views.
 *
 * Binding occurs in two phases. First, if a
 * {@link android.widget.SimpleCursorAdapter.ViewBinder} is available,
 * {@link ViewBinder#setViewValue(android.view.View, android.database.Cursor, int)}
 * is invoked. If the returned value is true, binding has occured. If the
 * returned value is false and the view to bind is a TextView,
 * {@link #setViewText(TextView, String)} is invoked. If the returned value
 * is false and the view to bind is an ImageView,
 * {@link #setViewImage(ImageView, String)} is invoked. If no appropriate
 * binding can be found, an {@link IllegalStateException} is thrown.
 *
 * If this adapter is used with filtering, for instance in an
 * {@link android.widget.AutoCompleteTextView}, you can use the
 * {@link android.widget.SimpleCursorAdapter.CursorToStringConverter} and the
 * {@link android.widget.FilterQueryProvider} interfaces
 * to get control over the filtering process. You can refer to
 * {@link #convertToString(android.database.Cursor)} and
 * {@link #runQueryOnBackgroundThread(CharSequence)} for more information.
 */
public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
    /**
     * A list of columns containing the data to bind to the UI.
     * This field should be made private, so it is hidden from the SDK.
     * {@hide}
     */
    protected int[] mFrom;
    /**
     * A list of View ids representing the views to which the data must be bound.
     * This field should be made private, so it is hidden from the SDK.
     * {@hide}
     */
    protected int[] mTo;

    private int mStringConversionColumn = -1;
    private CursorToStringConverter mCursorToStringConverter;
    private ViewBinder mViewBinder;

    String[] mOriginalFrom;

    /**
     * Constructor the enables auto-requery.
     *
     * @deprecated This option is discouraged, as it results in Cursor queries
     * being performed on the application's UI thread and thus can cause poor
     * responsiveness or even Application Not Responding errors.  As an alternative,
     * use {@link android.app.LoaderManager} with a {@link android.content.CursorLoader}.
     */
    @Deprecated
    public SimpleDragSortCursorAdapter(Context context, int layout, Cursor c, String[] from, int[] to) {
        super(context, layout, c);
        mTo = to;
        mOriginalFrom = from;
        findColumns(c, from);
    }

    /**
     * Standard constructor.
     * 
     * @param context The context where the ListView associated with this
     *            SimpleListItemFactory is running
     * @param layout resource identifier of a layout file that defines the views
     *            for this list item. The layout file should include at least
     *            those named views defined in "to"
     * @param c The database cursor.  Can be null if the cursor is not available yet.
     * @param from A list of column names representing the data to bind to the UI.  Can be null 
     *            if the cursor is not available yet.
     * @param to The views that should display column in the "from" parameter.
     *            These should all be TextViews. The first N views in this list
     *            are given the values of the first N columns in the from
     *            parameter.  Can be null if the cursor is not available yet.
     * @param flags Flags used to determine the behavior of the adapter,
     * as per {@link CursorAdapter#CursorAdapter(Context, Cursor, int)}.
     */
    public SimpleDragSortCursorAdapter(Context context, int layout,
            Cursor c, String[] from, int[] to, int flags) {
        super(context, layout, c, flags);
        mTo = to;
        mOriginalFrom = from;
        findColumns(c, from);
    }

    /**
     * Binds all of the field names passed into the "to" parameter of the
     * constructor with their corresponding cursor columns as specified in the
     * "from" parameter.
     *
     * Binding occurs in two phases. First, if a
     * {@link android.widget.SimpleCursorAdapter.ViewBinder} is available,
     * {@link ViewBinder#setViewValue(android.view.View, android.database.Cursor, int)}
     * is invoked. If the returned value is true, binding has occured. If the
     * returned value is false and the view to bind is a TextView,
     * {@link #setViewText(TextView, String)} is invoked. If the returned value is
     * false and the view to bind is an ImageView,
     * {@link #setViewImage(ImageView, String)} is invoked. If no appropriate
     * binding can be found, an {@link IllegalStateException} is thrown.
     *
     * @throws IllegalStateException if binding cannot occur
     * 
     * @see android.widget.CursorAdapter#bindView(android.view.View,
     *      android.content.Context, android.database.Cursor)
     * @see #getViewBinder()
     * @see #setViewBinder(android.widget.SimpleCursorAdapter.ViewBinder)
     * @see #setViewImage(ImageView, String)
     * @see #setViewText(TextView, String)
     */
    @Override
    public void bindView(View view, Context context, Cursor cursor) {
        final ViewBinder binder = mViewBinder;
        final int count = mTo.length;
        final int[] from = mFrom;
        final int[] to = mTo;

        for (int i = 0; i < count; i++) {
            final View v = view.findViewById(to[i]);
            if (v != null) {
                boolean bound = false;
                if (binder != null) {
                    bound = binder.setViewValue(v, cursor, from[i]);
                }

                if (!bound) {
                    String text = cursor.getString(from[i]);
                    if (text == null) {
                        text = "";
                    }

                    if (v instanceof TextView) {
                        setViewText((TextView) v, text);
                    } else if (v instanceof ImageView) {
                        setViewImage((ImageView) v, text);
                    } else {
                        throw new IllegalStateException(v.getClass().getName() + " is not a " +
                                " view that can be bounds by this SimpleCursorAdapter");
                    }
                }
            }
        }
    }

    /**
     * Returns the {@link ViewBinder} used to bind data to views.
     *
     * @return a ViewBinder or null if the binder does not exist
     *
     * @see #bindView(android.view.View, android.content.Context, android.database.Cursor)
     * @see #setViewBinder(android.widget.SimpleCursorAdapter.ViewBinder)
     */
    public ViewBinder getViewBinder() {
        return mViewBinder;
    }

    /**
     * Sets the binder used to bind data to views.
     *
     * @param viewBinder the binder used to bind data to views, can be null to
     *        remove the existing binder
     *
     * @see #bindView(android.view.View, android.content.Context, android.database.Cursor)
     * @see #getViewBinder()
     */
    public void setViewBinder(ViewBinder viewBinder) {
        mViewBinder = viewBinder;
    }

    /**
     * Called by bindView() to set the image for an ImageView but only if
     * there is no existing ViewBinder or if the existing ViewBinder cannot
     * handle binding to an ImageView.
     *
     * By default, the value will be treated as an image resource. If the
     * value cannot be used as an image resource, the value is used as an
     * image Uri.
     *
     * Intended to be overridden by Adapters that need to filter strings
     * retrieved from the database.
     *
     * @param v ImageView to receive an image
     * @param value the value retrieved from the cursor
     */
    public void setViewImage(ImageView v, String value) {
        try {
            v.setImageResource(Integer.parseInt(value));
        } catch (NumberFormatException nfe) {
            v.setImageURI(Uri.parse(value));
        }
    }

    /**
     * Called by bindView() to set the text for a TextView but only if
     * there is no existing ViewBinder or if the existing ViewBinder cannot
     * handle binding to a TextView.
     *
     * Intended to be overridden by Adapters that need to filter strings
     * retrieved from the database.
     * 
     * @param v TextView to receive text
     * @param text the text to be set for the TextView
     */    
    public void setViewText(TextView v, String text) {
        v.setText(text);
    }

    /**
     * Return the index of the column used to get a String representation
     * of the Cursor.
     *
     * @return a valid index in the current Cursor or -1
     *
     * @see android.widget.CursorAdapter#convertToString(android.database.Cursor)
     * @see #setStringConversionColumn(int) 
     * @see #setCursorToStringConverter(android.widget.SimpleCursorAdapter.CursorToStringConverter)
     * @see #getCursorToStringConverter()
     */
    public int getStringConversionColumn() {
        return mStringConversionColumn;
    }

    /**
     * Defines the index of the column in the Cursor used to get a String
     * representation of that Cursor. The column is used to convert the
     * Cursor to a String only when the current CursorToStringConverter
     * is null.
     *
     * @param stringConversionColumn a valid index in the current Cursor or -1 to use the default
     *        conversion mechanism
     *
     * @see android.widget.CursorAdapter#convertToString(android.database.Cursor)
     * @see #getStringConversionColumn()
     * @see #setCursorToStringConverter(android.widget.SimpleCursorAdapter.CursorToStringConverter)
     * @see #getCursorToStringConverter()
     */
    public void setStringConversionColumn(int stringConversionColumn) {
        mStringConversionColumn = stringConversionColumn;
    }

    /**
     * Returns the converter used to convert the filtering Cursor
     * into a String.
     *
     * @return null if the converter does not exist or an instance of
     *         {@link android.widget.SimpleCursorAdapter.CursorToStringConverter}
     *
     * @see #setCursorToStringConverter(android.widget.SimpleCursorAdapter.CursorToStringConverter)
     * @see #getStringConversionColumn()
     * @see #setStringConversionColumn(int)
     * @see android.widget.CursorAdapter#convertToString(android.database.Cursor)
     */
    public CursorToStringConverter getCursorToStringConverter() {
        return mCursorToStringConverter;
    }

    /**
     * Sets the converter  used to convert the filtering Cursor
     * into a String.
     *
     * @param cursorToStringConverter the Cursor to String converter, or
     *        null to remove the converter
     *
     * @see #setCursorToStringConverter(android.widget.SimpleCursorAdapter.CursorToStringConverter) 
     * @see #getStringConversionColumn()
     * @see #setStringConversionColumn(int)
     * @see android.widget.CursorAdapter#convertToString(android.database.Cursor)
     */
    public void setCursorToStringConverter(CursorToStringConverter cursorToStringConverter) {
        mCursorToStringConverter = cursorToStringConverter;
    }

    /**
     * Returns a CharSequence representation of the specified Cursor as defined
     * by the current CursorToStringConverter. If no CursorToStringConverter
     * has been set, the String conversion column is used instead. If the
     * conversion column is -1, the returned String is empty if the cursor
     * is null or Cursor.toString().
     *
     * @param cursor the Cursor to convert to a CharSequence
     *
     * @return a non-null CharSequence representing the cursor
     */
    @Override
    public CharSequence convertToString(Cursor cursor) {
        if (mCursorToStringConverter != null) {
            return mCursorToStringConverter.convertToString(cursor);
        } else if (mStringConversionColumn > -1) {
            return cursor.getString(mStringConversionColumn);
        }

        return super.convertToString(cursor);
    }

    /**
     * Create a map from an array of strings to an array of column-id integers in cursor c.
     * If c is null, the array will be discarded.
     *
     * @param c the cursor to find the columns from
     * @param from the Strings naming the columns of interest
     */
    private void findColumns(Cursor c, String[] from) {
        if (c != null) {
            int i;
            int count = from.length;
            if (mFrom == null || mFrom.length != count) {
                mFrom = new int[count];
            }
            for (i = 0; i < count; i++) {
                mFrom[i] = c.getColumnIndexOrThrow(from[i]);
            }
        } else {
            mFrom = null;
        }
    }

    @Override
    public Cursor swapCursor(Cursor c) {
        // super.swapCursor() will notify observers before we have
        // a valid mapping, make sure we have a mapping before this
        // happens
        findColumns(c, mOriginalFrom);
        return super.swapCursor(c);
    }
    
    /**
     * Change the cursor and change the column-to-view mappings at the same time.
     *  
     * @param c The database cursor.  Can be null if the cursor is not available yet.
     * @param from A list of column names representing the data to bind to the UI.  Can be null 
     *            if the cursor is not available yet.
     * @param to The views that should display column in the "from" parameter.
     *            These should all be TextViews. The first N views in this list
     *            are given the values of the first N columns in the from
     *            parameter.  Can be null if the cursor is not available yet.
     */
    public void changeCursorAndColumns(Cursor c, String[] from, int[] to) {
        mOriginalFrom = from;
        mTo = to;
        // super.changeCursor() will notify observers before we have
        // a valid mapping, make sure we have a mapping before this
        // happens
        findColumns(c, mOriginalFrom);
        super.changeCursor(c);
    }

    /**
     * This class can be used by external clients of SimpleCursorAdapter
     * to bind values fom the Cursor to views.
     *
     * You should use this class to bind values from the Cursor to views
     * that are not directly supported by SimpleCursorAdapter or to
     * change the way binding occurs for views supported by
     * SimpleCursorAdapter.
     *
     * @see SimpleCursorAdapter#bindView(android.view.View, android.content.Context, android.database.Cursor)
     * @see SimpleCursorAdapter#setViewImage(ImageView, String) 
     * @see SimpleCursorAdapter#setViewText(TextView, String)
     */
    public static interface ViewBinder {
        /**
         * Binds the Cursor column defined by the specified index to the specified view.
         *
         * When binding is handled by this ViewBinder, this method must return true.
         * If this method returns false, SimpleCursorAdapter will attempts to handle
         * the binding on its own.
         *
         * @param view the view to bind the data to
         * @param cursor the cursor to get the data from
         * @param columnIndex the column at which the data can be found in the cursor
         *
         * @return true if the data was bound to the view, false otherwise
         */
        boolean setViewValue(View view, Cursor cursor, int columnIndex);
    }

    /**
     * This class can be used by external clients of SimpleCursorAdapter
     * to define how the Cursor should be converted to a String.
     *
     * @see android.widget.CursorAdapter#convertToString(android.database.Cursor)
     */
    public static interface CursorToStringConverter {
        /**
         * Returns a CharSequence representing the specified Cursor.
         *
         * @param cursor the cursor for which a CharSequence representation
         *        is requested
         *
         * @return a non-null CharSequence representing the cursor
         */
        CharSequence convertToString(Cursor cursor);
    }

}

@#$
package com.mobeta.android.dslv;

import android.graphics.Bitmap;
import android.graphics.Point;
import android.graphics.Color;
import android.widget.ListView;
import android.widget.ImageView;
import android.view.View;
import android.view.ViewGroup;
import android.util.Log;

/**
 * Simple implementation of the FloatViewManager class. Uses list
 * items as they appear in the ListView to create the floating View.
 */
public class SimpleFloatViewManager implements DragSortListView.FloatViewManager {

    private Bitmap mFloatBitmap;

    private ImageView mImageView;

    private int mFloatBGColor = Color.BLACK;

    private ListView mListView;

    public SimpleFloatViewManager(ListView lv) {
        mListView = lv;
    }

    public void setBackgroundColor(int color) {
        mFloatBGColor = color;
    }

    /**
     * This simple implementation creates a Bitmap copy of the
     * list item currently shown at ListView <code>position</code>.
     */
    @Override
    public View onCreateFloatView(int position) {
        // Guaranteed that this will not be null? I think so. Nope, got
        // a NullPointerException once...
        View v = mListView.getChildAt(position + mListView.getHeaderViewsCount() - mListView.getFirstVisiblePosition());

        if (v == null) {
            return null;
        }

        v.setPressed(false);

        // Create a copy of the drawing cache so that it does not get
        // recycled by the framework when the list tries to clean up memory
        //v.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);
        v.setDrawingCacheEnabled(true);
        mFloatBitmap = Bitmap.createBitmap(v.getDrawingCache());
        v.setDrawingCacheEnabled(false);

        if (mImageView == null) {
            mImageView = new ImageView(mListView.getContext());
        }
        mImageView.setBackgroundColor(mFloatBGColor);
        mImageView.setPadding(0, 0, 0, 0);
        mImageView.setImageBitmap(mFloatBitmap);
        mImageView.setLayoutParams(new ViewGroup.LayoutParams(v.getWidth(), v.getHeight()));

        return mImageView;
    }

    /**
     * This does nothing
     */
    @Override
    public void onDragFloatView(View floatView, Point position, Point touch) {
        // do nothing
    }

    /**
     * Removes the Bitmap from the ImageView created in
     * onCreateFloatView() and tells the system to recycle it.
     */
    @Override
    public void onDestroyFloatView(View floatView) {
        ((ImageView) floatView).setImageDrawable(null);

        mFloatBitmap.recycle();
        mFloatBitmap = null;
    }

}


@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Animations;

import android.view.View;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.view.animation.Interpolator;

/**
 * Fade animation class. Pass in any view to apply 
 * the animation.
 * 
 * @author Saravan Pantham
 */
public class FadeAnimation extends AlphaAnimation {

	private View mView;
	private long mDuration;
	private float mFromAlpha;
	private float mToAlpha;
	private Interpolator mInterpolator;
	
	public FadeAnimation(View view, long duration, float fromAlpha, 
						 float toAlpha, Interpolator interpolator) {
		
		super(fromAlpha, toAlpha);
		mView = view;
		mDuration = duration;
		mFromAlpha = fromAlpha;
		mToAlpha = toAlpha;
		mInterpolator = interpolator;
		
	}

	/**
	 * Performs the fade animation.
	 */
	public void animate() {
		
		if (mView==null)
			return;
		
		if (mFromAlpha==mToAlpha)
			return;
		
		if (mDuration==0)
			return;
		
		//Set the animation parameters.
		if (mFromAlpha > mToAlpha)
			//Fade out animation.
			this.setAnimationListener(fadeOutListener);
		else
			//Fade in animation.
			this.setAnimationListener(fadeInListener);
		
		this.setDuration(mDuration);
        if (mInterpolator!=null)
		    this.setInterpolator(mInterpolator);
		mView.startAnimation(this);

	}
	
	/**
	 * Fade in animation listener.
	 */
	private AnimationListener fadeInListener = new AnimationListener() {

		@Override
		public void onAnimationEnd(Animation arg0) {
			mView.setVisibility(View.VISIBLE);
			
		}

		@Override
		public void onAnimationRepeat(Animation arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onAnimationStart(Animation arg0) {
			mView.setVisibility(View.INVISIBLE);
			
		}
		
	};
	
	/**
	 * Fade out animation listener.
	 */
	private AnimationListener fadeOutListener = new AnimationListener() {

		@Override
		public void onAnimationEnd(Animation arg0) {
			mView.setVisibility(View.INVISIBLE);
			
		}

		@Override
		public void onAnimationRepeat(Animation arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onAnimationStart(Animation arg0) {
			mView.setVisibility(View.VISIBLE);
			
		}
		
	};
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Animations;

import android.view.View;
import android.view.animation.Animation;
import android.view.animation.Interpolator;
import android.widget.ImageView;

/**
 * Translate animation class. Pass in any view to apply 
 * the animation.
 * 
 * @author Saravan Pantham
 */
public class TranslateAnimation extends android.view.animation.TranslateAnimation {

	private View mView;
	private long mDuration;
	private int mFinalVisibility;
	private int mNewImageResourceId;
	private Interpolator mInterpolator;
	
	private boolean mChangeImageResource = false;
	
	/**
	 * Use this constructor to animate a view from one location to another.
	 */
	public TranslateAnimation(View view, long duration, Interpolator interpolator, 
							  int finalVisibility, int fromXType, float fromXValue, int toXType,
							  float toXValue, int fromYType, float fromYValue, 
							  int toYType, float toYValue) {
		
		super(fromXType, fromXValue, toXType, 
			  toXValue, fromYType, fromYValue, 
			  toYType, toYValue);
		
		mView = view;
		mDuration = duration;
		mFinalVisibility = finalVisibility;
		mInterpolator = interpolator;
		
	}
	
	/**
	 * Use this constructor to animate an ImageView/ImageButton from one location to another and 
	 * change the image at the end of the animation.
	 */
	public TranslateAnimation(View view, long duration, int newImageResourceId, Interpolator interpolator, 
			                  int finalVisibility, int fromXType, float fromXValue, int toXType,
			                  float toXValue, int fromYType, float fromYValue,
			                  int toYType, float toYValue) {

		super(fromXType, fromXValue, toXType, 
		toXValue, fromYType, fromYValue, 
		toYType, toYValue);
		
		mChangeImageResource = true;
		mView = view;
		mDuration = duration;
		mFinalVisibility = finalVisibility;
		mNewImageResourceId = newImageResourceId;
		mInterpolator = interpolator;
		
	}
	
	/**
	 * Performs the fade animation.
	 */
	public void animate() {
		
		if (mView==null)
			return;
		
		if (mDuration==0)
			return;

		//Set the animation parameters.
		this.setAnimationListener(translateListener);
		this.setDuration(mDuration);
		this.setInterpolator(mInterpolator);
		mView.startAnimation(this);

	}
	
	/**
	 * Translate animation listener.
	 */
	private AnimationListener translateListener = new AnimationListener() {

		@Override
		public void onAnimationEnd(Animation arg0) {
			mView.setVisibility(mFinalVisibility);
			
			if (mChangeImageResource && (mView instanceof ImageView))
				((ImageView) mView).setImageResource(mNewImageResourceId);
			
		}

		@Override
		public void onAnimationRepeat(Animation arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onAnimationStart(Animation arg0) {
			// TODO Auto-generated method stub
			
		}
		
	};

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.provider.MediaStore;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;

public class AsyncAddSongsToPlaylistTask extends AsyncTask<String, Integer, Boolean> {
    private Context mContext;
    private Cursor mCursor;
    private String mPlaylistName;
    private String mPlaylistId;
    private SharedPreferences sharedPreferences;
    private DBAccessHelper musicLibraryDBHelper;
    private DBAccessHelper musicLibraryPlaylistsDBHelper;
    
    private String mArtist;
    private String mAlbum;
    private String mSong;
    private String mGenre;
    private String mAlbumArtist;
    private String mAddType;
    
    public AsyncAddSongsToPlaylistTask(Context context, 
    								   String playlistName, 
    								   String playlistId,
    								   String ARTIST, 
    								   String ALBUM, 
    								   String SONG, 
    								   String GENRE,
    								   String ALBUM_ARTIST, 
    								   String ADD_TYPE) {
    	
    	mContext = context;
    	mPlaylistName = playlistName;
    	mPlaylistId = playlistId;
    	sharedPreferences = context.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    	musicLibraryDBHelper = new DBAccessHelper(mContext);
    	musicLibraryPlaylistsDBHelper = new DBAccessHelper(mContext);
    	
    	mArtist = ARTIST;
    	mAlbum = ALBUM;
    	mSong = SONG;
    	mGenre = GENRE;
    	mAlbumArtist = ALBUM_ARTIST;
    	mAddType = ADD_TYPE;
    }
 
    @Override
    protected Boolean doInBackground(String... params) {
    	
		/*//Replace illegal characters in the playlistName.
		if (mPlaylistName.contains("/")) {
			mPlaylistName = mPlaylistName.replace("/", "_");
		}
		
		if (mPlaylistName.contains("\\")) {
			mPlaylistName = mPlaylistName.replace("\\", "_");
		}
    	
    	//Get the cursor with the playlist elements.
    	String playlistFolderPath = sharedPreferences.getString("PLAYLISTS_SAVE_FOLDER", 
    															Environment.getExternalStorageDirectory() + "/Playlists/");
    	String playlistFilePath = playlistFolderPath + mPlaylistName + ".m3u";
    	mCursor = AddPlaylistUtils.getPlaylistElementsCursor(mContext, 
    														 musicLibraryDBHelper, 
    														 sharedPreferences, 
    														 mArtist, 
    														 mAlbum, 
    														 mSong, 
    														 mGenre, 
    														 mAlbumArtist,
    														 mAddType);
    	
    	Cursor gMusicCursor = null;
    	ArrayList<Integer> gMusicSongOrder = new ArrayList<Integer>();
    	
    	//Fetch the total number of songs in the playlist right now.
    	int currentSongCount = musicLibraryPlaylistsDBHelper.getPlaylistSongCount(null, mPlaylistId);
    	
    	//Loop through the number of GMusic songs in the playlist and add their order to gMusicSongOrder.
    	gMusicCursor = musicLibraryPlaylistsDBHelper.getGMusicSongsInPlaylist(null, mPlaylistId);
    	while (gMusicCursor.moveToNext()) {
    		if (gMusicCursor.getString(gMusicCursor.getColumnIndex(DBAccessHelper.PLAYLIST_SOURCE))
    						.equals(DBAccessHelper.GMUSIC)) {
    			int songOrder = gMusicCursor.getInt(gMusicCursor.getColumnIndex(DBAccessHelper.PLAYLIST_ORDER));
    			gMusicSongOrder.add(songOrder);
    		}
    		
    	}
    	
    	gMusicCursor.close();
    	gMusicCursor = null;
    	for (int i=currentSongCount; i < (mCursor.getCount() + currentSongCount); i++) {
    		try {
    			mCursor.moveToPosition(i - currentSongCount);
    			String songSource = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_SOURCE));
    			
    			 This if/else block will handle the different operations that need to be 
    			 * done/ommitted for each different song type (Google Play Music vs local
    			 * song file).
    			 
    			String clientId = "";
    			if (songSource.equals(DBAccessHelper.GMUSIC)) {
    				
    				//Retrieve the clientId of the current song from GMusic's content mApp.
        	    	Uri googlePlayMusicContentProviderUri = Uri.parse("content://com.google.android.music.MusicContent/audio");
        	    	String[] projection = { "SourceId", "ClientId AS client_id" };
        			
        			String songId = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ID));
        			String selection = "SourceId=" + "'" + songId + "'";
        	    	gMusicCursor = mContext.getContentResolver().query(googlePlayMusicContentProviderUri, projection, selection, null, null);
        	    	gMusicCursor.moveToFirst();
        	    	clientId = gMusicCursor.getString(1);
        			
        	    	//Populate the mutations JSONArray.
        			JSONObject createObject = new JSONObject();

        			createObject.put("lastModifiedTimestamp", "0");
        			createObject.put("playlistId", mPlaylistId);
        			createObject.put("creationTimestamp", "-1");
        			createObject.put("type", "USER_GENERATED");
        			createObject.put("source", 1);
        			createObject.put("deleted", false);
        			createObject.put("trackId", songId);
        			createObject.put("clientId", clientId);
        			
        			//Add the request to the JSONArray queue that will update Google's servers.
        	    	GMusicClientCalls.putCreatePlaylistEntryRequest(createObject);	
        	    	gMusicSongOrder.add(i);
        			
    			} else {

    				//Add the song to Android's MediaStore database.
    				String artist = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ARTIST));
    				String album = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ALBUM));
    				String title = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_TITLE));
    				
    				try {
    					long audioId = getSongAudioId(artist, album, title);
    					if (audioId!=-1) {
    						addSongToPlaylist(mContext.getContentResolver(), audioId, Long.parseLong(mPlaylistId));
    					}
        				
    				} catch (Exception e) {
    					//Just fail silently if this song can't be inserted into the playlist.
    					e.printStackTrace();
    				}
    				
        			//Add the song to the playlists database.
        			musicLibraryPlaylistsDBHelper.addNewPlaylist(mPlaylistName, 
        														 playlistFilePath, 
        														 playlistFolderPath, 
        														 mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH)), 
        														 DBAccessHelper.GMUSIC, 
        														 mPlaylistId,
        														 mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ID)),
        														 new Date().getTime(),
        														 i,
        														 clientId);
    				
    			}
    		
    		} catch (Exception e) {
    			e.printStackTrace();
    			continue;
    		}
    		
    	}
    	
    	//Show a confirmation toast message.
    	publishProgress(new Integer[] {0});
    	
    	//Send the HTTP request that will update Google's servers.
    	if (sharedPreferences.getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
        	try {
        		if (GMusicClientCalls.getQueuedMutationsCount() > 0) {
        			GMusicClientCalls.modifyPlaylist(mContext);
        			
        			//Refetch the entire playlist that has just been modified.
        			reloadPlaylistEntries(gMusicSongOrder);
        		}
    			
    		} catch (IllegalArgumentException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		} catch (JSONException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
        	
    	}
		
    	if (gMusicCursor!=null) {
    		gMusicCursor.close();
    		gMusicCursor = null;
    	}
    	
    	return true;
    }
    
    public void reloadPlaylistEntries(ArrayList<Integer> gMusicSongOrder) {
    	JSONArray jsonArray = null;
    	try {
			jsonArray = GMusicClientCalls.getPlaylistEntriesWebClient(mContext, mPlaylistId);
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (JSONException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	
    	//Remove the current GMusic entries within the playlist.
    	musicLibraryPlaylistsDBHelper.removeGMusicSongsFromPlaylist(mContext, mPlaylistId);
    	
    	//Loop through the playlist's songs array and retrieve each song's metadata.
		WebClientSongsSchema currentPlaylistSong = new WebClientSongsSchema();
    	for (int j=0; j < jsonArray.length(); j++) {
    		try {
    			currentPlaylistSong = currentPlaylistSong.fromJsonObject(jsonArray.getJSONObject(j));
        		//Extract the current playlist song's metadata.
            	String songTrackId = currentPlaylistSong.getId();
            	String playlistEntryId = currentPlaylistSong.getPlaylistEntryId();
            	
            	ContentValues playlistValues = new ContentValues();
            	playlistValues.put(DBAccessHelper.PLAYLIST_NAME, mPlaylistName);
            	playlistValues.put(DBAccessHelper.PLAYLIST_ID, mPlaylistId); 
            	playlistValues.put(DBAccessHelper.PLAYLIST_ART_URL, "");
            	playlistValues.put(DBAccessHelper.PLAYLIST_SOURCE, DBAccessHelper.GMUSIC);
            	playlistValues.put(DBAccessHelper.PLAYLIST_BLACKLIST_STATUS, "FALSE");
            	playlistValues.put(DBAccessHelper.PLAYLIST_SONG_FILE_PATH, songTrackId);
            	playlistValues.put(DBAccessHelper.PLAYLIST_SONG_ENTRY_ID, playlistEntryId);
            	playlistValues.put(DBAccessHelper.PLAYLIST_ORDER, gMusicSongOrder.get(j));
            	
            	//Add all the entries to the database to build the songs library.
            	musicLibraryPlaylistsDBHelper.getWritableDatabase().insert(DBAccessHelper.MUSIC_LIBRARY_PLAYLISTS_NAME, 
            												 			   null, 
            												 			   playlistValues);
    		} catch (Exception e) {
    			e.printStackTrace();
    			continue;
    		}
    		
    	}*/
    	
    	return null;
        	
    }
    
    private void addSongToPlaylist(ContentResolver resolver, long audioId, long playlistId) {

        String[] cols = new String[] {
                "count(*)"
        };
        
        Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId);
        Cursor cur = resolver.query(uri, cols, null, null, null);
        cur.moveToFirst();
        final int base = cur.getInt(0);
        cur.close();
        ContentValues values = new ContentValues();
        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, Long.valueOf(base + audioId));
        values.put(MediaStore.Audio.Playlists.Members.AUDIO_ID, audioId);
        resolver.insert(uri, values);
    }
    
    private long getSongAudioId(String artist, String album, String title) {
    	artist = artist.replace("'", "''");
    	album = album.replace("'", "''");
    	title = title.replace("'", "''");
    	
    	String selection = MediaStore.Audio.AudioColumns.ALBUM + "=" + "'" + album + "'" + " AND "
    					 + MediaStore.Audio.AudioColumns.ARTIST + "=" + "'" + artist + "'" + " AND "
    					 + MediaStore.Audio.AudioColumns.TITLE + "=" + "'" + title + "'";
    	
    	Cursor cursor = mContext.getContentResolver().query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, 
    														null, 
    														selection, 
    														null,
    														null);
    	
    	if (cursor!=null && cursor.getCount() > 0) {
    		cursor.moveToFirst();
    		return cursor.getLong(cursor.getColumnIndex(MediaStore.Audio.Media._ID));
    	} else {
    		return -1;
    	}
    	
    }
    
    @Override
    protected void onProgressUpdate(Integer... values) {
    	super.onProgressUpdate(values);
    	switch(values[0]) {
    	case 0:
    		//Common.displayToast(R.string.playlist_created, Toast.LENGTH_SHORT);
    		Toast.makeText(mContext, R.string.playlist_modified, Toast.LENGTH_SHORT).show();
    		break;
    	case 1:
    		//Common.displayToast(R.string.playlist_could_not_be_created, Toast.LENGTH_SHORT);
    		Toast.makeText(mContext, R.string.playlist_could_not_be_modified, Toast.LENGTH_SHORT).show();
    		break;
    	}
    	
    }
    
    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
    	
    	if (mCursor!=null) {
    		mCursor.close();
        	mCursor = null;
    	}
    
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.os.AsyncTask;
import android.support.v4.app.Fragment;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.Services.AudioPlaybackService;
import com.jams.music.player.Utils.Common;

public class AsyncAddToQueueTask extends AsyncTask<Boolean, Integer, Boolean> {
	
    private Context mContext;
    private Common mApp;
    
    private String mArtistName;
    private String mAlbumName;
    private String mSongTitle;
    private String mGenreName;
    private String mPlaylistId;
    private String mPlaylistName;
    private String mAlbumArtistName;
    
    private Fragment mFragment;
    private Cursor mCursor;
    private String mEnqueueType;
    private int originalPlaybackIndecesSize = 0;
    private boolean mPlayNext = false;
    private String mPlayingNext = "";
    
    public AsyncAddToQueueTask(Context context,
    						   Fragment fragment,
    						   String enqueueType,
    						   String artistName,
    						   String albumName,
    						   String songTitle,
    						   String genreName,
    						   String playlistId, 
    						   String playlistName,
    						   String albumArtistName) {
    	
    	mContext = context;
    	mApp = (Common) mContext;
    	
    	mArtistName = artistName;
    	mAlbumName = albumName;
    	mSongTitle = songTitle;
    	mGenreName = genreName;
    	mPlaylistId = playlistId;
    	mPlaylistName = playlistName;
    	mAlbumArtistName = albumArtistName;
    	
    	mFragment = fragment;
    	mEnqueueType = enqueueType;
    	
    	if (mApp.getService().getPlaybackIndecesList()!=null) {
    		originalPlaybackIndecesSize = mApp.getService().getPlaybackIndecesList().size();
    	}
    	
    }
    
    protected void onPreExecute() {
		super.onPreExecute();
    }
 
    @Override
    protected Boolean doInBackground(Boolean... params) {
		
    	//Specifies if the user is trying to add song(s) to play next.
    	if (params.length > 0) {
    		mPlayNext = params[0];
    	}
    	
    	
		//Escape any rogue apostrophes.
		if (mArtistName!=null && mArtistName.contains("'")) {
			mArtistName = mArtistName.replace("'", "''");
		}
		
		if (mAlbumName!=null && mAlbumName.contains("'")) {
			mAlbumName = mAlbumName.replace("'", "''");
		}
		
		if (mSongTitle!=null && mSongTitle.contains("'")) {
			mSongTitle = mSongTitle.replace("'", "''");
		}
		
		if (mGenreName!=null && mGenreName.contains("''")) {
			mGenreName = mGenreName.replace("'", "''");
		}
		
		if (mAlbumArtistName!=null && mAlbumArtistName.contains("'")) {
			mAlbumArtistName = mAlbumArtistName.replace("'", "''");
		}
		
		//Fetch the cursor based on the type of set of songs that are being enqueued.
		assignCursor();

		//Check if the service is currently active.
		if (mApp.isServiceRunning()) {
			
			if (mPlayNext) {
				/* Loop through the mCursor of the songs that will be enqueued and add the 
				 * loop's counter value to the size of the current mCursor. This will add 
				 * the additional mCursor indeces of the new, merged mCursor to playbackIndecesList. 
				 * The new indeces must be placed after the current song's index.
				 */
				int playNextIndex = 0;
				if (mApp.isServiceRunning()) {
					playNextIndex = mApp.getService().getCurrentSongIndex() + 1;
				}
				
				for (int i=0; i < mCursor.getCount(); i++) {
					mApp.getService().getPlaybackIndecesList().add(playNextIndex + i, 
																   mApp.getService().getCursor().getCount() + i);
				}
				
			} else {
				/* Loop through the mCursor of the songs that will be enqueued and add the 
				 * loop's counter value to the size of the current mCursor. This will add 
				 * the additional mCursor indeces of the new, merged mCursor to playbackIndecesList.
				 */
				for (int i=0; i < mCursor.getCount(); i++) {
					mApp.getService().getPlaybackIndecesList().add(mApp.getService().getCursor().getCount() + i);
				}
				
			}
			
			mApp.getService().enqueueCursor(mCursor, mPlayNext);
			
		} else {
			//The service doesn't seem to be running. We'll explicitly stop it, just in case, and then launch NowPlayingActivity.class.
			Intent serviceIntent = new Intent(mContext, AudioPlaybackService.class);
			mContext.stopService(serviceIntent);
			
			publishProgress(new Integer[] {0});
		}
		
		publishProgress(new Integer[] {1});
		
    	return true;
    }
    
    //Retrieves and assigns the cursor based on the set of song(s) that are being enqueued.
    private void assignCursor() {
    	
    	DBAccessHelper dbHelper = new DBAccessHelper(mContext);
    	
    	if (mEnqueueType.equals("SONG")) {
    		String selection = null;
    		if (mApp.isGooglePlayMusicEnabled()) {
    			selection = DBAccessHelper.SONG_ARTIST + "=" + "'" + mArtistName + "'" + " AND "
    					  + DBAccessHelper.SONG_ALBUM + "=" + "'" + mAlbumName + "'" + " AND "
    					  + DBAccessHelper.SONG_TITLE + "=" + "'" + mSongTitle + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
    		} else {
    			selection = DBAccessHelper.SONG_ARTIST + "=" + "'" + mArtistName + "'" + " AND "
  					  	  + DBAccessHelper.SONG_ALBUM + "=" + "'" + mAlbumName + "'" + " AND "
  					  	  + DBAccessHelper.SONG_TITLE + "=" + "'" + mSongTitle + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'" + " AND "
  					  	  + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    		}

    		mCursor = dbHelper.getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
   													   	   null, 
   													   	   selection, 
   													   	   null, 
   													   	   null, 
   													   	   null, 
   													   	   DBAccessHelper.SONG_TITLE + " ASC");
    		
    		mPlayingNext = mSongTitle;
    	} else if (mEnqueueType.equals("ARTIST")) {
    		String selection = null;
    		if (mApp.isGooglePlayMusicEnabled()) {
    			selection = DBAccessHelper.SONG_ARTIST + "=" + "'" + mArtistName + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
    		} else {
    			selection = DBAccessHelper.SONG_ARTIST + "=" + "'" + mArtistName + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'" + " AND "
  					  	  + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    		}
    		
    		mCursor = dbHelper.getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
    													   null, 
    													   selection, 
    													   null, 
    													   null, 
    													   null, 
    													   DBAccessHelper.SONG_ALBUM + " ASC" + ", " + DBAccessHelper.SONG_TRACK_NUMBER + "*1 ASC");	
    		
    		mPlayingNext = mArtistName;
    	} else if (mEnqueueType.equals("ALBUM")) {
    		
    		String selection = null;
    		if (mApp.isGooglePlayMusicEnabled()) {
    			selection = DBAccessHelper.SONG_ARTIST + "=" + "'" + mArtistName + "'" + " AND "
    					  + DBAccessHelper.SONG_ALBUM + "=" + "'" + mAlbumName + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
    		} else {
    			selection = DBAccessHelper.SONG_ARTIST + "=" + "'" + mArtistName + "'" + " AND "
  					  	  + DBAccessHelper.SONG_ALBUM + "=" + "'" + mAlbumName + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'" + " AND "
  					  	  + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    		}
    		
    		mCursor = dbHelper.getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
														   null, 
														   selection, 
														   null, 
														   null, 
														   null, 
														   DBAccessHelper.SONG_TRACK_NUMBER + "*1 ASC");
    		
    		mPlayingNext = mAlbumName;
    	} else if (mEnqueueType.equals("ALBUM_BY_ALBUM_ARTIST")) { 
    		String selection = null;
    		if (mApp.isGooglePlayMusicEnabled()) {
    			selection = DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mAlbumArtistName + "'" + " AND "
    					  + DBAccessHelper.SONG_ALBUM + "=" + "'" + mAlbumName + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
    		} else {
    			selection = DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mAlbumArtistName + "'" + " AND "
    					  + DBAccessHelper.SONG_ALBUM + "=" + "'" + mAlbumName + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'" + " AND "
  					  	  + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    		}
    		
    		mCursor = dbHelper.getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
														   null, 
														   selection, 
														   null, 
														   null, 
														   null, 
														   DBAccessHelper.SONG_TRACK_NUMBER + "*1 ASC");
    		
    		mPlayingNext = mAlbumName;
    	} else if (mEnqueueType.equals("ALBUM_ARTIST")) {
    		String selection = null;
    		if (mApp.isGooglePlayMusicEnabled()) {
    			selection = DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mAlbumArtistName + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
    		} else {
    			selection = DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mAlbumArtistName + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'" + " AND "
  					  	  + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    		}
    		
    		mCursor = dbHelper.getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
														   null, 
														   selection, 
														   null, 
														   null, 
														   null, 
														   DBAccessHelper.SONG_ALBUM + " ASC, " + DBAccessHelper.SONG_TRACK_NUMBER + "*1 ASC");
    	
    		mPlayingNext = mAlbumArtistName;
    	} else if (mEnqueueType.equals("TOP_25_PLAYED")) {
    		
    		String selection = null;
            if (mApp.isGooglePlayMusicEnabled()==false) {
            	selection = DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " AND "
            			  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
            } else {
            	selection = DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
            }
            
            mCursor = dbHelper.getTop25PlayedTracks(selection);
            mPlayingNext = mContext.getResources().getString(R.string.the_top_25_played_tracks);
    	} else if (mEnqueueType.equals("RECENTLY_ADDED")) {
    		String selection = null;
            if (mApp.isGooglePlayMusicEnabled()==false) {
            	selection = DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " AND "
            			  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
            } else {
            	selection = DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
            }
            
            mCursor = dbHelper.getRecentlyAddedSongs(selection);
            mPlayingNext =  mContext.getResources().getString(R.string.the_most_recently_added_songs);
    	} else if (mEnqueueType.equals("TOP_RATED")) {
    		String selection = null;
            if (mApp.isGooglePlayMusicEnabled()==false) {
            	selection = DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " AND "
            			  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
            } else {
            	selection = DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
            }
            
            mCursor = dbHelper.getTopRatedSongs(selection);
            mPlayingNext =  mContext.getResources().getString(R.string.the_top_rated_songs);
    	} else if (mEnqueueType.equals("RECENTLY_PLAYED")) {
    		String selection = null;
            if (mApp.isGooglePlayMusicEnabled()==false) {
            	selection = DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " AND "
            			  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
            } else {
            	selection = DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
            }
            
            mCursor = dbHelper.getRecentlyPlayedSongs(selection);
            mPlayingNext =  mContext.getResources().getString(R.string.the_most_recently_played_songs);
    	} else if (mEnqueueType.equals("PLAYLIST")) {
           /* String selection = " AND " + DBAccessHelper.MUSIC_LIBRARY_PLAYLISTS_NAME + "." 
            				 + DBAccessHelper.PLAYLIST_ID + "=" + "'" + mPlaylistId + "'";
            
            if (mApp.isGooglePlayMusicEnabled()) {
            	mCursor = dbHelper.getAllSongsInPlaylistSearchable(selection);
            } else {
            	mCursor = dbHelper.getLocalSongsInPlaylistSearchable(selection);
            }
    		
            mPlayingNext = mPlaylistName;*/
    	} else if (mEnqueueType.equals("GENRE")) {
    		
    		String selection = null;
    		if (mApp.isGooglePlayMusicEnabled()) {
    			selection = DBAccessHelper.SONG_GENRE + "=" + "'" + mGenreName + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
    		} else {
    			selection = DBAccessHelper.SONG_GENRE + "=" + "'" + mGenreName + "'" + " AND "
	   				 	  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'" + " AND "
  					  	  + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    		}
    		
    		mCursor = dbHelper.getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
												   		   null, 
												   		   selection, 
												   		   null, 
												   		   null, 
												   		   null, 
												   		   DBAccessHelper.SONG_ALBUM + " ASC, " + 
												   		   DBAccessHelper.SONG_TRACK_NUMBER + "*1 ASC");
    		
    		mPlayingNext = mGenreName;
    	}
    	
    	
    }
    
    @Override
    protected void onProgressUpdate(Integer... values) {
    	super.onProgressUpdate(values);
    	int value = values[0];
    	
    	switch(value) {
    	case 0:
			Intent intent = new Intent(mContext, NowPlayingActivity.class);
			
			//Get the parameters for the first song.
			if (mCursor.getCount() > 0) {
				mCursor.moveToFirst();
				
				if (mEnqueueType.equals("ARTIST")) {
					intent.putExtra("PLAY_ALL", "ARTIST");
					intent.putExtra("CALLING_FRAGMENT", "ARTISTS_FLIPPED_FRAGMENT");
				} else if (mEnqueueType.equals("ALBUM_ARTIST")) {
					intent.putExtra("PLAY_ALL", "ALBUM_ARTIST");
					intent.putExtra("CALLING_FRAGMENT", "ALBUM_ARTISTS_FLIPPED_FRAGMENT");
				} else if (mEnqueueType.equals("ALBUM")) {
					intent.putExtra("PLAY_ALL", "ALBUM");
					intent.putExtra("CALLING_FRAGMENT", "ALBUMS_FLIPPED_FRAGMENT");
				} else if (mEnqueueType.equals("PLAYLIST")) {
					intent.putExtra("CALLING_FRAGMENT", "PLAYLISTS_FLIPPED_FRAGMENT");
					intent.putExtra("PLAYLIST_NAME", mPlaylistName);
				} else if (mEnqueueType.equals("GENRE")) {
					intent.putExtra("PLAY_ALL", "GENRE");
					intent.putExtra("CALLING_FRAGMENT", "GENRES_FLIPPED_FRAGMENT");
				} else if (mEnqueueType.equals("ALBUM_ARTIST")) {
					intent.putExtra("CALLING_FRAGMENT", "ALBUM_ARTISTS_FLIPPED_FRAGMENT");
					intent.putExtra("PLAY_ALL", "ALBUM_ARTIST");
				} else if (mEnqueueType.equals("SONG")) {
					intent.putExtra("CALLING_FRAGMENT", "SONGS_FRAGMENT");
					intent.putExtra("SEARCHED", true);
				} else if (mEnqueueType.equals("ALBUM_BY_ALBUM_ARTIST")) {
					intent.putExtra("CALLING_FRAGMENT", "ALBUM_ARTISTS_FLIPPED_SONGS_FRAGMENT");
					intent.putExtra("PLAY_ALL", "ALBUM");
				}

    			intent.putExtra("SELECTED_SONG_DURATION", mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_DURATION)));
				intent.putExtra("SELECTED_SONG_TITLE", mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_TITLE)));
				intent.putExtra("SELECTED_SONG_ARTIST", mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ARTIST)));
				intent.putExtra("SELECTED_SONG_ALBUM", mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ALBUM)));
				intent.putExtra("SELECTED_SONG_ALBUM_ARTIST",  mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ALBUM_ARTIST)));
				intent.putExtra("SONG_SELECTED_INDEX", 0);
				intent.putExtra("SELECTED_SONG_DATA_URI", mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH)));
				intent.putExtra("SELECTED_SONG_GENRE", mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_GENRE)));
				intent.putExtra("NEW_PLAYLIST", true);
				intent.putExtra("NUMBER_SONGS", mCursor.getCount());
				intent.putExtra("CALLED_FROM_FOOTER", false);
				intent.putExtra(Common.CURRENT_LIBRARY, mApp.getCurrentLibrary());
				
			} else {
				Toast.makeText(mContext, R.string.error_occurred, Toast.LENGTH_LONG).show();
				break;
			}
			
			mFragment.getActivity().startActivity(intent);
			mFragment.getActivity().overridePendingTransition(R.anim.slide_in_from_right, R.anim.slide_out_to_left);
    		break;
    	case 1:
    		int numberOfSongs = mCursor.getCount();
    		String toastMessage = "";
    		if (numberOfSongs==1) {
    			if (mPlayNext) {
    				toastMessage = mPlayingNext + " " + mContext.getResources().getString(R.string.will_be_played_next);
    			} else {
    				toastMessage = numberOfSongs + " " + mContext.getResources().getString(R.string.song_enqueued_toast);
    			}
    			
    		} else {
    			if (mPlayNext) {
    				toastMessage = mPlayingNext + " " + mContext.getResources().getString(R.string.will_be_played_next);
    			} else {
    				toastMessage = numberOfSongs + " " + mContext.getResources().getString(R.string.songs_enqueued_toast);
    			}
    			
    		}
    		
    		Toast.makeText(mContext, toastMessage, Toast.LENGTH_SHORT).show();
    		break;
    	}
    	
    }

    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
		
		//Send out a broadcast that loads the new queue across the app.
		Intent intent = new Intent("com.jams.music.player.NEW_SONG_UPDATE_UI");
		intent.putExtra("MESSAGE", "com.jams.music.player.NEW_SONG_UPDATE_UI");
		intent.putExtra("INIT_QUEUE_DRAWER_ADAPTER", true);
		
    	//Start preparing the next song if the current song is the last track.
		if (mApp.getService().getCurrentSongIndex()==(originalPlaybackIndecesSize - 1)) {

			//Check if the service is running.
			if (mApp.isServiceRunning()) {
				mApp.getService().prepareAlternateMediaPlayer();
				
			}
			
		}
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import android.content.Context;
import android.database.Cursor;
import android.os.AsyncTask;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Utils.Common;

public class AsyncApplyEQToAlbumTask extends AsyncTask<String, Void, Void> {
	
    private Context mContext;
    private Common mApp;
	private String titleAlbum = "";
    
	private int mFiftyHertzLevel; 
	private int mOneThirtyHertzLevel; 
	private int mThreeTwentyHertzLevel; 
	private int mEightHundredHertzLevel; 
	private int mTwoKilohertzLevel; 
	private int mFiveKilohertzLevel; 
	private int mTwelvePointFiveKilohertzLevel; 
	private int mVirtualizerLevel; 
    private int mBassBoostLevel; 
    private int mReverbSetting;
	
    public AsyncApplyEQToAlbumTask(Context context, 
    							   String albumName, 
    							   int fiftyHertzLevel, 
    							   int oneThirtyHertzLevel, 
    							   int threeTwentyHertzLevel, 
    							   int eightHundredHertzLevel, 
    							   int twoKilohertzLevel, 
    							   int fiveKilohertzLevel, 
    							   int twelvePointFiveKilohertzLevel, 
    							   int virtualizerLevel, 
    							   int bassBoostLevel, 
    							   int reverbSetting) {
    	
    	mContext = context.getApplicationContext();
    	mApp = (Common) mContext;
    	titleAlbum = albumName;
    	
    	mFiftyHertzLevel = fiftyHertzLevel;
        mOneThirtyHertzLevel = oneThirtyHertzLevel;
        mThreeTwentyHertzLevel = threeTwentyHertzLevel;
        mEightHundredHertzLevel = eightHundredHertzLevel;
        mTwoKilohertzLevel = twoKilohertzLevel;
        mFiveKilohertzLevel = fiveKilohertzLevel;
        mTwelvePointFiveKilohertzLevel = twelvePointFiveKilohertzLevel;
        mVirtualizerLevel = virtualizerLevel;
        mBassBoostLevel = bassBoostLevel;
        mReverbSetting = reverbSetting;
    	
    }
    
    protected void onPreExecute() {
    	Toast.makeText(mContext, R.string.applying_equalizer, Toast.LENGTH_SHORT).show();
    	
    }
 
    @Override
    protected Void doInBackground(String... params) {
    	
    	int which = Integer.parseInt(params[0]);
    	
        //Get a cursor with the list of all albums.
        final Cursor cursor = mApp.getDBAccessHelper().getAllUniqueAlbums("");
    	
        //Get a list of all songs in the album.
		cursor.moveToPosition(which);
		String albumName = cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ALBUM));
		String artistName = cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ARTIST));
		
		Cursor songsCursor = mApp.getDBAccessHelper().getAllSongsInAlbum(albumName, artistName);
		
		//Loop through the songs and add them to the EQ settings DB with the current EQ settings.
		if (songsCursor!=null && songsCursor.getCount() > 0) {
			
			for (int j=0; j < songsCursor.getCount(); j++) {
				songsCursor.moveToPosition(j);
				String songId = songsCursor.getString(songsCursor.getColumnIndex(DBAccessHelper.SONG_ID));
				
				saveSettingsToDB(songId);
				
			}
			
		}
		
		cursor.close();
		songsCursor.close();
    	
    	return null;
	    
    }
    
	/** 
	 * Commit the settings to the database 
	 */
    public void saveSettingsToDB(String songId) {
    	
		//Check if a database entry already exists for this song.
		if (mApp.getDBAccessHelper().hasEqualizerSettings(songId)==false) {
			//Add a new DB entry.
			mApp.getDBAccessHelper().addSongEQValues(songId,
													 mFiftyHertzLevel, 
													 mOneThirtyHertzLevel, 
													 mThreeTwentyHertzLevel, 
													 mEightHundredHertzLevel, 
													 mTwoKilohertzLevel, 
													 mFiveKilohertzLevel,
													 mTwelvePointFiveKilohertzLevel,
													 mVirtualizerLevel, 
													 mBassBoostLevel, 
													 mReverbSetting);
		} else {
			//Update the existing entry.
			mApp.getDBAccessHelper().updateSongEQValues(songId, 
													    mFiftyHertzLevel, 
													    mOneThirtyHertzLevel, 
													    mThreeTwentyHertzLevel, 
													    mEightHundredHertzLevel, 
													    mTwoKilohertzLevel, 
													    mFiveKilohertzLevel,
													    mTwelvePointFiveKilohertzLevel,
													    mVirtualizerLevel, 
													    mBassBoostLevel, 
													    mReverbSetting);
			
		}

    }

    @Override
    protected void onPostExecute(Void arg0) {
    	Toast.makeText(mContext, 
    				   mContext.getResources().getString(R.string.equalizer_applied_to_songs_in) + " " + titleAlbum + ".", 
    				   Toast.LENGTH_SHORT).show();
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import android.content.Context;
import android.database.Cursor;
import android.os.AsyncTask;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.EqualizerActivity.EqualizerActivity;
import com.jams.music.player.Utils.Common;

public class AsyncApplyEQToAllSongsTask extends AsyncTask<String, Void, Void> {
	
    private Context mContext;
    private Common mApp;
    private EqualizerActivity mEqualizerFragment;
    
    public AsyncApplyEQToAllSongsTask(Context context, EqualizerActivity fragment) {
    	mContext = context;
    	mEqualizerFragment = fragment;
    	mApp = (Common) context.getApplicationContext();
    }
    
    protected void onPreExecute() {
		Toast.makeText(mContext, R.string.applying_equalizer_to_all_songs, Toast.LENGTH_SHORT).show();

    }
 
    @Override
    protected Void doInBackground(String... params) {
    	
		//Get a cursor with all the songs in the library.
		Cursor songsCursor = mApp.getDBAccessHelper().getAllSongs();
    	
		//Loop through the songs and add them to the EQ settings DB with the current EQ settings.
		if (songsCursor!=null && songsCursor.getCount() > 0) {
			
			for (int j=0; j < songsCursor.getCount(); j++) {
				songsCursor.moveToPosition(j);

				String songId = songsCursor.getString(songsCursor.getColumnIndex(DBAccessHelper.SONG_ID));
				mEqualizerFragment.setEQValuesForSong(songId);

			}

		}
    	
		if (songsCursor!=null)
			songsCursor.close();
		
    	return null;
	    
    }

    @Override
    protected void onPostExecute(Void arg0) {
		Toast.makeText(mContext, R.string.equalizer_applied_to_all_songs, Toast.LENGTH_SHORT).show();
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import android.content.Context;
import android.database.Cursor;
import android.os.AsyncTask;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Utils.Common;

public class AsyncApplyEQToArtistTask extends AsyncTask<String, Void, Void> {
	
    private Context mContext;
    private Common mApp;
    private String mArtist;
    
	int mFiftyHertzLevel; 
    int mOneThirtyHertzLevel; 
    int mThreeTwentyHertzLevel; 
    int mEightHundredHertzLevel; 
    int mTwoKilohertzLevel; 
    int mFiveKilohertzLevel; 
    int mTwelvePointFiveKilohertzLevel; 
    int mVirtualizerLevel; 
    int mBassBoostLevel; 
    int mReverbSetting;
	
    public AsyncApplyEQToArtistTask(Context context, 
    								String artistName, 
    								int fiftyHertzLevel, 
     							   	int oneThirtyHertzLevel, 
     							   	int threeTwentyHertzLevel, 
     							   	int eightHundredHertzLevel, 
     							   	int twoKilohertzLevel, 
     							   	int fiveKilohertzLevel, 
     							   	int twelvePointFiveKilohertzLevel, 
     							   	int virtualizerLevel, 
     							   	int bassBoostLevel, 
     							   	int reverbSetting) {
    	
    	mContext = context;
    	mApp = (Common) mContext.getApplicationContext();
    	mArtist = artistName;
    	
    	mFiftyHertzLevel = fiftyHertzLevel;
        mOneThirtyHertzLevel = oneThirtyHertzLevel;
        mThreeTwentyHertzLevel = threeTwentyHertzLevel;
        mEightHundredHertzLevel = eightHundredHertzLevel;
        mTwoKilohertzLevel = twoKilohertzLevel;
        mFiveKilohertzLevel = fiveKilohertzLevel;
        mTwelvePointFiveKilohertzLevel = twelvePointFiveKilohertzLevel;
        mVirtualizerLevel = virtualizerLevel;
        mBassBoostLevel = bassBoostLevel;
        mReverbSetting = reverbSetting;
        
    }
 
    @Override
    public void onPreExecute() {
    	super.onPreExecute();
    	Toast.makeText(mContext, R.string.applying_equalizer, Toast.LENGTH_SHORT).show();
    }
    
    @Override
    protected Void doInBackground(String... params) {
    	
		Cursor songsCursor = mApp.getDBAccessHelper().getAllSongsByArtist(mArtist);
		
		//Loop through the songs and add them to the EQ settings DB with the current EQ settings.
		if (songsCursor!=null && songsCursor.getCount() > 0) {
			
			for (int j=0; j < songsCursor.getCount(); j++) {
				songsCursor.moveToPosition(j);
				
				String songId = songsCursor.getString(songsCursor.getColumnIndex(DBAccessHelper.SONG_ID));
				saveSettingsToDB(songId);
				
			}
			
		}

		if (songsCursor!=null)
			songsCursor.close();
		
    	return null;
	    
    }
    
	/**
	 * Commit the settings to the database 
	 */
    public void saveSettingsToDB(String songId) {
		
		//Check if a database entry already exists for this song.
		if (mApp.getDBAccessHelper().hasEqualizerSettings(songId)==false) {
			
			//Add a new DB entry.
			mApp.getDBAccessHelper().addSongEQValues(songId,
												 	 mFiftyHertzLevel, 
												 	 mOneThirtyHertzLevel, 
												 	 mThreeTwentyHertzLevel, 
												 	 mEightHundredHertzLevel, 
												 	 mTwoKilohertzLevel, 
												 	 mFiveKilohertzLevel,
												 	 mTwelvePointFiveKilohertzLevel,
												 	 mVirtualizerLevel, 
												 	 mBassBoostLevel, 
												 	 mReverbSetting);
		} else {
			//Update the existing entry.
			mApp.getDBAccessHelper().updateSongEQValues(songId,
												 	    mFiftyHertzLevel, 
												 	    mOneThirtyHertzLevel, 
												 	    mThreeTwentyHertzLevel, 
												 	    mEightHundredHertzLevel, 
												 	    mTwoKilohertzLevel, 
												 	    mFiveKilohertzLevel,
												 	    mTwelvePointFiveKilohertzLevel,
												 	    mVirtualizerLevel, 
												 	    mBassBoostLevel, 
												 	    mReverbSetting);
		}

    }
    
    @Override
    protected void onPostExecute(Void arg0) {
    	Toast.makeText(mContext, 
    				   mContext.getResources().getString(R.string.equalizer_applied_to_songs_by) + " " + mArtist + ".", 
    				   Toast.LENGTH_SHORT).show();
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import android.content.Context;
import android.database.Cursor;
import android.os.AsyncTask;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Utils.Common;

public class AsyncApplyEQToGenreTask extends AsyncTask<String, Void, Void> {
	
    private Context mContext;
	private Common mApp;
    
	private String titleGenre = "";
    private int mFiftyHertzLevel; 
    private int mOneThirtyHertzLevel; 
    private int mThreeTwentyHertzLevel; 
    private int mEightHundredHertzLevel; 
    private int mTwoKilohertzLevel; 
    private int mFiveKilohertzLevel; 
    private int mTwelvePointFiveKilohertzLevel; 
    private int mVirtualizerLevel; 
    private int mBassBoostLevel; 
    private int mReverbSetting;
	
    public AsyncApplyEQToGenreTask(Context context, 
    							   String genreName,
    							   int fiftyHertzLevel, 
    							   int oneThirtyHertzLevel, 
    							   int threeTwentyHertzLevel, 
    							   int eightHundredHertzLevel, 
    							   int twoKilohertzLevel, 
    							   int fiveKilohertzLevel, 
    							   int twelvePointFiveKilohertzLevel, 
    							   int virtualizerLevel, 
    							   int bassBoostLevel, 
    							   int reverbSetting) {
    	
    	mContext = context.getApplicationContext();
    	mApp = (Common) mContext;
    	titleGenre = genreName;
    	
    	mFiftyHertzLevel = fiftyHertzLevel;
        mOneThirtyHertzLevel = oneThirtyHertzLevel;
        mThreeTwentyHertzLevel = threeTwentyHertzLevel;
        mEightHundredHertzLevel = eightHundredHertzLevel;
        mTwoKilohertzLevel = twoKilohertzLevel;
        mFiveKilohertzLevel = fiveKilohertzLevel;
        mTwelvePointFiveKilohertzLevel = twelvePointFiveKilohertzLevel;
        mVirtualizerLevel = virtualizerLevel;
        mBassBoostLevel = bassBoostLevel;
        mReverbSetting = reverbSetting;
    	
    }
    
    @Override
    protected void onPreExecute() {
    	super.onPreExecute();
    	Toast.makeText(mContext, R.string.applying_equalizer, Toast.LENGTH_SHORT).show();
    }
 
    @Override
    protected Void doInBackground(String... params) {
    	
    	int which = Integer.parseInt(params[0]);
    	
        //Get a cursor with the list of all genres.
        final Cursor cursor = mApp.getDBAccessHelper().getAllUniqueGenres("");
        cursor.moveToPosition(which);
        String selectedGenre = cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_GENRE));
        cursor.close();

        String genreQuery = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'"+selectedGenre+"'";

        //Get a cursor with all the songs in the specified genre.
        final Cursor songsCursor = mApp.getDBAccessHelper().getAllSongsInGenre(genreQuery);
		
		//Loop through the songs in the genre and add them to the EQ settings DB with the current EQ settings.
		if (songsCursor!=null && songsCursor.getCount() > 0) {

			for (int j=0; j < songsCursor.getCount(); j++) {
				songsCursor.moveToPosition(j);
				
				String songId = songsCursor.getString(songsCursor.getColumnIndex(DBAccessHelper.SONG_ID));
				saveSettingsToDB(songId);
				
			}
			
		}
    	
		songsCursor.close();
    	return null;
	    
    }
    
    /** 
     * Commit the settings to the database.
     */
    public void saveSettingsToDB(String songId) {
    
		//Check if a database entry already exists for this song.
		if (mApp.getDBAccessHelper().hasEqualizerSettings(songId)==false) {
			//Add a new DB entry.
			mApp.getDBAccessHelper().addSongEQValues(songId,
												     mFiftyHertzLevel, 
												     mOneThirtyHertzLevel, 
												     mThreeTwentyHertzLevel, 
												     mEightHundredHertzLevel, 
												     mTwoKilohertzLevel, 
												     mFiveKilohertzLevel,
												     mTwelvePointFiveKilohertzLevel,
												     mVirtualizerLevel, 
												     mBassBoostLevel, 
												     mReverbSetting);
		} else {
			//Update the existing entry.
			mApp.getDBAccessHelper().updateSongEQValues(songId,
												 	    mFiftyHertzLevel, 
												 	    mOneThirtyHertzLevel, 
												 	    mThreeTwentyHertzLevel, 
												 	    mEightHundredHertzLevel, 
												 	    mTwoKilohertzLevel, 
												 	    mFiveKilohertzLevel,
												 	    mTwelvePointFiveKilohertzLevel,
												 	    mVirtualizerLevel, 
												 	    mBassBoostLevel, 
												 	    mReverbSetting);
		}

    }

    @Override
    protected void onPostExecute(Void params) {
	   	Toast.makeText(mContext, 
	 				   mContext.getResources().getString(R.string.equalizer_applied_to_songs_in) + " " + titleGenre + ".", 
	 				   Toast.LENGTH_SHORT).show();

	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import android.app.ProgressDialog;
import android.content.Context;
import android.os.AsyncTask;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.EqualizerActivity.EqualizerActivity;

public class AsyncApplyEQToPlaylistTask extends AsyncTask<String, Void, Boolean> {
    private Context mContext;
    private EqualizerActivity mEqualizerFragment;
    private ProgressDialog pd;
    
	int max = 10000;
	int progressIncrement;
	int progress = 0;
	String songTitle = "";
	String songArtist = "";
	String titlePlaylist = "";
    String songAlbum = "";
	
    public AsyncApplyEQToPlaylistTask(Context context, EqualizerActivity fragment, String playlistName) {
    	mContext = context;
    	mEqualizerFragment = fragment;
    	titlePlaylist = playlistName;
    	
    }
    
    protected void onPreExecute() {
		pd = new ProgressDialog(mContext);
		pd.setIndeterminate(false);
		pd.setMax(max);
		pd.setCancelable(false);
		pd.setTitle(mContext.getResources().getString(R.string.applying_equalizer_to) + " " + titlePlaylist);
		pd.show();
    	
    }
 
    @Override
    protected Boolean doInBackground(String... params) {
    	
    	/*int which = Integer.parseInt(params[0]);
    	
        //Get a cursor with the list of all user-created playlists.
        DBAccessHelper dbHelper = new DBAccessHelper(mContext);
        final Cursor cursor = dbHelper.getAllUniqueUserPlaylists();
    	
        //Get the file path of the selected playlist.
		cursor.moveToPosition(which);
		String playlistFilePath = cursor.getString(cursor.getColumnIndex(DBAccessHelper.PLAYLIST_FILE_PATH));
		cursor.close();
		
		//Get a list of all songs in the playlist.
		Cursor playlistCursor = dbHelper.getPlaylistByFilePath(playlistFilePath);
		String songFilePath = "";
		
		//Loop through the songs and add them to the EQ settings DB with the current EQ settings.
		if (playlistCursor!=null && playlistCursor.getCount() > 0) {
			
			MediaMetadataRetriever mmdr = new MediaMetadataRetriever();
			songTitle = "";
			songAlbum = "";
			String songArtist = "";
			for (int j=0; j < playlistCursor.getCount(); j++) {
				playlistCursor.moveToPosition(j);
				songFilePath = playlistCursor.getString(playlistCursor.getColumnIndex(DBAccessHelper.PLAYLIST_SONG_FILE_PATH));
				
				try {
					mmdr.setDataSource(songFilePath);
				} catch (Exception e) {
					return false;
				}
				
				songTitle = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE);
				songAlbum = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);
				songArtist = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);	
				
				mEqualizerFragment.saveSettingsToDB(songTitle, songAlbum, songArtist);
				publishProgress();
				
			}
			
		}
    	
		playlistCursor.close();*/
    	return true;
	    
    }
    
    @Override
    protected void onProgressUpdate(Void... v) {
		//Update the progress on the progress dialog.
		progress = progress + progressIncrement;
		pd.setProgress(progress);
		pd.setMessage(mContext.getResources().getString(R.string.applying_to) + " " + songTitle);
    	
    }

    @Override
    protected void onPostExecute(Boolean successStatus) {
    	pd.dismiss();
    	
    	if (successStatus==true) {
        	Toast.makeText(mContext, 
		 				   mContext.getResources().getString(R.string.equalizer_applied_to_songs_in) + " " + titlePlaylist + ".", 
		 				   Toast.LENGTH_LONG).show();
    	} else {
        	Toast.makeText(mContext, R.string.error_occurred, Toast.LENGTH_LONG).show();
    	}
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.audio.exceptions.CannotReadException;
import org.jaudiotagger.audio.exceptions.CannotWriteException;
import org.jaudiotagger.audio.exceptions.InvalidAudioFrameException;
import org.jaudiotagger.audio.exceptions.ReadOnlyFileException;
import org.jaudiotagger.tag.FieldKey;
import org.jaudiotagger.tag.Tag;
import org.jaudiotagger.tag.TagException;
import org.jaudiotagger.tag.images.Artwork;
import org.jaudiotagger.tag.images.ArtworkFactory;

import android.app.Activity;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.ProgressDialog;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.os.AsyncTask;
import android.os.Environment;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Services.AutoFetchAlbumArtService;
import com.jams.music.player.Utils.Common;

/*********************************************************************
 * This class is different from AsyncGetAlbumArtTask. It includes an 
 * additional search functionality that scans the ENTIRE library,
 * checks for missing art, and then downloads them.
 *********************************************************************/
public class AsyncAutoGetAlbumArtTask extends AsyncTask<String, String, Void> {
	
    private Context mContext;
    private Common mApp;
    private Activity mActivity;
    private SharedPreferences sharedPreferences;
    private AsyncTask<String, String, Void> task;
    private String artworkURL;
    private Bitmap artworkBitmap;
    private byte[] buffer;
    private AudioFile audioFile;
    private File file;
    private DBAccessHelper dbHelper;
    
    private ProgressDialog pd;
    private int currentProgress = 0;
    private boolean DIALOG_VISIBLE = true;
    
	public static ArrayList<String> dataURIsList = new ArrayList<String>();
	public static ArrayList<String> artistsList = new ArrayList<String>();
	public static ArrayList<String> albumsList = new ArrayList<String>();
    
    public AsyncAutoGetAlbumArtTask(Context context, Activity activity) {
    	mContext = context;
        mApp = (Common) context.getApplicationContext();
    	mActivity = activity;
    	sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    	task = this;
    	dbHelper = new DBAccessHelper(mContext);
    }
    
    public void onPreExecute() {
    	super.onPreExecute();
    	
    	pd = new ProgressDialog(mActivity);
    	pd.setTitle(R.string.downloading_album_art);
    	pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
    	pd.setCancelable(false);
    	pd.setCanceledOnTouchOutside(false);
    	pd.setMessage(mContext.getResources().getString(R.string.scanning_for_missing_art));
    	pd.setButton(DialogInterface.BUTTON_NEGATIVE, 
    				 mContext.getResources().getString(R.string.cancel),
    				 new OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							dialog.dismiss();
							task.cancel(true);
							
						}
    		
    	});
    	
    	pd.show();	
    	
    }
 
    @Override
    protected Void doInBackground(String... params) {

    	//First, we'll go through all the songs in the music library DB and get their attributes.
    	dbHelper = new DBAccessHelper(mContext);
    	String selection = DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    	String[] projection = { DBAccessHelper._ID, 
    							DBAccessHelper.SONG_FILE_PATH,
    							DBAccessHelper.SONG_ALBUM,
    							DBAccessHelper.SONG_ARTIST, 
    							DBAccessHelper.SONG_TITLE };
    	
    	Cursor cursor = dbHelper.getWritableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
				    										 projection, 
				    										 selection, 
				    										 null, 
				    										 null, 
				    										 null, 
				    										 null);
    	
    	if (cursor.getCount()!=0) {
    		
    		cursor.moveToFirst();
    		dataURIsList.add(cursor.getString(1));
    		albumsList.add(cursor.getString(2));
    		artistsList.add(cursor.getString(3));
    		
    		while(cursor.moveToNext()) {
    			
    			dataURIsList.add(cursor.getString(1));
        		albumsList.add(cursor.getString(2));
        		artistsList.add(cursor.getString(3));
    		}
    		
    	} else {
    		//The user doesn't have any music so let's get outta here.
    		return null;
    	}
    	
    	pd.setMax(dataURIsList.size());
    	    	
    	//Now that we have the attributes of the songs, we'll go through them each and check for missing covers.
    	for (int i=0; i < dataURIsList.size(); i++) {
    		
    		try {
    			file = new File(dataURIsList.get(i));
    		} catch (Exception e) {
    			continue;
    		}

    		audioFile = null;
			try {
				audioFile = AudioFileIO.read(file);
			} catch (CannotReadException e2) {
				// TODO Auto-generated catch block
				continue;
			} catch (IOException e2) {
				// TODO Auto-generated catch block
				continue;
			} catch (TagException e2) {
				// TODO Auto-generated catch block
				continue;
			} catch (ReadOnlyFileException e2) {
				// TODO Auto-generated catch block
				continue;
			} catch (InvalidAudioFrameException e2) {
				// TODO Auto-generated catch block
				continue;
			}
			
    		Tag tag = audioFile.getTag();
    		
	        //Set the destination directory for the xml file.
	        File SDCardRoot = Environment.getExternalStorageDirectory();
	        File xmlFile = new File(SDCardRoot,"albumArt.xml");
    		
	        if (tag!=null) {
	        	
    			String title = tag.getFirst(FieldKey.TITLE);
        		String checkingMessage = mContext.getResources().getString(R.string.checking_if)
        							   + " " 
        							   + title 
        							   + " " 
        							   + mContext.getResources().getString(R.string.has_album_art)
        							   + ".";
        		
        		currentProgress = currentProgress + 1;
	    		String[] checkingProgressParams = { checkingMessage, "" + currentProgress };
	    		publishProgress(checkingProgressParams);
	        	
	        	List<Artwork> artworkList = tag.getArtworkList();
	        	
	    		if (artworkList.size()==0) {

	    			//Since the file doesn't have any album artwork, we'll have to download it.
	    			//Get the artist and album name of the file we're working with.
	    			String artist = tag.getFirst(FieldKey.ARTIST);
	    			String album = tag.getFirst(FieldKey.ALBUM);
	    			
	    			//Update the progress dialog.
	    			String message = mContext.getResources().getString(R.string.downloading_artwork_for) + " " + title;
	    			String[] progressParams = { message, "" + currentProgress };
	    			publishProgress(progressParams);
	    			
	    			//Remove any unacceptable characters.
	    			if (artist.contains("#")) {
	    				artist = artist.replace("#", "");
	    			}
	    			
	    			if (artist.contains("$")) {
	    				artist = artist.replace("$", "");
	    			}
	    			
	    			if (artist.contains("@")) {
	    				artist = artist.replace("@", "");
	    			}
	    			
	    			if (album.contains("#")) {
	    				album = album.replace("#", "");
	    			}
	    			
	    			if (album.contains("$")) {
	    				album = album.replace("$", "");
	    			}
	    			
	    			if (album.contains("@")) {
	    				album = album.replace("@", "");
	    			}
	    			
	    			//Replace any spaces in the artist and album fields with "%20".
	    			if (artist.contains(" ")) {
	    				artist = artist.replace(" ", "%20");
	    			}
	    			
	    			if (album.contains(" ")) {
	    				album = album.replace(" ", "%20");
	    			}
	    			
	    	    	//Construct the url for the HTTP request.
	    	    	URL url = null;
	    			try {
	    				url = new URL("http://itunes.apple.com/search?term=" + artist + "+" + album + "&entity=album");
	    			} catch (MalformedURLException e1) {
	    				// TODO Auto-generated catch block
	    				continue;
	    			}
	    
	    			String xml = null;
	    	    	try {
	    	    		
	    		    	//Create a new HTTP connection.
	    		        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
	    		
	    		        urlConnection.connect();
	    		        
	    		        //Check if albumArt.xml already exists and delete it.
	    		        if (xmlFile.exists()) {
	    		        	xmlFile.delete();
	    		        }
	    		        
	    		        //Create the OuputStream that will be used to store the downloaded data into the file.
	    		        FileOutputStream fileOutput = new FileOutputStream(xmlFile);
	    		
	    		        //Create the InputStream that will read the data from the HTTP connection.
	    		        InputStream inputStream = urlConnection.getInputStream();
	    		        
	    		        //Total size of target file.
	    		        int totalSize = urlConnection.getContentLength();
	    		
	    		        //Temp variable that stores the number of downloaded bytes.
	    		        int downloadedSize = 0;
	    		
	    		        //Create a buffer to store the downloaded bytes.
	    		        buffer = new byte[1024];
	    		        int bufferLength = 0;

	    		        //Now read through the buffer and write the contents to the file.
	    		        while((bufferLength = inputStream.read(buffer)) > 0 ) {
	    		            fileOutput.write(buffer, 0, bufferLength);
	    		            downloadedSize += bufferLength;
	    		
	    		        }
	    		        
	    		        //Close the File Output Stream.
	    		        fileOutput.close();

	    	    	} catch (MalformedURLException e) {
	    	    		//TODO Auto-generated method stub
	    	    		continue;
	    	    	} catch (IOException e) {
	    	    		// TODO Auto-generated method stub
	    	    		continue;
	    	    	}
	    	    	
	    	    	//Load the XML file into a String variable for local use.
	    	    	String xmlAsString = null;
	    			try {
	    				xmlAsString = FileUtils.readFileToString(xmlFile);
	    			} catch (IOException e) {
	    				// TODO Auto-generated catch block
	    				e.printStackTrace();
	    			}
	    			
	    			//Extract the albumArt parameter from the XML file.
	    			artworkURL = StringUtils.substringBetween(xmlAsString, "\"artworkUrl100\":\"", "\",");
	    	    	
	    			if (artworkURL==null) {
	    				
	    				//Check and see if a lower resolution image available.
	    				artworkURL = StringUtils.substringBetween(xmlAsString, "\"artworkUrl60\":\"", "\",");
	    				
	    				if (artworkURL==null) {
	    					//Can't do anything about that here.
	    				} else {
	    					//Replace "100x100" with "600x600" to retrieve larger album art images.
	    					artworkURL = artworkURL.replace("100x100", "600x600");
	    				}
	    		    	
	    			} else {
	    				//Replace "100x100" with "600x600" to retrieve larger album art images.
	    				artworkURL = artworkURL.replace("100x100", "600x600");
	    			}
	    			
	    			//If no URL has been found, there's no point in continuing.
	    			if (artworkURL!=null) {
	    				
	        			artworkBitmap = null;
	        			artworkBitmap = mApp.getImageLoader().loadImageSync(artworkURL);
	        			
	    	    		File artworkFile = new File(Environment.getExternalStorageDirectory() + "/artwork.jpg");
	        			
	        	    	//Save the artwork.
	        	    	try {
	        	    		
	        	    		FileOutputStream out = new FileOutputStream(artworkFile);
	     	    	       	artworkBitmap.compress(Bitmap.CompressFormat.JPEG, 90, out);
	    					
	        	    	} catch (Exception e) {
	        	    		e.printStackTrace();
	        	    	} finally {
	        	    		
	        	    		Artwork artwork = null;
	    					try {
	    						artwork = ArtworkFactory.createArtworkFromFile(artworkFile);
	    					} catch (IOException e) {
	    						// TODO Auto-generated catch block
	    						setArtworkAsFile(artworkFile, dataURIsList.get(i));
								continue;
	    					} catch (ArrayIndexOutOfBoundsException e) {
	    						// TODO Auto-generated catch block
	    						setArtworkAsFile(artworkFile, dataURIsList.get(i));
								continue;
	    					} catch (Exception e) {
	    						e.printStackTrace();
	    						setArtworkAsFile(artworkFile, dataURIsList.get(i));
								continue;
	    					} catch (Error e) {
								e.printStackTrace();
								setArtworkAsFile(artworkFile, dataURIsList.get(i));
								continue;
							}
	    					
	    					if (artwork!=null) {
	    						
	        		    		try {
	        						//Remove the current artwork field and recreate it.
	        		    			tag.deleteArtworkField();
	        		    			tag.addField(artwork);
	        					} catch (Exception e) {
	        						// TODO Auto-generated catch block
	        						setArtworkAsFile(artworkFile, dataURIsList.get(i));
									continue;
	        					} catch (Error e) {
	    							e.printStackTrace();
	    							setArtworkAsFile(artworkFile, dataURIsList.get(i));
	    							continue;
	    						}
	        		    		
	        		    		try {
	        						audioFile.commit();
	        					} catch (CannotWriteException e) {
	        						// TODO Auto-generated catch block
	        						setArtworkAsFile(artworkFile, dataURIsList.get(i));
									continue;
	        					} catch (Error e) {
	    							e.printStackTrace();
	    							setArtworkAsFile(artworkFile, dataURIsList.get(i));
	    							continue;
	    						}
	    						
	    					}
	    					
	            	    	//Delete the temporary files that we stored during the fetching process.
	    		    		if (artworkFile.exists()) {
	    		    			artworkFile.delete();
	    		    		}
	    		    		
	    		    		if (xmlFile.exists()) {
	    		    			xmlFile.delete();
	    		    		}
	    	    	    	
	    		    		//Set the files to null to help clean up memory.
	    		    		artworkBitmap = null;
	    		    		audioFile = null;
	    		    		tag = null;
	    		    		xmlFile = null;
	    		    		artworkFile = null;
	    		    		
	    	    		}

	    			}

	    		}
	        	
	        }
    		
    	}
    	
    	audioFile = null;
    	file = null;
    	//System.gc();
    	
    	return null;
	    
    }
    
  //Saves the artwork as a JPEG file in the song's parent folder.
    public void setArtworkAsFile(File artworkFile, String songFilePath) {

    	File songFile = new File(songFilePath);
    	String songTitle = songFile.getName();
    	int lastDotSlash = songTitle.lastIndexOf(".");
    	String albumArtFileName = songTitle.substring(0, lastDotSlash);
    	
    	if (songFile.exists()) {
    		int lastSlashIndex = songFilePath.lastIndexOf("/");
    		String folderPath = songFilePath.substring(0, lastSlashIndex);
    		File destFile = new File(folderPath + "/" + albumArtFileName + ".jpg");
    		
    		try {
				FileUtils.copyFile(artworkFile, destFile);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				return;
			}
    		
    		//Update the album art tag in Jams' database.
			ContentValues values = new ContentValues();
			songFilePath = songFilePath.replace("'", "''");
			String where = DBAccessHelper.SONG_FILE_PATH + "=" + "'" + songFilePath + "'";
			values.put(DBAccessHelper.SONG_ALBUM_ART_PATH, folderPath + "/" + albumArtFileName + ".jpg");
			dbHelper.getWritableDatabase().update(DBAccessHelper.MUSIC_LIBRARY_TABLE, values, where, null);
    		
    	}

    }
    
    @Override
    public void onProgressUpdate(String... values) {
    	super.onProgressUpdate(values);
    	
    	if (DIALOG_VISIBLE==true) {
    		pd.setProgress(Integer.parseInt(values[1]));
    		pd.setMessage(values[0]);
    	}
    	
    	//Update the notification.
    	AutoFetchAlbumArtService.builder.setContentTitle(mContext.getResources().getString(R.string.downloading_missing_cover_art));
    	AutoFetchAlbumArtService.builder.setSmallIcon(R.drawable.notif_icon);
    	AutoFetchAlbumArtService.builder.setContentInfo(null);
    	AutoFetchAlbumArtService.builder.setContentText(null);
    	AutoFetchAlbumArtService.builder.setProgress(dataURIsList.size(), currentProgress, false);
    	AutoFetchAlbumArtService.notification = AutoFetchAlbumArtService.builder.build();

    	NotificationManager notifyManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    	notifyManager.notify(AutoFetchAlbumArtService.NOTIFICATION_ID, AutoFetchAlbumArtService.notification);
    	
    }

    @Override
    protected void onPostExecute(Void arg0) {
		
    	Intent intent = new Intent(mContext, AutoFetchAlbumArtService.class);
    	mContext.stopService(intent);
    	
    	if (pd.isShowing() && DIALOG_VISIBLE==true) {
    		pd.dismiss();
    	}
    	
    	//Dismiss the notification.
    	AutoFetchAlbumArtService.builder.setTicker(mContext.getResources().getString(R.string.done_downloading_art));
    	AutoFetchAlbumArtService.builder.setContentTitle(mContext.getResources().getString(R.string.done_downloading_art));
    	AutoFetchAlbumArtService.builder.setSmallIcon(R.drawable.notif_icon);
    	AutoFetchAlbumArtService.builder.setContentInfo(null);
    	AutoFetchAlbumArtService.builder.setContentText(null);
    	AutoFetchAlbumArtService.builder.setProgress(0, 0, false);
    	AutoFetchAlbumArtService.notification = AutoFetchAlbumArtService.builder.build();
    	AutoFetchAlbumArtService.notification.flags = Notification.FLAG_AUTO_CANCEL;

    	NotificationManager notifyManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    	notifyManager.notify(AutoFetchAlbumArtService.NOTIFICATION_ID, AutoFetchAlbumArtService.notification);
    	
    	Toast.makeText(mContext, R.string.done_downloading_art, Toast.LENGTH_LONG).show();
    	
    	//Rescan for album art.
		//Seting the "RESCAN_ALBUM_ART" flag to true will force MainActivity to rescan the folders.
		sharedPreferences.edit().putBoolean("RESCAN_ALBUM_ART", true).commit();
		
		//Restart the app.
		final Intent i = mActivity.getBaseContext()
				                  .getPackageManager()
				                  .getLaunchIntentForPackage(mActivity.getBaseContext().getPackageName());
		
		i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
		mActivity.startActivity(i);
		mActivity.finish();
    	
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;
import java.util.ArrayList;

import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.tag.FieldKey;
import org.jaudiotagger.tag.Tag;

import android.content.Context;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.os.AsyncTask;

import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Utils.Common;

/*************************************************************
 * Builds an initial MatrixCursor with 5 entries/songs. This 
 * initial cursor is then returned to the service for playback. 
 * This AsyncTask then continues to add rows to the MatrixCursor 
 * and periodically updates the service with the new cursor.
 * This will allow NowPlayingActivity to load as quick as possible 
 * and build the MatrixCursor in the background.
 * 
 * @author Saravan Pantham
 *************************************************************/
public class AsyncBuildFoldersCursorTask extends AsyncTask<String, Integer, Boolean> {

	private Context mContext;
	private Common mApp;
	private ArrayList<String> mSongFilePathsList = new ArrayList<String>();
	
	public AsyncBuildFoldersCursorTask(Context context, ArrayList<String> songFilePathsList) {
		mContext = context;
		mApp = (Common) mContext;
		mSongFilePathsList = songFilePathsList;
	}
	
	@Override
	public void onPreExecute() {
		super.onPreExecute();
	}
	
	@Override
	protected Boolean doInBackground(String... params) {
		
		//We'll create a matrix cursor that includes all the audio files within the specified folder.
		String[] foldersCursorColumns = { DBAccessHelper.SONG_ARTIST,  
										  DBAccessHelper.SONG_ALBUM, 
										  DBAccessHelper.SONG_TITLE, 
										  DBAccessHelper.SONG_FILE_PATH,
										  DBAccessHelper.SONG_DURATION, 
										  DBAccessHelper.SONG_GENRE, 
										  DBAccessHelper.SONG_SOURCE, 
										  DBAccessHelper.SONG_ALBUM_ART_PATH, 
										  DBAccessHelper.SONG_ID, 
										  DBAccessHelper.LOCAL_COPY_PATH };
					    		
		MatrixCursor foldersCursor = new MatrixCursor(foldersCursorColumns);
		String artist = "";
		String album = "";
		String title = "";
		String filePath = "";
		String duration = "";
		String genre = "";
		String songSource = "LOCAL_FILE";
		String songAlbumArtPath = "";
		String songId = "";
		
		for (int i=0; i < mSongFilePathsList.size(); i++) {
			
			if (mSongFilePathsList.size() <= 5 && i==5) {
				mApp.getService().setCursor((Cursor) foldersCursor);
			}
			
			/*//Extract metadata from the file, (if it exists).
			try {
				mmdr.setDataSource(mSongFilePathsList.get(i));
			} catch (Exception e) {
				//Skip the audio file if we can't read it.
				continue;
			}
			
			artist = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);
			if (artist==null || artist.isEmpty()) {
				artist = "Unknown Artist";
			}
			
			album = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);
			if (album==null || album.isEmpty()) {
				album = "Unknown Album";
			}
			
			title = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE);
			if (title==null || title.isEmpty()) {
				title = mSongFilePathsList.get(i);
			}
			
			filePath = mSongFilePathsList.get(i);
			duration = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION);
			if (duration==null || duration.isEmpty()) {
				duration = "0";
			}
			
			genre = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_GENRE);
			if (genre==null || genre.isEmpty()) {
				genre = "Unknown Genre";
			}*/
			
			try {
				File file = new File(mSongFilePathsList.get(i));
    			AudioFile audioFile = AudioFileIO.read(file);
    			Tag tag = audioFile.getTag();
    			filePath = mSongFilePathsList.get(i);
    			
    			artist = tag.getFirst(FieldKey.ARTIST);
    			if (artist==null || artist.equals(" ") || artist.isEmpty()) {
    				artist = "Unknown Artist";
    			}
    			
    			album = tag.getFirst(FieldKey.ALBUM);
    			if (album==null || album.equals(" ") || album.isEmpty()) {
    				album = "Unknown Album";
    			}
    			
    			title = tag.getFirst(FieldKey.ARTIST);
    			if (title==null || title.equals(" ") || title.isEmpty()) {
    				title = filePath;
    			}
    			
    			duration = "" + audioFile.getAudioHeader().getTrackLength();
    			if (duration==null || duration.equals(" ") || duration.isEmpty()) {
    				duration = "0";
    			}
    			
    			genre = tag.getFirst(FieldKey.GENRE);
    			if (genre==null || genre.equals(" ") || genre.isEmpty()) {
    				genre = "Unknown Genre";
    			}
    			
    			foldersCursor.addRow(new Object[] { artist,
    												album,
    												title,
    												filePath,
    												duration,
    												genre,
    												songSource,
    												songAlbumArtPath,
    												songId, 
    												"" });
			} catch (Exception e) {
				e.printStackTrace();
				continue;
			}
			
		}
		
		//cursor = (Cursor) foldersCursor;
		mApp.getService().setCursor((Cursor) foldersCursor);
		
		return null;
	}
	
	@Override
	public void onProgressUpdate(Integer... values) {
		super.onProgressUpdate(values);
		
	}
	
	@Override
	public void onPostExecute(Boolean result) {
		super.onPostExecute(result);
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.media.MediaMetadataRetriever;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.PowerManager;
import android.provider.MediaStore;
import android.util.Log;
import android.widget.Toast;

import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.DBHelpers.MediaStoreAccessHelper;
import com.jams.music.player.FoldersFragment.FileExtensionFilter;
import com.jams.music.player.R;
import com.jams.music.player.Services.BuildMusicLibraryService;
import com.jams.music.player.Utils.Common;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;

/**
 * The Mother of all AsyncTasks in this app.
 *
 * @author Saravan Pantham
 */
public class AsyncBuildLibraryTask extends AsyncTask<String, String, Void> {

	private Context mContext;
	private Common mApp;
    private BuildMusicLibraryService mService;
	public ArrayList<OnBuildLibraryProgressUpdate> mBuildLibraryProgressUpdate;
	
	private String mCurrentTask = "";
	private int mOverallProgress = 0;
	private Date date = new Date();

	private String mMediaStoreSelection = null;
	private HashMap<String, String> mGenresHashMap = new HashMap<String, String>();
    private HashMap<String, Integer> mGenresSongCountHashMap = new HashMap<String, Integer>();
    private HashMap<String, Integer> mAlbumsCountMap = new HashMap<String, Integer>();
    private HashMap<String, Integer> mSongsCountMap = new HashMap<String, Integer>();
    private HashMap<String, Uri> mMediaStoreAlbumArtMap = new HashMap<String, Uri>();
	private HashMap<String, String> mFolderArtHashMap = new HashMap<String, String>();
	private MediaMetadataRetriever mMMDR = new MediaMetadataRetriever();
	
	private PowerManager pm;
	private PowerManager.WakeLock wakeLock;

	public AsyncBuildLibraryTask(Context context, BuildMusicLibraryService service) {
		mContext = context;
		mApp = (Common) mContext;
        mService = service;
        mBuildLibraryProgressUpdate = new ArrayList<OnBuildLibraryProgressUpdate>();
	}
	
	/**
	 * Provides callback methods that expose this 
	 * AsyncTask's progress.
	 * 
	 * @author Saravan Pantham
	 */
	public interface OnBuildLibraryProgressUpdate {
		
		/**
		 * Called when this AsyncTask begins executing 
		 * its doInBackground() method.
		 */
		public void onStartBuildingLibrary();
		
		/**
		 * Called whenever mOverall Progress has been updated.
		 */
		public void onProgressUpdate(AsyncBuildLibraryTask task, String mCurrentTask,
                                     int overallProgress, int maxProgress,
                                     boolean mediaStoreTransferDone);
		
		/**
		 * Called when this AsyncTask finishes executing
		 * its onPostExecute() method.
		 */
		public void onFinishBuildingLibrary(AsyncBuildLibraryTask task);
		
	}

	@Override
	protected void onPreExecute() {
		super.onPreExecute();

		mApp.setIsBuildingLibrary(true);
		mApp.setIsScanFinished(false);
		
		if (mBuildLibraryProgressUpdate!=null)
            for (int i=0; i < mBuildLibraryProgressUpdate.size(); i++)
                if (mBuildLibraryProgressUpdate.get(i)!=null)
			        mBuildLibraryProgressUpdate.get(i).onStartBuildingLibrary();
		
		// Acquire a wakelock to prevent the CPU from sleeping while the process is running.
		pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
		wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
								  "com.jams.music.player.AsyncTasks.AsyncBuildLibraryTask");
		wakeLock.acquire();

	}

	@Override
    protected Void doInBackground(String... params) {
		
		/* 
		 * Get a cursor of songs from MediaStore. The cursor 
		 * is limited by the folders that have been selected 
		 * by the user.
		 */
		mCurrentTask = mContext.getResources().getString(R.string.building_music_library);
		Cursor mediaStoreCursor = getSongsFromMediaStore();
		
		/* 
		 * Transfer the content in mediaStoreCursor over to 
		 * Jams' private database.
		 */
		if (mediaStoreCursor!=null) {
			saveMediaStoreDataToDB(mediaStoreCursor);
			mediaStoreCursor.close();
		}

    	//Save EQ presets to the database.
		saveEQPresets();

        //Notify all listeners that the MediaStore transfer is complete.
        publishProgress(new String[] { "MEDIASTORE_TRANSFER_COMPLETE" });

		//Save album art paths for each song to the database.
		getAlbumArt();
		
    	return null;
    }
	
	/**
	 * Retrieves a cursor of songs from MediaStore. The cursor 
	 * is limited to songs that are within the folders that the user 
	 * selected.
	 */
	private Cursor getSongsFromMediaStore() {
		//Get a cursor of all active music folders.
        Cursor musicFoldersCursor = mApp.getDBAccessHelper().getAllMusicFolderPaths();
        
        //Build the appropriate selection statement.
        Cursor mediaStoreCursor = null;
        String sortOrder = null;
        String projection[] = { MediaStore.Audio.Media.TITLE, 
        						MediaStore.Audio.Media.ARTIST,
        						MediaStore.Audio.Media.ALBUM, 
        						MediaStore.Audio.Media.ALBUM_ID,
        						MediaStore.Audio.Media.DURATION, 
        						MediaStore.Audio.Media.TRACK, 
        						MediaStore.Audio.Media.YEAR, 
        						MediaStore.Audio.Media.DATA, 
        						MediaStore.Audio.Media.DATE_ADDED, 
        						MediaStore.Audio.Media.DATE_MODIFIED, 
        						MediaStore.Audio.Media._ID,
        						MediaStoreAccessHelper.ALBUM_ARTIST };
        
        //Grab the cursor of MediaStore entries.
        if (musicFoldersCursor==null || musicFoldersCursor.getCount() < 1) {
        	//No folders were selected by the user. Grab all songs in MediaStore.
        	mediaStoreCursor = MediaStoreAccessHelper.getAllSongs(mContext, projection, sortOrder);
        } else {
        	//Build a selection statement for querying MediaStore.
            mMediaStoreSelection = buildMusicFoldersSelection(musicFoldersCursor);
            mediaStoreCursor = MediaStoreAccessHelper.getAllSongsWithSelection(mContext, 
            																   mMediaStoreSelection, 
            																   projection, 
            																   sortOrder);

            //Close the music folders cursor.
            musicFoldersCursor.close(); 
        }

    	return mediaStoreCursor;
	}
	
	/**
	 * Iterates through mediaStoreCursor and transfers its data 
	 * over to Jams' private database.
	 */
	private void saveMediaStoreDataToDB(Cursor mediaStoreCursor) {
		try {
    		//Initialize the database transaction manually (improves performance).
    		mApp.getDBAccessHelper().getWritableDatabase().beginTransaction();
    		
    		//Clear out the table.
    		mApp.getDBAccessHelper()
    			.getWritableDatabase()
    			.delete(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
    					null, 
    					null);
    		
    		//Tracks the progress of this method.
    		int subProgress = 0;
    		if (mediaStoreCursor.getCount()!=0) {
    			subProgress = 250000/(mediaStoreCursor.getCount());
    		} else {
    			subProgress = 250000/1;
    		}
    		
    		//Populate a hash of all songs in MediaStore and their genres.
    		buildGenresLibrary();

            //Populate a hash of all artists and their number of albums.
            buildArtistsLibrary();

            //Populate a hash of all albums and their number of songs.
            buildAlbumsLibrary();

            //Populate a has of all albums and their album art path.
            buildMediaStoreAlbumArtHash();

    		//Prefetch each column's index.
    		final int titleColIndex = mediaStoreCursor.getColumnIndex(MediaStore.Audio.Media.TITLE);
    		final int artistColIndex = mediaStoreCursor.getColumnIndex(MediaStore.Audio.Media.ARTIST);
    		final int albumColIndex = mediaStoreCursor.getColumnIndex(MediaStore.Audio.Media.ALBUM);
            final int albumIdColIndex = mediaStoreCursor.getColumnIndex(MediaStore.Audio.Media.ALBUM_ID);
    		final int durationColIndex = mediaStoreCursor.getColumnIndex(MediaStore.Audio.Media.DURATION);
    		final int trackColIndex = mediaStoreCursor.getColumnIndex(MediaStore.Audio.Media.TRACK);
    		final int yearColIndex = mediaStoreCursor.getColumnIndex(MediaStore.Audio.Media.YEAR);
    		final int dateAddedColIndex = mediaStoreCursor.getColumnIndex(MediaStore.Audio.Media.DATE_ADDED);
    		final int dateModifiedColIndex = mediaStoreCursor.getColumnIndex(MediaStore.Audio.Media.DATE_MODIFIED);
    		final int filePathColIndex = mediaStoreCursor.getColumnIndex(MediaStore.Audio.Media.DATA);
    		final int idColIndex = mediaStoreCursor.getColumnIndex(MediaStore.Audio.Media._ID);
    		int albumArtistColIndex = mediaStoreCursor.getColumnIndex(MediaStoreAccessHelper.ALBUM_ARTIST);
    		
    		/* The album artist field is hidden by default and we've explictly exposed it.
    		 * The field may cease to exist at any time and if it does, use the artists 
    		 * field instead.
    		 */
    		if (albumArtistColIndex==-1) {
    			albumArtistColIndex = artistColIndex;
    		}
    		
    		//Iterate through MediaStore's cursor and save the fields to Jams' DB.
            for (int i=0; i < mediaStoreCursor.getCount(); i++) {
            	
            	mediaStoreCursor.moveToPosition(i);
            	mOverallProgress += subProgress;
            	publishProgress();
            	
            	String songTitle = mediaStoreCursor.getString(titleColIndex);
            	String songArtist = mediaStoreCursor.getString(artistColIndex);
            	String songAlbum = mediaStoreCursor.getString(albumColIndex);
                String songAlbumId = mediaStoreCursor.getString(albumIdColIndex);
            	String songAlbumArtist = mediaStoreCursor.getString(albumArtistColIndex);
            	String songFilePath = mediaStoreCursor.getString(filePathColIndex);
            	String songGenre = getSongGenre(songFilePath);
            	String songDuration = mediaStoreCursor.getString(durationColIndex);
            	String songTrackNumber = mediaStoreCursor.getString(trackColIndex);
            	String songYear = mediaStoreCursor.getString(yearColIndex);
            	String songDateAdded = mediaStoreCursor.getString(dateAddedColIndex);
            	String songDateModified = mediaStoreCursor.getString(dateModifiedColIndex);
            	String songId = mediaStoreCursor.getString(idColIndex);
                String numberOfAlbums = "" + mAlbumsCountMap.get(songArtist);
                String numberOfTracks = "" + mSongsCountMap.get(songAlbum + songArtist);
                String numberOfSongsInGenre = "" + getGenreSongsCount(songGenre);
            	String songSource = DBAccessHelper.LOCAL;
            	String songSavedPosition = "-1";

                String songAlbumArtPath = "";
                if (mMediaStoreAlbumArtMap.get(songAlbumId)!=null)
                    songAlbumArtPath = mMediaStoreAlbumArtMap.get(songAlbumId).toString();

                if (numberOfAlbums.equals("1"))
                    numberOfAlbums += " " + mContext.getResources().getString(R.string.album_small);
                else
                    numberOfAlbums += " " + mContext.getResources().getString(R.string.albums_small);

                if (numberOfTracks.equals("1"))
                    numberOfTracks += " " + mContext.getResources().getString(R.string.song_small);
                else
                    numberOfTracks += " " + mContext.getResources().getString(R.string.songs_small);

                if (numberOfSongsInGenre.equals("1"))
                    numberOfSongsInGenre += " " + mContext.getResources().getString(R.string.song_small);
                else
                    numberOfSongsInGenre += " " + mContext.getResources().getString(R.string.songs_small);

            	//Check if any of the other tags were empty/null and set them to "Unknown xxx" values.
            	if (songArtist==null || songArtist.isEmpty()) {
            		songArtist = mContext.getResources().getString(R.string.unknown_artist);
            	}
            	
            	if (songAlbumArtist==null || songAlbumArtist.isEmpty()) {
            		if (songArtist!=null && !songArtist.isEmpty()) {
            			songAlbumArtist = songArtist;
            		} else {
            			songAlbumArtist = mContext.getResources().getString(R.string.unknown_album_artist);
            		}
            		
            	}
            	
            	if (songAlbum==null || songAlbum.isEmpty()) {
            		songAlbum = mContext.getResources().getString(R.string.unknown_album);;
            	}

                if (songGenre==null || songGenre.isEmpty()) {
                    songGenre = mContext.getResources().getString(R.string.unknown_genre);
                }
            	
            	//Filter out track numbers and remove any bogus values.
            	if (songTrackNumber!=null) {
        			if (songTrackNumber.contains("/")) {
        				int index = songTrackNumber.lastIndexOf("/");
        				songTrackNumber = songTrackNumber.substring(0, index);            	
        			}

                    try {
                        if (Integer.parseInt(songTrackNumber) <= 0) {
                            songTrackNumber = "";
                        }

                    } catch (Exception e) {
                        e.printStackTrace();
                        songTrackNumber = "";
                    }
                	
            	}

                long durationLong = 0;
                try {
                    durationLong = Long.parseLong(songDuration);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            	
            	ContentValues values = new ContentValues();
            	values.put(DBAccessHelper.SONG_TITLE, songTitle);
            	values.put(DBAccessHelper.SONG_ARTIST, songArtist);
            	values.put(DBAccessHelper.SONG_ALBUM, songAlbum);
            	values.put(DBAccessHelper.SONG_ALBUM_ARTIST, songAlbumArtist);
            	values.put(DBAccessHelper.SONG_DURATION, convertMillisToMinsSecs(durationLong));
            	values.put(DBAccessHelper.SONG_FILE_PATH, songFilePath);
            	values.put(DBAccessHelper.SONG_TRACK_NUMBER, songTrackNumber);
            	values.put(DBAccessHelper.SONG_GENRE, songGenre);
            	values.put(DBAccessHelper.SONG_YEAR, songYear);
                values.put(DBAccessHelper.SONG_ALBUM_ART_PATH, songAlbumArtPath);
            	values.put(DBAccessHelper.SONG_LAST_MODIFIED, songDateModified);
                values.put(DBAccessHelper.SONG_ALBUM_ART_PATH, songAlbumArtPath);
            	values.put(DBAccessHelper.BLACKLIST_STATUS, false);
            	values.put(DBAccessHelper.ADDED_TIMESTAMP, date.getTime());
            	values.put(DBAccessHelper.RATING, 0);
            	values.put(DBAccessHelper.LAST_PLAYED_TIMESTAMP, songDateModified);
            	values.put(DBAccessHelper.SONG_SOURCE, songSource);
            	values.put(DBAccessHelper.SONG_ID, songId);
            	values.put(DBAccessHelper.SAVED_POSITION, songSavedPosition);
                values.put(DBAccessHelper.ALBUMS_COUNT, numberOfAlbums);
                values.put(DBAccessHelper.SONGS_COUNT, numberOfTracks);
                values.put(DBAccessHelper.GENRE_SONG_COUNT, numberOfSongsInGenre);
            	
            	//Add all the entries to the database to build the songs library.
            	mApp.getDBAccessHelper().getWritableDatabase().insert(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
            												 		  null, 
            												 		  values);	
            	
            	
            }
    		
    	} catch (SQLException e) {
    		// TODO Auto-generated method stub.
    		e.printStackTrace();
    	} finally {
    		//Close the transaction.
            mApp.getDBAccessHelper().getWritableDatabase().setTransactionSuccessful();
    		mApp.getDBAccessHelper().getWritableDatabase().endTransaction();
    	}

	}
	
	/**
	 * Constructs the selection string for limiting the MediaStore 
	 * query to specific music folders.
	 */
	private String buildMusicFoldersSelection(Cursor musicFoldersCursor) {
		String mediaStoreSelection = MediaStore.Audio.Media.IS_MUSIC + "!=0 AND (";
        int folderPathColIndex = musicFoldersCursor.getColumnIndex(DBAccessHelper.FOLDER_PATH);
        int includeColIndex = musicFoldersCursor.getColumnIndex(DBAccessHelper.INCLUDE);
        
        for (int i=0; i < musicFoldersCursor.getCount(); i++) {
        	musicFoldersCursor.moveToPosition(i);
        	boolean include = musicFoldersCursor.getInt(includeColIndex) > 0;
        	
        	//Set the correct LIKE clause.
        	String likeClause;
        	if (include)
        		likeClause = " LIKE ";
        	else
        		likeClause = " NOT LIKE ";
        	
        	//The first " AND " clause was already appended to mediaStoreSelection.
        	if (i!=0 && !include)
        		mediaStoreSelection += " AND ";
        	else if (i!=0 && include)
        		mediaStoreSelection += " OR ";
        	
        	mediaStoreSelection += MediaStore.Audio.Media.DATA + likeClause
								+ "'%" + musicFoldersCursor.getString(folderPathColIndex) 
								+ "/%'";

        }
        
        //Append the closing parentheses.
        mediaStoreSelection += ")";
        return mediaStoreSelection;
	}
	
	/**
	 * Builds a HashMap of all songs and their genres.
	 */
	private void buildGenresLibrary() {
		//Get a cursor of all genres in MediaStore.
		Cursor genresCursor = mContext.getContentResolver().query(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI,
																  new String[] { MediaStore.Audio.Genres._ID, MediaStore.Audio.Genres.NAME },
		            								  			  null, 
		            								  			  null, 
		            								  			  null);
		 
		//Iterate thru all genres in MediaStore.
        for (genresCursor.moveToFirst(); !genresCursor.isAfterLast(); genresCursor.moveToNext()) {
        	String genreId = genresCursor.getString(0);
        	String genreName = genresCursor.getString(1);

            if (genreName==null || genreName.isEmpty() ||
                genreName.equals(" ") || genreName.equals("   ") ||
                genreName.equals("    "))
                genreName = mContext.getResources().getString(R.string.unknown_genre);

        	/* Grab a cursor of songs in the each genre id. Limit the songs to 
        	 * the user defined folders using mMediaStoreSelection.
        	 */
        	Cursor cursor = mContext.getContentResolver().query(makeGenreUri(genreId),
        														new String[] { MediaStore.Audio.Media.DATA },
				     											mMediaStoreSelection,
				     											null, 
				     											null);
        	 
        	//Add the songs' file paths and their genre names to the hash.
        	if (cursor!=null) {
        		for (int i=0; i < cursor.getCount(); i++) {
        			cursor.moveToPosition(i);
        			mGenresHashMap.put(cursor.getString(0), genreName);
                    mGenresSongCountHashMap.put(genreName, cursor.getCount());
            	}
            	 
            	cursor.close();
        	}
        	 
        }         
         
        if (genresCursor!=null)
        	genresCursor.close();
         
	}

    /**
     * Builds a HashMap of all artists and their individual albums count.
     */
    private void buildArtistsLibrary() {
        Cursor artistsCursor = mContext.getContentResolver().query(MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,
                                        new String[] { MediaStore.Audio.Artists.ARTIST, MediaStore.Audio.Artists.NUMBER_OF_ALBUMS },
                                        null,
                                        null,
                                        null);

        if (artistsCursor==null)
            return;

        for (int i=0; i < artistsCursor.getCount(); i++) {
            artistsCursor.moveToPosition(i);
            mAlbumsCountMap.put(artistsCursor.getString(0), artistsCursor.getInt(1));

        }

        artistsCursor.close();
    }

    /**
     * Builds a HashMap of all albums and their individual songs count.
     */
    private void buildAlbumsLibrary() {
        Cursor albumsCursor = mContext.getContentResolver().query(MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,
                                       new String[] { MediaStore.Audio.Albums.ALBUM, MediaStore.Audio.Albums.ARTIST, MediaStore.Audio.Albums.NUMBER_OF_SONGS },
                                       null,
                                       null,
                                       null);

        if (albumsCursor==null)
            return;

        for (int i=0; i < albumsCursor.getCount(); i++) {
            albumsCursor.moveToPosition(i);
            mSongsCountMap.put(albumsCursor.getString(0) + albumsCursor.getString(1), albumsCursor.getInt(2));

        }

        albumsCursor.close();
    }

    /**
     * Builds a HashMap of all albums and their album art path.
     */
    private void buildMediaStoreAlbumArtHash() {
        Cursor albumsCursor = mContext.getContentResolver().query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
                new String[] { MediaStore.Audio.Media.ALBUM_ID },
                MediaStore.Audio.Media.IS_MUSIC + "=1",
                null,
                null);

        final Uri ART_CONTENT_URI = Uri.parse("content://media/external/audio/albumart");
        if (albumsCursor==null)
            return;

        for (int i=0; i < albumsCursor.getCount(); i++) {
            albumsCursor.moveToPosition(i);
            Uri albumArtUri = ContentUris.withAppendedId(ART_CONTENT_URI, albumsCursor.getLong(0));
            mMediaStoreAlbumArtMap.put(albumsCursor.getString(0), albumArtUri);
        }

        albumsCursor.close();
    }
	
	/**
	 * Returns the genre of the song at the specified file path.
	 */
	private String getSongGenre(String filePath) {
        if (mGenresHashMap!=null)
		    return mGenresHashMap.get(filePath);
        else
            return mContext.getResources().getString(R.string.unknown_genre);
	}

    /**
     * Returns the number of songs in the specified genre.
     */
    private int getGenreSongsCount(String genre) {
        if (mGenresSongCountHashMap!=null)
            if (genre!=null)
                if (mGenresSongCountHashMap.get(genre)!=null)
                    return mGenresSongCountHashMap.get(genre);
                else
                    return 0;
            else
                if (mGenresSongCountHashMap.get(mContext.getResources().getString(R.string.unknown_genre))!=null)
                    return mGenresSongCountHashMap.get(mContext.getResources().getString(R.string.unknown_genre));
                else
                    return 0;
        else
            return 0;
    }
	
	/**
	 * Returns a Uri of a specific genre in MediaStore. 
	 * The genre is specified using the genreId parameter.
	 */
	private Uri makeGenreUri(String genreId) {
        String CONTENTDIR = MediaStore.Audio.Genres.Members.CONTENT_DIRECTORY;
        return Uri.parse(new StringBuilder().append(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI.toString())
        									.append("/")
        									.append(genreId)
        									.append("/")
        									.append(CONTENTDIR)
        									.toString());
    }
	
	/**
	 * Saves premade equalizer presets to the database.
	 */
	private void saveEQPresets() {
		Cursor eqPresetsCursor = mApp.getDBAccessHelper().getAllEQPresets();
        
		//Check if this is the first startup (eqPresetsCursor.getCount() will be 0).
        if (eqPresetsCursor!=null && eqPresetsCursor.getCount()==0) {
        	mApp.getDBAccessHelper().addNewEQPreset("Flat", 16, 16, 16, 16, 16, 16, 16, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Bass Only", 31, 31, 31, 0, 0, 0, 31, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Treble Only", 0, 0, 0, 31, 31, 31, 0, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Rock", 16, 18, 16, 17, 19, 20, 22, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Grunge", 13, 16, 18, 19, 20, 17, 13, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Metal", 12, 16, 16, 16, 20, 24, 16, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Dance", 14, 18, 20, 17, 16, 20, 23, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Country", 16, 16, 18, 20, 17, 19, 20, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Jazz", 16, 16, 18, 18, 18, 16, 20, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Speech", 14, 16, 17, 14, 13, 15, 16, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Classical", 16, 18, 18, 16, 16, 17, 18, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Blues", 16, 18, 19, 20, 17, 18, 16, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Opera", 16, 17, 19, 20, 16, 24, 18, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Swing", 15, 16, 18, 20, 18, 17, 16, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("Acoustic", 17, 18, 16, 19, 17, 17, 14, (short) 0, (short) 0, (short) 0);
        	mApp.getDBAccessHelper().addNewEQPreset("New Age", 16, 19, 15, 18, 16, 16, 18, (short) 0, (short) 0, (short) 0);

        }
        
        //Close the cursor.
        if (eqPresetsCursor!=null)
        	eqPresetsCursor.close();
        
	}
	
	/**
	 * Loops through a cursor of all local songs in 
	 * the library and searches for their album art.
	 */
	private void getAlbumArt() {
		
		//Get a cursor with a list of all local music files on the device.
		Cursor cursor = mApp.getDBAccessHelper().getAllLocalSongs();
		mCurrentTask = mContext.getResources().getString(R.string.building_album_art);
		
		if (cursor==null || cursor.getCount() < 1)
			return;
		
		//Tracks the progress of this method.
		int subProgress = 0;
		if (cursor.getCount()!=0) {
			subProgress = 750000/(cursor.getCount());
		} else {
			subProgress = 750000/1;
		}

		try {
			mApp.getDBAccessHelper().getWritableDatabase().beginTransactionNonExclusive();
			
			//Loop through the cursor and retrieve album art.
			for (int i=0; i < cursor.getCount(); i++) {
				
				try {
	 				cursor.moveToPosition(i);
	 				mOverallProgress += subProgress;
					publishProgress();
					
					String filePath = cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH));
					String artworkPath = "";
					if (mApp.getSharedPreferences().getInt("ALBUM_ART_SOURCE", 0)==0 || 
						mApp.getSharedPreferences().getInt("ALBUM_ART_SOURCE", 0)==1) {
						artworkPath = getEmbeddedArtwork(filePath);
					} else {
						artworkPath = getArtworkFromFolder(filePath);
					}
						
					String normalizedFilePath = filePath.replace("'", "''");
					
					//Store the artwork file path into the DB.
					ContentValues values = new ContentValues();
					values.put(DBAccessHelper.SONG_ALBUM_ART_PATH, artworkPath);
					String where = DBAccessHelper.SONG_FILE_PATH + "='" + normalizedFilePath + "'";
					
					mApp.getDBAccessHelper().getWritableDatabase().update(DBAccessHelper.MUSIC_LIBRARY_TABLE, values, where, null);
                    mApp.getDBAccessHelper().getWritableDatabase().yieldIfContendedSafely();
                } catch (Exception e) {
					e.printStackTrace();
					continue;
				}

			}
			
			mApp.getDBAccessHelper().getWritableDatabase().setTransactionSuccessful();
			mApp.getDBAccessHelper().getWritableDatabase().endTransaction();
			cursor.close();
			cursor = null;
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	
	/**
	 * Searchs for folder art within the specified file's 
	 * parent folder. Returns a path string to the artwork 
	 * image file if it exists. Returns an empty string 
	 * otherwise.
	 */
	public String getArtworkFromFolder(String filePath) {
		
		File file = new File(filePath);
		if (!file.exists()) {
			return "";
			
		} else {
			//Create a File that points to the parent directory of the album.
			File directoryFile = file.getParentFile();
			String directoryPath = "";
			String albumArtPath = "";
			try {
				directoryPath = directoryFile.getCanonicalPath();
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			
			//Check if album art was already found in this directory.
			if (mFolderArtHashMap.containsKey(directoryPath))
				return mFolderArtHashMap.get(directoryPath);
			
			//Get a list of images in the album's folder.
			FileExtensionFilter IMAGES_FILTER = new FileExtensionFilter(new String[] {".jpg", ".jpeg", 
																					  ".png", ".gif"});
			File[] folderList = directoryFile.listFiles(IMAGES_FILTER);
			
			//Check if any image files were found in the folder.
			if (folderList.length==0) {
				//No images found.
				return "";
				
			} else {
				
				//Loop through the list of image files. Use the first jpeg file if it's found.
				for (int i=0; i < folderList.length; i++) {
					
					try {
						albumArtPath = folderList[i].getCanonicalPath();
						if (albumArtPath.endsWith("jpg") ||
							albumArtPath.endsWith("jpeg")) {
							
							//Add the folder's album art file to the hash.
							mFolderArtHashMap.put(directoryPath, albumArtPath);
							return albumArtPath;
						}
						
					} catch (Exception e) {
						//Skip the file if it's corrupted or unreadable.
						continue;
					}
					
				}
				
				//If an image was not found, check for gif or png files (lower priority).
				for (int i=0; i < folderList.length; i++) {
    				
    				try {
    					albumArtPath = folderList[i].getCanonicalPath();
						if (albumArtPath.endsWith("png") ||
							albumArtPath.endsWith("gif")) {

							//Add the folder's album art file to the hash.
							mFolderArtHashMap.put(directoryPath, albumArtPath);
							return albumArtPath;
						}
						
					} catch (Exception e) {
						//Skip the file if it's corrupted or unreadable.
						continue;
					}
    				
    			}
				
			}
    		
			//Add the folder's album art file to the hash.
			mFolderArtHashMap.put(directoryPath, albumArtPath);
			return "";
    	}
		
	}
		
	/**
	 * Searchs for embedded art within the specified file.
	 * Returns a path string to the artwork if it exists.
	 * Returns an empty string otherwise.
	 */
	public String getEmbeddedArtwork(String filePath) {
		File file = new File(filePath);
		if (!file.exists()) {
			if (mApp.getSharedPreferences().getInt("ALBUM_ART_SOURCE", 0)==0) {
				return getArtworkFromFolder(filePath);
			} else {
				return "";
			}
			
		} else {
        	mMMDR.setDataSource(filePath);
        	byte[] embeddedArt = mMMDR.getEmbeddedPicture();
        	
        	if (embeddedArt!=null) {
        		return "byte://" + filePath;
        	} else {
    			if (mApp.getSharedPreferences().getInt("ALBUM_ART_SOURCE", 0)==0) {
    				return getArtworkFromFolder(filePath);
    			} else {
    				return "";
    			}
    			
        	}
        	
		}
		
	}

    /**
     * Convert millisseconds to hh:mm:ss format.
     *
     * @param milliseconds The input time in milliseconds to format.
     * @return The formatted time string.
     */
    private String convertMillisToMinsSecs(long milliseconds) {

    	int secondsValue = (int) (milliseconds / 1000) % 60;
    	int minutesValue = (int) ((milliseconds / (1000*60)) % 60);
    	int hoursValue  = (int) ((milliseconds / (1000*60*60)) % 24);

    	String seconds = "";
    	String minutes = "";
    	String hours = "";

    	if (secondsValue < 10) {
    		seconds = "0" + secondsValue;
    	} else {
    		seconds = "" + secondsValue;
    	}

    	minutes = "" + minutesValue;
    	hours = "" + hoursValue;

    	String output = "";
    	if (hoursValue!=0) {
    		minutes = "0" + minutesValue;
        	hours = "" + hoursValue;
    		output = hours + ":" + minutes + ":" + seconds;
    	} else {
    		minutes = "" + minutesValue;
        	hours = "" + hoursValue;
    		output = minutes + ":" + seconds;
    	}

    	return output;
    }
	
	@Override
	protected void onProgressUpdate(String... progressParams) {
		super.onProgressUpdate(progressParams);

        if (progressParams.length > 0 && progressParams[0].equals("MEDIASTORE_TRANSFER_COMPLETE")) {
            for (int i=0; i < mBuildLibraryProgressUpdate.size(); i++)
                if (mBuildLibraryProgressUpdate.get(i)!=null)
                    mBuildLibraryProgressUpdate.get(i).onProgressUpdate(this, mCurrentTask, mOverallProgress,
                            1000000, true);

            return;
        }

		if (mBuildLibraryProgressUpdate!=null)
            for (int i=0; i < mBuildLibraryProgressUpdate.size(); i++)
                if (mBuildLibraryProgressUpdate.get(i)!=null)
			        mBuildLibraryProgressUpdate.get(i).onProgressUpdate(this, mCurrentTask, mOverallProgress, 1000000, false);
		
	}

	@Override
	protected void onPostExecute(Void arg0) {
		//Release the wakelock.
		wakeLock.release();
		mApp.setIsBuildingLibrary(false);
		mApp.setIsScanFinished(true);

        Toast.makeText(mContext, R.string.finished_scanning_album_art, Toast.LENGTH_LONG).show();
		
		if (mBuildLibraryProgressUpdate!=null)
            for (int i=0; i < mBuildLibraryProgressUpdate.size(); i++)
                if (mBuildLibraryProgressUpdate.get(i)!=null)
			        mBuildLibraryProgressUpdate.get(i).onFinishBuildingLibrary(this);

	}
	
	/**
	 * Setter methods.
	 */
	public void setOnBuildLibraryProgressUpdate(OnBuildLibraryProgressUpdate 
												 buildLibraryProgressUpdate) {
        if (buildLibraryProgressUpdate!=null)
		    mBuildLibraryProgressUpdate.add(buildLibraryProgressUpdate);
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* package com.jams.music.player.AsyncTasks;

import java.util.ArrayList;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.media.MediaMetadataRetriever;
import android.os.AsyncTask;
import android.os.Bundle;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.LastCursorInfoDBHelper;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Utils.Common;

*//**
 * Builds the cursor that will be used by the app's main service.
 * 
 * @author Saravan Pantham
 *//*
public class AsyncBuildServiceCursorTask extends AsyncTask<String, Integer, Boolean> {

	private Context mContext;
	private Common mApp;
	
	private String mCallingFragment;
	private Bundle mBundle;
	private String mCurrentLibrary;
	private ArrayList<String> mAudioFilePathsInFolder = new ArrayList<String>();
	private String mSongTitle;
	private String mSongArtist;
	private String mSongAlbum;
	private String mSongGenre;
	private String mSongAlbumArtist;
	private Cursor mCursor;
	
	public AsyncBuildServiceCursorTask(Context context, 
									   String callingFragment, 
									   Bundle bundle,
									   String currentLibrary, 
									   ArrayList<String> audioFilePathsInFolder,
									   String songTitle,
									   String songArtist,
									   String songAlbum,
									   String songGenre,
									   String songAlbumArtist) {
		
		mContext = context;
		mApp = (Common) mContext;
		
		mCallingFragment = callingFragment;
		mBundle = bundle;
		mCurrentLibrary = currentLibrary;
		mAudioFilePathsInFolder = audioFilePathsInFolder;
		mSongTitle = songTitle;
		mSongArtist = songArtist;
		mSongAlbum = songAlbum;
		mSongGenre = songGenre;
		mSongAlbumArtist = songAlbumArtist;
		
	}
	
	@Override
	public void onPreExecute() {
		super.onPreExecute();
		
	}
	
	@Override
	protected Boolean doInBackground(String... params) {
		initializeDatabaseCursor();
		
		 Save the current cursor parameters to mApp.getSharedPreferences().
		 * This will allow the user to resume their previous playlist
		 * even if they manually kill it.
		 
		mApp.getSharedPreferences().edit().putString("LAST_CURSOR_CALLING_FRAGMENT", mCallingFragment).commit();
		mApp.getSharedPreferences().edit().putString("LAST_CURSOR_CURRENT_LIBRARY", mCurrentLibrary).commit();
		mApp.getSharedPreferences().edit().putString("LAST_CURSOR_SONG_TITLE", mSongTitle).commit();
		mApp.getSharedPreferences().edit().putString("LAST_CURSOR_SONG_ARTIST", mSongArtist).commit();
		mApp.getSharedPreferences().edit().putString("LAST_CURSOR_SONG_ALBUM", mSongAlbum).commit();
		mApp.getSharedPreferences().edit().putString("LAST_CURSOR_SONG_GENRE", mSongGenre).commit();
		mApp.getSharedPreferences().edit().putString("LAST_CURSOR_SONG_ALBUM_ARTIST", mSongAlbumArtist).commit();
		mApp.getSharedPreferences().edit().putString("LAST_CURSOR_PLAY_ALL", mBundle.getString("PLAY_ALL")).commit();
		mApp.getSharedPreferences().edit().putBoolean("LAST_CURSOR_SEARCHED", mBundle.getBoolean("SEARCHED")).commit();
		
		if (mAudioFilePathsInFolder!=null) {
			
			for (int i=0; i < mAudioFilePathsInFolder.size(); i++) {
				
				try {
					ContentValues values = new ContentValues();
					values.put(LastCursorInfoDBHelper.AUDIO_FILE_PATH, mAudioFilePathsInFolder.get(i));
					mApp.getDBAccessHelper().getWritableDatabase().insert(LastCursorInfoDBHelper.LAST_CURSOR_INFO, null, values);
					
				} catch (Exception e) {
					e.printStackTrace();
					continue;
				}
				
			}
			
		}
		
		return null;
	}
	
	//Constructs the DB mCursor for the music player service, based on the calling fragment.
    public void initializeDatabaseCursor() {

    	if (mSongTitle!=null) {
    		
    		if (mSongTitle.contains("'")) {
    			mSongTitle = mSongTitle.replace("'", "''");
    		}
    		
    	}
    	
    	if (mSongArtist!=null) {
    		
    	    if (mSongArtist.contains("'")) {
    	    	mSongArtist = mSongArtist.replace("'", "''");
    	    }
    	    
    	}

    	if (mSongAlbum!=null) {
    		
    	    if (mSongAlbum.contains("'")) {
    	    	mSongAlbum = mSongAlbum.replace("'", "''");
    	    }
    	    
    	}
	    
    	if (mSongGenre!=null) {
    		
    	    if (mSongGenre.contains("'")) {
    	    	mSongGenre = mSongGenre.replace("'", "''");
    	    }
    	    
    	}
    	
    	if (mSongAlbumArtist!=null) {
    		
    		if (mSongAlbumArtist.contains("'")) {
    			mSongAlbumArtist = mSongAlbumArtist.replace("'", "''");
    		}
    		
    	}
    	
    	if (mCurrentLibrary!=null) {
    		
    		if (mCurrentLibrary.contains("'")) {
    			mCurrentLibrary = mCurrentLibrary.replace("'", "''");
    		}
    		
    	}
    	
    	if (mBundle.getBoolean("SEARCHED")==true) {
    		String selection = DBAccessHelper.SONG_TITLE + "=" + "'" + mSongTitle + "'" + " AND "
    				  + DBAccessHelper.SONG_ARTIST + "= " + "'" + mSongArtist + "'" + " AND "
    				  + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum + "'" + " AND "
    				  + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'";
    		mCursor = mApp.getDBAccessHelper().getSongsInAlbum(selection, null);
    		mApp.getService().setCursor(mCursor);
    		
        	if (mSongArtist!=null) {
        		
        	    if (mSongArtist.contains("''")) {
        	    	mSongArtist = mSongArtist.replace("''", "'");
        	    }
        	    
        	}
    	    
        	if (mSongAlbum!=null) {
        		
        	    if (mSongAlbum.contains("'")) {
        	    	mSongAlbum = mSongAlbum.replace("''", "'");
        	    }
        	    
        	}
    	    
        	if (mSongGenre!=null) {
        		
        	    if (mSongGenre.contains("''")) {
        	    	mSongGenre = mSongGenre.replace("''", "'");
        	    }
        	    
        	}
    	    
        	if (mSongTitle!=null) {
        		
        		if (mSongTitle.contains("''")) {
        			mSongTitle = mSongTitle.replace("''", "'");
        		}
        		
        	}
        	
    		return;
    	}
    	
    	if (mCurrentLibrary!=null) {
            mCurrentLibrary = mCurrentLibrary.replace("'", "''");
    	}
    	
    	if (mCallingFragment.equals("SONGS_FRAGMENT")) {
            
    		String selection = "";
            if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.all_libraries))) {
            	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
            		selection = "";
            	} else {
            		selection = " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
            	}
            	mCursor = mApp.getDBAccessHelper().getAllSongsSearchable(selection);
            	mApp.getNowPlayingActivity().setCursor(mCursor);
    	    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.google_play_music_no_asterisk))) {
    		    selection = " AND " + DBAccessHelper.SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'";
    	        mCursor = mApp.getDBAccessHelper().getAllSongsSearchable(selection);
    	        mApp.getNowPlayingActivity().setCursor(mCursor);
    	    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.on_this_device))) { 
    	    	//Check if Google Play Music is enabled.
    	    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    	    		selection = " AND (" + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " OR "
    	    				  + DBAccessHelper.LOCAL_COPY_PATH + "<> '')";
    	    		mCursor = mApp.getDBAccessHelper().getAllSongsSearchable(selection);
    	    		mApp.getNowPlayingActivity().setCursor(mCursor);
    	    	} else {
    	    		selection = " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'"; 
    		        mCursor = mApp.getDBAccessHelper().getAllSongsSearchable(selection);
    		        mApp.getNowPlayingActivity().setCursor(mCursor);
    	    	}
    	    	
        	} else {
            	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
            		selection = " AND " + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'";
            	} else {
            		selection = " AND " + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'"
            	              + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
            	}
    		    
    	        mCursor = mApp.getDBAccessHelper().getAllSongsInLibrarySearchable(selection);
    	        mApp.getNowPlayingActivity().setCursor(mCursor);
    	    }

    		mApp.getService().setCursor(mCursor);
    	
    	} else if (mCallingFragment.equals("ALBUM_ARTISTS_FLIPPED_FRAGMENT")) {
            
    		String selection = "";
    		if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.all_libraries))) {
    	    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    	    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist  + "'";
    	    	} else {
    	    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist  + "'"
    						  + " AND " + DBAccessHelper.SONG_SOURCE + " <> " + "'GOOGLE_PLAY_MUSIC'";
    	    	}
    		    
    	        mCursor = mApp.getDBAccessHelper().getAllSongsByAlbumArtist(selection);
    	    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.google_play_music_no_asterisk))) {
	    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'" 
	    				  + " AND " + DBAccessHelper.SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'";
	    		mCursor = mApp.getDBAccessHelper().getAllSongsByAlbumArtist(selection);
    		    
    	    } else {
    	    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    	    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist  + "'" 
    	    				  + " AND " + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'";
    	    	} else {
    	    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist  + "'" 
    	    				  + " AND " + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'" 
    	    				  + " AND " + DBAccessHelper.SONG_SOURCE + " <> " + "'GOOGLE_PLAY_MUSIC'";
    	    	}
    	        mCursor = mApp.getDBAccessHelper().getAllSongsByAlbumArtistInLibrary(selection);
    	    }

    		mApp.getService().setCursor(mCursor);
    		AudioPlaybackService.originalCursor = mCursor;
    	
    	} else if (mCallingFragment.equals("PLAYLISTS_FLIPPED_FRAGMENT")) {
    		String playlistName = mBundle.getString("PLAYLIST_NAME");
    		
            //Retrieve the appropriate mCursor for the playlist.
            playlistName = playlistName.replace("'", "''");
            String selection = " AND " + DBAccessHelper.MUSIC_LIBRARY_PLAYLISTS_NAME + "." 
      			  	  		 + DBAccessHelper.PLAYLIST_NAME 
      			  	  		 + "=" + "'" + playlistName + "'";
            playlistName = playlistName.replace("''", "'");
            
            if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
            	mCursor = mApp.getDBAccessHelper().getAllSongsInPlaylistSearchable(selection);
            	mApp.getNowPlayingActivity().setCursor(mCursor);
            } else {
            	mCursor = mApp.getDBAccessHelper().getLocalSongsInPlaylistSearchable(selection);
            	mApp.getNowPlayingActivity().setCursor(mCursor);
            }
            
    		mApp.getService().setCursor(mCursor);

    	} else if (mCallingFragment.equals("GENRES_FLIPPED_SONGS_FRAGMENT")) {
    		//The cursor needs to be built from the songs table.
    		
    		String selection = "";
    		if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.all_libraries))) {
    	    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    	    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
    						  + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'";
    	    	} else {
    	    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
    						  + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'"
    						  + " AND " + DBAccessHelper.SONG_SOURCE + " <> " + "'GOOGLE_PLAY_MUSIC'";
    	    	}
    		    
    	        mCursor = mApp.getDBAccessHelper().getAllSongsInAlbumInGenre(selection);
    	        mApp.getNowPlayingActivity().setCursor(mCursor);
    	    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.google_play_music_no_asterisk))) {
    	    	selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
						  + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'" + " AND " + 
						  DBAccessHelper.SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'";
	    		mCursor = mApp.getDBAccessHelper().getAllSongsInAlbumInGenre(selection);
	    		mApp.getNowPlayingActivity().setCursor(mCursor);
	    		
    	    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.on_this_device))) { 
    	    	//Check if Google Play Music is enabled.
    	    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    	    		selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'"
    	    				  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum + "'"
    	    			      + " AND (" + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " OR "
    	    				  + DBAccessHelper.LOCAL_COPY_PATH + "<> '')";
    	    		mCursor = mApp.getDBAccessHelper().getAllSongsInAlbumInGenre(selection);
    	    		mApp.getNowPlayingActivity().setCursor(mCursor);
    	    		
    	    	} else {
    	    		selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'"
    	    				  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum + "'"
    	    				  + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'"; 
    	    		mCursor = mApp.getDBAccessHelper().getAllSongsInAlbumInGenre(selection);
    	    		mApp.getNowPlayingActivity().setCursor(mCursor);
    	    		
    	    	}
    	    	
        	} else {
    	    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    	    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
    						  + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'" + " AND " 
    						  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'";
    	    	} else {selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
    					  + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'" + " AND " 
    					  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'" + " AND "
    					  + DBAccessHelper.SONG_SOURCE + " <> " + "'GOOGLE_PLAY_MUSIC'";
    	    	}
    	        mCursor = mApp.getDBAccessHelper().getAllSongsByInAlbumInGenreInLibrary(selection);
    	        mApp.getNowPlayingActivity().setCursor(mCursor);
    	        
    	    }

    		mApp.getService().setCursor(mCursor);
    		
    	} else if (mCallingFragment.equals("TOP_25_PLAYED_SONGS")) {
    		String selection = "";
        	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
        		selection = DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
        	} else {
        		selection = DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'"
        	              + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
        	}
    		
			mCursor = mApp.getDBAccessHelper().getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
														  null, 
														  selection, 
														  null, 
														  null, 
														  null, 
														  DBAccessHelper.SONG_PLAY_COUNT + "*1 DESC", 
														  "25");
			
			mApp.getNowPlayingActivity().setCursor(mCursor);
			mApp.getService().setCursor(mCursor);
    	
    	} else if (mCallingFragment.equals("RECENTLY_ADDED")) {
    		String selection = "";
    		
        	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
        		selection = DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
        	} else {
        		selection = DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'"
        	              + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
        	}
        	
			mCursor = mApp.getDBAccessHelper().getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
																			  null, 
																			  selection, 
																			  null, 
																			  null, 
																			  null, 
																			  DBAccessHelper.ADDED_TIMESTAMP + "*1 DESC");

			mApp.getNowPlayingActivity().setCursor(mCursor);
			mApp.getService().setCursor(mCursor);
    		
    	} else if (mCallingFragment.equals("TOP_RATED")) {
    		String selection = "";
        	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
        		selection = DBAccessHelper.RATING + "<>" + "'0'" + " AND "
   					      + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
        	} else {
        		selection = DBAccessHelper.RATING + "<>" + "'0'" + " AND "
   					      + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'"
        	              + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
        	}
    		
			mCursor = mApp.getDBAccessHelper().getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
					  null, 
					  selection, 
					  null, 
					  null, 
					  null, 
					  DBAccessHelper.RATING + "*1 DESC");

			mApp.getNowPlayingActivity().setCursor(mCursor);
			mApp.getService().setCursor(mCursor);
    	
    	} else if (mCallingFragment.equals("RECENTLY_PLAYED")) {
    		String selection = "";
        	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
        		selection = DBAccessHelper.LAST_PLAYED_TIMESTAMP + "<>" + "'0'" + " AND "
   					      + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
        	} else {
        		selection = DBAccessHelper.LAST_PLAYED_TIMESTAMP + "<>" + "'0'" + " AND "
   					      + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'"
        	              + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
        	}
        	
			mCursor = mApp.getDBAccessHelper().getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
					  null, 
					  selection, 
					  null, 
					  null, 
					  null, 
					  DBAccessHelper.LAST_PLAYED_TIMESTAMP + "*1 DESC");

			mApp.getNowPlayingActivity().setCursor(mCursor);
			mApp.getService().setCursor(mCursor);
			
    	} else if (mCallingFragment.equals("FOLDERS_FRAGMENT")) {
    		
    		//We'll create a matrix mCursor that includes all the audio files within the specified folder.
    		String[] foldersCursorColumns = {  DBAccessHelper.SONG_ARTIST,  
											   DBAccessHelper.SONG_ALBUM, 
											   DBAccessHelper.SONG_TITLE, 
											   DBAccessHelper.SONG_FILE_PATH,
											   DBAccessHelper.SONG_DURATION, 
											   DBAccessHelper.SONG_GENRE, 
											   DBAccessHelper.SONG_SOURCE, 
											   DBAccessHelper.SONG_ALBUM_ART_PATH, 
											   DBAccessHelper.SONG_ID, 
											   DBAccessHelper.LOCAL_COPY_PATH, 
											   DBAccessHelper.LAST_PLAYBACK_POSITION };
						    		
    		MatrixCursor foldersCursor = new MatrixCursor(foldersCursorColumns, mAudioFilePathsInFolder.size());
    		MediaMetadataRetriever mmdr = new MediaMetadataRetriever();

    		String genre = "";
    		String songSource = "LOCAL_FILE";
    		String songAlbumArtPath = "";
    		String songId = "FOLDER";
    		boolean cursorChanged = false;
    		
    		for (int i=0; i < mAudioFilePathsInFolder.size(); i++) {

    			try {
    				
    				//Extract metadata from the file, (if it exists).
        			try {
        				mmdr.setDataSource(mAudioFilePathsInFolder.get(i));
        			} catch (Exception e) {
        				//Just keep going. The service will handle the resulting error from this file.
        			}
        			
        			String artist = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);
        			if (artist==null || artist.isEmpty()) {
        				artist = "Unknown Artist";
        			}
        			
        			String album = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);
        			if (album==null || album.isEmpty()) {
        				album = "Unknown Album";
        			}
        			
        			String title = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE);
        			if (title==null || title.isEmpty()) {
        				title = mAudioFilePathsInFolder.get(i);
        			}
        			
        			String filePath = mAudioFilePathsInFolder.get(i);
        			String duration = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION);
        			if (duration==null || duration.isEmpty()) {
        				duration = "0";
        			}
        			
    				filePath = mAudioFilePathsInFolder.get(i);
        			foldersCursor.addRow(new Object[] { artist,
        												album,
        												title,
        												filePath,
        												duration,
        												genre,
        												songSource,
        												songAlbumArtPath,
        												songId, 
        												"", 
        												"" });
        			
    				if (i >= 5 && cursorChanged==false) {
    					mApp.getNowPlayingActivity().setIsCursorLoaded(true);
    					
    					mCursor = (Cursor) foldersCursor;
    					mApp.getNowPlayingActivity().setCursor(mCursor);
    		    		mApp.getService().setCursor((Cursor) foldersCursor);
    		    		cursorChanged = true;
    				}
        			
    			} catch (Exception e) {
    				e.printStackTrace();
    				continue;
    			}

    		}
    		
    		mCursor = (Cursor) foldersCursor;
    		mApp.getNowPlayingActivity().setCursor(mCursor);
    		mApp.getService().setCursor((Cursor) foldersCursor);
    		
    	} else {

    		//Check if the "Play all" button was pressed (or the song was selected from an album).
    		if (mBundle.getString("PLAY_ALL").equals("ARTIST")) {

    			String selection = "";
    		    if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.all_libraries))) {

    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'";
    		    	} else {
    		    		selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'"
    		    				  + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    		    	}

    		        mCursor = mApp.getDBAccessHelper().playAllArtistsFlippedAllLibraries(selection);
    		        mApp.getNowPlayingActivity().setCursor(mCursor);
    		    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.google_play_music_no_asterisk))) {
    			    selection = " AND " + DBAccessHelper.SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'" + " AND "
    			    		  + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'";
    		        mCursor = mApp.getDBAccessHelper().getAllSongsByArtistSearchable(selection);
    		        mApp.getNowPlayingActivity().setCursor(mCursor);
    		    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.on_this_device))) { 
    		    	//Check if Google Play Music is enabled.
    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'"
    		    				  + " AND (" + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " OR "
    		    				  + DBAccessHelper.LOCAL_COPY_PATH + "<> '')";
    		    	} else {
    		    		selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'"
    		    				  + " AND " + DBAccessHelper.SONG_SOURCE + " <> " + "'GOOGLE_PLAY_MUSIC'";
    		    	}
    		    	
    		    	mCursor = mApp.getDBAccessHelper().getAllSongsByArtistSearchable(selection);
    		    	mApp.getNowPlayingActivity().setCursor(mCursor);
    	    	} else {
    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'" + " AND "
      		    			      + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'";
    		    	} else {
    		    		selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'" + " AND "
    		    			      + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'"
    		    				  + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    		    	}
    		    	
    		        mCursor = mApp.getDBAccessHelper().getAllSongsByArtistInLibrary(selection);
    		        mApp.getNowPlayingActivity().setCursor(mCursor);
    		    }
    			
    			mApp.getService().setCursor(mCursor);
    			
    		} else if (mBundle.getString("PLAY_ALL").equals("ALBUM_ARTIST")) {
    			
    			String selection = "";
    		    if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.all_libraries))) {

    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'";
    		    	} else {
    		    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'"
    		    				  + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    		    	}

    		        mCursor = mApp.getDBAccessHelper().playAllAlbumArtistsFlippedAllLibraries(selection);
    		        mApp.getNowPlayingActivity().setCursor(mCursor);
    		    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.google_play_music_no_asterisk))) {
    			    selection = " AND " + DBAccessHelper.SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'" + " AND "
    			    		  + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'";
    		        mCursor = mApp.getDBAccessHelper().getAllSongsByAlbumArtistSearchable(selection);
    		        mApp.getNowPlayingActivity().setCursor(mCursor);
    		    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.on_this_device))) { 
    		    	//Check if Google Play Music is enabled.
    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'"
    		    				  + " AND (" + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " OR "
    		    				  + DBAccessHelper.LOCAL_COPY_PATH + "<> '')";
    		    		mCursor = mApp.getDBAccessHelper().getAllUniqueAlbumsByAlbumArtist(selection);
    		    		mApp.getNowPlayingActivity().setCursor(mCursor);
    		    	} else {
    		    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'"
    		    				  + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'"; 
    			        mCursor = mApp.getDBAccessHelper().getAllUniqueAlbumsByAlbumArtist(selection);
    			        mApp.getNowPlayingActivity().setCursor(mCursor);
    		    	}
    		    	
    	    	} else {
    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'" + " AND "
      		    			      + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'";
    		    	} else {
    		    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'" + " AND "
    		    			      + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'"
    		    				  + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    		    	}
    		    	
    		        mCursor = mApp.getDBAccessHelper().getAllSongsByAlbumArtistInLibrary(selection);
    		        mApp.getNowPlayingActivity().setCursor(mCursor);
    		    }
    			
    			mApp.getService().setCursor(mCursor);
    			
    		} else if (mBundle.getString("PLAY_ALL").equals("ALBUM") && 
    				   mBundle.getString("CALLING_FRAGMENT").equals("ALBUM_ARTISTS_FLIPPED_SONGS_FRAGMENT")) {
    			
    			String selection = "";
    			if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.all_libraries))) {
    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
    							  + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'";
    		    	} else {
    		    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
    							  + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'"
    							  + " AND " + DBAccessHelper.SONG_SOURCE + " <> " + "'GOOGLE_PLAY_MUSIC'";
    		    	}
    			    
    		        mCursor = mApp.getDBAccessHelper().getAllSongsByAlbumArtistAlbum(selection);
    		        mApp.getNowPlayingActivity().setCursor(mCursor);
    		        
    		    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.google_play_music_no_asterisk))) {
		    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
							  + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'" + " AND " + 
							  DBAccessHelper.SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'";
		    		mCursor = mApp.getDBAccessHelper().getAllSongsByAlbumArtistAlbum(selection);
		    		mApp.getNowPlayingActivity().setCursor(mCursor);
    			    
    		    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.on_this_device))) { 
    		    	//Check if Google Play Music is enabled.
    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'"
    		    				  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum + "'"
    		    				  + " AND (" + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " OR "
    		    				  + DBAccessHelper.LOCAL_COPY_PATH + "<> '')";
    		    		mCursor = mApp.getDBAccessHelper().getAllUniqueAlbumsByAlbumArtist(selection);
    		    		mApp.getNowPlayingActivity().setCursor(mCursor);
    		    		
    		    	} else {
    		    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'"
    		    				  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum + "'"
    		    				  + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'"; 
    			        mCursor = mApp.getDBAccessHelper().getAllUniqueAlbumsByAlbumArtist(selection);
    			        mApp.getNowPlayingActivity().setCursor(mCursor);
    		    	}
    		    	
    	    	} else {
    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
    							  + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'" + " AND " 
    							  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'";
    		    	} else {selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
    						  + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + mSongAlbumArtist + "'" + " AND " 
    						  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'" + " AND "
    						  + DBAccessHelper.SONG_SOURCE + " <> " + "'GOOGLE_PLAY_MUSIC'";
    		    	}
    		    	mCursor = mApp.getDBAccessHelper().getAllSongsByAlbumArtistAlbumInLibrary(selection);
    		    	mApp.getNowPlayingActivity().setCursor(mCursor);
    		    }
    			
    			mApp.getService().setCursor(mCursor);
    			
    		} else if (mBundle.getString("PLAY_ALL").equals("ALBUM")) {
    	    				 
    	    	String selection = "";
			    if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.all_libraries))) {
			    	
			    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
			    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
								  + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'";
			    	} else {
			    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
								  + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'"
								  + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
			    	}

			        mCursor = mApp.getDBAccessHelper().getAllSongsByArtistAlbum(selection);
			        mApp.getNowPlayingActivity().setCursor(mCursor);
			    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.google_play_music_no_asterisk))) {
				    selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
							  + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'" + " AND " + 
							  DBAccessHelper.SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'";
			        mCursor = mApp.getDBAccessHelper().getAllSongsByArtistAlbum(selection);
			        mApp.getNowPlayingActivity().setCursor(mCursor);
			        
			    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.on_this_device))) { 
			    	//Check if Google Play Music is enabled.
			    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
			    		selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'"
			    				  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum + "'"
			    				  + " AND (" + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " OR "
			    				  + DBAccessHelper.LOCAL_COPY_PATH + "<> '')";
			    	} else {
			    		selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'"
			    				  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum + "'"
			    				  + " AND " + DBAccessHelper.SONG_SOURCE + " <> " + "'GOOGLE_PLAY_MUSIC'";
			    	}
			    	
			    	mCursor = mApp.getDBAccessHelper().getAllSongsByArtistAlbum(selection);
			    	mApp.getNowPlayingActivity().setCursor(mCursor);
			    	
		    	} else {
			    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
			    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
								  + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'" + " AND " 
								  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'";
			    	} else {
			    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum  + "'" + " AND "
								  + DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'" + " AND " 
								  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'"
								  + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
			    	}
				    
			        mCursor = mApp.getDBAccessHelper().getAllSongsByArtistAlbumInLibrary(selection);
			        mApp.getNowPlayingActivity().setCursor(mCursor);
			    }
    			
    			mApp.getService().setCursor(mCursor);
    			
    		} else if (mBundle.getString("PLAY_ALL").equals("GENRE")) {
				 
    			String selection = "";
    			if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.all_libraries))) {
    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'";
    		    	} else {
    		    		selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'"
    							  + " AND " + DBAccessHelper.SONG_SOURCE + " <> " + "'GOOGLE_PLAY_MUSIC'";
    		    	}
    			    
    		        mCursor = mApp.getDBAccessHelper().getAllSongsInGenre(selection);
    		        mApp.getNowPlayingActivity().setCursor(mCursor);
    		        
    		    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.google_play_music_no_asterisk))) {
    		    	selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre  + "'"
		    				  + " AND " +  DBAccessHelper.SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'";
    		    	mCursor = mApp.getDBAccessHelper().getAllSongsInGenre(selection);
    		    	mApp.getNowPlayingActivity().setCursor(mCursor);		    		
    		    	
    		    } else if (mCurrentLibrary.equals(mContext.getResources().getString(R.string.on_this_device))) { 
    		    	//Check if Google Play Music is enabled.
    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'"
    		    			      + " AND (" + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " OR "
    		    				  + DBAccessHelper.LOCAL_COPY_PATH + "<> '')";
    		    		mCursor = mApp.getDBAccessHelper().getAllSongsInGenre(selection);
    		    		mApp.getNowPlayingActivity().setCursor(mCursor);
    		    	} else {
    		    		selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre + "'"
    		    				  + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'"; 
    		    		mCursor = mApp.getDBAccessHelper().getAllSongsInGenre(selection);
    		    		mApp.getNowPlayingActivity().setCursor(mCursor);
    		    	}
    		    	
    	    	} else {
    		    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		    		selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre  + "'" + " AND " 
    							  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'";
    		    	} else {
    		    		selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + mSongGenre  + "'" + " AND " 
    		    				  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + mCurrentLibrary + "'" + " AND "
    		    				  + DBAccessHelper.SONG_SOURCE + " <> " + "'GOOGLE_PLAY_MUSIC'";
    		    	}
    		    	
    		    	mCursor = mApp.getDBAccessHelper().getAllSongsInGenreInLibrary(selection);
    		    	mApp.getNowPlayingActivity().setCursor(mCursor);
    		    }
	
    			mApp.getService().setCursor(mCursor);
	
    		} else {

    			if (mSongTitle!=null) {
    				
        			if (mSongTitle.contains("'")) {
        				mSongTitle = mSongTitle.replace("'", "''");
        			}
        			
    			}

    			String selection = "";
    			
    			if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
        			selection = DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'" + " AND "
      					      + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum + "'" + " AND "
     						  + DBAccessHelper.SONG_TITLE + "=" + "'" + mSongTitle + "'" + " AND "
     		    			  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'";
    			} else {
        			selection = DBAccessHelper.SONG_ARTIST + "=" + "'" + mSongArtist + "'" + " AND "
      					      + DBAccessHelper.SONG_ALBUM + "=" + "'" + mSongAlbum + "'" + " AND "
     						  + DBAccessHelper.SONG_TITLE + "=" + "'" + mSongTitle + "'" + " AND "
     		    			  + DBAccessHelper.BLACKLIST_STATUS + "=" + "'FALSE'" + " AND "
     						  + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
    			}

    			
    			mCursor = mApp.getDBAccessHelper().getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
		   													  null, 
		   													  selection, 
		   													  null, 
		   													  null, 
		   													  null, 
		   													  DBAccessHelper.SONG_TRACK_NUMBER + "*1 ASC");
    			
    			mApp.getService().setCursor(mCursor);
    			
    		}
    		
    	}
    	
    	if (mCurrentLibrary!=null) {
    		
    		if (mCurrentLibrary.contains("'")) {
    			mCurrentLibrary = mCurrentLibrary.replace("''", "'");
    		}
    		
    	}
    	
    	if (mSongArtist!=null) {
    		
    	    if (mSongArtist.contains("''")) {
    	    	mSongArtist = mSongArtist.replace("''", "'");
    	    }
    	    
    	}
    	
    	if (mSongAlbumArtist!=null) {
    		
    		if (mSongAlbumArtist.contains("''")) {
    			mSongAlbumArtist = mSongAlbumArtist.replace("''", "'");
    		}
    		
    	}
	    
    	if (mSongAlbum!=null) {
    		
    	    if (mSongAlbum.contains("'")) {
    	    	mSongAlbum = mSongAlbum.replace("''", "'");
    	    }
    	    
    	}
	    
    	if (mSongGenre!=null) {
    		
    	    if (mSongGenre.contains("''")) {
    	    	mSongGenre = mSongGenre.replace("''", "'");
    	    }
    	    
    	}
	    
    	if (mSongTitle!=null) {
    		
    		if (mSongTitle.contains("''")) {
    			mSongTitle = mSongTitle.replace("''", "'");
    		}
    		
    	}

    }
	
	@Override
	public void onProgressUpdate(Integer... values) {
		super.onProgressUpdate(values);

		
	}
	
	@Override
	public void onPostExecute(Boolean result) {
		super.onPostExecute(result);
		
		try {
			mApp.getNowPlayingActivity().setIsCursorLoaded(true);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}

}
*/

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;

import org.apache.commons.io.FileUtils;

import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.AsyncTask;
import android.util.Log;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.FoldersFragment.FilesFoldersFragment;

public class AsyncCopyMoveTask extends AsyncTask<String, Void, Boolean> {
	
    private Context mContext;
    private ProgressDialog pd;
    private FilesFoldersFragment mFragment;
    private boolean mShouldMove;
	
	private File mSourceFile;
	private File mDestinationFile;
    
    public AsyncCopyMoveTask(Context context,
                             File sourceFile,
                             File destinationFile,
                             FilesFoldersFragment fragment,
                             boolean shouldMove) {
    	
    	mContext = context;
    	mSourceFile = sourceFile;
        mFragment = fragment;
    	mDestinationFile = destinationFile;
        mShouldMove = shouldMove;
    }
    
    protected void onPreExecute() {
		pd = new ProgressDialog(mFragment.getActivity());
		pd.setCancelable(false);
		pd.setIndeterminate(false);

        if (mShouldMove) {
            pd.setTitle(R.string.move);
            pd.setMessage(mContext.getResources().getString(R.string.moving_file));
        } else {
            pd.setTitle(R.string.copy);
            pd.setMessage(mContext.getResources().getString(R.string.copying_file));
        }

		pd.setButton(DialogInterface.BUTTON_NEUTRAL, mContext.getResources()
															 .getString(R.string.run_in_background), 
															 new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				pd.dismiss();
				
			}
			
		});
		
		pd.show();
    	
    }
 
    @Override
    protected Boolean doInBackground(String... params) {

        try {
            if (mSourceFile.getCanonicalPath()==mDestinationFile.getCanonicalPath()) {
                Toast.makeText(mContext, R.string.source_target_same, Toast.LENGTH_LONG).show();
                return false;
            }

        } catch (Exception e) {
            return false;
        }

    	if (mSourceFile.isDirectory()) {
    		
    		try {
                if (mShouldMove)
				    FileUtils.moveDirectoryToDirectory(mSourceFile, mDestinationFile, true);
                else
                    FileUtils.copyDirectoryToDirectory(mSourceFile, mDestinationFile);

			} catch (Exception e) {
				return false;
			}
    		
    	} else {
    		
    		try {
                if (mShouldMove)
    			    FileUtils.moveFileToDirectory(mSourceFile, mDestinationFile, true);
                else
                    FileUtils.copyFile(mSourceFile, mDestinationFile);

    		} catch (Exception e) {
    			return false;
    		}
    		
    	}

    	return true;
    }

    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
		
    	pd.dismiss();
    	if (result==true) {
            if (mShouldMove)
        	    Toast.makeText(mContext, R.string.done_move, Toast.LENGTH_SHORT).show();
            else
                Toast.makeText(mContext, R.string.done_copy, Toast.LENGTH_SHORT).show();
    	} else {
            if (mShouldMove)
        	    Toast.makeText(mContext, R.string.file_could_not_be_written_new_location, Toast.LENGTH_LONG).show();
            else
                Toast.makeText(mContext, R.string.file_could_not_be_written_new_location, Toast.LENGTH_LONG).show();
    	}

        try {
            mFragment.refreshListView();
        } catch (Exception e) {
            e.printStackTrace();
        } catch (Error er) {
            er.printStackTrace();
        }
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.util.HashSet;

import android.app.Activity;
import android.content.ContentValues;
import android.content.Context;
import android.os.AsyncTask;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Utils.Common;

/**************************************************************************************
 * This AsyncTask creates the specified music library.
 * 
 * @author Saravan Pantham
 **************************************************************************************/
public class AsyncCreateMusicLibraryTask extends AsyncTask<String, Void, Void> {
	
	private Activity mActivity;
    private Context mContext;
    private Common mApp;
    private HashSet<String> mSongDBIds = new HashSet<String>();
    private String mLibraryName;
    private String mLibraryColorCode;
    
    public AsyncCreateMusicLibraryTask(Activity activity,
    								   Context context, 
    								   HashSet<String> songDBIds, 
    								   String libraryName, 
    								   String libraryColorCode) {
    	mActivity = activity;
    	mContext = context;
    	mApp = (Common) context.getApplicationContext();
    	mSongDBIds = songDBIds;
    	mLibraryName = libraryName;
    	mLibraryColorCode = libraryColorCode;
    	
    }
 
    @Override
    protected Void doInBackground(String... params) {

    	//Delete the library if it currently exists.
    	mApp.getDBAccessHelper().deleteLibrary(mLibraryName, mLibraryColorCode);
    	
    	try {
    		mApp.getDBAccessHelper().getWritableDatabase().beginTransaction();
    		
    		//HashSets aren't meant to be browsable, so convert it into an array.
    		String[] songIdsArray = new String[mSongDBIds.size()];
    		mSongDBIds.toArray(songIdsArray);

    		//Loop through the array and add the songIDs to the library.
    		for (int i=0; i < songIdsArray.length; i++) {
    			ContentValues values = new ContentValues();
    			values.put(DBAccessHelper.LIBRARY_NAME, mLibraryName);
    			values.put(DBAccessHelper.SONG_ID, songIdsArray[i]);
    			values.put(DBAccessHelper.LIBRARY_TAG, mLibraryColorCode);
    			
        		mApp.getDBAccessHelper().getWritableDatabase().insert(DBAccessHelper.LIBRARIES_TABLE, null, values);
    		}
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    		return null;
    	} finally {
    		mApp.getDBAccessHelper().getWritableDatabase().setTransactionSuccessful();
    		mApp.getDBAccessHelper().getWritableDatabase().endTransaction();
    	}
    	
    	return null;
	    
    }

    @Override
    protected void onPostExecute(Void arg0) {
    	mActivity.finish();
    	Toast.makeText(mContext, R.string.done_creating_library, Toast.LENGTH_LONG).show();
       
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.util.ArrayList;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.provider.MediaStore;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;

public class AsyncCreateNewPlaylistTask extends AsyncTask<String, Integer, Boolean> {
    private Context mContext;
    private Cursor mCursor;
    private String mPlaylistName;
    private String mPlaylistId;
    private SharedPreferences sharedPreferences;
    private DBAccessHelper musicLibraryDBHelper;
    private DBAccessHelper musicLibraryPlaylistsDBHelper;
    
    private String mArtist;
    private String mAlbum;
    private String mSong;
    private String mGenre;
    private String mAlbumArtist;
    private String mAddType;
    
    private final String[] PROJECTION_PLAYLIST = new String[] {
        MediaStore.Audio.Playlists._ID,
        MediaStore.Audio.Playlists.NAME,
        MediaStore.Audio.Playlists.DATA
    };
    
    public AsyncCreateNewPlaylistTask(Context context, 
    								  String playlistName, 
    								  String ARTIST, 
    								  String ALBUM, 
    								  String SONG, 
    								  String GENRE, 
    								  String ALBUM_ARTIST,
    								  String ADD_TYPE) {
    	
    	mContext = context;
    	mPlaylistName = playlistName;
    	sharedPreferences = context.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    	musicLibraryDBHelper = new DBAccessHelper(mContext);
    	musicLibraryPlaylistsDBHelper = new DBAccessHelper(mContext);
    	
    	mArtist = ARTIST;
    	mAlbum = ALBUM;
    	mSong = SONG;
    	mGenre = GENRE;
    	mAlbumArtist = ALBUM_ARTIST;
    	mAddType = ADD_TYPE;
    }
 
    @Override
    protected Boolean doInBackground(String... params) {
    	
		/*//Replace illegal characters in the playlistName.
		if (mPlaylistName.contains("/")) {
			mPlaylistName = mPlaylistName.replace("/", "_");
		}
		
		if (mPlaylistName.contains("\\")) {
			mPlaylistName = mPlaylistName.replace("\\", "_");
		}
    	
    	//Get the cursor with the playlist elements.
    	String playlistFolderPath = sharedPreferences.getString("PLAYLISTS_SAVE_FOLDER", 
    															Environment.getExternalStorageDirectory() + "/Playlists/");
    	
    	String playlistFilePath = playlistFolderPath + mPlaylistName + ".m3u";
    	mCursor = AddPlaylistUtils.getPlaylistElementsCursor(mContext, 
    														 musicLibraryDBHelper, 
    														 sharedPreferences, 
    														 mArtist, 
    														 mAlbum, 
    														 mSong, 
    														 mGenre, 
    														 mAlbumArtist,
    														 mAddType);
    	
		//If GMusic is enabled, create the playlist on Google's servers first.
    	if (sharedPreferences.getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
        	String playlistId = null;
    		try {
    			playlistId = GMusicClientCalls.createPlaylist(mContext, mPlaylistName);
    			mPlaylistId = playlistId;
    		} catch (IllegalArgumentException e) {
    			e.printStackTrace();
    			return false;
    		} catch (JSONException e) {
    			e.printStackTrace();
    			return false;
    		} catch (Exception e) {
    			e.printStackTrace();
    			return false;
    		}
    		
    	} else {
    		//Create the playlist in Android's MediaStore. mPlaylistId will be assigned in this method.
    		createMediaStorePlaylist(mPlaylistName);
    	}
    	
    	Cursor gMusicCursor = null;
    	ArrayList<Integer> gMusicSongOrder = new ArrayList<Integer>();
    	for (int i=0; i < mCursor.getCount(); i++) {
    		try {
    			mCursor.moveToPosition(i);
    			String songSource = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_SOURCE));
    			
    			 This if/else block will handle the different operations that need to be 
    			 * done/ommitted for each different song type (Google Play Music vs local
    			 * song file).
    			 
    			String clientId = "";
    			if (songSource.equals(DBAccessHelper.GMUSIC)) {
    				
    				//Retrieve the clientId of the current song from GMusic's content mApp.
        	    	Uri googlePlayMusicContentProviderUri = Uri.parse("content://com.google.android.music.MusicContent/audio");
        	    	String[] projection = { "SourceId", "ClientId AS client_id" };
        			
        			String songId = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ID));
        			String selection = "SourceId=" + "'" + songId + "'";
        	    	gMusicCursor = mContext.getContentResolver().query(googlePlayMusicContentProviderUri, projection, selection, null, null);
        	    	gMusicCursor.moveToFirst();
        	    	clientId = gMusicCursor.getString(1);
        			
        	    	//Populate the mutations JSONArray.
        			JSONObject createObject = new JSONObject();

        			createObject.put("lastModifiedTimestamp", "0");
        			createObject.put("playlistId", mPlaylistId);
        			createObject.put("creationTimestamp", "-1");
        			createObject.put("type", "USER_GENERATED");
        			createObject.put("source", 1);
        			createObject.put("deleted", false);
        			createObject.put("trackId", songId);
        			createObject.put("clientId", clientId);
        			
        			//Add the request to the JSONArray queue that will update Google's servers.
        	    	GMusicClientCalls.putCreatePlaylistEntryRequest(createObject);	
        	    	gMusicSongOrder.add(i);
        	    	
    			} else {
    				
    				//Add the song to Android's MediaStore database.
    				String artist = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ARTIST));
    				String album = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ALBUM));
    				String title = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_TITLE));
    				
    				try {
    					long audioId = getSongAudioId(artist, album, title);
    					if (audioId!=-1) {
    						addSongToPlaylist(mContext.getContentResolver(), audioId, Long.parseLong(mPlaylistId));
    					}
        				
    				} catch (Exception e) {
    					//Just fail silently if this song can't be inserted into the playlist.
    					e.printStackTrace();
    				}

        			//Add the song to the playlists database.
        			musicLibraryPlaylistsDBHelper.addNewPlaylist(mPlaylistName, 
        														 playlistFilePath, 
        														 playlistFolderPath, 
        														 mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH)), 
        														 "LOCAL", 
        														 mPlaylistId,
        														 mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ID)),
        														 new Date().getTime(),
        														 i,
        														 UUID.randomUUID().toString());
    			}
    		
    		} catch (Exception e) {
    			e.printStackTrace();
    			continue;
    		}
    		
    	}
    	
    	//Show a confirmation toast message.
    	publishProgress(new Integer[] {0});
    	
    	//Send the HTTP request that will update Google's servers.
    	if (sharedPreferences.getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		try {
        		if (GMusicClientCalls.getQueuedMutationsCount()!=0) {
        			GMusicClientCalls.modifyPlaylist(mContext);
        			
        			//Reload the entire playlist.
        			reloadPlaylistEntries(gMusicSongOrder);
        			
        		}
        		
    		} catch (IllegalArgumentException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		} catch (JSONException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    	}

    	if (gMusicCursor!=null) {
    		gMusicCursor.close();
    		gMusicCursor = null;
    	}*/
    	
    	return true;
    }
    
    public void reloadPlaylistEntries(ArrayList<Integer> gMusicSongOrder) {
    	/*JSONArray jsonArray = null;
    	try {
			jsonArray = GMusicClientCalls.getPlaylistEntriesWebClient(mContext, mPlaylistId);
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (JSONException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	
    	//Remove all GMusic songs in the current playlist (within the local databse).
		musicLibraryPlaylistsDBHelper.removeGMusicSongsFromPlaylist(mContext, mPlaylistId);
    	
    	//Loop through the playlist's songs array and retrieve each song's metadata.
		WebClientSongsSchema currentPlaylistSong = new WebClientSongsSchema();
    	for (int j=0; j < jsonArray.length(); j++) {
    		try {
    			currentPlaylistSong = currentPlaylistSong.fromJsonObject(jsonArray.getJSONObject(j));
        		//Extract the current playlist song's metadata.
            	String songTrackId = currentPlaylistSong.getId();
            	String playlistEntryId = currentPlaylistSong.getPlaylistEntryId();
            	
            	ContentValues playlistValues = new ContentValues();
            	playlistValues.put(DBAccessHelper.PLAYLIST_NAME, mPlaylistName);
            	playlistValues.put(DBAccessHelper.PLAYLIST_ID, mPlaylistId); 
            	playlistValues.put(DBAccessHelper.PLAYLIST_ART_URL, "");
            	playlistValues.put(DBAccessHelper.PLAYLIST_SOURCE, DBAccessHelper.GMUSIC);
            	playlistValues.put(DBAccessHelper.PLAYLIST_BLACKLIST_STATUS, "FALSE");
            	playlistValues.put(DBAccessHelper.PLAYLIST_SONG_FILE_PATH, songTrackId);
            	playlistValues.put(DBAccessHelper.PLAYLIST_SONG_ENTRY_ID, playlistEntryId);
            	playlistValues.put(DBAccessHelper.PLAYLIST_ORDER, gMusicSongOrder.get(j));
            	
            	//Add all the entries to the database to build the songs library.
            	musicLibraryPlaylistsDBHelper.getWritableDatabase().insert(DBAccessHelper.MUSIC_LIBRARY_PLAYLISTS_NAME, 
            												 			   null, 
            												 			   playlistValues);
    		} catch (Exception e) {
    			e.printStackTrace();
    			continue;
    		}
    		
    	}*/
        	
    }
    
    private void createMediaStorePlaylist(String playlistName) {
    	ContentValues mInserts = new ContentValues();
        mInserts.put(MediaStore.Audio.Playlists.NAME, playlistName);
        mInserts.put(MediaStore.Audio.Playlists.DATE_ADDED, System.currentTimeMillis());
        mInserts.put(MediaStore.Audio.Playlists.DATE_MODIFIED, System.currentTimeMillis());
        Uri mUri = mContext.getContentResolver().insert(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, mInserts);
        if (mUri != null) {
            Cursor c = mContext.getContentResolver().query(mUri, PROJECTION_PLAYLIST, null, null, null);
            if (c != null) {
                /* Save the newly created ID so it can be selected. Names are allowed to be duplicated,
                 * but IDs can never be. */
            	c.moveToFirst();
                mPlaylistId = "" + c.getLong(c.getColumnIndex(MediaStore.Audio.Playlists._ID));
                c.close();
            }

        }
        
    }
    
    private void addSongToPlaylist(ContentResolver resolver, long audioId, long playlistId) {

        String[] cols = new String[] {
                "count(*)"
        };
        
        Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId);
        Cursor cur = resolver.query(uri, cols, null, null, null);
        cur.moveToFirst();
        final int base = cur.getInt(0);
        cur.close();
        ContentValues values = new ContentValues();
        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, Long.valueOf(base + audioId));
        values.put(MediaStore.Audio.Playlists.Members.AUDIO_ID, audioId);
        resolver.insert(uri, values);
    }
    
    private long getSongAudioId(String artist, String album, String title) {
    	artist = artist.replace("'", "''");
    	album = album.replace("'", "''");
    	title = title.replace("'", "''");
    	
    	String selection = MediaStore.Audio.AudioColumns.ALBUM + "=" + "'" + album + "'" + " AND "
    					 + MediaStore.Audio.AudioColumns.ARTIST + "=" + "'" + artist + "'" + " AND "
    					 + MediaStore.Audio.AudioColumns.TITLE + "=" + "'" + title + "'";
    	
    	Cursor cursor = mContext.getContentResolver().query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, 
    														null, 
    														selection, 
    														null,
    														null);
    	
    	if (cursor!=null && cursor.getCount() > 0) {
    		cursor.moveToFirst();
    		return cursor.getLong(cursor.getColumnIndex(MediaStore.Audio.Media._ID));
    	} else {
    		return -1;
    	}
    	
    }
    
    @Override
    protected void onProgressUpdate(Integer... values) {
    	super.onProgressUpdate(values);
    	switch(values[0]) {
    	case 0:
    		//Common.displayToast(R.string.playlist_created, Toast.LENGTH_SHORT);
    		Toast.makeText(mContext, R.string.playlist_created, Toast.LENGTH_SHORT).show();
    		break;
    	case 1:
    		//Common.displayToast(R.string.playlist_could_not_be_created, Toast.LENGTH_SHORT);
    		Toast.makeText(mContext, R.string.playlist_could_not_be_created, Toast.LENGTH_SHORT).show();
    		break;
    	}
    	
    }
    
    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
    	
    	if (mCursor!=null) {
    		mCursor.close();
        	mCursor = null;
    	}
    
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.audio.exceptions.CannotReadException;
import org.jaudiotagger.audio.exceptions.CannotWriteException;
import org.jaudiotagger.audio.exceptions.InvalidAudioFrameException;
import org.jaudiotagger.audio.exceptions.ReadOnlyFileException;
import org.jaudiotagger.tag.KeyNotFoundException;
import org.jaudiotagger.tag.Tag;
import org.jaudiotagger.tag.TagException;

import android.app.Activity;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.os.AsyncTask;
import android.view.View;
import android.widget.ImageView;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Utils.Common;

public class AsyncDeleteAlbumArtTask extends AsyncTask<String, Void, Void> {
    private Context mContext;
    private Common mApp;
    
    private Activity mActivity;
    private String artist = "";
    private String album = "";
    private String mCallingFragment = null;
    private View mViewItem;
    private int mImageID;
    private ImageView frontImage;
    
	public static ArrayList<String> dataURIsList = new ArrayList<String>();
	public static ArrayList<String> albumArtPathsList = new ArrayList<String>();
    
    public AsyncDeleteAlbumArtTask(Context context, View viewItem, int imageID, Activity activity, String callingFragment) {
    	mContext = context;
    	mApp = (Common) mContext.getApplicationContext();
    	mViewItem = viewItem;
    	mImageID = imageID;
    	mActivity = activity;
    	mCallingFragment = callingFragment;
    }
 
    @Override
    protected Void doInBackground(String... params) {
    	
    	if (params.length==2) {
    		artist = params[0];
    		album = params[1];
    	}
    	
		/*
		 * Loop through the songs table and retrieve the data paths of all the songs (used to embed the artwork).
		 */
		
		//Remove the + and replace them back with spaces. Also replace any rogue apostrophes.
		try {
			if (album.contains("+")) {
				album = album.replace("+", " ");
			}
			
			if (album.contains("'")) {
				album = album.replace("'", "''");
			}
		
			if (artist.contains("+")) {
				artist = artist.replace("+", " ");
			}
			
			if (artist.contains("'")) {
				artist = artist.replace("'", "''");
			}
		} catch (Exception e) {
			e.printStackTrace();
		}

		
		String selection = DBAccessHelper.SONG_ALBUM + "=" + "'" + album + "'" + " AND "
						 + DBAccessHelper.SONG_ARTIST + "=" + "'" + artist + "'";
		
		String[] projection = { DBAccessHelper._ID, 
								DBAccessHelper.SONG_FILE_PATH, 
								DBAccessHelper.SONG_ALBUM_ART_PATH };
		
		Cursor cursor = mApp.getDBAccessHelper().getWritableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
											 				 				 projection, 
											 				 				 selection, 
											 				 				 null, 
											 				 				 null,
											 				 				 null, 
											 				 				 null);
		
		cursor.moveToFirst();
		if (cursor.getCount()!=0) {
			dataURIsList.add(cursor.getString(1));
			albumArtPathsList.add(cursor.getString(2));
		}
		
		while(cursor.moveToNext()) {
			dataURIsList.add(cursor.getString(1));
			albumArtPathsList.add(cursor.getString(2));
		}
		
		for (int i=0; i < dataURIsList.size(); i++) {
	       	
	       	File audioFile = new File(dataURIsList.get(i));
    		AudioFile f = null;
    		
			try {
				f = AudioFileIO.read(audioFile);
			} catch (CannotReadException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TagException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (ReadOnlyFileException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidAudioFrameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			Tag tag = null;
			if (f!=null) {
				tag = f.getTag();
			} else {
				continue;
			}
			
    		try {
    			tag.deleteArtworkField();
    		} catch (KeyNotFoundException e) {
    			Toast.makeText(mContext, R.string.album_doesnt_have_artwork, Toast.LENGTH_LONG).show();
    		}
    		
    		try {
				f.commit();
			} catch (CannotWriteException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
    		
    		//Check if the current song's album art is a JPEG file.
    		if (albumArtPathsList.get(i).startsWith("/")) {
    			File file = new File(albumArtPathsList.get(i));
    			if (file!=null) {
    				if (file.exists()) {
    					file.delete();
    				}
    				
    			}
    			
    		}
    		
    		//Remove the album art from the album art database.
    		String filePath = dataURIsList.get(i);
    		filePath = filePath.replace("'", "''");
    		String where = DBAccessHelper.SONG_FILE_PATH + "=" + "'" + filePath + "'";
    		
    		ContentValues values = new ContentValues();
    		values.put(DBAccessHelper.SONG_ALBUM_ART_PATH, "");
    		mApp.getDBAccessHelper().getWritableDatabase().update(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
    											  				  values, 
    											  				  where, 
    											  				  null);
    		
		}
		
		//Refresh the memory/disk cache.
		mApp.getImageLoader().clearDiscCache();
		mApp.getImageLoader().clearMemoryCache();
		
		cursor.close();
		cursor = null;
		
    	return null;
	    
    }

    @Override
    protected void onPostExecute(Void arg0) {
    	super.onPostExecute(arg0);
    	
		Toast.makeText(mContext, R.string.album_art_deleted, Toast.LENGTH_LONG).show();
		
		//Update the UI.
		mApp.broadcastUpdateUICommand(new String[] {  }, new String[] {  });
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*package com.jams.music.player.AsyncTasks;

import java.io.File;

import org.json.JSONException;

import android.content.Context;
import android.os.AsyncTask;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.GMusicHelpers.GMusicClientCalls;
import com.jams.music.player.Utils.Common;

public class AsyncDeletePlaylistTask extends AsyncTask<String, Void, Boolean> {
	
    private Context mContext;
    private Common mApp;
    
    private String mPlaylistId;
    private String mPlaylistFilePath;
    
    public AsyncDeletePlaylistTask(Context context, String playlistId, String playlistFilePath) {
    	
    	mContext = context;
    	mApp = (Common) mApp;
    	mPlaylistId = playlistId;
    	mPlaylistFilePath = playlistFilePath;
    	
    }
 
    @Override
    protected Boolean doInBackground(String... params) {
    	
    	String result = null;
    	if (mApp.isGooglePlayMusicEnabled()) {
        	try {
    			result = GMusicClientCalls.deletePlaylist(mContext, mPlaylistId);
    		} catch (IllegalArgumentException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		} catch (JSONException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
        	
    	}
    	
    	if (result!=null || mApp.isGooglePlayMusicEnabled()==false) {
			mApp.getDBAccessHelper().deletePlaylistById(mPlaylistId);
			
			if (mPlaylistFilePath!=null) {
				File file = new File(mPlaylistFilePath);
				if (file.exists()) {
					file.delete();
				}
				
			}
			
    	}
    	
    	return true;
    }

    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
		Toast.makeText(mContext, R.string.playlist_deleted, Toast.LENGTH_SHORT).show();

		//Update the playlists UI.
		mApp.broadcastUpdateUICommand();
		
	}

}*/

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;

import org.apache.commons.io.FileUtils;

import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.AsyncTask;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.FoldersFragment.FilesFoldersFragment;

public class AsyncDeleteTask extends AsyncTask<String, Void, Boolean> {
    private Context mContext;
    private ProgressDialog pd;
    private FilesFoldersFragment mFragment;
	
	private File mSourceFile;
	private int mSourceType;
    
    public AsyncDeleteTask(Context context,
                           FilesFoldersFragment fragment,
    					   File source,
    					   int sourceType) {
    	
    	mContext = context;
        mFragment = fragment;
    	mSourceFile = source;
    	mSourceType = sourceType;
    }
    
    protected void onPreExecute() {
		pd = new ProgressDialog(mContext);
		pd.setCancelable(false);
		pd.setIndeterminate(false);
		pd.setTitle(R.string.delete);
		pd.setMessage(mContext.getResources().getString(R.string.deleting_files));
		pd.setButton(DialogInterface.BUTTON_NEUTRAL, mContext.getResources()
															 .getString(R.string.run_in_background), 
															 new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				pd.dismiss();
				
			}
			
		});
		
		pd.show();
    	
    }
 
    @Override
    protected Boolean doInBackground(String... params) {
    	
    	if (mSourceType==FilesFoldersFragment.FOLDER) {
    		
    		try {
				FileUtils.deleteDirectory(mSourceFile);
			} catch (Exception e) {
				return false;
			}
    		
    	} else {
    		try {
    			boolean status = mSourceFile.delete();
    			if (status==true) {
    				return true;
    			} else {
    				return false;
    			}
    			
    		} catch (Exception e) {
    			return false;
    		}
    		
    	}

    	return true;
    }

    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
		
    	pd.dismiss();
    	if (result==true) {
            if (mSourceType==FilesFoldersFragment.FOLDER)
        	    Toast.makeText(mContext, R.string.folder_deleted, Toast.LENGTH_SHORT).show();
            else
                Toast.makeText(mContext, R.string.file_deleted, Toast.LENGTH_SHORT).show();

    	} else {
            if (mSourceType==FilesFoldersFragment.FOLDER)
        	    Toast.makeText(mContext, R.string.folder_could_not_be_deleted, Toast.LENGTH_LONG).show();
            else
                Toast.makeText(mContext, R.string.file_could_not_be_deleted, Toast.LENGTH_LONG).show();

    	}

        try {
            mFragment.refreshListView();
        } catch (Exception e) {
            e.printStackTrace();
        }

	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.audio.exceptions.CannotReadException;
import org.jaudiotagger.audio.exceptions.CannotWriteException;
import org.jaudiotagger.audio.exceptions.InvalidAudioFrameException;
import org.jaudiotagger.audio.exceptions.ReadOnlyFileException;
import org.jaudiotagger.tag.FieldDataInvalidException;
import org.jaudiotagger.tag.Tag;
import org.jaudiotagger.tag.TagException;
import org.jaudiotagger.tag.images.Artwork;
import org.jaudiotagger.tag.images.ArtworkFactory;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.os.AsyncTask;
import android.os.Environment;
import android.view.View;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Utils.Common;

public class AsyncGetAlbumArtTask extends AsyncTask<String, Void, Integer> {
    private Context mContext;
    private Common mApp;
    
    private String artist = "";
    private String album = "";
    private String urlArtist = "";
    private String urlAlbum = "";
    private String artworkURL;
    
    private File file;
    private Bitmap artworkBitmap;
    private Boolean URL_RETRIEVED = false;
    
	public static ArrayList<String> dataURIsList = new ArrayList<String>();
    
    public AsyncGetAlbumArtTask(Context context, View viewItem, int imageID) {
    	mContext = context;
    	mApp = (Common) mContext.getApplicationContext();
    	
    }
    
    @Override
    protected void onPreExecute() {
    	Toast.makeText(mContext, R.string.getting_album_art_toast, Toast.LENGTH_SHORT).show();
    	
    }
 
    @Override
    protected Integer doInBackground(String... params) {
    	/************************************************************************************************
    	 * RETRIEVE THE HTTP SEARCH RESPONSE FROM ITUNES SERVERS.
    	 ************************************************************************************************/
    	
    	//First, we'll make a HTTP request to iTunes' servers with the album and artist name.
    	if (params.length==2) {
        	artist = params[0];
        	album = params[1];

        	//Create duplicate strings that will be filtered out for the URL.
        	urlArtist = artist;
        	urlAlbum = album;
        	
        	//Remove any unacceptable characters.
			if (urlArtist.contains("#")) {
				urlArtist = urlArtist.replace("#", "");
			}
			
			if (urlArtist.contains("$")) {
				urlArtist = urlArtist.replace("$", "");
			}
			
			if (urlArtist.contains("@")) {
				urlArtist = urlArtist.replace("@", "");
			}
			
			if (urlAlbum.contains("#")) {
				urlAlbum = urlAlbum.replace("#", "");
			}
			
			if (urlAlbum.contains("$")) {
				urlAlbum = urlAlbum.replace("$", "");
			}
			
			if (urlAlbum.contains("@")) {
				urlAlbum = urlAlbum.replace("@", "");
			}
			
			//Replace any spaces in the artist and album fields with "%20".
			if (urlArtist.contains(" ")) {
				urlArtist = urlArtist.replace(" ", "%20");
			}
			
			if (urlAlbum.contains(" ")) {
				urlAlbum = urlAlbum.replace(" ", "%20");
			}
        	
    	}
    	
    	//Construct the url for the HTTP request.
    	URL uri = null;
		try {
			uri = new URL("http://itunes.apple.com/search?term=" + urlArtist + "+" + urlAlbum + "&entity=album");
		} catch (MalformedURLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
			return 1;
		}
    	
    	try {
	    	//Create a new HTTP connection.
	        HttpURLConnection urlConnection = (HttpURLConnection) uri.openConnection();
	        urlConnection.connect();
	
	        //Set the destination directory for the xml file.
	        File SDCardRoot = Environment.getExternalStorageDirectory();
	        file = new File(SDCardRoot, "albumArt.xml");
	
	        //Create the OuputStream that will be used to store the downloaded data into the file.
	        FileOutputStream fileOutput = new FileOutputStream(file);
	
	        //Create the InputStream that will read the data from the HTTP connection.
	        InputStream inputStream = urlConnection.getInputStream();
	        
	        //Total size of target file.
	        int totalSize = urlConnection.getContentLength();
	
	        //Temp variable that stores the number of downloaded bytes.
	        int downloadedSize = 0;
	
	        //Create a buffer to store the downloaded bytes.
	        byte[] buffer = new byte[1024];
	        int bufferLength = 0;

	        //Now read through the buffer and write the contents to the file.
	        while((bufferLength = inputStream.read(buffer)) > 0 ) {
	            fileOutput.write(buffer, 0, bufferLength);
	            downloadedSize += bufferLength;
	
	        }
	        
	        //Close the File Output Stream.
	        fileOutput.close();

    	} catch (MalformedURLException e) {
    		//TODO Auto-generated method stub
    		e.printStackTrace();
    		return 1;
    	} catch (IOException e) {
    		// TODO Auto-generated method stub
    		e.printStackTrace();
    		return 1;
    	}
    	
    	
    	//Create a File object that points to the downloaded file.
    	File phpSource = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/albumArt.xml");
    	String phpAsString = null;
		try {
			phpAsString = FileUtils.readFileToString(phpSource);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return 1;
		}
		
		//Extract the albumArt parameter from the PHP response.
		artworkURL = StringUtils.substringBetween(phpAsString, "\"artworkUrl100\":\"", "\",");
		if (artworkURL==null) {
			
			//Check and see if a lower resolution image available.
			artworkURL = StringUtils.substringBetween(phpAsString, "\"artworkUrl60\":\"", "\",");
			
			if (artworkURL==null) {
				URL_RETRIEVED = false;
				return 1;
			} else {
				//Replace "100x100" with "600x600" to retrieve larger album art images.
				artworkURL = artworkURL.replace("100x100", "600x600");
				URL_RETRIEVED = true;
			}
	    	
		} else {
			//Replace "100x100" with "600x600" to retrieve larger album art images.
			artworkURL = artworkURL.replace("100x100", "600x600");
			URL_RETRIEVED = true;
		}
		
		//Loop through the songs table and retrieve the data paths of all the songs (used to embed the artwork).

		//Replace any rogue apostrophes.
		if (album.contains("'")) {
			album = album.replace("'", "''");
		}
		
		if (artist.contains("'")) {
			artist = artist.replace("'", "''");
		}
		
		String selection = DBAccessHelper.SONG_ALBUM + "=" + "'" + album + "'" + " AND "
						 + DBAccessHelper.SONG_ARTIST + "=" + "'" + artist + "'";
		
		String[] projection = { DBAccessHelper._ID, 
								DBAccessHelper.SONG_FILE_PATH };
		
		Cursor cursor = mApp.getDBAccessHelper().getWritableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
											 								 projection, 
					 														 selection, 
					 														 null, 
					 														 null, 
					 														 null, 
					 														 null);
		
		if (cursor.getCount()!=0) {
			cursor.moveToFirst();
			dataURIsList.add(cursor.getString(1));
			
			while(cursor.moveToNext()) {
				dataURIsList.add(cursor.getString(1));
			}
			
		}
		
		cursor.close();
		
		if (URL_RETRIEVED==true) {
    		artworkBitmap = mApp.getImageLoader().loadImageSync(artworkURL);

	    	File artworkFile = new File(Environment.getExternalStorageDirectory() + "/artwork.jpg");
    		
	    	//Display the album art on the grid/listview so that the user knows that the download is complete.
	    	publishProgress();
	    	
	    	//Save the artwork.
	    	try {
	    		FileOutputStream out = new FileOutputStream(artworkFile);
	    	    artworkBitmap.compress(Bitmap.CompressFormat.JPEG, 90, out);
	    	    out.flush();
	    	    out.close();
	    	} catch (Exception e) {
	    		e.printStackTrace();
	    		return 1;
	    	} finally {
		    	
	    		for (int i=0; i < dataURIsList.size(); i++) {
	    	       	
	    			if (dataURIsList.get(i)!=null) {
	    				
	    				File audioFile = new File(dataURIsList.get(i));
			    		AudioFile f = null;
			    		
						try {
							f = AudioFileIO.read(audioFile);
						} catch (CannotReadException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (TagException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (ReadOnlyFileException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (InvalidAudioFrameException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
						Tag tag = null;
						try {
							if (f!=null) {
								tag = f.getTag();
							} else {
								continue;
							}
							
						} catch (Exception e) {
							e.printStackTrace();
							continue;
						} 
			    		
			    		Artwork artwork = null;
						try {
							artwork = ArtworkFactory.createArtworkFromFile(artworkFile);
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
							setArtworkAsFile(artworkFile, dataURIsList.get(i));
							continue;
						} catch (Error e) {
							e.printStackTrace();
							setArtworkAsFile(artworkFile, dataURIsList.get(i));
							continue;
						}
						
						if (artwork!=null) {
							
				    		try {
								tag.setField(artwork);
							} catch (FieldDataInvalidException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
								setArtworkAsFile(artworkFile, dataURIsList.get(i));
								continue;
							} catch (Exception e) {
								e.printStackTrace();
								setArtworkAsFile(artworkFile, dataURIsList.get(i));
								continue;
							} catch (Error e) {
								e.printStackTrace();
								setArtworkAsFile(artworkFile, dataURIsList.get(i));
								continue;
							}
							
						}

			    		try {
							f.commit();
						} catch (CannotWriteException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
							setArtworkAsFile(artworkFile, dataURIsList.get(i));
							continue;
						} catch (Error e) {
							e.printStackTrace();
							setArtworkAsFile(artworkFile, dataURIsList.get(i));
							continue;
						}
			    		
			    		//Update the album art tag in Jams' database.
		    			ContentValues values = new ContentValues();
		    			String filePath = dataURIsList.get(i);
		    			filePath = filePath.replace("'", "''");
		    			String where = DBAccessHelper.SONG_FILE_PATH + "=" + "'" + filePath + "'";
		    			values.put(DBAccessHelper.SONG_ALBUM_ART_PATH, "byte://" + dataURIsList.get(i));
		    			
		    			mApp.getDBAccessHelper()
		    				.getWritableDatabase()
		    				.update(DBAccessHelper.MUSIC_LIBRARY_TABLE, values, where, null);
			    		
	    			} else {
	    				continue;
	    			}
	    			
	    		}
	    		
	    		//Refresh the memory/disk cache for the ImageLoader instance.
	    		try {
		    		mApp.getImageLoader().clearMemoryCache();
		    		mApp.getImageLoader().clearDiscCache();
	    		} catch (Exception e) {
	    			e.printStackTrace();
	    		}
	    		
	    		//Delete the temporary files once the artwork has been embedded.
	    		artworkFile.delete();
	    		file.delete();
	    		
	    	}
	    	
    	}
		
    	return 0;
    }
    
    //Saves the artwork as a JPEG file in the song's parent folder.
    public void setArtworkAsFile(File artworkFile, String songFilePath) {

    	File songFile = new File(songFilePath);
    	String songTitle = songFile.getName();
    	int lastDotSlash = songTitle.lastIndexOf(".");
    	String albumArtFileName = songTitle.substring(0, lastDotSlash);
    	
    	if (songFile.exists()) {
    		int lastSlashIndex = songFilePath.lastIndexOf("/");
    		String folderPath = songFilePath.substring(0, lastSlashIndex);
    		File destFile = new File(folderPath + "/" + albumArtFileName + ".jpg");
    		
    		try {
				FileUtils.copyFile(artworkFile, destFile);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				return;
			}
    		
    		//Update the album art tag in Jams' database.
			ContentValues values = new ContentValues();
			songFilePath = songFilePath.replace("'", "''");
			String where = DBAccessHelper.SONG_FILE_PATH + "=" + "'" + songFilePath + "'";
			values.put(DBAccessHelper.SONG_ALBUM_ART_PATH, folderPath + "/" + albumArtFileName + ".jpg");
			
			mApp.getDBAccessHelper()
				.getWritableDatabase()
				.update(DBAccessHelper.MUSIC_LIBRARY_TABLE, values, where, null);
    		
    	}

    }
    
    @Override
    protected void onProgressUpdate(Void... v) {
    	
    	if (URL_RETRIEVED==false) {
        	Toast.makeText(mContext, R.string.album_art_not_found, Toast.LENGTH_SHORT).show();
    	} else {
    		Toast.makeText(mContext, R.string.album_art_downloaded, Toast.LENGTH_SHORT).show();
    	}
    	
    }

    @Override
    protected void onPostExecute(Integer result) {
	    dataURIsList.clear();

	    if (result==0) {
	    	//Update the UI.
	    	mApp.broadcastUpdateUICommand(new String[] { }, new String[] { });
		    Toast.makeText(mContext, R.string.album_art_downloaded, Toast.LENGTH_SHORT).show();
	    } else {
	    	Toast.makeText(mContext, R.string.unable_to_get_album_art, Toast.LENGTH_SHORT).show();
	    }
	    
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;

import org.json.JSONArray;

import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.database.Cursor;
import android.media.AudioManager;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.PowerManager;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Services.BuildMusicLibraryService;
import com.jams.music.player.Services.AudioPlaybackService;
import com.jams.music.player.Utils.Common;

/**
 * Checks if the Google Play Music app is installed on the user's device. If it
 * is, grabs the user's song data from Google Play Music's content mApp.
 */
public class AsyncGetGooglePlayMusicMetadataTask extends AsyncTask<String, String, String> {
	
    private Context mContext;
	private Common mApp;
	
	private HashMap<String, String> playlistIdsNameMap = new HashMap<String, String>();
	private JSONArray playlistsJSONArray = new JSONArray();
	private JSONArray playlistEntriesJSONArray = new JSONArray();
	private ArrayList<String> genresList = new ArrayList<String>();
	
	private int targetVolume = 0;
	private int currentVolume;
	private int stepDownValue = 1;
	private AudioManager am;
	
	private String currentTask = "";
	private int currentProgressValue = 0;
	private int numberOfSongs = 0;
	private int numberOfPlaylists = 0;
	private Date date = new Date();
	
	private PowerManager pm;
	private PowerManager.WakeLock wakeLock;
    
    public AsyncGetGooglePlayMusicMetadataTask(Context context) {
    	mContext = context;
    	mApp = (Common) mContext;
    	
    }
 
    @Override
    protected void onPreExecute() {
    	super.onPreExecute();
    	
    	//Hide the actionbar.
    	mApp.setIsBuildingLibrary(true);
    	
    	//Acquire a wakelock to prevent the CPU from sleeping while the process is running.
    	pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    	wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "com.jams.music.player.AsyncTasks.AsyncGetGooglePlayMusicMetadata");
    	wakeLock.acquire();
    	
    	//Set the initial setting of the progressbar as indeterminate.
    	currentTask = mContext.getResources().getString(R.string.contacting_google_play_music);
    	
    }
    
    @Override
    protected String doInBackground(String... params) {
    	
    	//Check if any music is playing and fade it out.
    	am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
    	if (mApp.isServiceRunning()) {
    		
    		if (mApp.getService().isPlayingMusic()) {
    			targetVolume = 0;
    			currentVolume = am.getStreamVolume(AudioManager.STREAM_MUSIC);		
    			while(currentVolume > targetVolume) {
    			    am.setStreamVolume(AudioManager.STREAM_MUSIC, (currentVolume - stepDownValue), 0);
    			    currentVolume = am.getStreamVolume(AudioManager.STREAM_MUSIC);
    			    
    			}
    			
    			mContext.stopService(new Intent(mContext, AudioPlaybackService.class));
    			
    		}
    		
    	}
    	
    	//Check if the Google Play Music app is installed.
    	PackageManager pm = mContext.getPackageManager();
    	boolean installed = false;
    	try {
			pm.getPackageInfo("com.google.android.music", PackageManager.GET_ACTIVITIES);
			installed = true;
		} catch (NameNotFoundException e1) {
			//The app isn't installed.
			installed = false;
		}
    	
    	String result = "GENERIC_EXCEPTION";
    	if (installed==false) {
    		//Can't do anything here anymore. Quit.
    		mApp.getSharedPreferences().edit().putBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false).commit();
    		return null;
    	} else {
    		//Grab music metadata from Google Play Music's public content mApp.
    		result = getMetadataFromGooglePlayMusicApp();
    	}
    	return result;
    }
    
    //Grab music metadata from Google Play Music's public content mApp.
	public String getMetadataFromGooglePlayMusicApp() {
    	
    	//Grab a handle on the mApp.
    	Uri googlePlayMusicContentProviderUri = Uri.parse("content://com.google.android.music.MusicContent/audio");
    	String[] projection = { "title", "artist", "album", "AlbumArtist",
    							"duration", "track", "year", "Genre", "TrackType AS track_type",
    							/*"_count",*/ "Rating", "AlbumArtLocation AS album_art", "SourceType AS source_type",
    							"SourceId", "ArtistArtLocation", /*, "artistId",*/ "StoreAlbumId" };
    	
    	/* source_type values:
    	 * 0: Local file (not used).
    	 * 1: Unknown.
    	 * 2: Personal, free GMusic library (used).
    	 * 3: All Access (not used).
    	 */
    	String selection = "source_type=2 AND track_type=0";
    	
    	//Catch any exceptions that may be thrown as a result of unknown columns in GMusic's content mApp.
    	Cursor cursor = null;
    	boolean projectionFailed = false;
    	try {
    		cursor = mContext.getContentResolver().query(googlePlayMusicContentProviderUri, projection, selection, null, null);
    	} catch (IllegalArgumentException e) {
    		e.printStackTrace();
    		
    		//Problematic columns are commented out here.
    		String[] failSafeProjection = { "title", "artist", "album", "AlbumArtist",
						   					"duration", "track", "year", "Genre", "TrackType AS track_type",
						   					/*"_count",*/ "Rating", "AlbumArtLocation AS album_art", /* "SourceType AS source_type", */
						   					"SourceId", /* "ArtistArtLocation", "artistId",*/ "StoreAlbumId" };
    		
    		cursor = mContext.getContentResolver().query(googlePlayMusicContentProviderUri, failSafeProjection, "track_type=0", null, null);
    		projectionFailed = true;
    		
    	}

    	//Clear out all the current Google Play Music songs in the database.
    	mApp.getDBAccessHelper().deleteAllGooglePlayMusicSongs();
    	
    	//Insert the songs and their metadata into Jams' local database.
    	/* To improve database insertion performance, we'll use a single transaction 
    	 * for the entire operation. SQLite journals each database insertion and 
    	 * creates a new transaction by default. We'll override this functionality 
    	 * and create a single transaction for all the database record insertions. 
    	 * In theory, this should reduce NAND memory overhead times and result in 
    	 * a 2x to 5x performance increase.
    	 */
    	try {
    		//We'll initialize the DB transaction manually.
    		mApp.getDBAccessHelper().getWritableDatabase().beginTransaction();

    		//Avoid "Divide by zero" errors.
    		int scanningSongsIncrement;
    		if (cursor!=null) {
        		if (cursor.getCount()!=0) {
        			scanningSongsIncrement = 800000/cursor.getCount();
        		} else {
        			scanningSongsIncrement = 800000/1;
        		}
        		
    		} else {
    			return "FAIL";
    		}
    		
    		currentTask = mContext.getResources().getString(R.string.syncing_with_google_play_music);
            for (int i=0; i < cursor.getCount(); i++) {
            	
            	cursor.moveToPosition(i);
            	currentProgressValue = currentProgressValue + scanningSongsIncrement;
            	publishProgress();
            	
            	//Get the song's metadata.
            	String songTitle = cursor.getString(cursor.getColumnIndex("title"));
            	String songArtist = cursor.getString(cursor.getColumnIndex("Artist"));
            	String songAlbum = cursor.getString(cursor.getColumnIndex("Album"));
            	String songAlbumArtist = cursor.getString(cursor.getColumnIndex("AlbumArtist"));
            	String songDuration = cursor.getString(cursor.getColumnIndex("Duration"));
            	String songTrackNumber =cursor.getString(cursor.getColumnIndex("Track"));
            	String songYear = cursor.getString(cursor.getColumnIndex("Year"));
            	String songGenre = cursor.getString(cursor.getColumnIndex("Genre"));
            	//String songPlayCount = cursor.getString(cursor.getColumnIndex("_count"));
            	String songRating = cursor.getString(cursor.getColumnIndex("Rating"));
            	String songSource = DBAccessHelper.GMUSIC;
            	String songAlbumArtPath = cursor.getString(cursor.getColumnIndex("album_art"));
            	String songID = cursor.getString(cursor.getColumnIndex("SourceId"));
            	//String artistID = cursor.getString(cursor.getColumnIndex("artistId"));
            	String storeAlbumID = cursor.getString(cursor.getColumnIndex("StoreAlbumId"));
            	
            	String songArtistArtPath = "";
            	if (projectionFailed==false) {
            		songArtistArtPath = cursor.getString(cursor.getColumnIndex("ArtistArtLocation"));
            	} else {
            		//Fall back on album art.
            		songArtistArtPath = cursor.getString(cursor.getColumnIndex("album_art"));
            	}
            	
            	//Prepare the genres ArrayList.
            	if (!genresList.contains(songGenre)) {
            		genresList.add(songGenre);
            	}
            	
            	//Filter out track numbers and remove any bogus values.
            	if (songTrackNumber!=null) {
        			if (songTrackNumber.contains("/")) {
        				int index = songTrackNumber.lastIndexOf("/");
        				songTrackNumber = songTrackNumber.substring(0, index);
        			}
                	
            	}
            	
            	if (songYear.equals("0")) {
            		songYear = "";
            	}
            	
            	//Check if any of the other tags were empty/null and set them to "Unknown xxx" values.
            	if (songArtist==null || songArtist.isEmpty() || songArtist.equals(" ")) {
            		songArtist = "Unknown Artist";
            	}
            	
            	if (songAlbumArtist==null || songAlbumArtist.isEmpty() || songAlbumArtist.equals(" ")) {
            		songAlbumArtist = "Unknown Album Artist";
            	}
            	
            	if (songAlbum==null || songAlbum.isEmpty() || songAlbum.equals(" ")) {
            		songAlbum = "Unknown Album";
            	}
            	
            	if (songGenre==null || songGenre.isEmpty() || songGenre.equals(" ")) {
            		songGenre = "Unknown Genre";
            	}
            	
            	ContentValues values = new ContentValues();
            	values.put(DBAccessHelper.SONG_TITLE, songTitle);
            	values.put(DBAccessHelper.SONG_ARTIST, songArtist);
            	values.put(DBAccessHelper.SONG_ALBUM, songAlbum);
            	values.put(DBAccessHelper.SONG_ALBUM_ARTIST, songAlbumArtist);
            	values.put(DBAccessHelper.SONG_DURATION, songDuration);
            	values.put(DBAccessHelper.SONG_FILE_PATH, songID);
            	values.put(DBAccessHelper.SONG_TRACK_NUMBER, songTrackNumber);
            	values.put(DBAccessHelper.SONG_GENRE, songGenre);
            	//values.put(DBAccessHelper.SONG_PLAY_COUNT, songPlayCount);
            	values.put(DBAccessHelper.SONG_YEAR, songYear);
            	values.put(DBAccessHelper.SONG_LAST_MODIFIED, "");
            	values.put(DBAccessHelper.BLACKLIST_STATUS, "FALSE"); //Keep the song whitelisted by default.
            	values.put(DBAccessHelper.ADDED_TIMESTAMP, date.getTime());
            	values.put(DBAccessHelper.RATING, songRating);
            	values.put(DBAccessHelper.SONG_SOURCE, songSource);
            	values.put(DBAccessHelper.SONG_ALBUM_ART_PATH, songAlbumArtPath);
            	values.put(DBAccessHelper.SONG_ID, songID);
            	values.put(DBAccessHelper.ARTIST_ART_LOCATION, songArtistArtPath);
            	//values.put(DBAccessHelper.ARTIST_ID, artistID);
            	values.put(DBAccessHelper.ALBUM_ID, storeAlbumID);
            	
            	/* We're gonna have to save the song ID into the SONG_FILE_PATH 
            	 * field. Google Play Music playlist songs don't have a file path, but we're using a 
            	 * JOIN in PlaylistsFlippedFragment that relies on this field, so we'll need to use the 
            	 * song ID as a placeholder instead.
            	 */
            	values.put(DBAccessHelper.SONG_FILE_PATH, songID);
            	
            	//Add all the entries to the database to build the songs library.
            	mApp.getDBAccessHelper().getWritableDatabase().insert(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
            												 		  null, 
            												 		  values);	
            	
            }
            
            mApp.getDBAccessHelper().getWritableDatabase().setTransactionSuccessful();
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    	} finally {
    		//Close the transaction.
    		mApp.getDBAccessHelper().getWritableDatabase().endTransaction();
    		
    		if (cursor!=null) {
    			cursor.close();
    			cursor = null;
    		}
    		
    	}
    	
    	/****************************************************************************
    	 * BUILD PLAYLISTS LIBRARY
    	 ****************************************************************************/
    	//getPlaylistsWebClient();
    	//getPlaylistsMobileClient();
    	
    	//Update the genres library.
    	updateGenreSongCount();
    	
    	return "SUCCESS";
    }
    
    /**
     * Downloads and stores song metadata from Google's servers.
     * 
     * @deprecated Grabbing metadata directly from Google's servers can potentially 
     * cause them to shutdown the "sj" service for this app. The official GMusic app
     * has a ContentProvider that can provide all the metadata for offline usage.
     */
     public String downloadMetadataFromGoogle() {
     /* //Retrieve a list of songs stored on Google Play Music and their metadata.
    	GMusicClientCalls gMusicClientCalls = GMusicClientCalls.getInstance(mContext);
    	try {
			songsList = gMusicClientCalls.getAllSongs(mContext.getApplicationContext());
		} catch (JSONException e) {
			return "GENERIC_EXCEPTION";
		}
    	
    	//Clear out all the current Google Play Music songs in the database.
    	DBAccessHelper libraryDBHelper = new DBAccessHelper(mContext);
    	libraryDBHelper.deleteAllGooglePlayMusicSongs();
    	
    	//Insert the songs and their metadata into Jams' local database.
    	/* To improve database insertion performance, we'll use a single transaction 
    	 * for the entire operation. SQLite journals each database insertion and 
    	 * creates a new transaction by default. We'll override this functionality 
    	 * and create a single transaction for all the database record insertions. 
    	 * In theory, this should reduce NAND memory overhead times and result in 
    	 * a 2x to 5x performance increase.
    	 *\/
    	try {
    		//We'll initialize the DB transaction manually.
    		libraryDBHelper.getWritableDatabase().beginTransaction();
    		
    		/* Now that we have a list of all the audio files that are either new or 
    		 * modified, we can just delete all the records of those files in the DB 
    		 * and re-add them.
    		 *\/
    		
    		//Avoid "Divide by zero" errors.
    		int scanningSongsIncrement;
    		if (songsList.size()!=0) {
    			scanningSongsIncrement = 800000/songsList.size();
    		} else {
    			scanningSongsIncrement = 800000/1;
    		}
    		
    		currentTask = mContext.getResources().getString(R.string.downloading_songs_info_from_google_play_music);
            for (int i=0; i < songsList.size(); i++) {
            	
            	WebClientSongsSchema song = songsList.get(i);
            	
            	currentProgressValue = currentProgressValue + scanningSongsIncrement;
            	publishProgress();
            	
            	//Get the song's metadata.
            	String songTitle = song.getTitle();
            	String songArtist = song.getArtist();
            	String songAlbum = song.getAlbum();
            	String songAlbumArtist = song.getAlbumArtist();
            	String songDuration = "" + song.getDurationMillis();
            	String songTrackNumber = "" + song.getTrack();
            	String songYear = "" + song.getYear();
            	String songGenre = song.getGenre();
            	String songPlayCount = "" + song.getPlayCount();
            	String songRating = "" + song.getRating();
            	String songSource = DBAccessHelper.GMUSIC;
            	String songAlbumArtPath = song.getAlbumArtUrl();
            	String songDeleted = "" + song.isDeleted();
            	String songLastPlayed = "" + song.getLastPlayed();
            	String songId = "" + song.getId();
            	
            	/* By default, Google will return an album art path that contains
            	 * an image that is 130x130 in size. The "=sxxx" parameter determines 
            	 * the size of the returned image. We'll replace all instances of "=s130" 
            	 * with "=s512" to get artwork that is 512x512 in size. Also, the "http://" 
            	 * part appears truncated, so add that into the beginning of the url.
            	 *\/
            	if (songAlbumArtPath!=null) {
            		
            		if (!songAlbumArtPath.isEmpty()) {
            			songAlbumArtPath = songAlbumArtPath.replace("=s130", "=s512");
            			songAlbumArtPath = "http:" + songAlbumArtPath;
            			
            		}
            		
            	}
            	
            	//Prepare the genres ArrayList.
            	if (!genresList.contains(songGenre)) {
            		genresList.add(songGenre);
            	}
            	
            	//Filter out track numbers and remove any bogus values.
            	if (songTrackNumber!=null) {
        			if (songTrackNumber.contains("/")) {
        				int index = songTrackNumber.lastIndexOf("/");
        				songTrackNumber = songTrackNumber.substring(0, index);
        			}
                	
            	}
            	
            	if (songYear.equals("0")) {
            		songYear = "";
            	}
            	
            	String songFilePath = "";
            	try {
            		URI uri = gMusicClientCalls.getSongStream(song.getId());
					songFilePath = uri.toURL().toString();
				} catch (JSONException e) {
					continue;
				} catch (URISyntaxException e) {
					continue;
				} catch (MalformedURLException e) {
					continue;
				} catch (Exception e) {
					continue;
				}
            	
            	ContentValues values = new ContentValues();
            	values.put(DBAccessHelper.SONG_TITLE, songTitle);
            	values.put(DBAccessHelper.SONG_ARTIST, songArtist);
            	values.put(DBAccessHelper.SONG_ALBUM, songAlbum);
            	values.put(DBAccessHelper.SONG_ALBUM_ARTIST, songAlbumArtist);
            	values.put(DBAccessHelper.SONG_DURATION, songDuration);
            	values.put(DBAccessHelper.SONG_FILE_PATH, songFilePath);
            	values.put(DBAccessHelper.SONG_FOLDER_PATH, "");
            	values.put(DBAccessHelper.SONG_TRACK_NUMBER, songTrackNumber);
            	values.put(DBAccessHelper.SONG_GENRE, songGenre);
            	values.put(DBAccessHelper.SONG_PLAY_COUNT, songPlayCount);
            	values.put(DBAccessHelper.SONG_YEAR, songYear);
            	values.put(DBAccessHelper.SONG_LAST_MODIFIED, "");
            	values.put(DBAccessHelper.BLACKLIST_STATUS, "FALSE"); //Keep the song whitelisted by default.
            	values.put(DBAccessHelper.ADDED_TIMESTAMP, date.getTime());
            	values.put(DBAccessHelper.RATING, songRating);
            	values.put(DBAccessHelper.LAST_PLAYED_TIMESTAMP, songLastPlayed);
            	values.put(DBAccessHelper.SONG_SOURCE, songSource);
            	values.put(DBAccessHelper.SONG_ALBUM_ART_PATH, songAlbumArtPath);
            	values.put(DBAccessHelper.SONG_DELETED, songDeleted);
            	values.put(DBAccessHelper.SONG_ID, songId);
            	
            	/* We're gonna have to save the song ID into the SONG_FILE_PATH 
            	 * field. Google Play Music playlist songs don't have a file path, but we're using a 
            	 * JOIN in PlaylistsFlippedFragment that relies on this field, so we'll need to use the 
            	 * song ID as a placeholder instead.
            	 *\/
            	values.put(DBAccessHelper.SONG_FILE_PATH, songId);
            	
            	//Add all the entries to the database to build the songs library.
            	libraryDBHelper.getWritableDatabase().insert(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
            												 null, 
            												 values);	
            	
            }
            
            libraryDBHelper.getWritableDatabase().setTransactionSuccessful();
    		
    	} catch (SQLException e) {
    		// TODO Auto-generated method stub.
    		return "GENERIC_EXCEPTION";
    	} finally {
    		//Close the transaction.
    		libraryDBHelper.getWritableDatabase().endTransaction();
    		libraryDBHelper.close();
    	}
    	
    	/**************************************************************************
    	 * BUILD PLAYLISTS LIBRARY.
    	 **************************************************************************\/
    	//Clear out all the current Google Play Music playlists in the database.
    	DBAccessHelper musicLibraryPlaylistsDBHelper = new DBAccessHelper(mContext);
    	musicLibraryPlaylistsDBHelper.deleteAllGooglePlayMusicPlaylists();
    	
    	//Insert the songs and their metadata into Jams' local database.
    	/* To improve database insertion performance, we'll use a single transaction 
    	 * for the entire operation. SQLite journals each database insertion and 
    	 * creates a new transaction by default. We'll override this functionality 
    	 * and create a single transaction for all the database record insertions. 
    	 * In theory, this should reduce NAND memory overhead times and result in 
    	 * a 2x to 5x performance increase.
    	 *\/
    	try {
    		//Open a connection to the database.
    		musicLibraryPlaylistsDBHelper.getWritableDatabase().beginTransaction();
    		
        	try {
    			playlistsList = gMusicClientCalls.getAllPlaylists(mContext.getApplicationContext()).getPlaylists();
    		} catch (JSONException e) {
    			return "GENERIC_EXCEPTION";
    		}

    		//Avoid "Divide by zero" errors.
    		int scanningPlaylistsIncrement;
    		if (playlistsList.size()!=0) {
    			scanningPlaylistsIncrement = 100000/playlistsList.size();
    		} else {
    			scanningPlaylistsIncrement = 100000/1;
    		}
    		currentTask = mContext.getResources().getString(R.string.syncing_with_google_play_music);
    		
    		for (int i=0; i < playlistsList.size(); i++) {

            	currentProgressValue = currentProgressValue + scanningPlaylistsIncrement;
            	publishProgress();
            	
            	//Get the playlist's metadata.
            	String playlistName = playlistsList.get(i).getTitle();
            	String playlistID = playlistsList.get(i).getPlaylistId();
            	String playlistArtUrl = "";

            	ContentValues playlistValues = new ContentValues();
            	playlistValues.put(DBAccessHelper.PLAYLIST_NAME, playlistName);
            	playlistValues.put(DBAccessHelper.PLAYLIST_ID, playlistID);
            	playlistValues.put(DBAccessHelper.PLAYLIST_ART_URL, playlistArtUrl);
            	playlistValues.put(DBAccessHelper.PLAYLIST_SOURCE, DBAccessHelper.GMUSIC);
            	playlistValues.put(DBAccessHelper.PLAYLIST_BLACKLIST_STATUS, "FALSE");
            	
            	//Add all the entries to the database to build the songs library.
            	musicLibraryPlaylistsDBHelper.getWritableDatabase().insert(DBAccessHelper.MUSIC_LIBRARY_PLAYLISTS_NAME, 
            												 			   null, 
            												 			   playlistValues);	
            	
            }
    		
    		musicLibraryPlaylistsDBHelper.getWritableDatabase().setTransactionSuccessful();
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    	} finally {
    		//Seal off all connections to the database.
    		musicLibraryPlaylistsDBHelper.getWritableDatabase().endTransaction();
    		musicLibraryPlaylistsDBHelper.close();
    	}
    	
    	//Build the genres library.
    	updateGenreSongCount();
    	
    	return "SUCCESS"; */
    	return null;
    }
     
    /**
     * Retrieves the user's playlists and their contents using the WebClient protocol.
     */
    //@SuppressWarnings("static-access")
	/*private void getPlaylistsWebClient() {
    	//Clear out all the current Google Play Music playlists in the database.\
    	mApp.getDBAccessHelper().deleteAllGooglePlayMusicPlaylists();
    	
    	//Insert the songs and their metadata into Jams' local database.
    	 To improve database insertion performance, we'll use a single transaction 
    	 * for the entire operation. SQLite journals each database insertion and 
    	 * creates a new transaction by default. We'll override this functionality 
    	 * and create a single transaction for all the database record insertions. 
    	 * In theory, this should reduce NAND memory overhead times and result in 
    	 * a 2x to 5x performance increase.
    	 
    	GMusicClientCalls gMusicClientCalls = GMusicClientCalls.getInstance(mContext);
    	try {
    		//Open a connection to the database.
    		mApp.getDBAccessHelper().getMusicLibraryPlaylistsDBHelper().getWritableDatabase().beginTransaction();

    		//Get a list of all playlists from Google's servers.
    		playlistsJSONArray = gMusicClientCalls.getUserPlaylistsMobileClient(mContext);

    		//Avoid "Divide by zero" errors.
    		int scanningPlaylistsIncrement;
    		if (playlistsJSONArray.length()!=0) {
    			scanningPlaylistsIncrement = 100000/playlistsJSONArray.length();
    		} else {
    			scanningPlaylistsIncrement = 100000/1;
    		}
    		currentTask = mContext.getResources().getString(R.string.syncing_with_google_play_music);
    		
    		MobileClientPlaylistsSchema currentPlaylist = new MobileClientPlaylistsSchema();
    		WebClientSongsSchema currentPlaylistSong = new WebClientSongsSchema();
    		for (int i=0; i < playlistsJSONArray.length(); i++) {
    			
    			currentPlaylist = currentPlaylist.fromJsonObject(playlistsJSONArray.getJSONObject(i));
            	currentProgressValue = currentProgressValue + scanningPlaylistsIncrement;
            	publishProgress();
            	
            	//Get the playlist's metadata.
            	String playlistName = currentPlaylist.getName();
            	String playlistId = currentPlaylist.getPlaylistId();
            	String playlistArtUrl = "";
            	
            	//Retrieve all the song's within the current playlist.
            	JSONArray songsArray = gMusicClientCalls.getPlaylistEntriesWebClient(mContext, playlistId);
            	
            	//Loop through the current playlist's songs array and retrieve each song's metadata.
            	for (int j=0; j < songsArray.length(); j++) {
            		try {
            			currentPlaylistSong = currentPlaylistSong.fromJsonObject(songsArray.getJSONObject(j));
                		//Extract the current playlist song's metadata.
                    	String songTrackId = currentPlaylistSong.getId();
                    	String playlistEntryId = currentPlaylistSong.getPlaylistEntryId();
                    	
                    	ContentValues playlistValues = new ContentValues();
                    	playlistValues.put(DBAccessHelper.PLAYLIST_NAME, playlistName);
                    	playlistValues.put(DBAccessHelper.PLAYLIST_ID, playlistId); 
                    	playlistValues.put(DBAccessHelper.PLAYLIST_ART_URL, playlistArtUrl);
                    	playlistValues.put(DBAccessHelper.PLAYLIST_SOURCE, DBAccessHelper.GMUSIC);
                    	playlistValues.put(DBAccessHelper.PLAYLIST_BLACKLIST_STATUS, "FALSE");
                    	playlistValues.put(DBAccessHelper.PLAYLIST_SONG_FILE_PATH, songTrackId);
                    	playlistValues.put(DBAccessHelper.PLAYLIST_SONG_ENTRY_ID, playlistEntryId);
                    	playlistValues.put(DBAccessHelper.PLAYLIST_ORDER, j);
                    	
                    	//Add all the entries to the database to build the songs library.
                    	mApp.getDBAccessHelper().getMusicLibraryPlaylistsDBHelper().getWritableDatabase().insert(DBAccessHelper.MUSIC_LIBRARY_PLAYLISTS_NAME, 
                    												 			   null, 
                    												 			   playlistValues);
            		} catch (Exception e) {
            			e.printStackTrace();
            			continue;
            		}
            		
            	}
            	
            }
    		
    		mApp.getDBAccessHelper().getMusicLibraryPlaylistsDBHelper().getWritableDatabase().setTransactionSuccessful();
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    	} finally {
    		//Seal off all connections to the database.
    		mApp.getDBAccessHelper().getMusicLibraryPlaylistsDBHelper().getWritableDatabase().endTransaction();
    	}
    	
    }*/
    
    /*************************************************************************************
     * Retrieves the user's playlists and their contents using the MobileClient protocol.
     * 
     * @deprecated The entryIds that we're fetching from the MobileClient protocol seem 
     * to be broken. They don't work with reordering playlist songs. I'll fix this if/when 
     * I have time. Until then, I'm gonna use getPlaylistsWebClient().
     *************************************************************************************/
    @SuppressWarnings("static-access")
	private void getPlaylistsMobileClient() {
    	
/*    	//Clear out all the current Google Play Music playlists in the database.
    	DBAccessHelper musicLibraryPlaylistsDBHelper = new DBAccessHelper(mContext);
    	musicLibraryPlaylistsDBHelper.deleteAllGooglePlayMusicPlaylists();
    	
    	//Insert the songs and their metadata into Jams' local database.
    	 To improve database insertion performance, we'll use a single transaction 
    	 * for the entire operation. SQLite journals each database insertion and 
    	 * creates a new transaction by default. We'll override this functionality 
    	 * and create a single transaction for all the database record insertions. 
    	 * In theory, this should reduce NAND memory overhead times and result in 
    	 * a 2x to 5x performance increase.
    	 
    	try {
    		//Open a connection to the database.
    		musicLibraryPlaylistsDBHelper.getWritableDatabase().beginTransaction();
    		
    		*//*****************************************************************************
    		 * The following calls are based on the MobileClient endpoints. Unfortunately, 
    		 * we can't get the correct entryIds for each song with these calls, so we'll 
    		 * have to revert to using the WebClient calls.
    		 *****************************************************************************//*
    		//Instantiate the GMusic API and retrieve an array of all playlists.
        	GMusicClientCalls gMusicClientCalls = GMusicClientCalls.getInstance(mContext);
        	try {
    			playlistsJSONArray = gMusicClientCalls.getUserPlaylistsMobileClient(mContext);
    		} catch (JSONException e) {
    			e.printStackTrace();
    		}
        	
        	//Retrieve an array of all song entries within every playlist.
        	try {
        		playlistEntriesJSONArray = gMusicClientCalls.getPlaylistEntriesMobileClient(mContext);
        	} catch (JSONException e) {
        		e.printStackTrace();
        	}
        	
        	 Now that we have a JSONArray with all the unique playlists, it's time to 
        	 * index the playlistIds and their name within the array. This will 
        	 * allow us to efficiently figure out the name of the playlist without 
        	 * going through the entire original array over and over again.
        	 
        	MobileClientPlaylistsSchema currentPlaylist = new MobileClientPlaylistsSchema();
        	for (int k=0; k < playlistsJSONArray.length(); k++) {
        		currentPlaylist = currentPlaylist.fromJsonObject(playlistsJSONArray.getJSONObject(k));
        		if (!playlistIdsNameMap.containsKey(currentPlaylist.getPlaylistId())) {
        			playlistIdsNameMap.put(currentPlaylist.getPlaylistId(), currentPlaylist.getName());
        		}
        		
        	}
        	

    		//Avoid "Divide by zero" errors.
    		int scanningPlaylistsIncrement;
    		if (playlistEntriesJSONArray.length()!=0) {
    			scanningPlaylistsIncrement = 100000/playlistEntriesJSONArray.length();
    		} else {
    			scanningPlaylistsIncrement = 100000/1;
    		}
    		currentTask = mContext.getResources().getString(R.string.syncing_with_google_play_music);
    		
    		MobileClientPlaylistEntriesSchema currentPlaylistEntry = new MobileClientPlaylistEntriesSchema();
    		for (int i=0; i < playlistEntriesJSONArray.length(); i++) {
            	currentProgressValue = currentProgressValue + scanningPlaylistsIncrement;
            	publishProgress();
            	
            	//Get the playlist's metadata.
            	currentPlaylistEntry = currentPlaylistEntry.fromJsonObject(playlistEntriesJSONArray.getJSONObject(i));
            	String playlistName = playlistIdsNameMap.get(currentPlaylistEntry.getPlaylistId());
            	String playlistId = currentPlaylistEntry.getPlaylistId();
            	String id = currentPlaylistEntry.getId();
            	String clientId = currentPlaylistEntry.getClientId();
            	String trackId = currentPlaylistEntry.getTrackId();
            	
            	 GMusic's backend server uses horribly misleading JSON key names. 
            	 * Each playlist entry has an entryId. When reordering songs, this 
            	 * entryId is actually the clientId of the song. The songId matches 
            	 * trackId. The "id" key in the JSON response is seemingly not 
            	 * used for anything in particular.
            	 
            	ContentValues playlistValues = new ContentValues();
            	playlistValues.put(DBAccessHelper.PLAYLIST_NAME, playlistName);
            	playlistValues.put(DBAccessHelper.PLAYLIST_ID, playlistId);
            	playlistValues.put(DBAccessHelper.PLAYLIST_ART_URL, "");
            	playlistValues.put(DBAccessHelper.PLAYLIST_SOURCE, DBAccessHelper.GMUSIC);
            	playlistValues.put(DBAccessHelper.PLAYLIST_SONG_ID, id);
            	playlistValues.put(DBAccessHelper.PLAYLIST_BLACKLIST_STATUS, "FALSE");
            	playlistValues.put(DBAccessHelper.PLAYLIST_ORDER, i);
            	playlistValues.put(DBAccessHelper.PLAYLIST_SONG_ENTRY_ID, clientId);
            	
            	Log.e("DEBUG", "--------------------PLAYLIST ENTRY--------------------");
            	Log.e("DEBUG", "playlistName: " + playlistName);
            	Log.e("DEBUG", "playlistId: " + playlistId);
            	Log.e("DEBUG", "id: " + id);
            	Log.e("DEBUG", "clientId (entryId): " + clientId);
            	Log.e("DEBUG", "trackId: " + trackId);
            	
            	 We're gonna have to save the playlist's song IDs into the PLAYLIST_SONG_FILE_PATH 
            	 * field. Google Play Music playlist songs don't have a file path, but we're using a 
            	 * JOIN in PlaylistsFlippedFragment that relies on this field, so we'll need to use the 
            	 * "songId" param as a placeholder instead. The "trackId" key corresponds to "songId"
            	 * in the songs table.
            	 
            	playlistValues.put(DBAccessHelper.PLAYLIST_SONG_FILE_PATH, trackId);
            	
            	//Add all the entries to the database to build the songs library.
            	musicLibraryPlaylistsDBHelper.getWritableDatabase().insert(DBAccessHelper.MUSIC_LIBRARY_PLAYLISTS_NAME, 
            												 			   null, 
            												 			   playlistValues);
            	
            }
    		
    		musicLibraryPlaylistsDBHelper.getWritableDatabase().setTransactionSuccessful();
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    	} finally {
    		//Seal off all connections to the database.
    		musicLibraryPlaylistsDBHelper.getWritableDatabase().endTransaction();
    		musicLibraryPlaylistsDBHelper.close();
    	}*/
    	
    }
    
    /****************************************************************************************
     * Scans the entire Music Library for songs, fetches their genres, and inputs the total 
     * count for that genre into each song's genre.
     ****************************************************************************************/
    public void updateGenreSongCount() {
    	
    	//We'll get the number of songs in a particular genre and apply that tag to all songs.
    	String genre = "";
    	int songCount = 0;
    	int buildingGenresIncrement;
    	currentTask = "Building Genres";
    	if (genresList.size()!=0) {
    		buildingGenresIncrement = 100000/genresList.size();
    	} else {
        	buildingGenresIncrement = 100000/1;
    	}

		//Open a single transaction connection to keep the operation as efficient as possible.    	
    	for (int i=0; i < genresList.size(); i++) {
    		
        	currentProgressValue = currentProgressValue + buildingGenresIncrement;
        	publishProgress();
    		
    		try {
        		genre = genresList.get(i);
        		
        		if (genre.contains("'")) {
        			genre = genre.replace("'", "''");
        		}
        		
        		//Get the number of songs in this genre.
        		songCount = mApp.getDBAccessHelper().getGenreSongCount(genre);
        		mApp.getDBAccessHelper().insertNumberOfSongsInGenre(genre, songCount);
        		
    		} catch (Exception e) {
    			e.printStackTrace();
    			continue;
    		}

    	}
    	
    }
    
    /**
     * Public method that provides access to the onProgressUpdate() method.
     * Used to update the progress bar from a different class/activity.
     * 
     * @param progressParams 
     */
    public void callOnProgressUpdate(String... progressParams) {
    	publishProgress(progressParams);
    }
    
    @Override
    protected void onProgressUpdate(String... progressParams) {
    	super.onProgressUpdate(progressParams);
    	
    	/*//Update the notification.
    	BuildMusicLibraryService.mBuilder.setTicker(null);
    	BuildMusicLibraryService.mBuilder.setContentTitle(mContext.getResources().getString(R.string.getting_google_play_music_library));
    	BuildMusicLibraryService.mBuilder.setContentText(currentTask);
    	BuildMusicLibraryService.mBuilder.setContentInfo(null);
    	BuildMusicLibraryService.mBuilder.setProgress(100000, currentProgressValue, false);
    	BuildMusicLibraryService.mNotification = BuildMusicLibraryService.mBuilder.build();
    	BuildMusicLibraryService.mNotifyManager.notify(BuildMusicLibraryService.mNotificationId, 
    												   BuildMusicLibraryService.mNotification);*/
    	
    }

    @Override
    protected void onPostExecute(String arg0) {
    	
    	//Release the wakelock.
    	wakeLock.release();
        	
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.net.MalformedURLException;
import java.net.URISyntaxException;

import org.json.JSONException;

import android.content.Context;
import android.os.AsyncTask;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.GMusicHelpers.GMusicClientCalls;
import com.jams.music.player.Utils.Common;

public class AsyncGetSongStreamURLTask extends AsyncTask<String, Void, Boolean> {
    private Context mContext;
    private Common mApp;
    private String mSongID;
    
    public AsyncGetSongStreamURLTask(Context context, String songID) {
    	mContext = context;
    	mApp = (Common) mContext;
    	mSongID = songID;
    	
    }
 
    @Override
    protected Boolean doInBackground(String... params) {
    	
    	if (mSongID.equals(mApp.getService().getCurrentSong().getId())) {
    		try {
    			mApp.getService().getCurrentSong().setFilePath(GMusicClientCalls.getSongStream(mSongID).toURL().toString());
    		} catch (MalformedURLException e) {
    			e.printStackTrace();
    			return false;
    		} catch (JSONException e) {
    			e.printStackTrace();
    			return false;
    		} catch (URISyntaxException e) {
    			e.printStackTrace();
    			return false;
    		} catch (Exception e) {
    			e.printStackTrace();
    			return false;
    		}
        	
        	if (mApp.getService().getCurrentSong().getId()==null) {
        		return false;
        	} else {
        		return true;
        	}
        	
    	} else {
    		this.cancel(true);
    		return false;
    	}
    	
    }

    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
		
		try {
			if (result==true && mApp.getService().getCurrentSong().getId().equals(mSongID)) {
				//We got the right URL, so go ahead and prepare the media player.
				mApp.getService().startPlayback();
			} else if (result==false && mApp.getService().getCurrentSong().getId().equals(mSongID)) {
				//We were unable to get the url, so skip to the next song.
				mApp.getService().skipToNextTrack();
				Toast.makeText(mContext, R.string.song_failed_to_load, Toast.LENGTH_LONG).show();
			} else {
				//The song has been changed, so the URL is now useless. Exit this AsyncTask.
				return;
			}
			
		} catch (Exception e) {
			return;
		}

	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.support.v4.app.FragmentActivity;
import android.widget.Toast;

import com.google.android.gms.auth.GoogleAuthException;
import com.google.android.gms.auth.GoogleAuthUtil;
import com.google.android.gms.auth.GooglePlayServicesAvailabilityException;
import com.google.android.gms.auth.UserRecoverableAuthException;
import com.google.android.gms.common.GooglePlayServicesUtil;
import com.jams.music.player.R;
import com.jams.music.player.GMusicHelpers.GMusicClientCalls;
import com.jams.music.player.LauncherActivity.LauncherActivity;
import com.jams.music.player.SettingsActivity.SettingsActivity____;
import com.jams.music.player.Utils.Common;

public class AsyncGoogleMusicAuthenticationTask extends AsyncTask<String, String, String> {
	
    private Context mContext;
    private Activity mActivity;
    
    private ProgressDialog pd;
	boolean dialogVisible = true;
	private boolean mFirstRun = false;
	private boolean mFirstRunFromSettings = false;
	private Common mApp;
	
	private String mAccountName;
	private String authToken = "";
	
	private int availabilityExceptionStatusCode;
	private Intent userRecoverableExceptionIntent;
    static final int REQUEST_CODE_RECOVER_FROM_AUTH_ERROR = 1001;
    static final int REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR = 1002;
    
    public AsyncGoogleMusicAuthenticationTask(Context context, FragmentActivity activity, boolean firstRun, String accountName) {
    	mContext = context;
    	mActivity = activity;
    	mAccountName = accountName;
    	mFirstRun = firstRun;
    	
		mApp = (Common) mContext.getApplicationContext();
    }
    
    public AsyncGoogleMusicAuthenticationTask(Context context, boolean firstRun, String accountName) {
    	mContext = context;
    	mAccountName = accountName;
    	mFirstRun = firstRun;
    	
		mApp = (Common) mContext.getApplicationContext();
    }
    
    public AsyncGoogleMusicAuthenticationTask(Context context, SettingsActivity____ activity, boolean firstRun, String accountName) {
    	mContext = context;
    	mActivity = activity;
    	mAccountName = accountName;
    	mFirstRun = firstRun;
    	mFirstRunFromSettings = true;
    	
		mApp = (Common) mContext.getApplicationContext();
    }
    
    protected void onPreExecute() {
    	
    	if (mFirstRun) {
        	pd = new ProgressDialog(mActivity);
    		pd.setCancelable(false);
    		pd.setIndeterminate(true);
    		pd.setTitle(R.string.signing_in);
    		pd.setMessage(mContext.getResources().getString(R.string.contacting_google_play_music));
    		pd.show();
    	}

    }
 
    @SuppressWarnings("static-access")
	@Override
    protected String doInBackground(String... params) {

		try {
			authToken = GoogleAuthUtil.getToken(mContext, mAccountName, "sj");
		} catch (GooglePlayServicesAvailabilityException e) {
			e.printStackTrace();
			availabilityExceptionStatusCode = e.getConnectionStatusCode();
			return "GOOGLE_PLAY_SERVICES_AVAILABILITY_EXCEPTION";
		} catch (UserRecoverableAuthException e) {
			e.printStackTrace();
			userRecoverableExceptionIntent = e.getIntent();
			return "USER_RECOVERABLE_AUTH_EXCEPTION";
		} catch (GoogleAuthException e) {
			e.printStackTrace();
			return "GOOGLE_AUTH_EXCEPTION";
		} catch (Exception e) {
			e.printStackTrace();
			return "GENERIC_EXCEPTION";
		}
		
		if (mFirstRun) {
			publishProgress(mContext.getResources().getString(R.string.signing_in_to_google_play_music));
		}
		
		//Login to Google Play Music using the unofficial API.
		mApp.setGMusicClientCalls(GMusicClientCalls.getInstance(mContext));
		boolean loginResult = mApp.getGMusicClientCalls().login(mContext, authToken);
		
		if (loginResult==true) {			
	    	return "AUTHENTICATED";
		} else {
	    	return "GENERIC_EXCEPTION";
		}
		
    }

    @Override
	protected void onProgressUpdate(String... values) {
		super.onProgressUpdate(values);
		
		String message = values[0];
		pd.setMessage(message);
	}

	@Override
	protected void onPostExecute(String result) {
		super.onPostExecute(result);
    	
		if (mFirstRun) {
			pd.dismiss();
		}
    	
    	//Perform an action based on the operation's result code.
    	if (result.equals("GOOGLE_PLAY_SERVICES_AVAILABILITY_EXCEPTION")) {
    		Dialog d = GooglePlayServicesUtil.getErrorDialog(availabilityExceptionStatusCode,
					 mActivity,
					 REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR);
    		d.show();
    	
    	} else if (result.equals("USER_RECOVERABLE_AUTH_EXCEPTION")) {
    		//45 is an arbitrary value that identifies this activity's result.
    		LauncherActivity.mAccountName = mAccountName;
    		SettingsActivity____.mAccountName = mAccountName;
    		
    		if (mActivity!=null) {
    			mActivity.startActivityForResult(userRecoverableExceptionIntent, 45);
    		}
			
    	} else if (result.equals("GOOGLE_AUTH_EXCEPTION") || result.equals("GENERIC_EXCEPTION")) {
    		Toast.makeText(mContext, R.string.unknown_error_google_music, Toast.LENGTH_LONG).show();
    	} else if (result.equals("AUTHENTICATED")) {
    		if (mFirstRun) {
        		String text = mContext.getResources().getString(R.string.signed_in_as) + " " + mAccountName;
        		Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();
    		} else if (mFirstRunFromSettings) {
    			//Start scanning the library to add GMusic songs.
    			String text = mContext.getResources().getString(R.string.signed_in_as) + " " + mAccountName;
        		Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();
        		
        		//Seting the "REBUILD_LIBRARY" flag to true will force MainActivity to rescan the folders.
				mApp.getSharedPreferences().edit().putBoolean("REBUILD_LIBRARY", true).commit();
				
				//Restart the app.
				final Intent i = mActivity.getBaseContext().getPackageManager().getLaunchIntentForPackage(mActivity.getBaseContext().getPackageName());
				
				i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
				mActivity.finish();
				mActivity.startActivity(i);
    		}
    		mApp.getSharedPreferences().edit().putBoolean("GOOGLE_PLAY_MUSIC_ENABLED", true).commit();
    	} else {
    		Toast.makeText(mContext, R.string.unknown_error_google_music, Toast.LENGTH_LONG).show();
    	}
    	
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

import android.app.ProgressDialog;
import android.content.Context;
import android.os.AsyncTask;

import com.jams.music.player.R;

/***********************************************************************************
 * This task goes through the specified parent folder and retrieves the canonical 
 * paths of all the subfolders within that parent folder. If the input parameter is 
 * "ADD", the task adds the paths to an ArrayList. If the input parameter is "REMOVE", 
 * the task removes the paths from the specified ArrayList.
 * 
 * @author Saravan Pantham
 ***********************************************************************************/
public class AsyncIterateThruFolderTask extends AsyncTask<String, String, Void> {
    private Context mContext;
    private ProgressDialog pd;
	private String mParentPath;
	private String mOperation;
	private String mFolderName;
	private ArrayList<String> mTempSelectedFolderPaths = new ArrayList<String>();
	private ArrayList<String> mTempSelectedFolderTimestamps = new ArrayList<String>();
	private boolean mFirstRun;
    
    public AsyncIterateThruFolderTask(Context context, 
    								  boolean firstRun, 
    								  ArrayList<String> tempSelectedFolderPaths, 
    								  ArrayList<String> tempSelectedFolderTimestamps,
    								  String parentPath, 
    								  String operation) {
    	mContext = context;
    	mFirstRun = firstRun;
    	mOperation = operation;
    	mParentPath = parentPath;
    	mTempSelectedFolderPaths = tempSelectedFolderPaths;
    	mTempSelectedFolderTimestamps = tempSelectedFolderTimestamps;
    	
    	//Get the name of the folder that's being iterated through.
    	int index = mParentPath.lastIndexOf("/");
    	mFolderName = mParentPath.substring((index+1), (mParentPath.length()));
    	
    }
    
    protected void onPreExecute() {
    	//Create a String template for the dialog's message body.
    	String message = mContext.getResources().getString(R.string.scanning_subfolders_message) + " " + mFolderName;
    	
		pd = new ProgressDialog(mContext);
		pd.setCancelable(false);
		pd.setIndeterminate(false);
		pd.setTitle(R.string.scanning_subfolders);
		pd.setMessage(message);
		pd.show();
    	
    }
 
    @Override
    protected Void doInBackground(String... params) {
    	iterateThruFolder(mParentPath, mOperation);
		return null;
		
    }
    
    /* This method goes through a folder recursively and gets all the paths 
     * of the directories within that folder. The method accepts two forms
     * for the "operation" argument:
     * "ADD": Adds the specified folder paths to tempSelectedFolderPaths.
     * "REMOVE": Removes the specified folder paths from tempSelectedFolderPaths. 
     */
    public void iterateThruFolder(String path, String operation) {

    	File root = null;
    	File[] list = null;
    	try {
            root = new File(path);
            list = root.listFiles();
    	} catch (Exception e) {
    		e.printStackTrace();
    	} catch (StackOverflowError e2) {
    		//The recursive function call is too damn long. Just quit at this point.
    		return;
    	}
    	
        if (list==null) {
        	return;
        }

        for (File f : list) {
        	
            if (f.isDirectory()) {
            	
            	//Update the progress dialog message.
            	try {
					publishProgress(new String[] { f.getCanonicalPath() });
				} catch (Exception e) {
					//Don't do anything.
				}
            	
            	if (operation.equals("ADD")) {
                    try {
						iterateThruFolder(f.getCanonicalPath(), "ADD");
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
					}
                    
                    try {
                    	String canonicalPath = f.getCanonicalPath();
						if (!mTempSelectedFolderPaths.contains(canonicalPath)) {
							mTempSelectedFolderPaths.add(canonicalPath);
							mTempSelectedFolderTimestamps.add("" + f.lastModified());
						}
						
					} catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
                    
            	} else if (operation.equals("REMOVE")) {
            		
                    try {
						iterateThruFolder(f.getCanonicalPath(), "REMOVE");
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
					}
                    
                    try {
                    	String canonicalPath = f.getCanonicalPath();
						if (mTempSelectedFolderPaths.contains(canonicalPath)) {
							mTempSelectedFolderPaths.remove(canonicalPath);
							mTempSelectedFolderTimestamps.remove("" + f.lastModified());
						}
						
					} catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
                    
            	}

            }
            
        }
        
    }
    
    @Override
    public void onProgressUpdate(String... values) {
    	super.onProgressUpdate(values);
    	String currentFolderName = values[0];
    	
    	//Create a String template for the dialog's message body.
    	String message = mContext.getResources().getString(R.string.scanning_subfolders_message) 
    				   + " " 
    				   + mFolderName
    				   + "\n"
    				   + "\n"
    				   + currentFolderName;
    	
    	pd.setMessage(message);
    	
    }

    @Override
	protected void onPostExecute(Void result) {
    	pd.dismiss();
    	
/*    	if (mFirstRun==true) {
    		//Assign the newly populated ArrayLists to the calling fragment/activity.
        	MusicFoldersSelectionFragment.tempSelectedFolderPaths = mTempSelectedFolderPaths;
        	MusicFoldersSelectionFragment.tempSelectedFolderTimestamps = mTempSelectedFolderTimestamps;
    	} else {
    		//Assign the newly populated ArrayLists to the calling fragment/activity.
        	MusicFoldersSelectionDialog.tempSelectedFolderPaths = mTempSelectedFolderPaths;
        	MusicFoldersSelectionDialog.tempSelectedFolderTimestamps = mTempSelectedFolderTimestamps;
    	}*/
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.DecimalFormat;
import java.util.ArrayList;

import org.json.JSONException;

import android.app.NotificationManager;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.Uri;
import android.os.AsyncTask;
import android.support.v4.app.NotificationCompat;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.GMusicHelpers.GMusicClientCalls;
import com.jams.music.player.Services.PinGMusicSongsService;
import com.jams.music.player.Utils.Common;

public class AsyncPinSongsTask extends AsyncTask<String, Integer, Boolean> {
	
    private Context mContext;
    private Common mApp;
    private String mSaveLocation;
    private String mFileName;
    private int fileSize;
    private int currentDownloadedSize = 0;
    
	private ArrayList<String> songIdsList;
	private ArrayList<String> songTitlesList;
	private int i;
	
	//File size/unit dividers
	private static final long kiloBytes = 1024;
	private static final long megaBytes = kiloBytes * kiloBytes;
	private static final long gigaBytes = megaBytes * kiloBytes;
	private static final long teraBytes = gigaBytes * kiloBytes;
    
    public AsyncPinSongsTask(Context context) {
    	
    	//Context.
    	mContext = context;
    	songIdsList = new ArrayList<String>();
    	songTitlesList = new ArrayList<String>();
    	
    	//If the cache storage directory for local copies doesn't exist, go ahead and create it.
    	File cacheFolder = null;
		try {
			cacheFolder = new File(mContext.getCacheDir().getCanonicalPath() + "/music");
	    	if (!cacheFolder.exists()) {
	    		cacheFolder.mkdirs();
	    	}
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
			Toast.makeText(mContext, R.string.download_failed_to_initialize, Toast.LENGTH_LONG).show();
			return;
		}
    	
    	mApp = (Common) mContext.getApplicationContext();
    	try {
			mSaveLocation = cacheFolder.getCanonicalPath();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	
    }
    
    protected void onPreExecute() {
    	super.onPreExecute();
    	
    	//The initial notification will display a "Starting download" message + indeterminate progress bar.
    	PinGMusicSongsService.mBuilder.setContentTitle(mContext.getResources().getString(R.string.starting_download));
    	PinGMusicSongsService.mBuilder.setTicker(mContext.getResources().getString(R.string.starting_download));
    	PinGMusicSongsService.mBuilder.setSmallIcon(R.drawable.pin_light);
    	PinGMusicSongsService.mBuilder.setProgress(0, 0, true);
    	
    	PinGMusicSongsService.mNotifyManager.notify(PinGMusicSongsService.notificationID, 
    											    PinGMusicSongsService.mBuilder.build());
    }
 
	@Override
    protected Boolean doInBackground(String... params) {
		
		//Iterate through the cursor and download/cache the requested songs.
		boolean getAllPinnedTracks = false;
		if (mApp.getPinnedSongsCursor()==null) {
			//The user asked to get all pinned songs from the official GMusic app.
			getAllPinnedTracks = true;
			
			//Check to make sure that the official GMusic app exists.
			PackageManager pm = mContext.getPackageManager();
	    	boolean installed = false;
	    	try {
				pm.getPackageInfo("com.google.android.music", PackageManager.GET_ACTIVITIES);
				installed = true;
			} catch (NameNotFoundException e1) {
				//The app isn't installed.
				installed = false;
			}
	    	
	    	if (installed==false) {
	    		//The app isn't installed. Notify the user.
	    		publishProgress(new Integer[] {2});
	    		return false;
	    	}
	    	
	    	//Query GMusic's content mApp for pinned songs.
	    	Uri googlePlayMusicContentProviderUri = Uri.parse("content://com.google.android.music.MusicContent/audio");
	    	String[] projection = { "title", "TrackType AS track_type", "LocalCopyPath AS local_copy_path",
	    							"SourceType AS source_type", "SourceId" };
	    	
	    	/* source_type values:
	    	 * 0: Local file (not used).
	    	 * 1: Unknown.
	    	 * 2: Personal, free GMusic library (used).
	    	 * 3: All Access (not used).
	    	 */
	    	String selection = "source_type=2 AND track_type=0 AND local_copy_path<>''";
	    	mApp.setPinnedSongsCursor(mContext.getContentResolver().query(googlePlayMusicContentProviderUri, 
	    																  projection, 
	    																  selection, 
	    																  null, 
	    																  null));

		}
		
		/* Load the cursor data into a temp ArrayList. If the app is closed, the cursor 
		 * will also be closed, so we need to preserve it.
		 */
		mApp.getPinnedSongsCursor().moveToPosition(-1);
		while (mApp.getPinnedSongsCursor().moveToNext()) {
			//Download the song only if it's from GMusic.
			if (getAllPinnedTracks || mApp.getPinnedSongsCursor().getString(
									  mApp.getPinnedSongsCursor().getColumnIndex(
									  DBAccessHelper.SONG_SOURCE)).equals(DBAccessHelper.GMUSIC)) {
				
		    	//Retrieve the song ID of current song and set it as the file name.
		    	String songID = "";
		    	String songTitle = "";
		    	if (mApp.getPinnedSongsCursor().getColumnIndex("SourceId")!=-1) {
		    		songID = mApp.getPinnedSongsCursor().getString(
		    				 mApp.getPinnedSongsCursor().getColumnIndex(
		    						 "SourceId"));
		    		
		    		songTitle = mApp.getPinnedSongsCursor().getString(
		    				 	mApp.getPinnedSongsCursor().getColumnIndex(
		    						 "title"));
		    	} else {
		        	songID = mApp.getPinnedSongsCursor().getString(
		       			 	 mApp.getPinnedSongsCursor().getColumnIndex(
		   		 					DBAccessHelper.SONG_ID));
		        	
		        	songTitle = mApp.getPinnedSongsCursor().getString(
		    				 	mApp.getPinnedSongsCursor().getColumnIndex(
		    						 DBAccessHelper.SONG_TITLE));
		    	}
		    	
				songIdsList.add(songID);
				songTitlesList.add(songTitle);
			}
			
		}

		//Clear out Common's cursor.
		if (mApp.getPinnedSongsCursor()!=null) {
			mApp.getPinnedSongsCursor().close();
			mApp.setPinnedSongsCursor(null);
		}
		
		//Iterate through the songs and download them.
		for (i=0; i < songIdsList.size(); i++) {
			downloadSong(songIdsList.get(i));
		}
		
    	return true;
    }
    
    public void downloadSong(String songID) {
    	
    	//Update the notification.
    	publishProgress(new Integer[] {1});

    	//Check if the file already exists. If so, skip it.
    	File tempFile = new File(mSaveLocation + "/" + songID + ".mp3");
    	
    	if (tempFile.exists()) {
    		tempFile = null;
    		return;
    	}
    	
    	tempFile = null;
    	mFileName = songID + ".mp3";
    	
		//Get the url for the song file using the songID.
		URL url = null;
		try {
			url = GMusicClientCalls.getSongStream(songID).toURL();
		} catch (MalformedURLException e) {
			e.printStackTrace();
			return;
		} catch (JSONException e) {
			e.printStackTrace();
			return;
		} catch (URISyntaxException e) {
			e.printStackTrace();
			return;
		} catch (Exception e) {
			e.printStackTrace();
			return;
		}
		
		try {
			//Download the file to the specified location.
			//Create a new connection to the server.
		    HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
		
		    //Set the request method of the connection.
		    urlConnection.setRequestMethod("GET");
		    urlConnection.setDoOutput(true);
		
		    //Aaaand connect!
		    urlConnection.connect();
		
		    //Set the destination path of the file.
		    File SDCardRoot = new File(mSaveLocation);

		    //Create the destination file.
		    File file = new File(SDCardRoot, mFileName);
		
		    //We'll use this to write the downloaded data into the file we created
		    FileOutputStream fileOutput = new FileOutputStream(file);
		
		    //Aaand we'll use this to read the data from the server.
		    InputStream inputStream = urlConnection.getInputStream();
		
		    //Total size of the file.
		    fileSize = urlConnection.getContentLength();
		    
		    //Specifies how much of the total size has been downloaded.
		    currentDownloadedSize = 0;
		
		    //Buffers galore!
		    byte[] buffer = new byte[1024];
		    int bufferLength = 0; //Used to store a temporary size of the buffer.
		    int updateValue = 0;
		    
		    //Read through the input buffer and write the destination file, piece by piece.
		    while ((bufferLength = inputStream.read(buffer)) > 0) {
	            fileOutput.write(buffer, 0, bufferLength);
	            currentDownloadedSize += bufferLength;
	            updateValue = updateValue + 1;
	            
	            //Update the notification for every 100 iterations.
	            if (updateValue==100) {
	            	publishProgress(new Integer[] {0});
	            	updateValue = 0;
	            }
	        
		    }
		    
		    try {
		    	//Close the output stream.
		    	fileOutput.close();
		    } catch (Exception e) {
		    	e.printStackTrace();
		    }
		    
		//And we're done!
		} catch (MalformedURLException e) {
			return;
		} catch (IOException e) {
			return;
		} catch (Exception e) {
			return;
		}
		
		//Insert the file path of the local copy into the DB.
		ContentValues values = new ContentValues();
		String selection = DBAccessHelper.SONG_ID + "=" + "'" + songID + "'";

		String localCopyPath = null;
		try {
			localCopyPath = mContext.getCacheDir().getCanonicalPath() + "/music/" + mFileName;
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		values.put(DBAccessHelper.LOCAL_COPY_PATH, localCopyPath);
		mApp.getDBAccessHelper()
			.getWritableDatabase()
			.update(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
					values, 
					selection, 
					null);

    }

    @Override
    protected void onProgressUpdate(Integer... values) {
    	int updateCode = values[0];
    	switch(updateCode) {
    	case 0:
    		String currentProgressText = getFormattedFileSize((long) currentDownloadedSize)
    								   + " of " 
    								   + getFormattedFileSize((long) fileSize);
    		
    		PinGMusicSongsService.mBuilder.setTicker(null);
    		PinGMusicSongsService.mBuilder.setProgress(fileSize, currentDownloadedSize, false);
    		PinGMusicSongsService.mBuilder.setContentText(currentProgressText);
    		PinGMusicSongsService.mNotifyManager.notify(PinGMusicSongsService.notificationID, PinGMusicSongsService.mBuilder.build());
    		break;
    	case 1:
    		if (i < songTitlesList.size()) {

			 	//Create the notification that displays the download progress of the song.
			 	String title = mContext.getResources().getString(R.string.downloading_no_dot) + " " + songTitlesList.get(i);
			
			 	PinGMusicSongsService.mNotifyManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
			 	PinGMusicSongsService.mBuilder = new NotificationCompat.Builder(mContext);
			 	PinGMusicSongsService.mBuilder.setContentTitle(title);
			 	PinGMusicSongsService.mBuilder.setContentText(mContext.getResources().getString(R.string.starting_download));
			 	PinGMusicSongsService.mBuilder.setSmallIcon(R.drawable.pin_light);
			 	PinGMusicSongsService.mBuilder.setProgress(0, 0, true);
			 	PinGMusicSongsService.mNotifyManager.notify(PinGMusicSongsService.notificationID, PinGMusicSongsService.mBuilder.build());
    		}
    		break;
    	case 2:
    		Toast.makeText(mContext, R.string.gmusic_app_not_installed_pin, Toast.LENGTH_SHORT).show();
    		break;
    	}

    }
    
    public static String getFormattedFileSize(final long value) {
    	
    	final long[] dividers = new long[] { teraBytes, gigaBytes, megaBytes, kiloBytes, 1 };
        final String[] units = new String[] { "TB", "GB", "MB", "KB", "bytes" };
        
        if(value < 1) {
        	return "";
        }
        
        String result = null;
        for(int i = 0; i < dividers.length; i++) {
            final long divider = dividers[i];
            if(value >= divider) {
                result = format(value, divider, units[i]);
                break;
            }
            
        }
        
        return result;
    }
    
    private static String format(final long value, final long divider, final String unit) {
        final double result = divider > 1 ? (double) value / (double) divider : (double) value;
        return new DecimalFormat("#,##0.#").format(result) + " " + unit;
    }
    
    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);	
		PinGMusicSongsService.mBuilder.setProgress(0, 0, false);
		PinGMusicSongsService.mBuilder.setContentText("");
		PinGMusicSongsService.mBuilder.setContentTitle(mContext.getResources().getString(R.string.done_pinning_songs));
		PinGMusicSongsService.mNotifyManager.notify(PinGMusicSongsService.notificationID, PinGMusicSongsService.mBuilder.build());
		
		//Notify the user.
		if (mApp.isFetchingPinnedSongs()==true) {
			Toast.makeText(mContext, R.string.done_pinning_songs_from_gmusic, Toast.LENGTH_LONG).show();
		} else {
			Toast.makeText(mContext, R.string.done_pinning_songs, Toast.LENGTH_LONG).show();
		}
		
		songTitlesList.clear();
		songTitlesList = null;
		songIdsList.clear();
		songIdsList = null;

		mApp.setIsFetchingPinnedSongs(false);
		
		//Stop the service.
		mContext.stopService(new Intent(mContext, PinGMusicSongsService.class));
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.media.MediaMetadataRetriever;
import android.os.AsyncTask;
import android.util.Log;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.FoldersFragment.FileExtensionFilter;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;

public class AsyncPlayFolderRecursiveTask extends AsyncTask<String, Void, Void> {
    private Activity mContext;
    private String mFolderName;
    private ProgressDialog pd;
	boolean dialogVisible = true;
	
	private ArrayList<String> audioFilePathsInFolder = new ArrayList<String>();
	private ArrayList<String> subdirectoriesList = new ArrayList<String>();
	private ArrayList<Object> metadata = new ArrayList<Object>();
    
    public AsyncPlayFolderRecursiveTask(Activity context, String folderName) {
    	mContext = context;
    	mFolderName = folderName;
    }
    
    protected void onPreExecute() {
		pd = new ProgressDialog(mContext);
		pd.setCancelable(false);
		pd.setIndeterminate(false);
		pd.setTitle(R.string.play_folder_recursive);
		pd.setButton(DialogInterface.BUTTON_NEUTRAL, mContext.getResources()
															 .getString(R.string.cancel), new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				pd.dismiss();
				
			}
			
		});
		
		pd.show();
    	
    }
 
    @Override
    protected Void doInBackground(String... params) {
    	String folderPath = params[0];
    	getAudioFilePathsInFolder(folderPath);
		
		//Get the list of subdirectories and iterate through them for audio files.
		iterateThruFolder(folderPath);
		
		for (int i=0; i < subdirectoriesList.size(); i++) {
			getAudioFilePathsInFolder(subdirectoriesList.get(i));
		}
		
		//Extract the metadata from the first audio file (if any).
		if (audioFilePathsInFolder!=null && audioFilePathsInFolder.size() > 0) {
			metadata = extractFileMetadata(audioFilePathsInFolder.get(0));
		}
    	
    	return null;
	    
    }
    
    //Stores an ArrayList of all the audio files' paths within the specified folder.
    public void getAudioFilePathsInFolder(String folderPath) {
    	
    	//We'll use a filter to retrieve a list of all files with a matching extension.
    	File file = new File(folderPath);
    	FileExtensionFilter AUDIO_FILES_FILTER = new FileExtensionFilter(new String[] {".mp3", ".3gp", ".mp4",
    																				   ".m4a", ".aac", ".ts", 
    																				   ".flac", ".mid", ".xmf", 
    																				   ".mxmf", ".midi", ".rtttl", 
    																				   ".rtx", ".ota", ".imy", ".ogg", 
    																				   ".mkv", ".wav" });
    	
    	File[] filesInFolder = file.listFiles(AUDIO_FILES_FILTER);
    	
    	//Loop through the list of files and add their file paths to the corresponding ArrayList.
    	for (int i=0; i < filesInFolder.length; i++) {
    		
    		try {
				audioFilePathsInFolder.add(filesInFolder[i].getCanonicalPath());
			} catch (IOException e) {
				//Skip any corrupt audilo files.
				continue;
			}
    		
    	}
    	
    }
    
    /* This method goes through a folder recursively and saves all its
     * subdirectories to an ArrayList (subdirectoriesList). */
    public void iterateThruFolder(String path) {

        File root = new File(path);
        File[] list = root.listFiles();

        if (list==null) {
        	return;
        }

        for (File f : list) {
        	
        	mFolderName = f.getName();
        	publishProgress();
        	
            if (f.isDirectory()) {
                iterateThruFolder(f.getAbsolutePath());
                
                if (!subdirectoriesList.contains(f.getPath())) {
                	subdirectoriesList.add(f.getPath());
                }
                    
            }
            
        }
        
    }
    
    @Override
    protected void onProgressUpdate(Void... v) {

		//Update the progress on the progress dialog.
		pd.setMessage(mContext.getResources().getString(R.string.scanning_for_files) + " " + mFolderName);
    	 
    }
    
    //Extracts specific ID3 metadata from an audio file and returns them in an ArrayList.
    public static ArrayList<Object> extractFileMetadata(String filePath) {
    	ArrayList<Object> metadata = new ArrayList<Object>();
    	
    	MediaMetadataRetriever mediaMetadataRetriever = new MediaMetadataRetriever();
    	mediaMetadataRetriever.setDataSource(filePath);
    	
    	metadata.add(mediaMetadataRetriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE));
    	metadata.add(mediaMetadataRetriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST));
    	metadata.add(mediaMetadataRetriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM));
    	metadata.add(mediaMetadataRetriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION));
    	metadata.add(mediaMetadataRetriever.getEmbeddedPicture());
    	
    	return metadata;
    	
    }
    
    //Call the player activity once we've accumulated the first song's path.
    
    

    @Override
    protected void onPostExecute(Void arg0) {
    	
    	/* Now that we have a list of audio files within the folder, pass them
    	 * on to NowPlayingActivity (which will assemble the files into a cursor for the service. */
		
    	//Check if the list is empty. If it is, show a Toast message to the user.
    	if (audioFilePathsInFolder.size() > 0) {
    		
    		//Check if the audio file has a title. If not, use the file name.
    		String title = "";
    		if (metadata.get(0)==null) {
    			title = audioFilePathsInFolder.get(0);
    		} else {
    			title = (String) metadata.get(0);
    		}
    		
    		Intent intent = new Intent(mContext, NowPlayingActivity.class);
    		intent.putExtra("DURATION", (String) metadata.get(3));
    		intent.putExtra("SONG_NAME", title);
    		intent.putExtra("NUMBER_SONGS", 1);
    		
    		if (metadata.get(1)==null) {
    			intent.putExtra("ARTIST", "Unknown Artist");
    		} else {
    			intent.putExtra("ARTIST", (String) metadata.get(1));
    		}
    		
    		if (metadata.get(2)==null) {
    			intent.putExtra("ALBUM", "Unknown Album");
    		} else {
    			intent.putExtra("ALBUM", (String) metadata.get(2));
    		}
    		
    		if (metadata.get(3)==null) {
    			intent.putExtra("SELECTED_SONG_DURATION", 0);
    		} else {
    			intent.putExtra("SELECTED_SONG_DURATION", (String) metadata.get(3));
    		}
    		
    		intent.putExtra("DATA_URI", audioFilePathsInFolder.get(0));
    		
    		if (metadata.get(4)==null) {
    			intent.putExtra("EMBEDDED_ART", (byte[]) null);
    		} else {
    			intent.putExtra("EMBEDDED_ART", (byte[]) metadata.get(4));
    		}

    		intent.putExtra("NEW_PLAYLIST", true);
    		intent.putExtra("CALLED_FROM_FOOTER", false);
    		intent.putExtra("CALLED_FROM_FOLDERS", true);
    		intent.putExtra("CALLING_FRAGMENT", "FOLDERS_FRAGMENT");
    		
    		//We're dealing with the first audio file in the list, so just use zero for SONG_SELECTED_INDEX.
    		intent.putExtra("SONG_SELECTED_INDEX", 0);
    		
    		//Pass on the list of file paths to NowPlayingActivity (which will assemble them into a cursor).
    		intent.putStringArrayListExtra("FOLDER_AUDIO_FILE_PATHS", audioFilePathsInFolder);
    		
    		pd.dismiss();
    		
    		Log.e("DEBUG", ">>>>>>>>>>>>TIME TO START THE ACTIVITY");
    		mContext.startActivity(intent);
    		mContext.overridePendingTransition(R.anim.slide_in_from_right, R.anim.slide_out_to_left);
    		
    	} else {
    		pd.dismiss();
    		Toast.makeText(mContext, R.string.no_audio_files_found, Toast.LENGTH_LONG).show();
    	}
    	
    	mContext = null;
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.os.AsyncTask;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;

public class AsyncRemovePinnedSongsTask extends AsyncTask<String, Integer, Boolean> {
    private Context mContext;
    private String mSelection;
    private Cursor mSmartPlaylistCursor;
    
    public AsyncRemovePinnedSongsTask(Context context, String selection, Cursor smartPlaylistCursor) {
    	//Context.
    	mContext = context;
    	mSelection = selection;
    	mSmartPlaylistCursor = smartPlaylistCursor;
    }
    
    protected void onPreExecute() {
    	super.onPreExecute();
    	Toast.makeText(mContext, R.string.removing_pinned_songs, Toast.LENGTH_SHORT).show();
    }
 
	@Override
    protected Boolean doInBackground(String... params) {
		
		//Delete the specified local copies of the song(s) and remove the local copy reference from the DB.
		Cursor cursor = null;
		DBAccessHelper dbHelper = new DBAccessHelper(mContext);
		if (mSmartPlaylistCursor==null) {
			mSelection += " AND " + DBAccessHelper.SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'";
			cursor = dbHelper.getAllSongsSearchable(mSelection);
		} else {
			cursor = mSmartPlaylistCursor;
		}
		
		if (cursor!=null) {
			for (int i=0; i < cursor.getCount(); i++) {
				try {
					cursor.moveToPosition(i);
					String localCopyPath = cursor.getString(cursor.getColumnIndex(DBAccessHelper.LOCAL_COPY_PATH));
					String songID = cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ID));
					
					File file = new File(localCopyPath);
					if (file!=null && file.exists()) {
						file.delete();
					}
					
					String selection = DBAccessHelper.SONG_ID + "=" + "'" + songID + "'";
					ContentValues values = new ContentValues();
					values.put(DBAccessHelper.LOCAL_COPY_PATH, "");
					dbHelper.getWritableDatabase().update(DBAccessHelper.MUSIC_LIBRARY_TABLE, values, selection, null);
					
				} catch (Exception e) {
					e.printStackTrace();
					continue;
				}

			}
			
		}
		
		if (dbHelper!=null) {
			dbHelper.close();
			dbHelper = null;
		}

    	return true;
    }
   
    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);	
		Toast.makeText(mContext, R.string.pinned_songs_removed, Toast.LENGTH_SHORT).show();
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.AsyncTask;

public class AsyncRemovePlaylistEntryTask extends AsyncTask<String, Integer, Boolean> {
    private Context mContext;
    private SharedPreferences sharedPreferences;
    private String mEntryId;
    
    public AsyncRemovePlaylistEntryTask(Context context, String entryId) {
    	mContext = context;
    	sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    	mEntryId = entryId;
    	
    }
 
    @Override
    protected Boolean doInBackground(String... params) {

/*    	if (sharedPreferences.getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
    		try {
    			GMusicClientCalls.putDeletePlaylistEntryRequest(mEntryId);
    			GMusicClientCalls.modifyPlaylist(mContext);
    		} catch (IllegalArgumentException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		} catch (JSONException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
    		
    	}

		//Update the playlists database.
		DBAccessHelper dbHelper = new DBAccessHelper(mContext);
		dbHelper.deleteSongFromPlaylist(mEntryId);
		dbHelper.close();
		dbHelper = null;*/
    	
    	return true;
    }
    
    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
		
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.util.ArrayList;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.AsyncTask;

public class AsyncReorderPlaylistEntriesTask extends AsyncTask<String, Integer, Boolean> {
    private Context mContext;
    private SharedPreferences sharedPreferences;
    
    private String mPlaylistId;
    private ArrayList<String> mSongId;
    private ArrayList<String> mSongEntryId;
    private String mAfterEntryId;
    private String mBeforeEntryId;
    private String mPlaylistName;
    private ArrayList<String> mEntryIds;
    private ArrayList<String> mSongIds;
    
    public AsyncReorderPlaylistEntriesTask(Context context, 
    								   	   String playlistId,
    								   	   String playlistName,
    								   	   ArrayList<String> songId,
    								   	   ArrayList<String> songEntryId,
    								   	   String afterEntryId,
    								   	   String beforeEntryId,
    								   	   ArrayList<String> entryIds,
    								   	   ArrayList<String> songIds) {
    	
    	mContext = context;
    	sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    	
    	mPlaylistId = playlistId;
    	mSongId = songId;
    	mSongEntryId = songEntryId;
    	mAfterEntryId = afterEntryId;
    	mBeforeEntryId = afterEntryId;
    	mPlaylistName = playlistName;
    	mEntryIds = entryIds;
    	mSongIds = songIds;
    	
    }
 
    @Override
    protected Boolean doInBackground(String... params) {
    	
/*    	if (sharedPreferences.getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
        	try {
    			GMusicClientCalls.reorderPlaylistEntryWebClient(mContext, 
    															mPlaylistId, 
    															mSongId, 
    															mSongEntryId, 
    															mAfterEntryId, 
    															mBeforeEntryId);
    		} catch (JSONException e) {
    			// TODO Auto-generated catch block
    			e.printStackTrace();
    		}
        	
    	}
    	
		//Update the playlists database.
		DBAccessHelper dbHelper = new DBAccessHelper(mContext);
		dbHelper.reorderSongInPlaylist(mContext, mPlaylistName, mPlaylistId, mEntryIds, mSongIds);
		dbHelper.close();
		dbHelper = null;*/
    	
    	return true;
    }
    
    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
		
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import android.content.ContentValues;
import android.content.Context;
import android.os.AsyncTask;
import android.util.Log;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Utils.Common;

public class AsyncSaveMusicFoldersTask extends AsyncTask<String, Void, Boolean> {
	
    private Context mContext;
    private Common mApp;
    private HashMap<String, Boolean> mMusicFolders;
    private List<String> mPathsList;
    
    public AsyncSaveMusicFoldersTask(Context context, HashMap<String, Boolean> musicFolders) {
    	mContext = context;
    	mApp = (Common) mContext;
    	mMusicFolders = musicFolders;
    	
    }
 
    @Override
    protected Boolean doInBackground(String... params) {
    	
		//Clear the DB and insert the new selections (along with the old ones).
		mApp.getDBAccessHelper().deleteAllMusicFolderPaths();
		try {
			mApp.getDBAccessHelper().getWritableDatabase().beginTransaction();
			
			//Retrieve a list of all keys in the hash map (key = music folder path).
			mPathsList = new ArrayList<String>(mMusicFolders.keySet());
				
			for (int i=0; i < mMusicFolders.size(); i++) {
				String path = mPathsList.get(i);
				boolean include = mMusicFolders.get(path);

				//Trim down the folder path to include only the folder and its parent.
				int secondSlashIndex = path.lastIndexOf("/", path.lastIndexOf("/")-1);
				if ((secondSlashIndex < path.length()) && secondSlashIndex!=-1)
					path = path.substring(secondSlashIndex, path.length());
				
		        ContentValues values = new ContentValues();
		        values.put(DBAccessHelper.FOLDER_PATH, path);
		        values.put(DBAccessHelper.INCLUDE, include);

		        mApp.getDBAccessHelper().getWritableDatabase().insert(DBAccessHelper.MUSIC_FOLDERS_TABLE, null, values);
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			mApp.getDBAccessHelper().getWritableDatabase().setTransactionSuccessful();
			mApp.getDBAccessHelper().getWritableDatabase().endTransaction();
		}
		
		//Populate the UserLibraries table.
		try {
			mApp.getDBAccessHelper().getWritableDatabase().beginTransaction();
			
			//Insert the default libaries.
			ContentValues allLibrariesValues = new ContentValues();
			allLibrariesValues.put(DBAccessHelper.LIBRARY_NAME, mContext.getResources().getString(R.string.all_libraries));
			allLibrariesValues.put(DBAccessHelper.SONG_ID, "ALL_LIBRARIES");
			allLibrariesValues.put(DBAccessHelper.LIBRARY_TAG, "circle_blue_dark");
			mApp.getDBAccessHelper().getWritableDatabase().insert(DBAccessHelper.LIBRARIES_TABLE, null, allLibrariesValues);
			
			ContentValues googlePlayMusicLibrary = new ContentValues();
			googlePlayMusicLibrary.put(DBAccessHelper.LIBRARY_NAME, mContext.getResources().getString(R.string.google_play_music_no_asterisk));
			googlePlayMusicLibrary.put(DBAccessHelper.SONG_ID, DBAccessHelper.GMUSIC);
			googlePlayMusicLibrary.put(DBAccessHelper.LIBRARY_TAG, "circle_yellow_dark");
			mApp.getDBAccessHelper().getWritableDatabase().insert(DBAccessHelper.LIBRARIES_TABLE, null, googlePlayMusicLibrary);
			
			//Default to "All Libraries".
			mApp.getSharedPreferences().edit().putString(Common.CURRENT_LIBRARY, mContext.getResources().getString(R.string.all_libraries)).commit();
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			mApp.getDBAccessHelper().getWritableDatabase().setTransactionSuccessful();
			mApp.getDBAccessHelper().getWritableDatabase().endTransaction();
			
			//Use "All Libraries" as the default library.
			mApp.getSharedPreferences().edit().putString(Common.CURRENT_LIBRARY, mContext.getResources().getString(R.string.all_libraries)).commit();
			
		}
    	
    	return true;
    }
    
    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;

import android.annotation.SuppressLint;
import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.os.AsyncTask;
import android.widget.RemoteViews;

import com.jams.music.player.R;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.Utils.Common;

public class AsyncUpdateAlbumArtWidgetTask extends AsyncTask<String, Integer, Boolean> {
	
    private Context mContext;
    private Common mApp;
    private int mNumWidgets;
    private int mAppWidgetIds[];
    private AppWidgetManager mAppWidgetManager;
    
    private int currentAppWidgetId;
    private RemoteViews views;
    
	public static final String PREVIOUS_ACTION = "com.jams.music.player.PREVIOUS_ACTION";
	public static final String PLAY_PAUSE_ACTION = "com.jams.music.player.PLAY_PAUSE_ACTION";
	public static final String NEXT_ACTION = "com.jams.music.player.NEXT_ACTION";
    
    public AsyncUpdateAlbumArtWidgetTask(Context context, int numWidgets, int appWidgetIds[], AppWidgetManager appWidgetManager) {
    	mContext = context;
    	mApp = (Common) mContext.getApplicationContext();
    	mAppWidgetIds = appWidgetIds;
    	mAppWidgetManager = appWidgetManager;
    	mNumWidgets = numWidgets;
    	
    }
 
    @SuppressLint("NewApi")
	@Override
    protected Boolean doInBackground(String... params) {

    	//Perform this loop procedure for each App Widget that belongs to this mApp
        for (int i=0; i < mNumWidgets; i++) {
            currentAppWidgetId = mAppWidgetIds[i];
            
            Intent playPauseIntent = new Intent();
        	playPauseIntent.setAction(PLAY_PAUSE_ACTION);
        	PendingIntent playPausePendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, playPauseIntent, 0);
        	
        	Intent nextIntent = new Intent();
        	nextIntent.setAction(NEXT_ACTION);
        	PendingIntent nextPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, nextIntent, 0);
        	
        	Intent previousIntent = new Intent();
        	previousIntent.setAction(PREVIOUS_ACTION);
        	PendingIntent previousPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, previousIntent, 0);

            //Get the layout of the widget and attach a click listener to each element.
            RemoteViews views = new RemoteViews(mContext.getPackageName(), R.layout.album_art_widget_layout);
            views.setOnClickPendingIntent(R.id.widget_play, playPausePendingIntent);
            views.setOnClickPendingIntent(R.id.widget_previous_track, previousPendingIntent);
            views.setOnClickPendingIntent(R.id.widget_next_track, nextPendingIntent);
            
            //Get the downsampled image of the current song's album art.
            views.setImageViewBitmap(R.id.widget_album_art, getAlbumArt());
            views.setTextViewText(R.id.widget_song_title_text, mApp.getService().getCurrentSong().getTitle());
            views.setTextViewText(R.id.widget_artist_album_text, mApp.getService().getCurrentSong().getAlbum() 
            												   + mApp.getService().getCurrentSong().getArtist());

            if (mApp.isServiceRunning()) {
            	
            	try {
                	if (mApp.getService().getCurrentMediaPlayer().isPlaying()) {
                		views.setImageViewResource(R.id.widget_play, R.drawable.btn_playback_pause_light);
                	} else {
                		views.setImageViewResource(R.id.widget_play, R.drawable.btn_playback_play_light);
                	}
            	} catch (Exception e) {
            		// TODO Auto-generated method stub
            		e.printStackTrace();
            	}
            	
            }
            
            //Tapping the album art should open up the app's NowPlayingActivity.
            if (mApp.isServiceRunning()) {
            	final Intent notificationIntent = new Intent(mContext, NowPlayingActivity.class);
                notificationIntent.putExtra("CALLED_FROM_FOOTER", true);
                notificationIntent.putExtra("CALLED_FROM_NOTIF", true);
                
                PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, notificationIntent, 0);
                views.setOnClickPendingIntent(R.id.app_widget_small_image, pendingIntent);
            }

            //Tell the AppWidgetManager to perform an update on the current app widget\
            try {
            	mAppWidgetManager.updateAppWidget(currentAppWidgetId, views);
            } catch (Exception e) {
            	continue;
            }
            
        }
    	
    	return true;
    }
    
    private Bitmap getAlbumArt() {
    	mApp = (Common) mContext.getApplicationContext();
    	
        //Check if the album art has been cached for this song.
        File albumArtFile = new File(mContext.getExternalCacheDir() + "/current_album_art.jpg");
        Bitmap bm = null;
        if (albumArtFile.exists() && mApp.isServiceRunning()) {
        	//Decode a subsampled version of the cached album art.
        	bm = mApp.decodeSampledBitmapFromFile(albumArtFile, 450, 450);
        } else if (!albumArtFile.exists() && mApp.isServiceRunning()) {
        	//Decode a subsampled version of the default album art.
            bm = mApp.decodeSampledBitmapFromResource(R.drawable.transparent_drawable, 450, 450);
        } else {
        	return null;
        }
        
        return bm;
    }

    @Override
    public void onProgressUpdate(Integer... values) {
    	super.onProgressUpdate(values);
    	switch(values[0]) {
    	case 0:
    		try {
    			mAppWidgetManager.updateAppWidget(currentAppWidgetId, views);
    		} catch (Exception e) {
    			e.printStackTrace();
    		}

    		break;
    	}
    	
    }
    
    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
        
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;

import android.annotation.SuppressLint;
import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Bitmap;
import android.os.AsyncTask;
import android.widget.RemoteViews;

import com.jams.music.player.R;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.Utils.GaussianBlur;

public class AsyncUpdateBlurredWidgetTask extends AsyncTask<String, Integer, Boolean> {
	
    private Context mContext;
    private Common mApp;
    private int mNumWidgets;
    private int mAppWidgetIds[];
    private AppWidgetManager mAppWidgetManager;
    
    private int currentAppWidgetId;
    private RemoteViews views;
    
	private SharedPreferences sharedPreferences;
    
	public static final String PREVIOUS_ACTION = "com.jams.music.player.PREVIOUS_ACTION";
	public static final String PLAY_PAUSE_ACTION = "com.jams.music.player.PLAY_PAUSE_ACTION";
	public static final String NEXT_ACTION = "com.jams.music.player.NEXT_ACTION";
    
    public AsyncUpdateBlurredWidgetTask(Context context, int numWidgets, int appWidgetIds[], AppWidgetManager appWidgetManager) {
    	mContext = context;
    	mApp = (Common) mContext.getApplicationContext();
    	sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    	mAppWidgetIds = appWidgetIds;
    	mAppWidgetManager = appWidgetManager;
    	mNumWidgets = numWidgets;
    }
 
    @SuppressLint("NewApi")
	@Override
    protected Boolean doInBackground(String... params) {

    	//Perform this loop procedure for each App Widget that belongs to this mApp
        for (int i=0; i < mNumWidgets; i++) {
            currentAppWidgetId = mAppWidgetIds[i];
            
            Intent playPauseIntent = new Intent();
        	playPauseIntent.setAction(PLAY_PAUSE_ACTION);
        	PendingIntent playPausePendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, playPauseIntent, 0);
        	
        	Intent nextIntent = new Intent();
        	nextIntent.setAction(NEXT_ACTION);
        	PendingIntent nextPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, nextIntent, 0);
        	
        	Intent previousIntent = new Intent();
        	previousIntent.setAction(PREVIOUS_ACTION);
        	PendingIntent previousPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, previousIntent, 0);

            //Get the layout of the widget and attach a click listener to each element.
            RemoteViews views = new RemoteViews(mContext.getPackageName(), R.layout.blurred_widget_layout);
            views.setOnClickPendingIntent(R.id.widget_play, playPausePendingIntent);
            views.setOnClickPendingIntent(R.id.widget_previous_track, previousPendingIntent);
            views.setOnClickPendingIntent(R.id.widget_next_track, nextPendingIntent);
            
            //Get the downsampled image of the current song's album art.
            views.setImageViewBitmap(R.id.widget_album_art, getAlbumArt());
            views.setTextViewText(R.id.widget_song_title_text, mApp.getService().getCurrentSong().getTitle());
            views.setTextViewText(R.id.widget_artist_album_text, mApp.getService().getCurrentSong().getAlbum() 
            												   + mApp.getService().getCurrentSong().getArtist());

            if (mApp.isServiceRunning()) {
            	
            	try {
                	if (mApp.getService().getCurrentMediaPlayer().isPlaying()) {
                		views.setImageViewResource(R.id.widget_play, R.drawable.btn_playback_pause_light);
                	} else {
                		views.setImageViewResource(R.id.widget_play, R.drawable.btn_playback_play_light);
                	}
            	} catch (Exception e) {
            		// TODO Auto-generated method stub
            		e.printStackTrace();
            	}
            	
            }
            
            //Tapping the album art should open up the app's NowPlayingActivity.
            if (mApp.isServiceRunning()) {
            	final Intent notificationIntent = new Intent(mContext, NowPlayingActivity.class);
                notificationIntent.putExtra("CALLED_FROM_FOOTER", true);
                notificationIntent.putExtra("CALLED_FROM_NOTIF", true);
                
                PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, notificationIntent, 0);
                views.setOnClickPendingIntent(R.id.app_widget_small_image, pendingIntent);
                
            }

            //Tell the AppWidgetManager to perform an update on the current app widget\
            try {
            	mAppWidgetManager.updateAppWidget(currentAppWidgetId, views);
            } catch (Exception e) {
            	continue;
            }
            
        }
    	
    	return true;
    }
    
    private Bitmap getAlbumArt() {
    	mApp = (Common) mContext.getApplicationContext();
    	
        //Check if the album art has been cached for this song.
        File albumArtFile = new File(mContext.getExternalCacheDir() + "/current_album_art.jpg");
        Bitmap bm = null;
        if (albumArtFile.exists() && mApp.isServiceRunning()) {
        	//Decode a subsampled version of the cached album art.
        	bm = mApp.decodeSampledBitmapFromFile(albumArtFile, 150, 150);
        } else if (!albumArtFile.exists() && mApp.isServiceRunning()) {
        	//Decode a subsampled version of the default album art.
            bm = mApp.decodeSampledBitmapFromResource(R.drawable.transparent_drawable, 450, 450);
        } else {
        	return null;
        }
        
        return GaussianBlur.fastblur(mContext, bm, 5);
    }

    @Override
    public void onProgressUpdate(Integer... values) {
    	super.onProgressUpdate(values);
    	switch(values[0]) {
    	case 0:
    		try {
    			mAppWidgetManager.updateAppWidget(currentAppWidgetId, views);
    		} catch (Exception e) {
    			e.printStackTrace();
    		}

    		break;
    	}
    	
    }
    
    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
        
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;

import android.annotation.SuppressLint;
import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.net.Uri;
import android.os.AsyncTask;
import android.view.View;
import android.widget.RemoteViews;

import com.jams.music.player.R;
import com.jams.music.player.LauncherActivity.LauncherActivity;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.Services.LargeWidgetAdapterService;
import com.jams.music.player.Utils.Common;

public class AsyncUpdateLargeWidgetTask extends AsyncTask<String, Integer, Boolean> {
	
    private Context mContext;
    private Common mApp;
    private int mNumWidgets;
    private int mAppWidgetIds[];
    private AppWidgetManager mAppWidgetManager;
    
    private int currentAppWidgetId;
    private RemoteViews views;
    
	private String songTitle = "";
	private String albumName = "";
	private String artistName = "";
    
	public static final String PREVIOUS_ACTION = "com.jams.music.player.PREVIOUS_ACTION";
	public static final String PLAY_PAUSE_ACTION = "com.jams.music.player.PLAY_PAUSE_ACTION";
	public static final String NEXT_ACTION = "com.jams.music.player.NEXT_ACTION";
    
    public AsyncUpdateLargeWidgetTask(Context context, int numWidgets, int appWidgetIds[], AppWidgetManager appWidgetManager) {
    	mContext = context;
    	mApp = (Common) mContext.getApplicationContext();
    	mAppWidgetIds = appWidgetIds;
    	mAppWidgetManager = appWidgetManager;
    	mNumWidgets = numWidgets;
    }
 
    @SuppressLint("NewApi")
	@Override
    protected Boolean doInBackground(String... params) {
    	
    	//Perform this loop procedure for each App Widget that belongs to this mApp
        for (int i=0; i < mNumWidgets; i++) {
            currentAppWidgetId = mAppWidgetIds[i];
            String widgetColor = mApp.getSharedPreferences().getString("" + currentAppWidgetId, "DARK");
            
            //Initialize the RemoteView object to gain access to the widget's UI elements.
            views = new RemoteViews(mContext.getPackageName(), R.layout.large_widget_layout);

            if (widgetColor.equals("DARK")) {
            	views.setInt(R.id.large_widget_parent_layout, "setBackgroundResource", R.drawable.appwidget_dark_bg);
            	views.setImageViewResource(R.id.widget_play, R.drawable.btn_playback_play_light);
            	views.setImageViewResource(R.id.widget_previous_track, R.drawable.btn_playback_previous_light);
            	views.setImageViewResource(R.id.widget_next_track, R.drawable.btn_playback_next_light);
            } else if (widgetColor.equals("LIGHT")) {
            	views.setInt(R.id.large_widget_parent_layout, "setBackgroundResource", R.drawable.appwidget_bg);
            	views.setImageViewResource(R.id.widget_play, R.drawable.btn_playback_play);
            	views.setImageViewResource(R.id.widget_previous_track, R.drawable.btn_playback_previous);
            	views.setImageViewResource(R.id.widget_next_track, R.drawable.btn_playback_next);
            }
            
            /* Create a pendingIntent that will serve as a general template for the clickListener.
             * We'll create a fillInIntent in LargeWidgetAdapterService.java that will provide the 
             * index of the listview item that's been clicked. */
            Intent intent = new Intent();
            intent.setAction("com.jams.music.player.WIDGET_CHANGE_TRACK");
            PendingIntent pendingIntentTemplate = PendingIntent.getBroadcast(mContext, 0, intent, 0);
            views.setPendingIntentTemplate(R.id.widget_listview, pendingIntentTemplate);
            
            //Create the intent to fire up the service that will back the adapter of the listview.
            Intent serviceIntent = new Intent(mContext, LargeWidgetAdapterService.class);
            serviceIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetIds[i]);
            serviceIntent.setData(Uri.parse(serviceIntent.toUri(Intent.URI_INTENT_SCHEME)));
            serviceIntent.putExtra("WIDGET_COLOR", widgetColor);
            
            views.setRemoteAdapter(R.id.widget_listview, serviceIntent);
            mAppWidgetManager.notifyAppWidgetViewDataChanged(mAppWidgetIds, R.id.widget_listview);
            
            //Check if the service is running and update the widget elements.
            if (mApp.isServiceRunning()) {
            	
            	//Set the album art.
        		views.setViewVisibility(R.id.widget_listview, View.VISIBLE);
        		views.setImageViewBitmap(R.id.widget_album_art, getAlbumArt());
        		
        		final Intent notificationIntent = new Intent(mContext, NowPlayingActivity.class);
                notificationIntent.putExtra("CALLED_FROM_FOOTER", true);
                notificationIntent.putExtra("CALLED_FROM_NOTIF", true);
                
                PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, notificationIntent, 0);
                views.setOnClickPendingIntent(R.id.widget_album_art, pendingIntent);
            	
            } else {
            	songTitle = "";
            	albumName = mContext.getResources().getString(R.string.no_music_playing);
            	
            	//Set the default album art.
        		views.setImageViewResource(R.id.widget_album_art, R.drawable.default_album_art);
        		views.setViewVisibility(R.id.widget_listview, View.INVISIBLE);
        		
        		if (widgetColor.equals("DARK")) {
        			views.setImageViewResource(R.id.app_widget_small_play, R.drawable.btn_playback_play_light);
        		} else if (widgetColor.equals("LIGHT")) {
        			views.setImageViewResource(R.id.app_widget_small_play, R.drawable.btn_playback_play);
        		}
        		
        		final Intent notificationIntent = new Intent(mContext, LauncherActivity.class);
                PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, notificationIntent, 0);
                views.setOnClickPendingIntent(R.id.widget_album_art, pendingIntent);
        		
            }
            
            //Set the song title, artist name, and album name.
            views.setTextViewText(R.id.widget_song_title_text, songTitle);
            views.setTextViewText(R.id.widget_album_text, albumName);
            views.setTextViewText(R.id.widget_artist_text, artistName);
            
            if (widgetColor.equals("LIGHT")) {
    			views.setTextColor(R.id.widget_song_title_text, Color.BLACK);
    			views.setTextColor(R.id.widget_album_text, Color.BLACK);
    			views.setTextColor(R.id.widget_artist_text, Color.BLACK);
    		}
            
            //Attach PendingIntents to the widget controls.
        	Intent previousTrackIntent = new Intent();
        	previousTrackIntent.setAction(PREVIOUS_ACTION);
        	PendingIntent previousPendingIntent = PendingIntent.getBroadcast(mContext, 0, previousTrackIntent, 0);
        	
        	Intent playPauseTrackIntent = new Intent();
        	playPauseTrackIntent.setAction(PLAY_PAUSE_ACTION);
        	PendingIntent playPausePendingIntent = PendingIntent.getBroadcast(mContext, 0, playPauseTrackIntent, 0);
        	
        	Intent nextTrackIntent = new Intent();
        	nextTrackIntent.setAction(NEXT_ACTION);
        	PendingIntent nextPendingIntent = PendingIntent.getBroadcast(mContext, 0, nextTrackIntent, 0);
        	
        	//Set the pending intents on the buttons.
            views.setOnClickPendingIntent(R.id.widget_play, playPausePendingIntent);
            views.setOnClickPendingIntent(R.id.widget_previous_track, previousPendingIntent);
            views.setOnClickPendingIntent(R.id.widget_next_track, nextPendingIntent);
            
            if (mApp.isServiceRunning()) {
            	try {
                	if (mApp.getService().getCurrentMediaPlayer().isPlaying()) {
                		if (widgetColor.equals("DARK")) {
                			views.setImageViewResource(R.id.widget_play, R.drawable.btn_playback_pause_light);
                		} else if (widgetColor.equals("LIGHT")) {
                			views.setImageViewResource(R.id.widget_play, R.drawable.btn_playback_pause);
                		}
                		
                	} else {
                		if (widgetColor.equals("DARK")) {
                			views.setImageViewResource(R.id.widget_play, R.drawable.btn_playback_play_light);
                		} else if (widgetColor.equals("LIGHT")) {
                			views.setImageViewResource(R.id.widget_play, R.drawable.btn_playback_play);
                		}
                		
                	}
            	} catch (Exception e) {
            		// TODO Auto-generated method stub
            		e.printStackTrace();
            	}
            	
            }
            
            //Tell the AppWidgetManager to perform an update on the current app widget.
            try {
            	mAppWidgetManager.updateAppWidget(currentAppWidgetId, views);
            } catch (Exception e) {
            	continue;
            }
            
        }
    	
    	return true;
    }
    
    private Bitmap getAlbumArt() {
    	mApp = (Common) mContext.getApplicationContext();
    	
        //Check if the album art has been cached for this song.
        File albumArtFile = new File(mContext.getExternalCacheDir() + "/current_album_art.jpg");
        Bitmap bm = null;
        if (albumArtFile.exists()) {
        	//Decode a subsampled version of the cached album art.
        	bm = mApp.decodeSampledBitmapFromFile(albumArtFile, 150, 150);
        } else {
        	//Decode a subsampled version of the default album art.
            bm = mApp.decodeSampledBitmapFromResource(R.drawable.default_album_art, 150, 150);
        }
        
        return bm;
    }

    @Override
    public void onProgressUpdate(Integer... values) {
    	super.onProgressUpdate(values);
    	switch(values[0]) {
    	case 0:
    		mAppWidgetManager.updateAppWidget(currentAppWidgetId, views);
    		break;
    	}
    	
    }
    
    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
        
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import android.content.Context;
import android.os.AsyncTask;

public class AsyncUpdatePlayCountTask extends AsyncTask<String, Void, Void> {
    private Context mContext;
    
    public AsyncUpdatePlayCountTask(Context context) {
    	mContext = context;
    }
    
    @Override
    protected Void doInBackground(String... params) {
    	/*
    	try {
    		int currentPlayCount = 0;
    		mApp.getService().getCursor().moveToPosition(mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()));
    		if (mApp.getService().getCursor().getString(mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_SOURCE)).equals(DBAccessHelper.GMUSIC)) {
    			
    		} else {
    			//Increment the play counter for the song.
    			try {
    				
    				File file = new File(mApp.getService().getCursor().getString(mApp.getService().getCursor().getColumnIndex(AudioPlaybackService.getSongFilePathColumn())));
    				AudioFile audioFile = null;
    				try {
    					audioFile = AudioFileIO.read(file);
    				} catch (CannotReadException e) {
    					// TODO Auto-generated catch block
    					e.printStackTrace();
    				} catch (IOException e) {
    					// TODO Auto-generated catch block
    					e.printStackTrace();
    				} catch (TagException e) {
    					// TODO Auto-generated catch block
    					e.printStackTrace();
    				} catch (ReadOnlyFileException e) {
    					// TODO Auto-generated catch block
    					e.printStackTrace();
    				} catch (InvalidAudioFrameException e) {
    					// TODO Auto-generated catch block
    					e.printStackTrace();
    				}
    				
    				Tag tag = null;
    				try {
    					tag = audioFile.getTag();
    				} catch (Exception e) {
    					e.printStackTrace();
    				}
    				
    				//Get the current play count for the song.
    				currentPlayCount = 0;
    				try {
    					currentPlayCount = Integer.parseInt(tag.getFirst(FieldKey.CUSTOM1));
    				} catch (Exception e) {
    					currentPlayCount = 0;
    				} finally {
    					
    					currentPlayCount++;
    					try {
    						tag.setField(FieldKey.CUSTOM1, "" + currentPlayCount);
    					} catch (KeyNotFoundException e) {
    						// TODO Auto-generated catch block
    						e.printStackTrace();
    						try {
    							tag.createField(FieldKey.CUSTOM1, "" + currentPlayCount);
    						} catch (Exception e1) {
    							e.printStackTrace();
    						}
    						
    					} catch (FieldDataInvalidException e) {
    						// TODO Auto-generated catch block
    						e.printStackTrace();
    					} catch (Exception e) {
    						//Nothing much we can do about this exception. :/
    					}
    					
    					try {
    						audioFile.commit();
    					} catch (CannotWriteException e) {
    						// TODO Auto-generated catch block
    						e.printStackTrace();
    					}
    					
    				}
    				
    			} catch (Exception e) {
    				e.printStackTrace();
    			}
    			
    		}

    		//Update the last played timestamp in the DB.
    		DBAccessHelper dbHelper = new DBAccessHelper(mContext);
    		dbHelper.updateLastPlayedTimestamp(mApp.getService().getCursor().getString(
    										   mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_FILE_PATH)));
        	
        	//Get the file path and updated play count of the current song.
        	String filePath = params[0];
        	
        	if (filePath!=null) {
        		
            	if (filePath.contains("'")) {
            		filePath = filePath.replace("'", "''");
            	}
            	
            	String where = DBAccessHelper.SONG_FILE_PATH + "=" + "'" + filePath + "'";
            	
            	ContentValues values = new ContentValues();
            	values.put(DBAccessHelper.SONG_PLAY_COUNT, currentPlayCount);
            	
            	dbHelper.getWritableDatabase().update(DBAccessHelper.MUSIC_LIBRARY_TABLE, values, where, null);
            	
        	}
        	
        	dbHelper.close();
        	dbHelper = null;
        	
    	} catch (Exception e) {
    		e.printStackTrace();
    	}
    	*/
    	return null;
    }

    @Override
    protected void onPostExecute(Void arg0) {
    	
        
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.AsyncTasks;

import java.io.File;

import android.annotation.SuppressLint;
import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.os.AsyncTask;
import android.util.Log;
import android.widget.RemoteViews;

import com.jams.music.player.R;
import com.jams.music.player.LauncherActivity.LauncherActivity;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.Utils.Common;

public class AsyncUpdateSmallWidgetTask extends AsyncTask<String, Integer, Boolean> {
    private Context mContext;
    private Common mApp;
    private int mNumWidgets;
    private int mAppWidgetIds[];
    private AppWidgetManager mAppWidgetManager;
    
    private int currentAppWidgetId;
    private RemoteViews views;
    
	public static final String PREVIOUS_ACTION = "com.jams.music.player.PREVIOUS_ACTION";
	public static final String PLAY_PAUSE_ACTION = "com.jams.music.player.PLAY_PAUSE_ACTION";
	public static final String NEXT_ACTION = "com.jams.music.player.NEXT_ACTION";
    
    public AsyncUpdateSmallWidgetTask(Context context, int numWidgets, int appWidgetIds[], AppWidgetManager appWidgetManager) {
    	mContext = context;
    	mApp = (Common) mContext.getApplicationContext();
    	mAppWidgetIds = appWidgetIds;
    	mAppWidgetManager = appWidgetManager;
    	mNumWidgets = numWidgets;
    }
 
    @SuppressLint("NewApi")
	@Override
    protected Boolean doInBackground(String... params) {

    	//Perform this loop procedure for each App Widget that belongs to this mApp
        for (int i=0; i < mNumWidgets; i++) {
            currentAppWidgetId = mAppWidgetIds[i];
            String widgetColor = mApp.getSharedPreferences().getString("" + currentAppWidgetId, "DARK");
            views = new RemoteViews(mContext.getPackageName(), R.layout.small_widget_layout);
            
            if (widgetColor.equals("DARK")) {
            	views.setInt(R.id.small_widget_parent_layout, "setBackgroundResource", R.drawable.appwidget_dark_bg);
            	views.setImageViewResource(R.id.app_widget_small_previous, R.drawable.btn_playback_previous_light);
            	views.setImageViewResource(R.id.app_widget_small_next, R.drawable.btn_playback_next_light);
            } else if (widgetColor.equals("LIGHT")) {
            	views.setInt(R.id.small_widget_parent_layout, "setBackgroundResource", R.drawable.appwidget_bg);
            	views.setImageViewResource(R.id.app_widget_small_previous, R.drawable.btn_playback_previous);
            	views.setImageViewResource(R.id.app_widget_small_next, R.drawable.btn_playback_next);
            }
            
            Intent playPauseIntent = new Intent();
        	playPauseIntent.setAction(PLAY_PAUSE_ACTION);
        	PendingIntent playPausePendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, playPauseIntent, 0);
        	
        	Intent nextIntent = new Intent();
        	nextIntent.setAction(NEXT_ACTION);
        	PendingIntent nextPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, nextIntent, 0);
        	
        	Intent previousIntent = new Intent();
        	previousIntent.setAction(PREVIOUS_ACTION);
        	PendingIntent previousPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, previousIntent, 0);

            //Get the layout of the widget and attach a click listener to each element.
            views.setOnClickPendingIntent(R.id.app_widget_small_play, playPausePendingIntent);
            views.setOnClickPendingIntent(R.id.app_widget_small_previous, previousPendingIntent);
            views.setOnClickPendingIntent(R.id.app_widget_small_next, nextPendingIntent);
            
            //Get the downsampled image of the current song's album art.
            views.setImageViewBitmap(R.id.app_widget_small_image, getAlbumArt());
            
            if (mApp.isServiceRunning()) {
            	
            	final Intent notificationIntent = new Intent(mContext, NowPlayingActivity.class);
                notificationIntent.putExtra("CALLED_FROM_FOOTER", true);
                notificationIntent.putExtra("CALLED_FROM_NOTIF", true);
                
                PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, notificationIntent, 0);
                views.setOnClickPendingIntent(R.id.app_widget_small_image, pendingIntent);
            	
            } else {
            	views.setImageViewResource(R.id.app_widget_small_image, R.drawable.default_album_art);
            	
            	if (widgetColor.equals("DARK")) {
        			views.setImageViewResource(R.id.app_widget_small_play, R.drawable.btn_playback_play_light);
        		} else if (widgetColor.equals("LIGHT")) {
        			views.setImageViewResource(R.id.app_widget_small_play, R.drawable.btn_playback_play);
        		}
            	
            	final Intent intent = new Intent(mContext, LauncherActivity.class);
                PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, intent, 0);
                views.setOnClickPendingIntent(R.id.app_widget_small_image, pendingIntent);
            	
            }
            
            views.setTextViewText(R.id.app_widget_small_line_one, mApp.getService().getCurrentSong().getTitle());
            views.setTextViewText(R.id.app_widget_small_line_two, mApp.getService().getCurrentSong().getAlbum() + 
            													  mApp.getService().getCurrentSong().getArtist());

            if (widgetColor.equals("LIGHT")) {
    			views.setTextColor(R.id.app_widget_small_line_one, Color.BLACK);
    			views.setTextColor(R.id.app_widget_small_line_two, Color.BLACK);
    		}
            
            if (mApp.isServiceRunning()) {
            	
            	try {
            		if (mApp.getService().getCurrentMediaPlayer().isPlaying()) {
                		if (widgetColor.equals("DARK")) {
                			views.setImageViewResource(R.id.app_widget_small_play, R.drawable.btn_playback_pause_light);
                		} else if (widgetColor.equals("LIGHT")) {
                			views.setImageViewResource(R.id.app_widget_small_play, R.drawable.btn_playback_pause);
                		}
                		
                	} else {
                		if (widgetColor.equals("DARK")) {
                			views.setImageViewResource(R.id.app_widget_small_play, R.drawable.btn_playback_play_light);
                		} else if (widgetColor.equals("LIGHT")) {
                			views.setImageViewResource(R.id.app_widget_small_play, R.drawable.btn_playback_play);
                		}
                		
                	}
            	} catch (Exception e) {
            		// TODO Auto-generated method stub
            		e.printStackTrace();
            	}
            	
            }

            //Tell the AppWidgetManager to perform an update on the current app widget\
            try {
            	mAppWidgetManager.updateAppWidget(currentAppWidgetId, views);
            } catch (Exception e) {
            	continue;
            }
            
        }
    	
    	return true;
    }
    
    private Bitmap getAlbumArt() {
    	mApp = (Common) mContext.getApplicationContext();
    	
        //Check if the album art has been cached for this song.
        File albumArtFile = new File(mContext.getExternalCacheDir() + "/current_album_art.jpg");
        Bitmap bm = null;
        if (albumArtFile.exists()) {
        	//Decode a subsampled version of the cached album art.
        	bm = mApp.decodeSampledBitmapFromFile(albumArtFile, 150, 150);
        } else {
        	//Decode a subsampled version of the default album art.
            bm = mApp.decodeSampledBitmapFromResource(R.drawable.default_album_art, 150, 150);
        }
        
        return bm;
    }

    @Override
    public void onProgressUpdate(Integer... values) {
    	super.onProgressUpdate(values);
    	switch(values[0]) {
    	case 0:
    		try {
    			mAppWidgetManager.updateAppWidget(currentAppWidgetId, views);
    		} catch (Exception e) {
    			Log.e("DEBUG", ">>>exception");
    			e.printStackTrace();
    		}

    		break;
    	}
    	
    }
    
    @Override
	protected void onPostExecute(Boolean result) {
		super.onPostExecute(result);
        
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BlacklistManagerActivity;

import java.util.HashMap;

import android.app.ActionBar;
import android.app.ActionBar.Tab;
import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.SharedPreferences;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.text.Spannable;
import android.text.SpannableString;
import android.util.TypedValue;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.MusicLibraryEditorActivity.AlbumsPickerFragment;
import com.jams.music.player.MusicLibraryEditorActivity.ArtistsPickerFragment;
import com.jams.music.player.MusicLibraryEditorActivity.SongsPickerFragment;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.Utils.TypefaceSpan;
import com.nostra13.universalimageloader.core.DisplayImageOptions;
import com.nostra13.universalimageloader.core.assist.ImageScaleType;
import com.nostra13.universalimageloader.core.display.FadeInBitmapDisplayer;

public class BlacklistManagerActivity extends FragmentActivity {

	private Context mContext;
	private Common mApp;
	private Activity mActivity;
	private SharedPreferences sharedPreferences;
	private String libraryName;
	private String libraryIconName;
	public static ActionBar actionBar;
	public static String currentTab = "Artists";
	public static DisplayImageOptions displayImageOptions;
	public static HashMap<String, Boolean> songIdBlacklistStatusPair = new HashMap<String, Boolean>();
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		
		//Initialize Context and SharedPreferences.
		mContext = this;
		mActivity = this;
		mApp = (Common) this.getApplicationContext();
		sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		
    	//Set the UI theme.
    	if (mApp.getCurrentTheme()==Common.DARK_THEME) {
    		setTheme(R.style.AppTheme);
    	} else {
    		setTheme(R.style.AppThemeLight);
    	}
		super.onCreate(savedInstanceState);
		
	    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
	    	getWindow().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));
	    	int topPadding = Common.getStatusBarHeight(mContext);
	    	View activityView = (View) findViewById(android.R.id.content);
	    	
	    	//Calculate ActionBar height
            TypedValue tv = new TypedValue();
            int actionBarHeight = 0;
            if (getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) {
                actionBarHeight = TypedValue.complexToDimensionPixelSize(tv.data,getResources().getDisplayMetrics());
            }
            
            if (activityView!=null) {
            	activityView.setPadding(0, topPadding + actionBarHeight, 0, 0);
            }
            
	    }

		//Retrieve the actionbar.
		actionBar = getActionBar();
		
		//Create a set of options to optimize the bitmap memory usage.
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        options.inJustDecodeBounds = false;
        options.inPurgeable = true;
        
        //Display Image Options.
        int defaultArt = UIElementsHelper.getIcon(mContext, "default_album_art_padded");
        displayImageOptions = new DisplayImageOptions.Builder()
        						  .showImageForEmptyUri(R.drawable.default_album_art)
        						  .showImageOnFail(R.drawable.default_album_art)
        						  .showStubImage(R.drawable.transparent_drawable)
        						  .cacheInMemory(false)
        						  .cacheOnDisc(true)
        						  .decodingOptions(options)
        						  .imageScaleType(ImageScaleType.EXACTLY)
        						  .bitmapConfig(Bitmap.Config.RGB_565)
        						  .displayer(new FadeInBitmapDisplayer(400))
        						  .delayBeforeLoading(100)
        						  .build();
		
		//Retrieve a list of blacklisted songs.
		AsyncGetAllSongIdsBlacklistStatusTask task = new AsyncGetAllSongIdsBlacklistStatusTask();
		task.execute();
			
	}
	
	private class TabListener<T extends android.app.Fragment> implements ActionBar.TabListener {
		private android.app.Fragment mFragment;
		private final Activity mActivity;
		private final String mTag;
		private final Class<T> mClass;

		public TabListener(Activity activity, String tag, Class<T> clz) {
			mActivity = activity;
			mTag = tag;
			mClass = clz;
		}

		@Override
		public void onTabReselected(Tab arg0, android.app.FragmentTransaction arg1) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onTabSelected(Tab tab, android.app.FragmentTransaction ft) {
			
			currentTab = (String) tab.getText();
			//Check if the fragment is already initialized
			if (mFragment==null) {
				//If not, instantiate and add it to the activity
				mFragment = android.app.Fragment.instantiate(mActivity, mClass.getName());
				ft.add(android.R.id.content, mFragment, mTag);
			} else {
				//If it exists, simply attach it in order to show it
				ft.attach(mFragment);
			}
			
		}

		@Override
		public void onTabUnselected(Tab arg0, android.app.FragmentTransaction ft) {
			if (mFragment!=null) {
				ft.detach(mFragment);
			}
			
		}
	
	}
	
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		MenuInflater inflater = getMenuInflater();
	    inflater.inflate(R.menu.blacklist_manager, menu);
	    
	    ActionBar actionBar = getActionBar();
	    actionBar.setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));
		SpannableString s = new SpannableString(getResources().getString(R.string.blacklist_manager));
	    s.setSpan(new TypefaceSpan(this, "RobotoCondensed-Light"), 0, s.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
	    actionBar.setTitle(s);
	    
		return super.onCreateOptionsMenu(menu);
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
	    case R.id.done_blacklist_manager:
	    	AsyncBlacklistSongsTask task = new AsyncBlacklistSongsTask();
	    	task.execute();
	    	return true;
	    default:
	        return super.onOptionsItemSelected(item);
	    }

	}
	
	@Override
	public void onPause() {
		super.onPause();
		songIdBlacklistStatusPair.clear();
		
		if (SongsPickerFragment.cursor!=null) {
			SongsPickerFragment.cursor.close();
			SongsPickerFragment.cursor = null;
		}
		
		if (AlbumsPickerFragment.cursor!=null) {
			AlbumsPickerFragment.cursor.close();
			AlbumsPickerFragment.cursor = null;
		}
		
		if (ArtistsPickerFragment.cursor!=null) {
			ArtistsPickerFragment.cursor.close();
			ArtistsPickerFragment.cursor = null;
		}
		
	}
	
	class AsyncBlacklistSongsTask extends AsyncTask<String, String, String> {
		 
		private ProgressDialog pd;
		
		@Override
		public void onPreExecute() {
			super.onPreExecute();
			
			pd = new ProgressDialog(mContext);
			pd.setTitle(R.string.blacklist_manager);
			pd.setIndeterminate(true);
			pd.setMessage(mContext.getResources().getString(R.string.updating_blacklists));
			pd.setCancelable(false);
			pd.setCanceledOnTouchOutside(false);
			pd.show();
			
		}
		
		@Override
		protected String doInBackground(String... params) {
			mApp.getDBAccessHelper().batchUpdateSongBlacklist(songIdBlacklistStatusPair);
			return null;
		}
		
		@Override
		public void onPostExecute(String result) {
			super.onPostExecute(result);
			
			//Dismiss the progress dialog.
			pd.dismiss();
			mActivity.finish();
			Toast.makeText(mContext, R.string.done_updating_blacklists, Toast.LENGTH_LONG).show();
		}
		
	}
	
	class AsyncGetAllSongIdsBlacklistStatusTask extends AsyncTask<String, String, String> {
		 
		private ProgressDialog pd;
		
		@Override
		public void onPreExecute() {
			super.onPreExecute();
			
			pd = new ProgressDialog(mContext);
			pd.setTitle(R.string.blacklist_manager);
			pd.setIndeterminate(true);
			pd.setMessage(mContext.getResources().getString(R.string.fetching_blacklists));
			pd.setCancelable(false);
			pd.setCanceledOnTouchOutside(false);
			pd.show();
			
		}
		
		@Override
		protected String doInBackground(String... params) {
			songIdBlacklistStatusPair = mApp.getDBAccessHelper().getAllSongIdsBlacklistStatus();
			return null;
		}
		
		@Override
		public void onPostExecute(String result) {
			super.onPostExecute(result);
			
			//Dismiss the progress dialog.
			pd.dismiss();
			
			//Initialize the tabs.
			//Attach tabs to the ActionBar.
			actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);

			//Add the artists tab.
			String artistsLabel = getResources().getString(R.string.artists);
			Tab tab = actionBar.newTab();
			tab.setText(artistsLabel);
			TabListener<BlacklistedArtistsPickerFragment> artistsTabListener = new TabListener<BlacklistedArtistsPickerFragment>(mActivity, 
																						   				   artistsLabel, 
																						   				   BlacklistedArtistsPickerFragment.class);
			
			tab.setTabListener(artistsTabListener);
			actionBar.addTab(tab);

			//Add the albums tab.
			String albumsLabel = getResources().getString(R.string.albums);
			tab = actionBar.newTab();
			tab.setText(albumsLabel);
			TabListener<BlacklistedAlbumsPickerFragment> albumsTabListener = new TabListener<BlacklistedAlbumsPickerFragment>(mActivity,
																						  				albumsLabel, 
																						  				BlacklistedAlbumsPickerFragment.class);
			
			tab.setTabListener(albumsTabListener);
			actionBar.addTab(tab);
			
			//Add the songs tab.
			String songsLabel = getResources().getString(R.string.songs);
			tab = actionBar.newTab();
			tab.setText(songsLabel);
			TabListener<BlacklistedSongsPickerFragment> songsTabListener = new TabListener<BlacklistedSongsPickerFragment>(mActivity,
																									 songsLabel, 
																									 BlacklistedSongsPickerFragment.class);
			
			tab.setTabListener(songsTabListener);
			actionBar.addTab(tab);
			
		}
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BlacklistManagerActivity;

import java.util.ArrayList;

import android.app.AlertDialog;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Utils.Common;
import com.mobeta.android.dslv.DragSortListView;

/*******************************************************
 * Displays a list of blacklisted elements (which are 
 * specified by the user). Removing an element from the 
 * blacklist is as easy as flinging it away in either 
 * direction.
 * 
 * @author Saravan Pantham
 *******************************************************/
public class BlacklistManagerFragment extends Fragment {
	
	private Context mContext;
	private Common mApp;
	
	//Temp array that holds the checkbox statuses in the ListView.
	private static ArrayList<Boolean> checkboxStatuses = new ArrayList<Boolean>();
	private static String MANAGER_TYPE;
	private Cursor cursor;
	private BlacklistedElementsAdapter adapter;
	
	//Temp ArrayLists for the cursor data.
	private ArrayList<String> elementNameList = new ArrayList<String>();
	private ArrayList<String> artistNameList = new ArrayList<String>();
	private ArrayList<String> filePathList = new ArrayList<String>();
	private ArrayList<String> songIdsList = new ArrayList<String>();
	
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    	mApp = (Common) getActivity().getApplicationContext();
        View rootView = (ViewGroup) inflater.inflate(R.layout.fragment_blacklist_manager, container, false);
        mContext = getActivity().getApplicationContext();
        
        ImageView blacklistImage = (ImageView) rootView.findViewById(R.id.blacklist_image);
        blacklistImage.setImageResource(UIElementsHelper.getIcon(mContext, "manage_blacklists"));
    	
        MANAGER_TYPE = getArguments().getString("MANAGER_TYPE");
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        
        //Get a cursor with a list of blacklisted elements.
        if (MANAGER_TYPE.equals("ARTISTS")) {
            builder.setTitle(R.string.blacklisted_artists);
        	cursor = mApp.getDBAccessHelper().getBlacklistedArtists();
        	
            //Finish the activity if there are no blacklisted elements.
            if (cursor.getCount()==0) {
            	Toast.makeText(getActivity(), R.string.no_blacklisted_items_found, Toast.LENGTH_LONG).show();
            	getActivity().finish();
            } else {
                //Load the cursor data into temporary ArrayLists.
            	for (int i=0; i < cursor.getCount(); i++) {
            		cursor.moveToPosition(i);
            		elementNameList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ARTIST)));
            	}
            	
            }

        } else if (MANAGER_TYPE.equals("ALBUMS")) {
            builder.setTitle(R.string.blacklisted_albums);
        	cursor = mApp.getDBAccessHelper().getBlacklistedAlbums();
        	
        	//Finish the activity if there are no blacklisted elements.
            if (cursor.getCount()==0) {
            	Toast.makeText(getActivity(), R.string.no_blacklisted_items_found, Toast.LENGTH_LONG).show();
            	getActivity().finish();
            } else {
                //Load the cursor data into temporary ArrayLists.
            	for (int i=0; i < cursor.getCount(); i++) {
            		cursor.moveToPosition(i);
            		elementNameList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ALBUM)));
            		artistNameList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ARTIST)));
            	}
            	
            }
        	
        } else if (MANAGER_TYPE.equals("SONGS")) {
            builder.setTitle(R.string.blacklisted_songs);
        	cursor = mApp.getDBAccessHelper().getAllBlacklistedSongs();
        	
        	//Finish the activity if there are no blacklisted elements.
            if (cursor.getCount()==0) {
            	Toast.makeText(getActivity(), R.string.no_blacklisted_items_found, Toast.LENGTH_LONG).show();
            	getActivity().finish();
            } else {
                //Load the cursor data into temporary ArrayLists.
            	for (int i=0; i < cursor.getCount(); i++) {
            		cursor.moveToPosition(i);
            		elementNameList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_TITLE)));
            		artistNameList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ARTIST)));
            		filePathList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH)));
            		songIdsList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ID)));
            	}
            	
            }
        	
        } else if (MANAGER_TYPE.equals("PLAYLISTS")) {
            /*builder.setTitle(R.string.blacklisted_playlists);
        	DBAccessHelper playlistsDBHelper = new DBAccessHelper(getActivity());
        	cursor = playlistsDBHelper.getAllBlacklistedPlaylists();
        	
        	//Finish the activity if there are no blacklisted elements.
            if (cursor.getCount()==0) {
            	Toast.makeText(getActivity(), R.string.no_blacklisted_items_found, Toast.LENGTH_LONG).show();
            	getActivity().finish();
            } else {
                //Load the cursor data into temporary ArrayLists.
            	for (int i=0; i < cursor.getCount(); i++) {
            		cursor.moveToPosition(i);
            		elementNameList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.PLAYLIST_NAME)));
            		artistNameList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.NUMBER_OF_SONGS)));
            		filePathList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.PLAYLIST_FILE_PATH)));
            	}
            	
            }*/
        	
        } else {
        	Toast.makeText(getActivity(), R.string.error_occurred, Toast.LENGTH_LONG).show();
        	getActivity().finish();
        }
        
        
        TextView blacklistManagerInfoText = (TextView) rootView.findViewById(R.id.blacklist_manager_info_text);
        DragSortListView blacklistManagerListView = (DragSortListView) rootView.findViewById(R.id.blacklist_manager_list);
        blacklistManagerListView.setRemoveListener(onRemove);
        
        blacklistManagerInfoText.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
        blacklistManagerInfoText.setPaintFlags(blacklistManagerInfoText.getPaintFlags()
        									   | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        blacklistManagerListView.setFastScrollEnabled(true);
        adapter = new BlacklistedElementsAdapter(getActivity(), elementNameList, artistNameList, MANAGER_TYPE);
        blacklistManagerListView.setAdapter(adapter);
        
        return rootView;
        
    }
    
    private DragSortListView.RemoveListener onRemove = new DragSortListView.RemoveListener() {
    	
        @Override
        public void remove(int which) {
        	
        	//Before we remove the item, retrieve its parameters so we can form a where clause.
        	String element = elementNameList.get(which);
        	
        	String artist = "";
        	if (artistNameList.size()!=0) {
            	artist = artistNameList.get(which);
        	}
        	
        	String filePath = "";
        	if (filePathList.size()!=0) {
            	filePath = filePathList.get(which);
        	}
        	
        	//Escape any rogue apostrophes.
        	if (element.contains("'")) {
        		element = element.replace("'", "''");
        	}
        	
        	if (artist.contains("'")) {
        		artist = artist.replace("'", "''");
        	}
        	
        	if (filePath.contains("'")) {
        		filePath = filePath.replace("'", "''");
        	}
        	
            adapter.remove(adapter.getItem(which));
            
            //Remove the elements in the actual ArrayLists.
            artistNameList.remove(which);
            
            //Unblacklist the element based on the MANAGER_TYPE.
            String where = "";
            if (MANAGER_TYPE.equals("ARTISTS")) {
            	where = DBAccessHelper.SONG_ARTIST + "=" + "'" + element + "'";
            	mApp.getDBAccessHelper().setBlacklistForArtist(element, false);
            	
            } else if (MANAGER_TYPE.equals("ALBUMS")) {
            	where = DBAccessHelper.SONG_ARTIST + "=" + "'" + element + "'";
            	mApp.getDBAccessHelper().setBlacklistForAlbum(element, artist, false);
            	
            } else if (MANAGER_TYPE.equals("SONGS")) {
            	where = DBAccessHelper.SONG_ARTIST + "=" + "'" + element + "'";
            	mApp.getDBAccessHelper().setBlacklistForSong(songIdsList.get(which), false);
            	
            } else if (MANAGER_TYPE.equals("PLAYLISTS")) {
/*            	DBAccessHelper playlistsDBHelper = new DBAccessHelper(mContext);
            	where = DBAccessHelper.SONG_ARTIST + "=" + "'" + element + "'";
            	playlistsDBHelper.unBlacklistPlaylist(filePath);
            	playlistsDBHelper.close();*/
            	
            }
            
            Toast.makeText(mContext, R.string.item_removed_from_blacklist, Toast.LENGTH_LONG).show();
            
        }
        
    };
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BlacklistManagerActivity;

import android.content.Context;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.AsyncTask;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class BlacklistedAlbumsMultiselectAdapter extends SimpleCursorAdapter {
	
	private Context mContext;
	private static Common mApp;
	
    public BlacklistedAlbumsMultiselectAdapter(Context context, Cursor cursor) {
        super(context, -1, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        mApp = (Common) mContext.getApplicationContext();
    }

    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        final Cursor c = (Cursor) getItem(position);
	    SongsListViewHolder holder = null;

		if (convertView == null) {
			
			convertView = LayoutInflater.from(mContext).inflate(R.layout.music_library_editor_albums_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.image = (ImageView) convertView.findViewById(R.id.albumThumbnailMusicLibraryEditor);
			holder.title = (TextView) convertView.findViewById(R.id.albumNameMusicLibraryEditor);
			holder.checkBox = (CheckBox) convertView.findViewById(R.id.albumCheckboxMusicLibraryEditor);
			holder.subText = (TextView) convertView.findViewById(R.id.albumArtistNameMusicLibraryEditor);

			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}
		
		final View finalConvertView = convertView;
		final String songId = c.getString(c.getColumnIndex(DBAccessHelper._ID));
		final String songArtist = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ARTIST));
		final String songAlbum = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM));
		final String songAlbumArtPath = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH));
		final String songBlacklistStatus = c.getString(c.getColumnIndex(DBAccessHelper.BLACKLIST_STATUS));
		
		//Set the album's name and artist as the row's tag.
		convertView.setTag(R.string.album, songAlbum);
		convertView.setTag(R.string.artist, songArtist);
		
		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.title.setPaintFlags(holder.title.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		holder.subText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.subText.setPaintFlags(holder.subText.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		//Set the song title.
		holder.title.setText(songAlbum);
		holder.subText.setText(songArtist);
        mApp.getImageLoader().displayImage(songAlbumArtPath, holder.image, BlacklistManagerActivity.displayImageOptions);

        //Check if the song's DB ID exists in the HashSet and set the appropriate checkbox status.
        if (BlacklistManagerActivity.songIdBlacklistStatusPair.get(songId).equals("TRUE")) {
        	holder.checkBox.setChecked(true);
        	convertView.setBackgroundColor(0xCCFF4444);
        } else {
        	convertView.setBackgroundColor(0x00000000);
        	holder.checkBox.setChecked(false);
        }
        
        holder.checkBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean isChecked) {
				
				if (isChecked==true) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0xCCFF4444);
						AsyncBlacklistAlbumTask task = new AsyncBlacklistAlbumTask(songAlbum, songArtist);
						task.execute(new String[] {"ADD"});
					}
					
				} else if (isChecked==false) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0x00000000);
						AsyncBlacklistAlbumTask task = new AsyncBlacklistAlbumTask(songAlbum, songArtist);
						task.execute(new String[] {"REMOVE"});
						
					}

				}
				
			}
			
        });
 
		return convertView;
	}
    
	static class SongsListViewHolder {
	    public ImageView image;
	    public TextView title;
	    public TextView subText;
	    public CheckBox checkBox;
	}
	
	/***************************************************************
	 * This AsyncTask goes through a specified album and retrieves 
	 * every song in the album and its ID. It then inserts the ID(s) 
	 * into a HashSet.
	 ***************************************************************/
	static class AsyncBlacklistAlbumTask extends AsyncTask<String, String, String> {

		private String mAlbumName;
		private String mArtistName;
		
		public AsyncBlacklistAlbumTask(String albumName, String artistName) {
			mAlbumName = albumName;
			mArtistName = artistName;
		}
		
		@Override
		protected String doInBackground(String... params) {
			//Check if the user is adding or removing an album from the list.
			String operation = params[0];
			if (operation.equals("ADD")) {
				
				//Get a list of all songs in the album.
				Cursor cursor = mApp.getDBAccessHelper().getAllSongsInAlbum(mAlbumName, mArtistName);
				if (cursor.getCount() > 0) {
					for (int i=0; i < cursor.getCount(); i++) {
						cursor.moveToPosition(i);
						String songId = cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID));
						
						//Update the HashMap.
						BlacklistManagerActivity.songIdBlacklistStatusPair.remove(songId);
						BlacklistManagerActivity.songIdBlacklistStatusPair.put(songId, true);
						
					}
					
				}
				
				if (cursor!=null) {
					cursor.close();
					cursor = null;
				}
				
			} else {
				//Get a list of all songs in the album.
				Cursor cursor = mApp.getDBAccessHelper().getAllSongsInAlbum(mAlbumName, mArtistName);
				if (cursor.getCount() > 0) {
					for (int i=0; i < cursor.getCount(); i++) {
						cursor.moveToPosition(i);
						String songId = cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID));
						
						//Update the HashMap.
						BlacklistManagerActivity.songIdBlacklistStatusPair.remove(songId);
						BlacklistManagerActivity.songIdBlacklistStatusPair.put(songId, false);
						
					}
					
				}
				
				if (cursor!=null) {
					cursor.close();
					cursor = null;
				}
				
			}

			return null;
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BlacklistManagerActivity;

import android.annotation.SuppressLint;
import android.app.Fragment;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Build;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.ListView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.BlacklistManagerActivity.BlacklistedAlbumsMultiselectAdapter.AsyncBlacklistAlbumTask;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Utils.Common;

public class BlacklistedAlbumsPickerFragment extends Fragment {
	
	private Common mApp;
	public static Cursor cursor;
	public static ListView listView;
	
	@SuppressLint("NewApi")
	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		View rootView = inflater.inflate(R.layout.fragment_albums_music_library_editor, null);
		mApp = (Common) getActivity().getApplicationContext();

		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
			rootView.setBackground(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		} else {
			rootView.setBackgroundDrawable(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		}
		
		cursor = mApp.getDBAccessHelper().getAllUniqueAlbumsNoBlacklist("");
		listView = (ListView) rootView.findViewById(R.id.musicLibraryEditorAlbumsListView);
		listView.setFastScrollEnabled(true);
		listView.setAdapter(new BlacklistedAlbumsMultiselectAdapter(getActivity(), cursor));
		
		listView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> arg0, View view, int which, long dbID) {
				CheckBox checkbox = (CheckBox) view.findViewById(R.id.albumCheckboxMusicLibraryEditor);
				checkbox.performClick();
				
				/* Since we've performed a software-click (checkbox.performClick()), all we have 
				 * to do now is determine the *new* state of the checkbox. If the checkbox is checked, 
				 * that means that the user tapped on it when it was unchecked, and we should add 
				 * the album's songs to the HashSet. If the checkbox is unchecked, that means the user 
				 * tapped on it when it was checked, so we should remove the album's songs from the 
				 * HashSet.
				 */
				if (checkbox.isChecked()) {
					view.setBackgroundColor(0xCCFF4444);
					AsyncBlacklistAlbumTask task = new AsyncBlacklistAlbumTask((String) view.getTag(R.string.album),
																		 (String) view.getTag(R.string.artist));
					task.execute(new String[] {"ADD"});
				} else {
					view.setBackgroundColor(0x00000000);
					AsyncBlacklistAlbumTask task = new AsyncBlacklistAlbumTask((String) view.getTag(R.string.album),
																		 (String) view.getTag(R.string.artist));
					task.execute(new String[] {"REMOVE"});
				}
				
			}
			
		});
		
		TextView instructions = (TextView) rootView.findViewById(R.id.albums_music_library_editor_instructions);
		instructions.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		instructions.setPaintFlags(instructions.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		instructions.setText(R.string.blacklist_manager_albums_instructions);
		
		//KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
        	
            //Calculate navigation bar height.
            int navigationBarHeight = 0;
            int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
            if (resourceId > 0) {
                navigationBarHeight = getResources().getDimensionPixelSize(resourceId);
            }
            
            listView.setClipToPadding(false);
            listView.setPadding(0, 0, 0, navigationBarHeight);
        }
		
		return rootView;
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BlacklistManagerActivity;

import android.content.Context;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.AsyncTask;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class BlacklistedArtistsMultiselectAdapter extends SimpleCursorAdapter {
	
	private Context mContext;
	private static Common mApp;
	
    public BlacklistedArtistsMultiselectAdapter(Context context, Cursor cursor) {
        super(context, -1, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        mApp = (Common) mContext.getApplicationContext();
    }

    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        final Cursor c = (Cursor) getItem(position);
	    SongsListViewHolder holder = null;

		if (convertView == null) {
			
			convertView = LayoutInflater.from(mContext).inflate(R.layout.music_library_editor_artists_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.image = (ImageView) convertView.findViewById(R.id.artistThumbnailMusicLibraryEditor);
			holder.title = (TextView) convertView.findViewById(R.id.artistNameMusicLibraryEditor);
			holder.checkBox = (CheckBox) convertView.findViewById(R.id.artistCheckboxMusicLibraryEditor);

			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}
		
		final View finalConvertView = convertView;
		final String songId = c.getString(c.getColumnIndex(DBAccessHelper._ID));
		final String songArtist = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ARTIST));
		final String songBlacklistStatus = c.getString(c.getColumnIndex(DBAccessHelper.BLACKLIST_STATUS));
		String songAlbumArtPath = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH));
		
		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.title.setPaintFlags(holder.title.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		//Set the song title.
		holder.title.setText(songArtist);
        mApp.getImageLoader().displayImage(songAlbumArtPath, holder.image, BlacklistManagerActivity.displayImageOptions);

        //Check if the song's DB ID exists in the HashSet and set the appropriate checkbox status.
        try {
            if (BlacklistManagerActivity.songIdBlacklistStatusPair.get(songId).equals("TRUE")) {
            	holder.checkBox.setChecked(true);
            	convertView.setBackgroundColor(0xCCFF4444);
            } else {
            	holder.checkBox.setChecked(false);
            	convertView.setBackgroundColor(0x00000000);
            }
            
        } catch (Exception e) {
        	e.printStackTrace();
        }
        
        //Set a tag to the row that will attach the artist's name to it.
        convertView.setTag(R.string.artist, songArtist);
        
        holder.checkBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean isChecked) {
				
				if (isChecked==true) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0xCCFF4444);
						AsyncBlacklistArtistTask task = new AsyncBlacklistArtistTask(songArtist);
						task.execute(new String[] {"ADD"});
					}
					
				} else if (isChecked==false) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0x00000000);
						AsyncBlacklistArtistTask task = new AsyncBlacklistArtistTask(songArtist);
						task.execute(new String[] {"REMOVE"});
						
					}

				}
				
			}
			
        });
 
		return convertView;
	}
    
	static class SongsListViewHolder {
	    public ImageView image;
	    public TextView title;
	    public CheckBox checkBox;
	}
	
	/***************************************************************
	 * This AsyncTask goes through a specified artist and retrieves 
	 * every song by the artist and its ID. It then inserts the ID(s) 
	 * into a HashSet.
	 ***************************************************************/
	static class AsyncBlacklistArtistTask extends AsyncTask<String, String, String> {

		private String mArtistName;
		
		public AsyncBlacklistArtistTask(String artistName) {
			mArtistName = artistName;
		}
		
		@Override
		protected String doInBackground(String... params) {
			//Check if the user is adding or removing an artist from the blacklist.
			String operation = params[0];
			if (operation.equals("ADD")) {
				
				//Get a list of all songs in the album.
				Cursor cursor = mApp.getDBAccessHelper().getAllSongsByArtist(mArtistName);
				if (cursor.getCount() > 0) {
					for (int i=0; i < cursor.getCount(); i++) {
						cursor.moveToPosition(i);
						String songId = cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID));
						
						//Update the HashMap.
						BlacklistManagerActivity.songIdBlacklistStatusPair.remove(songId);
						BlacklistManagerActivity.songIdBlacklistStatusPair.put(songId, true);
						
					}
					
				}
				
				if (cursor!=null) {
					cursor.close();
					cursor = null;
				}
				
			} else {
				//Get a list of all songs in the album.
				Cursor cursor = mApp.getDBAccessHelper().getAllSongsByArtist(mArtistName);
				if (cursor.getCount() > 0) {
					for (int i=0; i < cursor.getCount(); i++) {
						cursor.moveToPosition(i);
						String songId = cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID));
						
						//Update the HashMap.
						BlacklistManagerActivity.songIdBlacklistStatusPair.remove(songId);
						BlacklistManagerActivity.songIdBlacklistStatusPair.put(songId, false);
						
					}
					
				}
				
				if (cursor!=null) {
					cursor.close();
					cursor = null;
				}
				
			}
			
			return null;
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BlacklistManagerActivity;

import android.annotation.SuppressLint;
import android.app.Fragment;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Build;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.ListView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.BlacklistManagerActivity.BlacklistedArtistsMultiselectAdapter.AsyncBlacklistArtistTask;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Utils.Common;

public class BlacklistedArtistsPickerFragment extends Fragment {
	
	private Common mApp;
	public static Cursor cursor;
	public static ListView listView;
	private TextView instructions;
	
	@SuppressLint("NewApi")
	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		mApp = (Common) getActivity().getApplicationContext();
		View rootView = inflater.inflate(R.layout.fragment_artists_music_library_editor, null);

		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
			rootView.setBackground(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		} else {
			rootView.setBackgroundDrawable(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		}
		
		cursor = mApp.getDBAccessHelper().getAllUniqueArtistsNoBlacklist("");
		listView = (ListView) rootView.findViewById(R.id.musicLibraryEditorArtistsListView);
		listView.setFastScrollEnabled(true);
		listView.setAdapter(new BlacklistedArtistsMultiselectAdapter(getActivity(), cursor));
		
		listView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> arg0, View view, int which, long dbID) {
				CheckBox checkbox = (CheckBox) view.findViewById(R.id.artistCheckboxMusicLibraryEditor);
				checkbox.performClick();
				
				/* Since we've performed a software-click (checkbox.performClick()), all we have 
				 * to do now is determine the *new* state of the checkbox. If the checkbox is checked, 
				 * that means that the user tapped on it when it was unchecked, and we should add 
				 * the artist's songs to the HashSet. If the checkbox is unchecked, that means the user 
				 * tapped on it when it was checked, so we should remove the artist's songs from the 
				 * HashSet.
				 */
				if (checkbox.isChecked()) {
					view.setBackgroundColor(0xCCFF4444);
					AsyncBlacklistArtistTask task = new AsyncBlacklistArtistTask((String) view.getTag(R.string.artist));
					task.execute(new String[] {"ADD"});
				} else {
					view.setBackgroundColor(0x00000000);
					AsyncBlacklistArtistTask task = new AsyncBlacklistArtistTask((String) view.getTag(R.string.artist));
					task.execute(new String[] {"REMOVE"});
				}
				
			}
			
		});
		
		instructions = (TextView) rootView.findViewById(R.id.artists_music_library_editor_instructions);
		instructions.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		instructions.setPaintFlags(instructions.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		instructions.setText(R.string.blacklist_manager_artists_instructions);
		
		//KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
        	
            //Calculate navigation bar height.
            int navigationBarHeight = 0;
            int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
            if (resourceId > 0) {
                navigationBarHeight = getResources().getDimensionPixelSize(resourceId);
            }
            
            listView.setClipToPadding(false);
            listView.setPadding(0, 0, 0, navigationBarHeight);
        }
        
		return rootView;
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BlacklistManagerActivity;

import java.util.ArrayList;

import android.content.Context;
import android.graphics.Paint;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;

//Adapter subclass for the Blacklists ListView.
public class BlacklistedElementsAdapter extends ArrayAdapter<String> {
	
	private Context mContext;
	private String elementName = "";
	private String artistName = "";
	private String MANAGER_TYPE = "";
	
	private ArrayList<String> mElementsList = new ArrayList<String>();
	private ArrayList<String> mArtistsList = new ArrayList<String>();
	
    public BlacklistedElementsAdapter(Context context, 
    								  ArrayList<String> elementsList, 
    								  ArrayList<String> artistsList,
    								  String MANAGER_TYPE) {
    	super(context, R.id.customize_screens_title, elementsList);
    	
    	mContext = context;
    	mElementsList = elementsList;
    	mArtistsList = artistsList;
        this.MANAGER_TYPE = MANAGER_TYPE;
        
    }

    @Override
	public View getView(final int position, View convertView, ViewGroup parent) {
	    BlacklistManagerHolder holder = null;

		if (convertView == null) {
			convertView = LayoutInflater.from(mContext).inflate(R.layout.blacklist_manager_list_layout, parent, false);

			holder = new BlacklistManagerHolder();
			holder.blacklistedElementName = (TextView) convertView.findViewById(R.id.blacklist_manager_element_name);
			holder.blacklistedArtistName = (TextView) convertView.findViewById(R.id.blacklist_manager_artist);

			convertView.setTag(holder);
		} else {
		    holder = (BlacklistManagerHolder) convertView.getTag();
		}
		
		//Retrieve the UI element values based on the manager type.
		if (MANAGER_TYPE.equals("ARTISTS")) {
			elementName = mElementsList.get(position);
		} else {
			elementName = mElementsList.get(position);
			artistName = mArtistsList.get(position);
		}

		//Set the element name.
		holder.blacklistedElementName.setText(elementName);

		holder.blacklistedElementName.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.blacklistedElementName.setPaintFlags(holder.blacklistedElementName.getPaintFlags() | 
												    Paint.SUBPIXEL_TEXT_FLAG | 
												    Paint.ANTI_ALIAS_FLAG);
		
		//Hide the artist textview if we're not dealing with blacklisted albums, songs, or playlists.
        if (MANAGER_TYPE.equals("ARTIST")) {
        	holder.blacklistedArtistName.setVisibility(View.GONE);
        } else {
        	
			holder.blacklistedArtistName.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
			holder.blacklistedArtistName.setPaintFlags(holder.blacklistedArtistName.getPaintFlags() | 
													    Paint.SUBPIXEL_TEXT_FLAG | 
													    Paint.ANTI_ALIAS_FLAG);
			
			holder.blacklistedArtistName.setText(artistName);
			
        }
		
		return convertView;
	}
    
    static class BlacklistManagerHolder {
        public TextView blacklistedElementName;
        public TextView blacklistedArtistName;
        
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BlacklistManagerActivity;

import android.content.Context;
import android.database.Cursor;
import android.graphics.Paint;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class BlacklistedSongsMultiselectAdapter extends SimpleCursorAdapter {
	
	private Context mContext;
	private Common mApp;
	
    public BlacklistedSongsMultiselectAdapter(Context context, Cursor cursor) {
        super(context, -1, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        mApp = (Common) mContext.getApplicationContext();
    }

    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        final Cursor c = (Cursor) getItem(position);
	    SongsListViewHolder holder = null;

		if (convertView == null) {
			
			convertView = LayoutInflater.from(mContext).inflate(R.layout.music_library_editor_songs_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.image = (ImageView) convertView.findViewById(R.id.songThumbnailMusicLibraryEditor);
			holder.title = (TextView) convertView.findViewById(R.id.songNameMusicLibraryEditor);
			holder.checkBox = (CheckBox) convertView.findViewById(R.id.songCheckboxMusicLibraryEditor);
			holder.subText = (TextView) convertView.findViewById(R.id.artistNameSongListView);

			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}
		
		final View finalConvertView = convertView;
		final String songId = c.getString(c.getColumnIndex(DBAccessHelper._ID));
		final String songTitle = c.getString(c.getColumnIndex(DBAccessHelper.SONG_TITLE));
		final String songFilePath = c.getString(c.getColumnIndex(DBAccessHelper.SONG_FILE_PATH));
		String songAlbumArtPath = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH));
		String songArtist = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ARTIST));
		String songBlacklistStatus = c.getString(c.getColumnIndex(DBAccessHelper.BLACKLIST_STATUS));
		
		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.title.setPaintFlags(holder.title.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		holder.subText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.subText.setPaintFlags(holder.subText.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		//Set the songID as the view's tag.
		convertView.setTag(R.string.song_id, songId);
		convertView.setTag(R.string.song_file_path, songFilePath);
		
		//Set the song title.
		holder.title.setText(songTitle);
		holder.subText.setText(songArtist);
        mApp.getImageLoader().displayImage(songAlbumArtPath, holder.image, BlacklistManagerActivity.displayImageOptions);

        //Check if the song's DB ID exists in the HashSet and set the appropriate checkbox status.
        if (BlacklistManagerActivity.songIdBlacklistStatusPair.get(songId).equals("TRUE")) {
        	convertView.setBackgroundColor(0xCCFF4444);
        	holder.checkBox.setChecked(true);
        } else {
        	convertView.setBackgroundColor(0x00000000);
        	holder.checkBox.setChecked(false);
        }
        
        holder.checkBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean isChecked) {
				
				if (isChecked==true) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0xCCFF4444);
						BlacklistManagerActivity.songIdBlacklistStatusPair.put(songId, true);
					}
					
				} else if (isChecked==false) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0x000000);
						BlacklistManagerActivity.songIdBlacklistStatusPair.put(songId, false);
					}

				}

			}
			
        });
 
		return convertView;
	}
    
	static class SongsListViewHolder {
	    public ImageView image;
	    public TextView title;
	    public TextView subText;
	    public CheckBox checkBox;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BlacklistManagerActivity;

import android.annotation.SuppressLint;
import android.app.Fragment;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Build;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.ListView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Utils.Common;

public class BlacklistedSongsPickerFragment extends Fragment {
	
	private static Common mApp;
	public static Cursor cursor;
	public static ListView listView;
	
	@SuppressLint("NewApi")
	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		mApp = (Common) getActivity().getApplicationContext();
		View rootView = inflater.inflate(R.layout.fragment_songs_music_library_editor, null);
		cursor = mApp.getDBAccessHelper().getAllSongsNoBlacklist();
		
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
			rootView.setBackground(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		} else {
			rootView.setBackgroundDrawable(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		}
		
		listView = (ListView) rootView.findViewById(R.id.musicLibraryEditorSongsListView);
		listView.setFastScrollEnabled(true);
		listView.setAdapter(new BlacklistedSongsMultiselectAdapter(getActivity(), cursor));

		listView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> arg0, View view, int which, long dbID) {
				CheckBox checkbox = (CheckBox) view.findViewById(R.id.songCheckboxMusicLibraryEditor);
				checkbox.performClick();
				
				/* Since we've performed a software-click (checkbox.performClick()), all we have 
				 * to do now is determine the *new* state of the checkbox. If the checkbox is checked, 
				 * that means that the user tapped on it when it was unchecked, and we should add 
				 * the song to the HashSet. If the checkbox is unchecked, that means the user 
				 * tapped on it when it was checked, so we should remove the song from the 
				 * HashSet.
				 */
				if (checkbox.isChecked()) {
					view.setBackgroundColor(0xCCFF4444);
					BlacklistManagerActivity.songIdBlacklistStatusPair.put((String) view.getTag(R.string.song_id), true);
				} else {
					view.setBackgroundColor(0x00000000);
					BlacklistManagerActivity.songIdBlacklistStatusPair.put((String) view.getTag(R.string.song_id), false);
				}
				
			}
			
		});
		
		TextView instructions = (TextView) rootView.findViewById(R.id.songs_music_library_editor_instructions);
		instructions.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		instructions.setPaintFlags(instructions.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		instructions.setText(R.string.blacklist_manager_songs_instructions);
		
		//KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
        	
            //Calculate navigation bar height.
            int navigationBarHeight = 0;
            int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
            if (resourceId > 0) {
                navigationBarHeight = getResources().getDimensionPixelSize(resourceId);
            }
            
            listView.setClipToPadding(false);
            listView.setPadding(0, 0, 0, navigationBarHeight);
        }
		
		return rootView;
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BroadcastReceivers;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.jams.music.player.Utils.Common;

/**
 * BroadcastReceiver that skips to the specified track.
 * 
 * @author Saravan Pantham
 */
public class ChangeTrackBroadcastReceiver extends BroadcastReceiver {
	
	private Common mApp;
	
	@Override
	public void onReceive(Context context, Intent intent) {
		
		mApp = (Common) context.getApplicationContext();
		
		//Retrieve the new song's index.
		int index = intent.getIntExtra("INDEX", 0);
		
		if (mApp.isServiceRunning())
			mApp.getService().skipToTrack(index);

	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BroadcastReceivers;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.view.KeyEvent;

import com.jams.music.player.Services.AudioPlaybackService;
import com.jams.music.player.Utils.Common;

/**
 * BroadcastReceiver that handles and processes all headset 
 * button clicks/events.
 * 
 * @author Saravan Pantham
 */
public class HeadsetButtonsReceiver extends BroadcastReceiver {
	
	private Common mApp;
	
    public HeadsetButtonsReceiver() {
        super();
    }

    @Override
    public void onReceive(Context context, Intent intent) {
    			
    	mApp = (Common) context.getApplicationContext();
    	
    	//There's no point in going any further if the service isn't running.
    	if (mApp.isServiceRunning()) {
    			
			//Aaaaand there's no point in continuing if the intent doesn't contain info about headset control inputs.
			String intentAction = intent.getAction();
			if (!Intent.ACTION_MEDIA_BUTTON.equals(intentAction)) {
				return;
			}
			
			KeyEvent event = (KeyEvent) intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
			int keycode = event.getKeyCode();
			int action = event.getAction();
			
			//Switch through each event and perform the appropriate action based on the intent that's ben
			if (keycode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE || keycode == KeyEvent.KEYCODE_HEADSETHOOK) {
				
				if (action == KeyEvent.ACTION_DOWN) {
					//Toggle play/pause.
					Intent playPauseIntent = new Intent();
					playPauseIntent.setAction(AudioPlaybackService.PLAY_PAUSE_ACTION);
					context.sendBroadcast(playPauseIntent);
					
				}
				
			}
			
			if (keycode == KeyEvent.KEYCODE_MEDIA_NEXT) {
				
				if (action == KeyEvent.ACTION_DOWN) {
					//Fire a broadcast that skips to the next track.
					Intent nextIntent = new Intent();
					nextIntent.setAction("com.jams.music.player.NEXT_ACTION");
					context.sendBroadcast(nextIntent);
					
				}
				
			}
			
			if (keycode == KeyEvent.KEYCODE_MEDIA_PREVIOUS) {
				
				if (action == KeyEvent.ACTION_DOWN) {
					//Fire a broadcast that goes back to the previous track.
					Intent previousIntent = new Intent();
					previousIntent.setAction("com.jams.music.player.PREVIOUS_ACTION");
					context.sendBroadcast(previousIntent);
					
				}
				
			}
	        
    	}
    	
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BroadcastReceivers;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.jams.music.player.Utils.Common;

/**
 * BroadcastReceiver that handles and processes all headset 
 * unplug/plug actions and events.
 * 
 * @author Saravan Pantham
 */
public class HeadsetPlugBroadcastReceiver extends BroadcastReceiver {

	private Common mApp;
	
	@Override
	public void onReceive(Context context, Intent intent) {
		
		mApp = (Common) context.getApplicationContext();

 	    if (intent.getAction().equals(Intent.ACTION_HEADSET_PLUG)) {
	        int state = intent.getIntExtra("state", -1);
	        switch (state) {
	        case 0:
	            //Headset unplug event.
	        	mApp.getService().pausePlayback();
	            break;
	        case 1:
	            //Headset plug-in event.
	        	mApp.getService().startPlayback();
	            break;
	        default:
	            //No idea what just happened.
	        }

		}
	    
	}
	  
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BroadcastReceivers;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.Utils.Common;

public class LaunchNowPlayingReceiver extends BroadcastReceiver {
	
	private Common mApp;
	
	@Override
	public void onReceive(Context context, Intent intent) {
		mApp = (Common) context.getApplicationContext();

		if (mApp.isServiceRunning()) {
            Intent activityIntent = new Intent(context, NowPlayingActivity.class);
            activityIntent.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT | Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(activityIntent);

        }

	}
	  
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BroadcastReceivers;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.jams.music.player.Utils.Common;

public class NextBroadcastReceiver extends BroadcastReceiver {
	
	private Common mApp;
	
	@Override
	public void onReceive(Context context, Intent intent) {
		mApp = (Common) context.getApplicationContext();
		
		if (mApp.isServiceRunning())
			mApp.getService().skipToNextTrack();

	}
	  
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BroadcastReceivers;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.jams.music.player.Utils.Common;

public class PlayPauseBroadcastReceiver extends BroadcastReceiver {

	private Common mApp;
	
	@Override
	public void onReceive(Context context, Intent intent) {
		mApp = (Common) context.getApplicationContext();
		
		if (mApp.isServiceRunning())
			mApp.getService().togglePlaybackState();
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BroadcastReceivers;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.jams.music.player.Utils.Common;

public class PreviousBroadcastReceiver extends BroadcastReceiver {

	private Common mApp;
	
	@Override
	public void onReceive(Context context, Intent intent) {
		mApp = (Common) context.getApplicationContext();
		
		if (mApp.isServiceRunning())
			mApp.getService().skipToPreviousTrack();
		
	}
	  
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BroadcastReceivers;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.jams.music.player.Utils.Common;

public class StopServiceBroadcastReceiver extends BroadcastReceiver {
	
	@Override
	public void onReceive(Context context, Intent intent) {
		
		//Stop the service.
		Common app = (Common) context.getApplicationContext();
		app.getService().stopSelf();
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BrowserSubGridActivity;

import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.support.v4.app.FragmentActivity;
import android.support.v4.widget.DrawerLayout;
import android.util.Log;
import android.view.View;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.DecelerateInterpolator;
import android.widget.AbsListView;
import android.widget.AdapterView;
import android.widget.GridView;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.jams.music.player.Animations.TranslateAnimation;
import com.jams.music.player.BrowserSubListActivity.BrowserSubListActivity;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Drawers.NavigationDrawerFragment;
import com.jams.music.player.Drawers.QueueDrawerFragment;
import com.jams.music.player.Helpers.PauseOnScrollHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;
import com.nhaarman.listviewanimations.swinginadapters.prepared.SwingBottomInAnimationAdapter;

import java.util.HashMap;

public class BrowserSubGridActivity extends FragmentActivity {

    //Context and common objects.
    private Context mContext;
    private Common mApp;
    private Handler mHandler;
    private QueueDrawerFragment mQueueDrawerFragment;

    //UI elements
    private ImageView mHeaderImage;
    private GridView mGridView;
    private RelativeLayout mDrawerParentLayout;
    private RelativeLayout mHeaderLayout;
    private TextView mHeaderTextView;
    private TextView mHeaderSubTextView;
    private TextView mPlayAllText;
    private DrawerLayout mDrawerLayout;
    private RelativeLayout mNavDrawerLayout;
    private RelativeLayout mCurrentQueueDrawerLayout;

    //Data adapter objects/vars.
    private HashMap<Integer, String> mDBColumnsMap;
    private BrowserSubGridAdapter mGridViewAdapter;
    private Cursor mCursor;
    private String mQuerySelection;

    //Arguments passed in from the calling activity.
    private String mHeaderImagePath;
    private String mHeaderText;
    private String mHeaderSubText;
    private int mFragmentId;

    @Override
    protected void onCreate(Bundle savedInstanceState) {

        mContext = getApplicationContext();
        mApp = (Common) mContext;
        mHandler = new Handler();
        mDBColumnsMap = new HashMap<Integer, String>();

        //Set the theme and inflate the layout.
        setTheme();
        overridePendingTransition(R.anim.fade_in, R.anim.fade_out);
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_browser_sub_grid);

        mHeaderImagePath = getIntent().getExtras().getString("headerImagePath");
        mFragmentId = getIntent().getExtras().getInt("fragmentId");
        mHeaderText = getIntent().getExtras().getString("headerText");
        mHeaderSubText = getIntent().getExtras().getString("subText");

        if (mHeaderText==null || mHeaderText.isEmpty())
            mHeaderText = mContext.getResources().getString(R.string.unknown_genre);

        mHeaderLayout = (RelativeLayout) findViewById(R.id.browser_sub_header_layout);
        mHeaderImage = (ImageView) findViewById(R.id.browser_sub_header_image);
        mHeaderTextView = (TextView) findViewById(R.id.browser_sub_header_text);
        mHeaderSubTextView = (TextView) findViewById(R.id.browser_sub_header_sub_text);
        mGridView = (GridView) findViewById(R.id.browser_sub_grid_view);
        mDrawerParentLayout = (RelativeLayout) findViewById(R.id.browser_sub_drawer_parent);
        mDrawerLayout = (DrawerLayout) findViewById(R.id.browser_sub_drawer_root);
        mNavDrawerLayout = (RelativeLayout) findViewById(R.id.nav_drawer_container);
        mCurrentQueueDrawerLayout = (RelativeLayout) findViewById(R.id.current_queue_drawer_container);
        mPlayAllText = (TextView) findViewById(R.id.browser_sub_play_all);

        mHeaderTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        mHeaderTextView.setText(mHeaderText);
        mHeaderTextView.setSelected(true);

        mHeaderSubTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        mHeaderSubTextView.setText(mHeaderSubText);
        mHeaderSubTextView.setSelected(true);

        mPlayAllText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        mPlayAllText.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                int playbackRouteId = Common.PLAY_ALL_SONGS;
                switch (mFragmentId) {
                    case Common.ARTISTS_FLIPPED_FRAGMENT:
                        playbackRouteId = Common.PLAY_ALL_BY_ARTIST;
                        break;
                    case Common.ALBUM_ARTISTS_FLIPPED_FRAGMENT:
                        playbackRouteId = Common.PLAY_ALL_BY_ALBUM_ARTIST;
                        break;
                    case Common.GENRES_FLIPPED_FRAGMENT:
                        playbackRouteId = Common.PLAY_ALL_IN_GENRE;
                        break;
                }

                mApp.getPlaybackKickstarter()
                    .initPlayback(mContext,
                            mQuerySelection,
                            playbackRouteId,
                            0,
                            true,
                            false);

            }

        });

        mDrawerParentLayout.setBackgroundColor(UIElementsHelper.getBackgroundColor(mContext));
        applyKitKatTranslucency();

        //Load the drawer fragments.
        loadDrawerFragments();

        //Set the number of gridview columns based on the screen density and orientation.
        if (mApp.isPhoneInLandscape() || mApp.isTabletInLandscape()) {
            mGridView.setNumColumns(4);
        } else if (mApp.isPhoneInPortrait()) {
            mGridView.setNumColumns(2);
        } else if (mApp.isTabletInPortrait()) {
            mGridView.setNumColumns(3);
        }

        //Start the content animations as soon the activity's transition finishes.
        mHandler.postDelayed(animateContent, 300);

        //Start loading the GridView cursor.
        AsyncRunQuery task = new AsyncRunQuery();
        task.execute();

    }

    /**
     * Sets the entire activity-wide theme.
     */
    private void setTheme() {
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            setTheme(R.style.AppThemeNoActionBar);
        } else {
            setTheme(R.style.AppThemeLightNoActionBar);
        }

    }

    /**
     * Apply KitKat specific translucency.
     */
    private void applyKitKatTranslucency() {

        //KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {

            int topPadding = Common.getStatusBarHeight(mContext);
            if (mDrawerParentLayout!=null) {
                mDrawerParentLayout.setPadding(0, (0-topPadding), 0, 0);
                mDrawerParentLayout.setClipToPadding(false);

                int navigationBarHeight = Common.getNavigationBarHeight(mContext);
                mGridView.setClipToPadding(false);
                mGridView.setPadding(mGridView.getPaddingLeft(),
                                     mGridView.getPaddingTop(),
                                     mGridView.getPaddingRight(),
                                     mGridView.getPaddingBottom() + navigationBarHeight);


            }

        }

    }

    /**
     * Loads the drawer fragments.
     */
    private void loadDrawerFragments() {
        //Load the navigation drawer.
        getSupportFragmentManager().beginTransaction()
                                   .replace(R.id.nav_drawer_container, new NavigationDrawerFragment())
                                   .commit();

        //Load the current queue drawer.
        mQueueDrawerFragment = new QueueDrawerFragment();
        getSupportFragmentManager().beginTransaction()
                                   .replace(R.id.current_queue_drawer_container, mQueueDrawerFragment)
                                   .commit();

    }

    /**
     * Animates the content views in.
     */
    private Runnable animateContent = new Runnable() {

        @Override
        public void run() {

            //Slide down the header image.
            mApp.getPicasso().load(mHeaderImagePath).into(mHeaderImage);

            TranslateAnimation slideDown = new TranslateAnimation(mHeaderLayout, 400, new DecelerateInterpolator(2.0f),
                                                                  View.VISIBLE, Animation.RELATIVE_TO_SELF,
                                                                  0.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                                                                  Animation.RELATIVE_TO_SELF, -2.0f,
                                                                  Animation.RELATIVE_TO_SELF, 0.0f);

            slideDown.setAnimationListener(new Animation.AnimationListener() {

                @Override
                public void onAnimationStart(Animation animation) {
                    mHeaderLayout.setVisibility(View.VISIBLE);

                }

                @Override
                public void onAnimationEnd(Animation animation) {

                }

                @Override
                public void onAnimationRepeat(Animation animation) {

                }

            });

            slideDown.animate();
        }

    };

    /**
     * Runs the correct DB query based on the passed in fragment id and
     * displays the GridView.
     *
     * @author Saravan Pantham
     */
    public class AsyncRunQuery extends AsyncTask<Void, Void, Void> {

        @Override
        protected Void doInBackground(Void... params) {
            mQuerySelection = buildQuerySelectionClause();
            mCursor = mApp.getDBAccessHelper().getFragmentCursor(mContext, mQuerySelection, mFragmentId);
            loadDBColumnNames();

            return null;
        }

        /**
         * Populates the DB column names based on the specifed fragment id.
         */
        private void loadDBColumnNames() {

            switch (mFragmentId) {
                case Common.ARTISTS_FLIPPED_FRAGMENT:
                    mDBColumnsMap.put(BrowserSubGridAdapter.TITLE_TEXT, DBAccessHelper.SONG_ALBUM);
                    mDBColumnsMap.put(BrowserSubGridAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
                    mDBColumnsMap.put(BrowserSubGridAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
                    mDBColumnsMap.put(BrowserSubGridAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
                    mDBColumnsMap.put(BrowserSubGridAdapter.FIELD_1, DBAccessHelper.SONGS_COUNT);
                    break;
                case Common.ALBUM_ARTISTS_FLIPPED_FRAGMENT:
                    mDBColumnsMap.put(BrowserSubGridAdapter.TITLE_TEXT, DBAccessHelper.SONG_ALBUM);
                    mDBColumnsMap.put(BrowserSubGridAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
                    mDBColumnsMap.put(BrowserSubGridAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
                    mDBColumnsMap.put(BrowserSubGridAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
                    mDBColumnsMap.put(BrowserSubGridAdapter.FIELD_1, DBAccessHelper.SONGS_COUNT);
                case Common.GENRES_FLIPPED_FRAGMENT:
                    mDBColumnsMap.put(BrowserSubGridAdapter.TITLE_TEXT, DBAccessHelper.SONG_ALBUM);
                    mDBColumnsMap.put(BrowserSubGridAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
                    mDBColumnsMap.put(BrowserSubGridAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
                    mDBColumnsMap.put(BrowserSubGridAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
                    mDBColumnsMap.put(BrowserSubGridAdapter.FIELD_1, DBAccessHelper.SONG_ARTIST);
                    mDBColumnsMap.put(BrowserSubGridAdapter.FIELD_2, DBAccessHelper.SONG_ARTIST); //Used by GenresFlippedSongs.
                    break;
            }

        }

        /**
         * Builds the cursor query's selection clause based on the activity's
         * current usage case.
         */
        private String buildQuerySelectionClause() {
            switch (mFragmentId) {
                case Common.ARTISTS_FLIPPED_FRAGMENT:
                    mQuerySelection = " AND " + DBAccessHelper.SONG_ARTIST + "=";
                    break;
                case Common.ALBUM_ARTISTS_FLIPPED_FRAGMENT:
                    mQuerySelection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=";
                    break;
                case Common.ALBUMS_FLIPPED_FRAGMENT:
                    mQuerySelection = " AND " + DBAccessHelper.SONG_ALBUM + "=";
                case Common.GENRES_FLIPPED_FRAGMENT:
                    mQuerySelection = " AND " + DBAccessHelper.SONG_GENRE + "=";
                    break;
            }

            mQuerySelection += "'" + mHeaderText.replace("'", "''") + "'";
            return mQuerySelection;
        }

        @Override
        public void onPostExecute(Void result) {
            super.onPostExecute(result);
            mHandler.postDelayed(initGridView, 200);

        }

    }

    /**
     * Item click listener for the GridView.
     */
    private AdapterView.OnItemClickListener onItemClickListener = new AdapterView.OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> arg0, View view, int index, long id) {

            Bundle bundle = new Bundle();
            bundle.putString("headerImagePath", (String) view.getTag(R.string.album_art));
            bundle.putString("headerText", (String) view.getTag(R.string.title_text));
            bundle.putString("field2", (String) view.getTag(R.string.field_2));
            bundle.putString("subText", mHeaderText);
            bundle.putInt("fragmentId", getNewFragmentId());

            Intent intent = new Intent(mContext, BrowserSubListActivity.class);
            intent.putExtras(bundle);
            startActivity(intent);
            overridePendingTransition(R.anim.fade_in, R.anim.fade_out);

        }

    };

    /**
     * Determines the next activity's fragment id based on the
     * current activity's fragment id.
     */
    private int getNewFragmentId() {
        switch (mFragmentId) {
            case Common.ARTISTS_FLIPPED_FRAGMENT:
                return Common.ARTISTS_FLIPPED_SONGS_FRAGMENT;
            case Common.ALBUM_ARTISTS_FLIPPED_FRAGMENT:
                return Common.ALBUM_ARTISTS_FLIPPED_SONGS_FRAGMENT;
            case Common.GENRES_FLIPPED_FRAGMENT:
                return Common.GENRES_FLIPPED_SONGS_FRAGMENT;
            default:
                return -1;
        }

    }

    /**
     * Runnable that loads the GridView after a set interval.
     */
    private Runnable initGridView = new Runnable() {

        @Override
        public void run() {
            android.view.animation.TranslateAnimation animation = new
                    android.view.animation.TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f,
                                                              Animation.RELATIVE_TO_SELF, 0.0f,
                                                              Animation.RELATIVE_TO_SELF, 2.0f,
                                                              Animation.RELATIVE_TO_SELF, 0.0f);

            animation.setDuration(150);
            animation.setInterpolator(new AccelerateDecelerateInterpolator());

            mGridViewAdapter = new BrowserSubGridAdapter(mContext, BrowserSubGridActivity.this, mDBColumnsMap);
            //mGridView.setAdapter(mGridViewAdapter);

            //GridView animation adapter.
            final SwingBottomInAnimationAdapter animationAdapter = new SwingBottomInAnimationAdapter(mGridViewAdapter, 100, 150);
            animationAdapter.setShouldAnimate(true);
            animationAdapter.setShouldAnimateFromPosition(0);
            animationAdapter.setAbsListView(mGridView);

            mGridView.setAdapter(animationAdapter);
            mGridView.setOnItemClickListener(onItemClickListener);

            PauseOnScrollHelper scrollHelper = new PauseOnScrollHelper(mApp.getPicasso(), onScrollListener, false, true);
            mGridView.setOnScrollListener(scrollHelper);

            animation.setAnimationListener(new Animation.AnimationListener() {

                @Override
                public void onAnimationEnd(Animation arg0) {

                }

                @Override
                public void onAnimationRepeat(Animation arg0) {
                    // TODO Auto-generated method stub

                }

                @Override
                public void onAnimationStart(Animation arg0) {
                    mGridView.setVisibility(View.VISIBLE);

                }

            });

            mGridView.startAnimation(animation);
        }

    };

    /**
     *
     */


    /**
     * Slides away the header layout.
     */
    private void slideAwayHeader() {
        TranslateAnimation slideDown = new TranslateAnimation(mHeaderLayout, 400, new AccelerateInterpolator(2.0f),
                                                              View.INVISIBLE, Animation.RELATIVE_TO_SELF,
                                                              0.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                                                              Animation.RELATIVE_TO_SELF, 0.0f,
                                                              Animation.RELATIVE_TO_SELF, -2.0f);

        slideDown.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {
                mHeaderLayout.setVisibility(View.VISIBLE);

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mHeaderLayout.setVisibility(View.INVISIBLE);

            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

        });

        slideDown.animate();
    }

    /**
     * Slides away the GridView.
     */
    private void slideAwayGridView() {
        android.view.animation.TranslateAnimation animation = new
                         android.view.animation.TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f,
                         Animation.RELATIVE_TO_SELF, 0.0f,
                         Animation.RELATIVE_TO_SELF, 0.0f,
                         Animation.RELATIVE_TO_SELF, 2.0f);

        animation.setDuration(400);
        animation.setInterpolator(new AccelerateInterpolator(2.0f));
        animation.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationEnd(Animation arg0) {
                mGridView.setVisibility(View.INVISIBLE);
                BrowserSubGridActivity.super.onBackPressed();

            }

            @Override
            public void onAnimationRepeat(Animation arg0) {
                // TODO Auto-generated method stub

            }

            @Override
            public void onAnimationStart(Animation arg0) {

            }

        });

        mGridView.startAnimation(animation);
    }

    /**
     * Scroll listener to calculate the GridView's scroll offset and adjust
     * the header view accordingly.
     */
    private AbsListView.OnScrollListener onScrollListener = new AbsListView.OnScrollListener() {

        @Override
        public void onScrollStateChanged(AbsListView view, int scrollState) {

        }

        @Override
        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {

            try {
                View topChild = view.getChildAt(0);
                int scrollY = -(topChild.getTop()) + view.getFirstVisiblePosition() * topChild.getHeight();
                int adjustedScrollY = (int) ((-scrollY)-mApp.convertDpToPixels(280.0f, mContext));

                RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mHeaderLayout.getLayoutParams();
                params.topMargin = adjustedScrollY/3;
                mHeaderLayout.setLayoutParams(params);

            } catch (Exception e) {
                e.printStackTrace();
            }

        }

    };

    public Cursor getCursor() {
        return mCursor;
    }

    @Override
    public void onBackPressed() {
        slideAwayHeader();
        slideAwayGridView();

    }

    @Override
    public void onPause() {
        super.onPause();
        overridePendingTransition(R.anim.fade_in, R.anim.fade_out);

    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BrowserSubGridActivity;

import android.content.Context;
import android.content.res.Resources;
import android.database.Cursor;
import android.os.Bundle;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.widget.SimpleCursorAdapter;
import android.util.DisplayMetrics;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.PopupMenu;
import android.widget.PopupMenu.OnMenuItemClickListener;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.andraskindler.quickscroll.Scrollable;
import com.jams.music.player.AsyncTasks.AsyncAddToQueueTask;
import com.jams.music.player.Dialogs.AddToPlaylistDialog;
import com.jams.music.player.Dialogs.CautionEditArtistsDialog;
import com.jams.music.player.Dialogs.ID3sArtistEditorDialog;
import com.jams.music.player.GridViewFragment.GridViewFragment;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

import java.util.HashMap;

/**
 * Generic GridView adapter for BrowserSubGridActivity.
 * 
 * @author Saravan Pantham
 */
public class BrowserSubGridAdapter extends SimpleCursorAdapter implements Scrollable {
	
	private Context mContext;
	private Common mApp;
	private BrowserSubGridActivity mActivity;
    public static GridViewHolder mHolder = null;
    private String mName = "";
    private int mWidth;
    private int mHeight;
    
    //HashMap for DB column names.
    private HashMap<Integer, String> mDBColumnsMap;
    public static final int TITLE_TEXT = 0;
    public static final int SOURCE = 1;
    public static final int FILE_PATH = 2;
    public static final int ARTWORK_PATH = 3;
    public static final int FIELD_1 = 4; //Empty fields for other parameters.
    public static final int FIELD_2 = 5;
    public static final int FIELD_3 = 6;
    public static final int FIELD_4 = 7;
    public static final int FIELD_5 = 8;
    
    public BrowserSubGridAdapter(Context context, BrowserSubGridActivity activity,
                                 HashMap<Integer, String> dbColumnsMap) {
    	
        super(context, -1, activity.getCursor(), new String[] {}, new int[] {}, 0);
        mContext = context;
        mActivity = activity;
        mApp = (Common) mContext.getApplicationContext();
        mDBColumnsMap = dbColumnsMap;

        //Calculate the height and width of each item image.
        DisplayMetrics metrics = Resources.getSystem().getDisplayMetrics();

        if (mApp.isTabletInPortrait()) {
            //3 column layout.
            mWidth = (metrics.widthPixels)/3;
            mHeight = mWidth + (mWidth/4);
        } else if (mApp.isPhoneInLandscape() || mApp.isTabletInLandscape()) {
            //4 column layout.
            mWidth = (metrics.widthPixels)/4;
            mHeight = mWidth + (mWidth/5);
        } else {
            //2 column layout.
            mWidth = (metrics.widthPixels)/2;
            mHeight = mWidth + (mWidth/3);
        }

    }
    
    /**
     * Quick scroll indicator implementation.
     */
    @Override
    public String getIndicatorForPosition(int childPosition, int groupPosition) {
    	Cursor c = (Cursor) getItem(childPosition);
    	String title = c.getString(c.getColumnIndex(mDBColumnsMap.get(TITLE_TEXT)));
    	if (title!=null && title.length() > 1)
    		return "  " + title.substring(0, 1) + "  ";
        else
    		return "  N/A  ";
    }
    
    /**
     * Returns the current position of the top view in the list/grid.
     */
	@Override
	public int getScrollPosition(int childPosition, int groupPosition) {
		// TODO Auto-generated method stub
		return childPosition;
	}

	/**
	 * Returns the individual row/child in the list/grid.
	 */
    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        Cursor c = (Cursor) getItem(position);

		if (convertView==null) {
			mHolder = new GridViewHolder();
            convertView = LayoutInflater.from(mContext).inflate(R.layout.grid_view_item, parent, false);

            mHolder.background = (RelativeLayout) convertView.findViewById(R.id.gridViewItemLayout);
            mHolder.textLayout = (RelativeLayout) convertView.findViewById(R.id.gridViewTextLayout);
			mHolder.gridViewArt = (ImageView) convertView.findViewById(R.id.gridViewImage);
			mHolder.titleText = (TextView) convertView.findViewById(R.id.gridViewTitleText);
            mHolder.subText = (TextView) convertView.findViewById(R.id.gridViewSubText);

			mHolder.overflowButton = (ImageButton) convertView.findViewById(R.id.gridViewOverflowButton);
            mHolder.overflowButton.setImageResource(UIElementsHelper.getIcon(mContext, "ic_action_overflow"));
			mHolder.overflowButton.setOnClickListener(overflowClickListener);
			mHolder.overflowButton.setFocusable(false);
			mHolder.overflowButton.setFocusableInTouchMode(false);

			mHolder.titleText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
            mHolder.subText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			
	        mHolder.gridViewArt.setScaleType(ImageView.ScaleType.CENTER_CROP);
            mHolder.gridViewArt.setImageResource(UIElementsHelper.getEmptyColorPatch(mContext));
            //mHolder.textLayout.setBackgroundColor(UIElementsHelper.getGridViewBackground(mContext));
            //mHolder.overflowButton.setBackgroundColor(UIElementsHelper.getGridViewBackground(mContext));
            mHolder.titleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
            mHolder.subText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));

            //Apply the ImageView's dimensions.
            RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mHolder.gridViewArt.getLayoutParams();
            params.width = mWidth;
            params.height = mWidth;
            mHolder.gridViewArt.setLayoutParams(params);

            //Apply the card's background.
            mHolder.background.setBackgroundResource(UIElementsHelper.getGridViewCardBackground(mContext));
			
			convertView.setTag(mHolder);
		} else {
		    mHolder = (GridViewHolder) convertView.getTag();
		}
		
		//Retrieve data from the cursor.
		String titleText = "";
		String source = "";
		String filePath = "";
		String artworkPath = "";
		String field1 = "";
		String field2 = "";
		String field3 = "";
		String field4 = "";
		String field5 = "";
		try {
			titleText = c.getString(c.getColumnIndex(mDBColumnsMap.get(TITLE_TEXT)));
			source = c.getString(c.getColumnIndex(mDBColumnsMap.get(SOURCE)));
			filePath = c.getString(c.getColumnIndex(mDBColumnsMap.get(FILE_PATH)));
			artworkPath = c.getString(c.getColumnIndex(mDBColumnsMap.get(ARTWORK_PATH)));
			field1 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_1)));
			field2 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_2)));
			field3 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_3)));
			field4 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_4)));
			field5 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_5)));
			
		} catch (NullPointerException e) {
			//e.printStackTrace();
		}
		
		//Set the tags for this grid item.
		convertView.setTag(R.string.title_text, titleText);
		convertView.setTag(R.string.song_source, source);
		convertView.setTag(R.string.song_file_path, filePath);
		convertView.setTag(R.string.album_art, artworkPath);
		convertView.setTag(R.string.field_1, field1);
		convertView.setTag(R.string.field_2, field2);
		convertView.setTag(R.string.field_3, field3);
		convertView.setTag(R.string.field_4, field4);
		convertView.setTag(R.string.field_5, field5);
		
		/*//Set the tags for this grid item's overflow button.
		mHolder.overflowButton.setTag(R.string.title_text, titleText);
		mHolder.overflowButton.setTag(R.string.source, source);
		mHolder.overflowButton.setTag(R.string.file_path, filePath);
		mHolder.overflowButton.setTag(R.string.field_1, field1);
		mHolder.overflowButton.setTag(R.string.field_2, field2);
		mHolder.overflowButton.setTag(R.string.field_3, field3);
		mHolder.overflowButton.setTag(R.string.field_4, field4);
		mHolder.overflowButton.setTag(R.string.field_5, field5);*/
		
		//Set the title text in the GridView.
		mHolder.titleText.setText(titleText);
        mHolder.subText.setText(field1);

		//Load the album art.
        mApp.getPicasso().load(artworkPath)
                         .placeholder(UIElementsHelper.getEmptyColorPatch(mContext))
                         .into(mHolder.gridViewArt);

		return convertView;
	}

    /**
     * Click listener for overflow button.
     */
    private OnClickListener overflowClickListener = new OnClickListener() {

		@Override
		public void onClick(View v) {
			PopupMenu menu = new PopupMenu(mContext, v);
			menu.inflate(R.menu.artist_overflow_menu);
			//menu.setOnMenuItemClickListener(popupMenuItemClickListener);
			mName = (String) v.getTag(R.string.artist);
		    menu.show();
			
		}
    	
    };
    
   /* *//**
     * Menu item click listener for the pop up menu.
     *//*
    private OnMenuItemClickListener popupMenuItemClickListener = new OnMenuItemClickListener() {

		@Override
		public boolean onMenuItemClick(MenuItem item) {
			
			switch(item.getItemId()) {
        	case R.id.edit_artist_tags:
        		//Edit Artist Tags.
        		if (mApp.getSharedPreferences().getBoolean("SHOW_ARTIST_EDIT_CAUTION", true)==true) {
            		FragmentTransaction transaction = mGridViewFragment.getFragmentManager().beginTransaction();
            		Bundle bundle = new Bundle();
            		bundle.putString("EDIT_TYPE", "ARTIST");
            		bundle.putString("ARTIST", mName);
            		CautionEditArtistsDialog dialog = new CautionEditArtistsDialog();
            		dialog.setArguments(bundle);
            		dialog.show(transaction, "cautionArtistsDialog");
        		} else {
    				FragmentTransaction ft = mGridViewFragment.getFragmentManager().beginTransaction();
    				Bundle bundle = new Bundle();
    				bundle.putString("EDIT_TYPE", "ARTIST");
    				bundle.putString("ARTIST", mName);
    				ID3sArtistEditorDialog dialog = new ID3sArtistEditorDialog();
    				dialog.setArguments(bundle);
    				dialog.show(ft, "id3ArtistEditorDialog");
        		}
        		break;
        	case R.id.add_to_queue: 
        		//Add to Queue.
        		AsyncAddToQueueTask task = new AsyncAddToQueueTask(mContext,
        														   mGridViewFragment,
        														   "ARTIST",
        														   mName, 
        														   null,
        														   null, 
        														   null, 
        														   null,
        														   null,
        														   null);
        		task.execute();
        		break;
        	case R.id.play_next:
        		AsyncAddToQueueTask playNextTask = new AsyncAddToQueueTask(mContext,
																		   mGridViewFragment,
																		   "ARTIST",
																		   mName, 
																		   null,
																		   null, 
																		   null, 
																		   null,
																		   null,
																		   null);
        		playNextTask.execute(new Boolean[] { true });
        		break;
        	case R.id.add_to_playlist:
        		//Add to Playlist
        		FragmentTransaction ft = mGridViewFragment.getFragmentManager().beginTransaction();
				AddToPlaylistDialog dialog = new AddToPlaylistDialog();
				Bundle bundle = new Bundle();
				bundle.putString("ADD_TYPE", "ARTIST");
				bundle.putString("ARTIST", mName);
				dialog.setArguments(bundle);
				dialog.show(ft, "AddToPlaylistDialog");
				break;
        	case R.id.blacklist_artist:
        		//Blacklist Artist
        		mApp.getDBAccessHelper().setBlacklistForArtist(mName, true);
        		Toast.makeText(mContext, R.string.artist_blacklisted, Toast.LENGTH_SHORT).show();
        		
        		//Update the GridView.
        		mGridViewFragment.mHandler.post(mGridViewFragment.queryRunnable);
        		mGridViewFragment.getGridViewAdapter().notifyDataSetChanged();

        		break;
        	
			}
			
			return false;
		}
    	
    };*/

    /**
     * Holder subclass for GridViewAdapter.
     * 
     * @author Saravan Pantham
     */
	public static class GridViewHolder {
	    public ImageView gridViewArt;
	    public TextView titleText;
        public TextView subText;
	    public RelativeLayout background;
	    public RelativeLayout textLayout;
        public ImageButton overflowButton;

	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BrowserSubListActivity;

import android.content.Context;
import android.database.Cursor;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.support.v4.app.FragmentActivity;
import android.support.v4.widget.DrawerLayout;
import android.view.View;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.DecelerateInterpolator;
import android.widget.AbsListView;
import android.widget.AdapterView;
import android.widget.GridView;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.jams.music.player.Animations.TranslateAnimation;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Drawers.NavigationDrawerFragment;
import com.jams.music.player.Drawers.QueueDrawerFragment;
import com.jams.music.player.Helpers.PauseOnScrollHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.ListViewFragment.ListViewCardsAdapter;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;
import com.nhaarman.listviewanimations.swinginadapters.prepared.SwingBottomInAnimationAdapter;
import com.squareup.picasso.Callback;

import java.util.HashMap;

public class BrowserSubListActivity extends FragmentActivity {

    //Context and common objects.
    private Context mContext;
    private Common mApp;
    private Handler mHandler;
    private QueueDrawerFragment mQueueDrawerFragment;

    //UI elements
    private ImageView mHeaderImage;
    private ListView mListView;
    private RelativeLayout mDrawerParentLayout;
    private RelativeLayout mHeaderLayout;
    private TextView mHeaderTextView;
    private TextView mHeaderSubTextView;
    private TextView mPlayAllText;
    private DrawerLayout mDrawerLayout;
    private RelativeLayout mNavDrawerLayout;
    private RelativeLayout mCurrentQueueDrawerLayout;

    //Data adapter objects/vars.
    private HashMap<Integer, String> mDBColumnsMap;
    private BrowserSubListAdapter mListViewAdapter;
    private Cursor mCursor;
    private String mQuerySelection;

    //Arguments passed in from the calling activity.
    private String mHeaderImagePath;
    private String mHeaderText;
    private String mHeaderSubText;
    private String mField2;
    private int mFragmentId;

    @Override
    protected void onCreate(Bundle savedInstanceState) {

        mContext = getApplicationContext();
        mApp = (Common) mContext;
        mHandler = new Handler();
        mDBColumnsMap = new HashMap<Integer, String>();

        //Set the theme and inflate the layout.
        setTheme();
        overridePendingTransition(R.anim.fade_in, R.anim.fade_out);
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_browser_sub_list);

        mHeaderImagePath = getIntent().getExtras().getString("headerImagePath");
        mFragmentId = getIntent().getExtras().getInt("fragmentId");
        mHeaderText = getIntent().getExtras().getString("headerText");
        mHeaderSubText = getIntent().getExtras().getString("subText");
        mField2 = getIntent().getExtras().getString("field2");

        if (mHeaderText==null || mHeaderText.isEmpty())
            mHeaderText = mContext.getResources().getString(R.string.unknown_genre);

        mHeaderLayout = (RelativeLayout) findViewById(R.id.browser_sub_header_layout);
        mHeaderImage = (ImageView) findViewById(R.id.browser_sub_header_image);
        mHeaderTextView = (TextView) findViewById(R.id.browser_sub_header_text);
        mHeaderSubTextView = (TextView) findViewById(R.id.browser_sub_header_sub_text);
        mListView = (ListView) findViewById(R.id.browser_sub_list_view);
        mDrawerParentLayout = (RelativeLayout) findViewById(R.id.browser_sub_drawer_parent);
        mDrawerLayout = (DrawerLayout) findViewById(R.id.browser_sub_drawer_root);
        mNavDrawerLayout = (RelativeLayout) findViewById(R.id.nav_drawer_container);
        mCurrentQueueDrawerLayout = (RelativeLayout) findViewById(R.id.current_queue_drawer_container);
        mPlayAllText = (TextView) findViewById(R.id.browser_sub_play_all);

        mHeaderTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        mHeaderTextView.setText(mHeaderText);
        mHeaderTextView.setSelected(true);

        mHeaderSubTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        mHeaderSubTextView.setText(mHeaderSubText);
        mHeaderSubTextView.setSelected(true);

        mPlayAllText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        mPlayAllText.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                int playbackRouteId = Common.PLAY_ALL_SONGS;
                switch (mFragmentId) {
                    case Common.ARTISTS_FLIPPED_SONGS_FRAGMENT:
                        playbackRouteId = Common.PLAY_ALL_BY_ALBUM;
                        break;
                    case Common.ALBUM_ARTISTS_FLIPPED_SONGS_FRAGMENT:
                        playbackRouteId = Common.PLAY_ALL_BY_ALBUM;
                        break;
                    case Common.GENRES_FLIPPED_SONGS_FRAGMENT:
                        playbackRouteId = Common.PLAY_ALL_BY_ALBUM;
                        break;
                }

                mApp.getPlaybackKickstarter()
                    .initPlayback(mContext,
                            mQuerySelection,
                            playbackRouteId,
                            0,
                            true,
                            false);

            }

        });

        //Apply the ListViews' dividers.
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            mListView.setDivider(mContext.getResources().getDrawable(R.drawable.list_divider));
        } else {
            mListView.setDivider(mContext.getResources().getDrawable(R.drawable.list_divider_light));
        }
        mListView.setDividerHeight(1);

        mDrawerParentLayout.setBackgroundColor(UIElementsHelper.getBackgroundColor(mContext));
        applyKitKatTranslucency();

        //Load the drawer fragments.
        loadDrawerFragments();

        //Start the content animations as soon the activity's transition finishes.
        mHandler.postDelayed(animateContent, 300);

        //Start loading the GridView cursor.
        AsyncRunQuery task = new AsyncRunQuery();
        task.execute();

    }

    /**
     * Sets the entire activity-wide theme.
     */
    private void setTheme() {
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            setTheme(R.style.AppThemeNoActionBar);
        } else {
            setTheme(R.style.AppThemeLightNoActionBar);
        }

    }

    /**
     * Apply KitKat specific translucency.
     */
    private void applyKitKatTranslucency() {

        //KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {

            int topPadding = Common.getStatusBarHeight(mContext);
            if (mDrawerParentLayout!=null) {
                mDrawerParentLayout.setPadding(0, (0-topPadding), 0, 0);
                mDrawerParentLayout.setClipToPadding(false);

                int navigationBarHeight = Common.getNavigationBarHeight(mContext);
                mListView.setClipToPadding(false);
                mListView.setPadding(mListView.getPaddingLeft(),
                                     mListView.getPaddingTop(),
                                     mListView.getPaddingRight(),
                                     mListView.getPaddingBottom() + navigationBarHeight);


            }

        }

    }

    /**
     * Loads the drawer fragments.
     */
    private void loadDrawerFragments() {
        //Load the navigation drawer.
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.nav_drawer_container, new NavigationDrawerFragment())
                .commit();

        //Load the current queue drawer.
        mQueueDrawerFragment = new QueueDrawerFragment();
        getSupportFragmentManager().beginTransaction()
                                   .replace(R.id.current_queue_drawer_container, mQueueDrawerFragment)
                                   .commit();

    }

    /**
     * Animates the content views in.
     */
    private Runnable animateContent = new Runnable() {

        @Override
        public void run() {

            //Slide down the header image.
            mApp.getPicasso().load(mHeaderImagePath).into(mHeaderImage);
            TranslateAnimation slideDown = new TranslateAnimation(mHeaderLayout, 400, new DecelerateInterpolator(2.0f),
                                                                  View.VISIBLE, Animation.RELATIVE_TO_SELF,
                                                                  0.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                                                                  Animation.RELATIVE_TO_SELF, -2.0f,
                                                                  Animation.RELATIVE_TO_SELF, 0.0f);

            slideDown.setAnimationListener(new Animation.AnimationListener() {

                @Override
                public void onAnimationStart(Animation animation) {
                    mHeaderLayout.setVisibility(View.VISIBLE);

                }

                @Override
                public void onAnimationEnd(Animation animation) {

                }

                @Override
                public void onAnimationRepeat(Animation animation) {

                }

            });

            slideDown.animate();
        }

    };

    /**
     * Runs the correct DB query based on the passed in fragment id and
     * displays the GridView.
     *
     * @author Saravan Pantham
     */
    public class AsyncRunQuery extends AsyncTask<Void, Void, Void> {

        @Override
        protected Void doInBackground(Void... params) {
            mQuerySelection = buildQuerySelectionClause();
            mCursor = mApp.getDBAccessHelper().getFragmentCursor(mContext, mQuerySelection, mFragmentId);
            loadDBColumnNames();

            return null;
        }

        /**
         * Populates the DB column names based on the specifed fragment id.
         */
        private void loadDBColumnNames() {

            switch (mFragmentId) {
                case Common.ARTISTS_FLIPPED_SONGS_FRAGMENT:
                case Common.ALBUM_ARTISTS_FLIPPED_SONGS_FRAGMENT:
                case Common.ALBUMS_FLIPPED_FRAGMENT:
                case Common.GENRES_FLIPPED_SONGS_FRAGMENT:
                    mDBColumnsMap.put(ListViewCardsAdapter.TITLE_TEXT, DBAccessHelper.SONG_TITLE);
                    mDBColumnsMap.put(ListViewCardsAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
                    mDBColumnsMap.put(ListViewCardsAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
                    mDBColumnsMap.put(ListViewCardsAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
                    mDBColumnsMap.put(ListViewCardsAdapter.FIELD_1, DBAccessHelper.SONG_DURATION);
                    mDBColumnsMap.put(ListViewCardsAdapter.FIELD_2, DBAccessHelper.SONG_ARTIST);
                    mDBColumnsMap.put(ListViewCardsAdapter.FIELD_3, DBAccessHelper.SONG_TRACK_NUMBER);
                    break;
            }

        }

        /**
         * Builds the cursor query's selection clause based on the activity's
         * current usage case.
         */
        private String buildQuerySelectionClause() {
            switch (mFragmentId) {
                case Common.ARTISTS_FLIPPED_SONGS_FRAGMENT:
                    mQuerySelection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'"
                                    + mHeaderText.replace("'", "''") + "'" + " AND "
                                    + DBAccessHelper.SONG_ARTIST + "=" + "'"
                                    + mHeaderSubText.replace("'", "''") + "'";
                    break;
                case Common.ALBUM_ARTISTS_FLIPPED_SONGS_FRAGMENT:
                    mQuerySelection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'"
                                    + mHeaderText.replace("'", "''") + "'" + " AND "
                                    + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'"
                                    + mHeaderSubText.replace("'", "''") + "'";
                    break;
                case Common.ALBUMS_FLIPPED_FRAGMENT:
                    mQuerySelection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'"
                                    + mHeaderText.replace("'", "''") + "'" + " AND "
                                    + DBAccessHelper.SONG_ARTIST + "=" + "'"
                                    + mHeaderSubText.replace("'", "''") + "'";
                    break;
                case Common.GENRES_FLIPPED_SONGS_FRAGMENT:
                    mQuerySelection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'"
                                    + mHeaderText.replace("'", "''") + "'" + " AND "
                                    + DBAccessHelper.SONG_GENRE + "=" + "'"
                                    + mHeaderSubText.replace("'", "''") + "'" + " AND "
                                    + DBAccessHelper.SONG_ARTIST + "=" + "'"
                                    + mField2.replace("'", "''") + "'";
                    break;
            }

            return mQuerySelection;
        }

        @Override
        public void onPostExecute(Void result) {
            super.onPostExecute(result);
            mHandler.postDelayed(initGridView, 200);

        }

    }

    /**
     * Item click listener for the ListView.
     */
    private AdapterView.OnItemClickListener onItemClickListener = new AdapterView.OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> arg0, View view, int index, long id) {
            int playbackRouteId = Common.PLAY_ALL_SONGS;
            switch (mFragmentId) {
                case Common.ARTISTS_FLIPPED_SONGS_FRAGMENT:
                case Common.ALBUM_ARTISTS_FLIPPED_SONGS_FRAGMENT:
                case Common.GENRES_FLIPPED_FRAGMENT:
                case Common.ALBUMS_FLIPPED_FRAGMENT:
                    playbackRouteId = Common.PLAY_ALL_BY_ALBUM;
                    break;
            }

            mApp.getPlaybackKickstarter()
                .initPlayback(mContext,
                        mQuerySelection,
                        playbackRouteId,
                        index,
                        true,
                        false);

        }

    };

    /**
     * Runnable that loads the GridView after a set interval.
     */
    private Runnable initGridView = new Runnable() {

        @Override
        public void run() {
            android.view.animation.TranslateAnimation animation = new
                    android.view.animation.TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f,
                    Animation.RELATIVE_TO_SELF, 0.0f,
                    Animation.RELATIVE_TO_SELF, 2.0f,
                    Animation.RELATIVE_TO_SELF, 0.0f);

            animation.setDuration(150);
            animation.setInterpolator(new AccelerateDecelerateInterpolator());

            mListViewAdapter = new BrowserSubListAdapter(mContext, BrowserSubListActivity.this, mDBColumnsMap);
            //mListView.setAdapter(mListViewAdapter);

            //GridView animation adapter.
            final SwingBottomInAnimationAdapter animationAdapter = new SwingBottomInAnimationAdapter(mListViewAdapter, 100, 150);
            animationAdapter.setShouldAnimate(true);
            animationAdapter.setShouldAnimateFromPosition(0);
            animationAdapter.setAbsListView(mListView);
            mListView.setAdapter(animationAdapter);
            mListView.setOnItemClickListener(onItemClickListener);

            PauseOnScrollHelper scrollHelper = new PauseOnScrollHelper(mApp.getPicasso(), onScrollListener, false, true);
            mListView.setOnScrollListener(scrollHelper);

            animation.setAnimationListener(new Animation.AnimationListener() {

                @Override
                public void onAnimationEnd(Animation arg0) {

                }

                @Override
                public void onAnimationRepeat(Animation arg0) {
                    // TODO Auto-generated method stub

                }

                @Override
                public void onAnimationStart(Animation arg0) {
                    mListView.setVisibility(View.VISIBLE);

                }

            });

            mListView.startAnimation(animation);
        }

    };

    /**
     * Slides away the header layout.
     */
    private void slideAwayHeader() {
        TranslateAnimation slideDown = new TranslateAnimation(mHeaderLayout, 400, new AccelerateInterpolator(2.0f),
                View.INVISIBLE, Animation.RELATIVE_TO_SELF,
                0.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                Animation.RELATIVE_TO_SELF, 0.0f,
                Animation.RELATIVE_TO_SELF, -2.0f);

        slideDown.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {
                mHeaderLayout.setVisibility(View.VISIBLE);

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mHeaderLayout.setVisibility(View.INVISIBLE);

            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

        });

        slideDown.animate();
    }

    /**
     * Slides away the GridView.
     */
    private void slideAwayGridView() {
        android.view.animation.TranslateAnimation animation = new
                android.view.animation.TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f,
                Animation.RELATIVE_TO_SELF, 0.0f,
                Animation.RELATIVE_TO_SELF, 0.0f,
                Animation.RELATIVE_TO_SELF, 2.0f);

        animation.setDuration(400);
        animation.setInterpolator(new AccelerateInterpolator(2.0f));
        animation.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationEnd(Animation arg0) {
                mListView.setVisibility(View.INVISIBLE);
                BrowserSubListActivity.super.onBackPressed();

            }

            @Override
            public void onAnimationRepeat(Animation arg0) {
                // TODO Auto-generated method stub

            }

            @Override
            public void onAnimationStart(Animation arg0) {

            }

        });

        mListView.startAnimation(animation);
    }

    /**
     * Scroll listener to calculate the ListView's scroll offset and adjust
     * the header view accordingly.
     */
    private AbsListView.OnScrollListener onScrollListener = new AbsListView.OnScrollListener() {

        @Override
        public void onScrollStateChanged(AbsListView view, int scrollState) {

        }

        @Override
        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {

            try {
                View topChild = view.getChildAt(0);
                int scrollY = -(topChild.getTop()) + view.getFirstVisiblePosition() * topChild.getHeight();
                int adjustedScrollY = (int) ((-scrollY)-mApp.convertDpToPixels(340.0f, mContext));

                RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mHeaderLayout.getLayoutParams();
                params.topMargin = adjustedScrollY/3;
                mHeaderLayout.setLayoutParams(params);

            } catch (Exception e) {
                e.printStackTrace();
            }

        }

    };

    public Cursor getCursor() {
        return mCursor;
    }

    @Override
    public void onBackPressed() {
        slideAwayHeader();
        slideAwayGridView();

    }

    @Override
    public void onPause() {
        super.onPause();
        overridePendingTransition(R.anim.fade_in, R.anim.fade_out);

    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.BrowserSubListActivity;

import android.content.Context;
import android.database.Cursor;
import android.os.Bundle;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.PopupMenu;
import android.widget.PopupMenu.OnMenuItemClickListener;
import android.widget.TextView;
import android.widget.Toast;

import com.andraskindler.quickscroll.Scrollable;
import com.jams.music.player.AsyncTasks.AsyncAddToQueueTask;
import com.jams.music.player.Dialogs.AddToPlaylistDialog;
import com.jams.music.player.Dialogs.CautionEditArtistsDialog;
import com.jams.music.player.Dialogs.ID3sArtistEditorDialog;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.ImageTransformers.PicassoCircularTransformer;
import com.jams.music.player.ListViewFragment.ListViewFragment;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

import java.util.HashMap;

/**
 * Generic ListView adapter for ListViewFragment.
 * 
 * @author Saravan Pantham
 */
public class BrowserSubListAdapter extends SimpleCursorAdapter implements Scrollable {

	private Context mContext;
	private Common mApp;
	private BrowserSubListActivity mActivity;
    public static ListViewHolder mHolder = null;
    private String mName = "";

    //HashMap for DB column names.
    private HashMap<Integer, String> mDBColumnsMap;
    public static final int TITLE_TEXT = 0;
    public static final int SOURCE = 1;
    public static final int FILE_PATH = 2;
    public static final int ARTWORK_PATH = 3;
    public static final int FIELD_1 = 4; //Empty fields for other
    public static final int FIELD_2 = 5;
    public static final int FIELD_3 = 6;
    public static final int FIELD_4 = 7;
    public static final int FIELD_5 = 8;

    public BrowserSubListAdapter(Context context, BrowserSubListActivity activity,
                                 HashMap<Integer, String> dbColumnsMap) {
    	
        super(context, -1, activity.getCursor(), new String[] {}, new int[] {}, 0);
        mContext = context;
        mActivity = activity;
        mApp = (Common) mContext.getApplicationContext();
        mDBColumnsMap = dbColumnsMap;
        
    }
    
    /**
     * Quick scroll indicator implementation.
     */
    @Override
    public String getIndicatorForPosition(int childPosition, int groupPosition) {
    	Cursor c = (Cursor) getItem(childPosition);
    	String title = c.getString(c.getColumnIndex(mDBColumnsMap.get(TITLE_TEXT)));
    	if (title!=null && title.length() > 1)
    		return "  " + title.substring(0, 1) + "  ";
        else
            return "  N/A  ";
    }
    
    /**
     * Returns the current position of the top view in the list/grid.
     */
	@Override
	public int getScrollPosition(int childPosition, int groupPosition) {
		// TODO Auto-generated method stub
		return childPosition;
	}

	/**
	 * Returns the individual row/child in the list/grid.
	 */
    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        Cursor c = (Cursor) getItem(position);

		if (convertView == null) {
			convertView = LayoutInflater.from(mContext).inflate(R.layout.list_view_sub_browser_item, parent, false);
			
			mHolder = new ListViewHolder();
			mHolder.trackNumber = (TextView) convertView.findViewById(R.id.listViewTrackNumber);
			mHolder.titleText = (TextView) convertView.findViewById(R.id.listViewTitleText);
			mHolder.subText = (TextView) convertView.findViewById(R.id.listViewSubText);
			mHolder.rightSubText = (TextView) convertView.findViewById(R.id.listViewRightSubText);
            mHolder.overflowIcon = (ImageButton) convertView.findViewById(R.id.listViewOverflow);

			mHolder.titleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
            mHolder.subText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
            mHolder.rightSubText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
            mHolder.trackNumber.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
			
			mHolder.titleText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			mHolder.subText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			mHolder.rightSubText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
            mHolder.trackNumber.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));

            mHolder.overflowIcon.setImageResource(UIElementsHelper.getIcon(mContext, "ic_action_overflow"));
			mHolder.overflowIcon.setOnClickListener(overflowClickListener);
			mHolder.overflowIcon.setFocusable(false);
			mHolder.overflowIcon.setFocusableInTouchMode(false);
			
			convertView.setTag(mHolder);
		} else {
		    mHolder = (ListViewHolder) convertView.getTag();
		}

		//Retrieve data from the cursor.
		String titleText = "";
		String source = "";
		String filePath = "";
		String artworkPath = "";
		String field1 = "";
		String field2 = "";
		String field3 = "";
		String field4 = "";
		String field5 = "";
		try {
			titleText = c.getString(c.getColumnIndex(mDBColumnsMap.get(TITLE_TEXT)));
			source = c.getString(c.getColumnIndex(mDBColumnsMap.get(SOURCE)));
			filePath = c.getString(c.getColumnIndex(mDBColumnsMap.get(FILE_PATH)));
			artworkPath = c.getString(c.getColumnIndex(mDBColumnsMap.get(ARTWORK_PATH)));
			field1 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_1)));
			field2 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_2)));
			field3 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_3)));
			field4 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_4)));
			field5 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_5)));
			
		} catch (NullPointerException e) {
			//e.printStackTrace();
		}
		
		//Set the tags for this grid item.
		convertView.setTag(R.string.title_text, titleText);
		convertView.setTag(R.string.song_source, source);
		convertView.setTag(R.string.song_file_path, filePath);
		convertView.setTag(R.string.album_art, artworkPath);
		convertView.setTag(R.string.field_1, field1);
		convertView.setTag(R.string.field_2, field2);
		convertView.setTag(R.string.field_3, field3);
		convertView.setTag(R.string.field_4, field4);
		convertView.setTag(R.string.field_5, field5);
		
		//Set the tags for this list item's overflow button.
		mHolder.overflowIcon.setTag(R.string.title_text, titleText);
		mHolder.overflowIcon.setTag(R.string.source, source);
		mHolder.overflowIcon.setTag(R.string.file_path, filePath);
		mHolder.overflowIcon.setTag(R.string.field_1, field1);
		mHolder.overflowIcon.setTag(R.string.field_2, field2);
		mHolder.overflowIcon.setTag(R.string.field_3, field3);
		mHolder.overflowIcon.setTag(R.string.field_4, field4);
		mHolder.overflowIcon.setTag(R.string.field_5, field5);
		
		//Set the title text in the ListView.
		mHolder.titleText.setText(titleText);
		mHolder.subText.setText(field2);
		mHolder.rightSubText.setText(field1);
        mHolder.trackNumber.setText(field3);
		
		return convertView;
	}

    
    /**
     * Click listener for overflow button.
     */
    private OnClickListener overflowClickListener = new OnClickListener() {

		@Override
		public void onClick(View v) {
			PopupMenu menu = new PopupMenu(mContext, v);
			menu.inflate(R.menu.artist_overflow_menu);
			//menu.setOnMenuItemClickListener(popupMenuItemClickListener);
			mName = (String) v.getTag(R.string.artist);
		    menu.show();
			
		}
    	
    };
    
    /**
     * Menu item click listener for the pop up menu.
     *//*
    private OnMenuItemClickListener popupMenuItemClickListener = new OnMenuItemClickListener() {

		@Override
		public boolean onMenuItemClick(MenuItem item) {
			
			switch(item.getItemId()) {
        	case R.id.edit_artist_tags:
        		//Edit Artist Tags.
        		if (mApp.getSharedPreferences().getBoolean("SHOW_ARTIST_EDIT_CAUTION", true)==true) {
            		FragmentTransaction transaction = mListViewFragment.getFragmentManager().beginTransaction();
            		Bundle bundle = new Bundle();
            		bundle.putString("EDIT_TYPE", "ARTIST");
            		bundle.putString("ARTIST", mName);
            		CautionEditArtistsDialog dialog = new CautionEditArtistsDialog();
            		dialog.setArguments(bundle);
            		dialog.show(transaction, "cautionArtistsDialog");
        		} else {
    				FragmentTransaction ft = mListViewFragment.getFragmentManager().beginTransaction();
    				Bundle bundle = new Bundle();
    				bundle.putString("EDIT_TYPE", "ARTIST");
    				bundle.putString("ARTIST", mName);
    				ID3sArtistEditorDialog dialog = new ID3sArtistEditorDialog();
    				dialog.setArguments(bundle);
    				dialog.show(ft, "id3ArtistEditorDialog");
        		}
        		break;
        	case R.id.add_to_queue: 
        		//Add to Queue.
        		AsyncAddToQueueTask task = new AsyncAddToQueueTask(mContext,
        														   mListViewFragment,
        														   "ARTIST",
        														   mName, 
        														   null,
        														   null, 
        														   null, 
        														   null,
        														   null,
        														   null);
        		task.execute();
        		break;
        	case R.id.play_next:
        		AsyncAddToQueueTask playNextTask = new AsyncAddToQueueTask(mContext,
																		   mListViewFragment,
																		   "ARTIST",
																		   mName, 
																		   null,
																		   null, 
																		   null, 
																		   null,
																		   null,
																		   null);
        		playNextTask.execute(new Boolean[] { true });
        		break;
        	case R.id.add_to_playlist:
        		//Add to Playlist
        		FragmentTransaction ft = mListViewFragment.getFragmentManager().beginTransaction();
				AddToPlaylistDialog dialog = new AddToPlaylistDialog();
				Bundle bundle = new Bundle();
				bundle.putString("ADD_TYPE", "ARTIST");
				bundle.putString("ARTIST", mName);
				dialog.setArguments(bundle);
				dialog.show(ft, "AddToPlaylistDialog");
				break;
        	case R.id.blacklist_artist:
        		//Blacklist Artist
        		mApp.getDBAccessHelper().setBlacklistForArtist(mName, true);
        		Toast.makeText(mContext, R.string.artist_blacklisted, Toast.LENGTH_SHORT).show();
        		
        		//Update the ListView.
        		mListViewFragment.mHandler.post(mListViewFragment.queryRunnable);
        		mListViewFragment.getListViewAdapter().notifyDataSetChanged();

        		break;
        	
			}
			
			return false;
		}
    	
    };*/

    /**
     * Holder subclass for ListViewCardsAdapter.
     * 
     * @author Saravan Pantham
     */
	static class ListViewHolder {
	    public TextView trackNumber;
	    public TextView titleText;
	    public TextView subText;
	    public TextView rightSubText;
	    public ImageButton overflowIcon;

	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.DBHelpers;

import java.util.HashMap;
import java.util.HashSet;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

/**
 * SQLite database implementation. Note that this class 
 * only contains methods that access Jams' private 
 * database. For methods that access Android's 
 * MediaStore database, see MediaStoreAccessHelper.
 * 
 * @author Saravan Pantham
 */
public class DBAccessHelper extends SQLiteOpenHelper {

	//Database instance. Will last for the lifetime of the application.
	private static DBAccessHelper sInstance;
	
	//Writable database instance.
	private SQLiteDatabase mDatabase;
	
	//Commmon utils object.
	private Common mApp;
	
	//Database Version.
    private static final int DATABASE_VERSION = 1;
 
    //Database Name.
    private static final String DATABASE_NAME = "Jams.db";
    
    //Common fields.
    public static final String _ID = "_id";
    public static final String SONG_ID = "song_id";
    public static final String EQ_50_HZ = "eq_50_hz";
    public static final String EQ_130_HZ = "eq_130_hz";
    public static final String EQ_320_HZ = "eq_320_hz";
    public static final String EQ_800_HZ = "eq_800_hz";
    public static final String EQ_2000_HZ = "eq_2000_hz";
    public static final String EQ_5000_HZ = "eq_5000_hz";
    public static final String EQ_12500_HZ = "eq_12500_hz";
    public static final String VIRTUALIZER = "eq_virtualizer";
    public static final String BASS_BOOST = "eq_bass_boost";
    public static final String REVERB = "eq_reverb";
    
    //Music folders table.
    public static final String MUSIC_FOLDERS_TABLE = "MusicFoldersTable";
    public static final String FOLDER_PATH = "folder_path";
    public static final String INCLUDE = "include";
    
    //Equalizer settings table for individual songs.
    public static final String EQUALIZER_TABLE = "EqualizerTable";
    
    //Equalizer presets table.
    public static final String EQUALIZER_PRESETS_TABLE = "EqualizerPresetsTable";
    public static final String PRESET_NAME = "preset_name";
    
    //Custom libraries table.
    public static final String LIBRARIES_TABLE = "LibrariesTable";
    public static final String LIBRARY_NAME = "library_name";
    public static final String LIBRARY_TAG = "library_tag";
	
    //Music library table.
    public static final String MUSIC_LIBRARY_TABLE = "MusicLibraryTable";
    public static final String SONG_TITLE = "title";
    public static final String SONG_ARTIST = "artist";
    public static final String SONG_ALBUM = "album";
    public static final String SONG_ALBUM_ARTIST = "album_artist";
    public static final String SONG_DURATION = "duration";
    public static final String SONG_FILE_PATH = "file_path";
    public static final String SONG_TRACK_NUMBER = "track_number";
    public static final String SONG_GENRE = "genre";
    public static final String SONG_PLAY_COUNT = "play_count";
    public static final String SONG_YEAR = "year";
    public static final String SONG_LAST_MODIFIED = "last_modified";
    public static final String SONG_SCANNED = "scanned";
    public static final String SONG_RATING = "rating";
    public static final String BLACKLIST_STATUS = "blacklist_status";
    public static final String ADDED_TIMESTAMP = "added_timestamp";
    public static final String RATING = "rating";
    public static final String LAST_PLAYED_TIMESTAMP = "last_played_timestamp";
    public static final String SONG_SOURCE = "source";
    public static final String SONG_ALBUM_ART_PATH = "album_art_path";
    public static final String SONG_DELETED = "deleted";
    public static final String ARTIST_ART_LOCATION = "artist_art_location";
    public static final String ALBUM_ID = "album_id";
    public static final String ARTIST_ID = "artist_id";
    public static final String GENRE_ID = "genre_id";
    public static final String GENRE_SONG_COUNT = "genre_song_count";
    public static final String LOCAL_COPY_PATH = "local_copy_path";
    public static final String LIBRARIES = "libraries";
    public static final String SAVED_POSITION = "saved_position";
    public static final String ALBUMS_COUNT = "albums_count";
    public static final String SONGS_COUNT = "songs_count";
    public static final String GENRES_SONG_COUNT = "genres_song_count";
    
    //Playlist fields.
    public static final String PLAYLIST_ID = "playlist_id";
    public static final String PLAYLIST_NAME = "playlist_name";
    public static final String PLAYLIST_SOURCE = "playlist_source";
    public static final String PLAYLIST_FILE_PATH = "playlist_file_path";
    public static final String PLAYLIST_FOLDER_PATH = "playlist_folder_path";
    public static final String PLAYLIST_SONG_ENTRY_ID = "song_entry_id";
    public static final String PLAYLIST_ORDER = "order";
    
    //Song source values.
    public static final String GMUSIC = "gmusic";
    public static final String LOCAL = "local";
    
	public DBAccessHelper(Context context) {
		super(context, DATABASE_NAME, null, DATABASE_VERSION);
		mApp = (Common) context.getApplicationContext();
		
	}
	
	/**
	 * Returns a singleton instance for the database. 
	 * @param context
	 * @return
	 */
	public static synchronized DBAccessHelper getInstance(Context context) {
	    if (sInstance==null)
	    	sInstance = new DBAccessHelper(context.getApplicationContext());
	    
	    return sInstance;
	}
	
	/**
	 * Returns a writable instance of the database. Provides an additional 
	 * null check for additional stability.
	 */
	private synchronized SQLiteDatabase getDatabase() {
		if (mDatabase==null)
			mDatabase = getWritableDatabase();

		return mDatabase;
	}
	
	@Override
	public void onCreate(SQLiteDatabase db) {
		
		//Music folders table.
		String[] musicFoldersTableCols = { FOLDER_PATH, INCLUDE };
		String[] musicFoldersTableColTypes = { "TEXT", "TEXT" };
		String createMusicFoldersTable = buildCreateStatement(MUSIC_FOLDERS_TABLE, 
																musicFoldersTableCols, 
																musicFoldersTableColTypes);
		
		//Equalizer table.
		String[] equalizerTableCols = { SONG_ID, EQ_50_HZ, EQ_130_HZ, 
										EQ_320_HZ, EQ_800_HZ, EQ_2000_HZ, 
										EQ_5000_HZ, EQ_12500_HZ, VIRTUALIZER, 
										BASS_BOOST, REVERB };
		
		String[] equalizerTableColTypes = { "TEXT", "TEXT", "TEXT", 
											"TEXT", "TEXT", "TEXT", 
											"TEXT", "TEXT", "TEXT", 
											"TEXT", "TEXT" };
		
		String createEqualizerTable = buildCreateStatement(EQUALIZER_TABLE, 
															 equalizerTableCols,
															 equalizerTableColTypes);
		
		//Equalizer presets table.
		String[] equalizerPresetsTableCols = { PRESET_NAME, EQ_50_HZ, EQ_130_HZ, 
											   EQ_320_HZ, EQ_800_HZ, EQ_2000_HZ, 
											   EQ_5000_HZ, EQ_12500_HZ, VIRTUALIZER, 
											   BASS_BOOST, REVERB };
		
		String[] equalizerPresetsTableColTypes = { "TEXT", "TEXT", "TEXT", 
												   "TEXT", "TEXT", "TEXT", 
												   "TEXT", "TEXT", "TEXT", 
												   "TEXT", "TEXT" };
		
		String createEqualizerPresetsTable = buildCreateStatement(EQUALIZER_PRESETS_TABLE, 
															 		equalizerPresetsTableCols,
															 		equalizerPresetsTableColTypes);
		
		//Custom libraries table.
		String[] librariesTableCols = { LIBRARY_NAME, LIBRARY_TAG, SONG_ID };
		String[] librariesTableColTypes = { "TEXT", "TEXT", "TEXT" };
		String createLibrariesTable = buildCreateStatement(LIBRARIES_TABLE, 
															 librariesTableCols,
															 librariesTableColTypes);
		
		//Music library table.
		String[] musicLibraryTableCols = { SONG_ID, SONG_TITLE, SONG_ARTIST, 
			    						   SONG_ALBUM, SONG_ALBUM_ARTIST, 
			    						   SONG_DURATION, SONG_FILE_PATH, 
			    						   SONG_TRACK_NUMBER, SONG_GENRE, 
			    						   SONG_PLAY_COUNT, SONG_YEAR, ALBUMS_COUNT,
			    						   SONGS_COUNT, GENRES_SONG_COUNT, SONG_LAST_MODIFIED, SONG_SCANNED,
			    						   BLACKLIST_STATUS, ADDED_TIMESTAMP, RATING, 
			    						   LAST_PLAYED_TIMESTAMP, SONG_SOURCE, SONG_ALBUM_ART_PATH,
			    						   SONG_DELETED, ARTIST_ART_LOCATION, ALBUM_ID, 
			    						   ARTIST_ID, GENRE_ID, GENRE_SONG_COUNT, 
			    						   LOCAL_COPY_PATH, LIBRARIES, SAVED_POSITION };
		
		String[] musicLibraryTableColTypes = new String[musicLibraryTableCols.length];
		for (int i=0; i < musicLibraryTableCols.length; i++)
			musicLibraryTableColTypes[i] = "TEXT";
			
		String createMusicLibraryTable = buildCreateStatement(MUSIC_LIBRARY_TABLE, 
															  musicLibraryTableCols,
															  musicLibraryTableColTypes);	

		//Execute the CREATE statements.
		db.execSQL(createMusicFoldersTable);
		db.execSQL(createEqualizerTable);
		db.execSQL(createEqualizerPresetsTable);
		db.execSQL(createLibrariesTable);
		db.execSQL(createMusicLibraryTable);
				
	}

	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
		// TODO Auto-generated method stub
		
	}
	
	@Override
	protected void finalize() {
		try {
			getDatabase().close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	
	/**
	 * Constructs a fully formed CREATE statement using the input 
	 * parameters.
	 */
	private String buildCreateStatement(String tableName, String[] columnNames, String[] columnTypes) {
		String createStatement = "";
		if (columnNames.length==columnTypes.length) {
			createStatement += "CREATE TABLE IF NOT EXISTS " + tableName + "("
							 + _ID + " INTEGER PRIMARY KEY, ";
			
			for (int i=0; i < columnNames.length; i++) {
				
				if (i==columnNames.length-1) {
					createStatement += columnNames[i] 
							 		+ " "
							 		+ columnTypes[i] 
							 		+ ")";
				} else {
					createStatement += columnNames[i] 
									 + " "
									 + columnTypes[i] 
							 		 + ", ";
				}

			}
			
		}
		
		return createStatement;
	}

	/***********************************************************
	 * MUSIC FOLDERS TABLE METHODS.
	 ***********************************************************/
	
	/**
	 * Adds a music folder to the table.
	 */
    public void addMusicFolderPath(String folderPath) {
        //Escape any rogue apostrophes.
        if (folderPath.contains("'")) {
        	folderPath = folderPath.replace("'", "''");
        }
        
        ContentValues values = new ContentValues();
        values.put(FOLDER_PATH, folderPath);

        getDatabase().insert(MUSIC_FOLDERS_TABLE, null, values);
        
    }
    
    /**
     * Deletes the specified music folder from the table.
     */
    public void deleteMusicFolderPath(String folderPath) {
        String condition = FOLDER_PATH + " = '" + folderPath + "'";
        getDatabase().delete(MUSIC_FOLDERS_TABLE, condition, null);
    }
    
   /**
    * Deletes all music folders from the table.
    */
    public void deleteAllMusicFolderPaths() {
        getDatabase().delete(MUSIC_FOLDERS_TABLE, null, null);
    }
    
    /**
     * Returns a cursor with all music folder paths in the table.
     */
    public Cursor getAllMusicFolderPaths() {
        String selectQuery = "SELECT  * FROM " + MUSIC_FOLDERS_TABLE 
        				   + " ORDER BY " + INCLUDE + "*1 DESC";
        
        return getDatabase().rawQuery(selectQuery, null);
    }
	
	/***********************************************************
	 * EQUALIZER TABLE METHODS.
	 ***********************************************************/
	
    /**
	 * Returns an integer array with EQ values for the specified song. 
	 * The final array index (10) indicates whether the specified song 
	 * has any saved EQ values (0 for false, 1 for true).
	 * 
	 * @param songId The id of the song to retrieve EQ values for.
     */
    public int[] getSongEQValues(String songId) {

        String condition = SONG_ID + "=" + "'" + songId + "'";
        String[] columnsToReturn = { _ID, EQ_50_HZ, EQ_130_HZ, EQ_320_HZ, 
        							 EQ_800_HZ, EQ_2000_HZ, EQ_5000_HZ, 
        							 EQ_12500_HZ, VIRTUALIZER, BASS_BOOST, REVERB };
        
        Cursor cursor = getDatabase().query(EQUALIZER_TABLE, columnsToReturn, condition, null, null, null, null);
        int[] eqValues = new int[11];
        
        if (cursor!=null && cursor.getCount()!=0)  {
        	cursor.moveToFirst();
			eqValues[0] = cursor.getInt(cursor.getColumnIndex(EQ_50_HZ));
			eqValues[1] = cursor.getInt(cursor.getColumnIndex(EQ_130_HZ));
			eqValues[2] = cursor.getInt(cursor.getColumnIndex(EQ_320_HZ));
			eqValues[3] = cursor.getInt(cursor.getColumnIndex(EQ_800_HZ));
			eqValues[4] = cursor.getInt(cursor.getColumnIndex(EQ_2000_HZ));
			eqValues[5] = cursor.getInt(cursor.getColumnIndex(EQ_5000_HZ));
			eqValues[6] = cursor.getInt(cursor.getColumnIndex(EQ_12500_HZ));
			eqValues[7] = cursor.getInt(cursor.getColumnIndex(VIRTUALIZER));
			eqValues[8] = cursor.getInt(cursor.getColumnIndex(BASS_BOOST));
			eqValues[9] = cursor.getInt(cursor.getColumnIndex(REVERB));
			eqValues[10] = 1; //The song id exists in the EQ table.
			
			cursor.close();
			
		} else {
			eqValues[0] = 16;
			eqValues[1] = 16;
			eqValues[2] = 16;
			eqValues[3] = 16;
			eqValues[4] = 16;
			eqValues[5] = 16;
			eqValues[6] = 16;
			eqValues[7] = 0;
			eqValues[8] = 0;
			eqValues[9] = 0;
			eqValues[10] = 0; //The song id doesn't exist in the EQ table.
			
		}
        
        return eqValues;
    }
    
    /**
     * Saves a song's equalizer/audio effect settings to the database.
     */
    public void addSongEQValues(String songId, 
						 	    int fiftyHertz, 
						 	    int oneThirtyHertz, 
						 	    int threeTwentyHertz, 
						 	    int eightHundredHertz, 
						 	    int twoKilohertz, 
						 	    int fiveKilohertz, 
						 	    int twelvePointFiveKilohertz, 
						 	    int virtualizer,
						 	    int bassBoost, 
						 	    int reverb) {

		ContentValues values = new ContentValues();
		values.put(SONG_ID, songId);
		values.put(EQ_50_HZ, fiftyHertz);
        values.put(EQ_130_HZ, threeTwentyHertz);
        values.put(EQ_320_HZ, threeTwentyHertz);
        values.put(EQ_800_HZ, eightHundredHertz);
        values.put(EQ_2000_HZ, twoKilohertz);
        values.put(EQ_5000_HZ, fiveKilohertz);
        values.put(EQ_12500_HZ, twelvePointFiveKilohertz);
		values.put(VIRTUALIZER, virtualizer);
		values.put(BASS_BOOST, bassBoost);
		values.put(REVERB, reverb);

        getDatabase().insert(EQUALIZER_TABLE, null, values);
        
    }
    
    /**
     * Checks if equalizer settings already exist for the given song.
     */
    public boolean hasEqualizerSettings(String songId) {
    	
    	String where = SONG_ID + "=" + "'" + songId + "'";
    	Cursor cursor = getDatabase().query(EQUALIZER_TABLE, 
    							 new String[] { SONG_ID }, 
    							 where, 
    							 null, 
    							 null, 
    							 null, 
    							 null);
    	
    	if (cursor!=null) {
    		if (cursor.getCount() > 0) {
    			cursor.close();
    			return true;
    		} else {
    			cursor.close();
    			return false;
    		}
    		
    	} else {
    		return false;
    	}
    	
    }
    
    /**
     * Updates the equalizer/audio effects for the specified song.
     */
    public void updateSongEQValues(String songId, 
							 	   int fiftyHertz, 
							 	   int oneThirtyHertz, 
							 	   int threeTwentyHertz, 
							 	   int eightHundredHertz, 
							 	   int twoKilohertz, 
							 	   int fiveKilohertz, 
							 	   int twelvePointFiveKilohertz, 
							 	   int virtualizer,
							 	   int bassBoost, 
							 	   int reverb) {
     
        ContentValues values = new ContentValues();
        values.put(EQ_50_HZ, fiftyHertz);
        values.put(EQ_130_HZ, threeTwentyHertz);
        values.put(EQ_320_HZ, threeTwentyHertz);
        values.put(EQ_800_HZ, eightHundredHertz);
        values.put(EQ_2000_HZ, twoKilohertz);
        values.put(EQ_5000_HZ, fiveKilohertz);
        values.put(EQ_12500_HZ, twelvePointFiveKilohertz);
		values.put(VIRTUALIZER, virtualizer);
		values.put(BASS_BOOST, bassBoost);
		values.put(REVERB, reverb);
     
        String condition = SONG_ID + " = " + "'" + songId + "'" ;
        getDatabase().update(EQUALIZER_TABLE, values, condition, null);
        
    }
	
	/***********************************************************
	 * EQUALIZER PRESETS TABLE METHODS.
	 ***********************************************************/
	
    /**
     * Adds a new EQ preset to the table.
     */
    public void addNewEQPreset(String presetName, 
					 	     int fiftyHertz, 
					 	     int oneThirtyHertz, 
					 	     int threeTwentyHertz, 
					 	     int eightHundredHertz, 
					 	     int twoKilohertz, 
					 	     int fiveKilohertz, 
					 	     int twelvePointFiveKilohertz, 
					 	     short virtualizer,
					 	     short bassBoost, 
					 	     short reverb) {
    	
		ContentValues values = new ContentValues();
		values.put(PRESET_NAME, presetName);
		values.put(EQ_50_HZ, fiftyHertz);
		values.put(EQ_130_HZ, threeTwentyHertz);
		values.put(EQ_320_HZ, threeTwentyHertz);
		values.put(EQ_800_HZ, eightHundredHertz);
		values.put(EQ_2000_HZ, twoKilohertz);
		values.put(EQ_5000_HZ, fiveKilohertz);
		values.put(EQ_12500_HZ, twelvePointFiveKilohertz);
		values.put(VIRTUALIZER, virtualizer);
		values.put(BASS_BOOST, bassBoost);
		values.put(REVERB, reverb);

        getDatabase().insert(EQUALIZER_PRESETS_TABLE, null, values);
        
    }
  
    /**
     * This method returns the specified eq preset.
     */
    public int[] getPresetEQValues(String presetName) {
    	
        String condition = PRESET_NAME + "=" + "'" + presetName.replace("'", "''") + "'";
        String[] columnsToReturn = { _ID, EQ_50_HZ, EQ_130_HZ, EQ_320_HZ, 
        							 EQ_800_HZ, EQ_2000_HZ, EQ_5000_HZ, 
        							 EQ_12500_HZ, VIRTUALIZER, BASS_BOOST, REVERB };
        
        Cursor cursor = getDatabase().query(EQUALIZER_PRESETS_TABLE, columnsToReturn, condition, null, null, null, null);
        int[] eqValues = new int[10];
        
        if (cursor!=null && cursor.getCount()!=0)  {
			eqValues[0] = cursor.getInt(cursor.getColumnIndex(EQ_50_HZ));
			eqValues[1] = cursor.getInt(cursor.getColumnIndex(EQ_130_HZ));
			eqValues[2] = cursor.getInt(cursor.getColumnIndex(EQ_320_HZ));
			eqValues[3] = cursor.getInt(cursor.getColumnIndex(EQ_800_HZ));
			eqValues[4] = cursor.getInt(cursor.getColumnIndex(EQ_2000_HZ));
			eqValues[5] = cursor.getInt(cursor.getColumnIndex(EQ_5000_HZ));
			eqValues[6] = cursor.getInt(cursor.getColumnIndex(EQ_12500_HZ));
			eqValues[7] = cursor.getInt(cursor.getColumnIndex(VIRTUALIZER));
			eqValues[8] = cursor.getInt(cursor.getColumnIndex(BASS_BOOST));
			eqValues[9] = cursor.getInt(cursor.getColumnIndex(REVERB));
			
			cursor.close();
			
		} else {
			eqValues[0] = 16;
			eqValues[1] = 16;
			eqValues[2] = 16;
			eqValues[3] = 16;
			eqValues[4] = 16;
			eqValues[5] = 16;
			eqValues[6] = 16;
			eqValues[7] = 16;
			eqValues[8] = 16;
			eqValues[9] = 16;
			
		}
        
        return eqValues;
    }
    
    /**
     * This method updates the specified EQ preset.
     */
    public void updateEQPreset(String presetName, 
					 	       int fiftyHertz, 
					 	       int oneThirtyHertz, 
					 	       int threeTwentyHertz, 
					 	       int eightHundredHertz, 
					 	       int twoKilohertz, 
					 	       int fiveKilohertz, 
					 	       int twelvePointFiveKilohertz, 
					 	       short virtualizer,
					 	       short bassBoost, 
					 	       short reverb) {

    	//Escape any rogue apostrophes.
        if (presetName!=null) {
        	
            if (presetName.contains("'")) {
            	presetName = presetName.replace("'", "''");
            }
            
        }
        
        ContentValues values = new ContentValues();
        values.put(EQ_50_HZ, fiftyHertz);
        values.put(EQ_130_HZ, threeTwentyHertz);
        values.put(EQ_320_HZ, threeTwentyHertz);
        values.put(EQ_800_HZ, eightHundredHertz);
        values.put(EQ_2000_HZ, twoKilohertz);
        values.put(EQ_5000_HZ, fiveKilohertz);
        values.put(EQ_12500_HZ, twelvePointFiveKilohertz);
		values.put(VIRTUALIZER, virtualizer);
		values.put(BASS_BOOST, bassBoost);
		values.put(REVERB, reverb);
     
        String condition = PRESET_NAME + " = " + "'" + presetName + "'";
        getDatabase().update(EQUALIZER_PRESETS_TABLE, values, condition, null);
        
    }
    
    /**
     * Returns a cursor with all EQ presets in the table.
     */
    public Cursor getAllEQPresets() {
    	String query = "SELECT * FROM " + EQUALIZER_PRESETS_TABLE;
    	return getDatabase().rawQuery(query, null);
    	
    }
    
    //Deletes the specified preset.
    public void deletePreset(String presetName) {
        String condition = PRESET_NAME + " = " + "'" + presetName.replace("'", "''") + "'";
        getDatabase().delete(EQUALIZER_PRESETS_TABLE, condition, null);
        
    }
	
	/***********************************************************
	 * LIBRARIES TABLE METHODS.
	 ***********************************************************/
	
    /** 
     * Returns a cursor with a list of all unique libraries within the database.
     * @return
     */
    public Cursor getAllUniqueLibraries() {
    	String rawQuery = "SELECT DISTINCT(" + LIBRARY_NAME + "), " + 
						  _ID + ", " + LIBRARY_TAG +
						  " FROM " + LIBRARIES_TABLE + " GROUP BY " + 
						  LIBRARY_NAME + " ORDER BY " + _ID
						  + " ASC";
    	
    	Cursor cursor = getDatabase().rawQuery(rawQuery, null);
    	return cursor;
    }
    
    /**
     * Deletes the specified library by its name and tag.
     */
    public void deleteLibrary(String libraryName, String tag) {
    	
    	//Escape any rogue apostrophes.
    	libraryName = libraryName.replace("'", "''");
    	tag = tag.replace("'", "''");
    	
    	//Perform the delete operation.
    	String where = LIBRARY_NAME + "=" + "'" + libraryName + "'" + " AND " 
    				 + LIBRARY_TAG + "=" + "'" + tag + "'";
    	
    	getDatabase().delete(LIBRARIES_TABLE, where, null);
    }
    
    /**
     * Returns a cursor with all libraries except the default 
     * ones ("All Libraries" and "Google Play Music").
     */
    public Cursor getAllUniqueUserLibraries(Context context) {
    	String allLibraries = context.getResources().getString(R.string.all_libraries);
    	String googlePlayMusic = context.getResources().getString(R.string.google_play_music_no_asterisk);
    	allLibraries = allLibraries.replace("'", "''");
    	googlePlayMusic = googlePlayMusic.replace("'", "''");
    	
    	String rawQuery = "SELECT DISTINCT(" + LIBRARY_NAME + "), " + 
						  _ID + ", " + LIBRARY_TAG +
						  " FROM " + LIBRARIES_TABLE + " WHERE " + 
						  LIBRARY_NAME + "<>" + "'" + allLibraries + "'" + " AND " + 
						  LIBRARY_NAME + "<>" + "'" + googlePlayMusic + "'" + 
						  " GROUP BY " + LIBRARY_NAME + " ORDER BY " + _ID
						  + " ASC";
    	
    	Cursor cursor = getDatabase().rawQuery(rawQuery, null);
    	return cursor;
    }
    
    /**
     * Retrieves a HashSet of all the song ids within a particular music library.
     */
    public HashSet<String> getAllSongIdsInLibrary(String libraryName, String tag) {
    	HashSet<String> songIdsHashSet = new HashSet<String>();
    	
    	libraryName = libraryName.replace("'", "''");
    	tag = tag.replace("'", "''");
    	
    	String where = LIBRARY_NAME + "=" + "'" + libraryName + "'" + " AND "
    				 + LIBRARY_TAG + "=" + "'" + tag + "'";
    	
    	Cursor cursor = getDatabase().query(LIBRARIES_TABLE, null, where, null, null, null, SONG_ID);
    	if (cursor.getCount() > 0) {
    		for (int i=0; i < cursor.getCount(); i++) {
    			cursor.moveToPosition(i);
    			songIdsHashSet.add(cursor.getString(cursor.getColumnIndex(SONG_ID)));
    		}
    		
    	}
    	
    	if (cursor!=null) {
    		cursor.close();
    		cursor = null;
    	}
    	
    	return songIdsHashSet;
    }
	
    /***********************************************************
     * MUSIC LIBRARY TABLE METHODS.
     ***********************************************************/
	
    /**
     * Returns the cursor based on the specified fragment.
     */
    public Cursor getFragmentCursor(Context context, String querySelection, int fragmentId) {
    	String currentLibrary = mApp.getCurrentLibraryNormalized();

	    if (currentLibrary.equals(context.getResources().getString(R.string.all_libraries))) {
	    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
	    		querySelection += "";
	    	} else {
	    		querySelection += " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
	    	}

	    	return getFragmentCursorHelper(querySelection, fragmentId);
	    	
	    } else if (currentLibrary.equals(context.getResources().getString(R.string.google_play_music_no_asterisk))) {
	    	//Check to make sure that Google Play Music is enabled.
	    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
	    		querySelection += " AND " + DBAccessHelper.SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'";
	    		return getFragmentCursorHelper(querySelection, fragmentId);
	    	} else {
	    		return null;
	    	}
	    	
	    } else if (currentLibrary.equals(context.getResources().getString(R.string.on_this_device))) { 
	    	//Check if Google Play Music is enabled.
	    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
	    		querySelection += " AND (" + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " OR "
	    				  		 + DBAccessHelper.LOCAL_COPY_PATH + "<> '')";
	    	} else {
	    		querySelection += " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
	    	}
	    	
	    	return getFragmentCursorHelper(querySelection, fragmentId);
	    	
    	} else {
	    	if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
			    querySelection += " AND " + DBAccessHelper.LIBRARY_NAME + "=" + "'" + currentLibrary + "'";
	    	} else {
			    querySelection += " AND " + DBAccessHelper.LIBRARY_NAME + "=" + "'" + currentLibrary + "'"
	    	              	   + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
	    	}
	    	
	    	return getFragmentCursorInLibraryHelper(querySelection, fragmentId);
	    }
	    
    }
    
    /**
     * Helper method for getFragmentCursor(). Returns the correct 
     * cursor retrieval method for the specified fragment.
     */
    private Cursor getFragmentCursorHelper(String querySelection, int fragmentId) {
    	switch (fragmentId) {
    	case Common.ARTISTS_FRAGMENT:
    		return getAllUniqueArtists(querySelection);
    	case Common.ALBUM_ARTISTS_FRAGMENT:
    		return getAllUniqueAlbumArtists(querySelection);
    	case Common.ALBUMS_FRAGMENT:
    		return getAllUniqueAlbums(querySelection);
    	case Common.SONGS_FRAGMENT:
            querySelection += " ORDER BY " + SONG_TITLE + " ASC";
    		return getAllSongsSearchable(querySelection);
    	case Common.PLAYLISTS_FRAGMENT:
            //TODO case stub.
    	case Common.GENRES_FRAGMENT:
    		return getAllUniqueGenres(querySelection);
    	case Common.FOLDERS_FRAGMENT:
    		//TODO case stub.
    	case Common.ARTISTS_FLIPPED_FRAGMENT:
    		return getAllUniqueAlbumsByArtist(querySelection);
    	case Common.ARTISTS_FLIPPED_SONGS_FRAGMENT:
    		return getAllSongsInAlbumByArtist(querySelection);
    	case Common.ALBUM_ARTISTS_FLIPPED_FRAGMENT:
    		return getAllUniqueAlbumsByAlbumArtist(querySelection);
    	case Common.ALBUM_ARTISTS_FLIPPED_SONGS_FRAGMENT:
    		return getAllSongsInAlbumByAlbumArtist(querySelection);
    	case Common.ALBUMS_FLIPPED_FRAGMENT:
    		return getAllSongsInAlbumByArtist(querySelection);
    	case Common.GENRES_FLIPPED_FRAGMENT:
    		return getAllUniqueAlbumsInGenre(querySelection);
    	case Common.GENRES_FLIPPED_SONGS_FRAGMENT:
    		return getAllSongsInAlbumInGenre(querySelection);
    	default:
    		return null;
    	}
    	
    }
    
    /**
     * Helper method for getFragmentCursor(). Returns the correct 
     * cursor retrieval method for the specified fragment in the 
     * specified library.
     */
    private Cursor getFragmentCursorInLibraryHelper(String querySelection, int fragmentId) {
    	switch (fragmentId) {
    	case Common.ARTISTS_FRAGMENT:
    		return getAllUniqueArtistsInLibrary(querySelection);
    	case Common.ALBUM_ARTISTS_FRAGMENT:
    		return getAllUniqueAlbumArtistsInLibrary(querySelection);
    	case Common.ALBUMS_FRAGMENT:
    		return getAllUniqueAlbumsInLibrary(querySelection);
    	case Common.SONGS_FRAGMENT:
            querySelection += " ORDER BY " + SONG_TITLE + " ASC";
    		return getAllSongsInLibrarySearchable(querySelection);
    	case Common.PLAYLISTS_FRAGMENT:
    		//TODO case stub.
    	case Common.GENRES_FRAGMENT:
    		return getAllUniqueGenresInLibrary(querySelection);
    	case Common.FOLDERS_FRAGMENT:
    		//TODO case stub.
    	case Common.ARTISTS_FLIPPED_FRAGMENT:
    		return getAllUniqueAlbumsByArtistInLibrary(querySelection);
    	case Common.ARTISTS_FLIPPED_SONGS_FRAGMENT:
    		return getAllSongsInAlbumByArtistInLibrary(querySelection);
    	case Common.ALBUM_ARTISTS_FLIPPED_FRAGMENT:
    		return getAllUniqueAlbumsByAlbumArtistInLibrary(querySelection);
    	case Common.ALBUM_ARTISTS_FLIPPED_SONGS_FRAGMENT:
    		return getAllSongsInAlbumByAlbumArtistInLibrary(querySelection);
    	case Common.ALBUMS_FLIPPED_FRAGMENT:
    		return getAllSongsInAlbumByArtistInLibrary(querySelection);
    	case Common.GENRES_FLIPPED_FRAGMENT:
    		return getAllUniqueAlbumsInGenreInLibrary(querySelection);
    	case Common.GENRES_FLIPPED_SONGS_FRAGMENT:
    		return getAllSongsByInAlbumInGenreInLibrary(querySelection);
    	default:
    		return null;
    	}
    	
    }

    /**
     * Returns the playback cursor based on the specified query selection.
     */
    public Cursor getPlaybackCursor(Context context, String querySelection, int fragmentId) {
        String currentLibrary = mApp.getCurrentLibraryNormalized();

        if (currentLibrary.equals(context.getResources().getString(R.string.all_libraries))) {
            if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
                querySelection += "";
            } else {
                querySelection += " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
            }

            return getPlaybackCursorHelper(querySelection, fragmentId);

        } else if (currentLibrary.equals(context.getResources().getString(R.string.google_play_music_no_asterisk))) {
            //Check to make sure that Google Play Music is enabled.
            if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
                querySelection += " AND " + DBAccessHelper.SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'";
                return getPlaybackCursorHelper(querySelection, fragmentId);
            } else {
                return null;
            }

        } else if (currentLibrary.equals(context.getResources().getString(R.string.on_this_device))) {
            //Check if Google Play Music is enabled.
            if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
                querySelection += " AND (" + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'" + " OR "
                        + DBAccessHelper.LOCAL_COPY_PATH + "<> '')";
            } else {
                querySelection += " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
            }

            return getPlaybackCursorHelper(querySelection, fragmentId);

        } else {
            if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
                querySelection += " AND " + DBAccessHelper.LIBRARY_NAME + "=" + "'" + currentLibrary + "'";
            } else {
                querySelection += " AND " + DBAccessHelper.LIBRARY_NAME + "=" + "'" + currentLibrary + "'"
                        + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
            }

            return getPlaybackCursorInLibraryHelper(querySelection, fragmentId);
        }

    }

    /**
     * Helper method for getPlaybackCursor(). Returns the correct
     * cursor retrieval method for the specified playback/fragment route.
     */
    private Cursor getPlaybackCursorHelper(String querySelection, int fragmentId) {
        switch (fragmentId) {
            case Common.PLAY_ALL_BY_ARTIST:
            case Common.PLAY_ALL_BY_ALBUM_ARTIST:
            case Common.PLAY_ALL_BY_ALBUM:
            case Common.PLAY_ALL_IN_GENRE:
            case Common.PLAY_ALL_IN_FOLDER:
                querySelection +=  " ORDER BY " + SONG_TRACK_NUMBER + "*1 ASC";
                break;
            case Common.PLAY_ALL_SONGS:
                querySelection +=  " ORDER BY " + SONG_TITLE + " ASC";
                break;
            case Common.PLAY_ALL_IN_PLAYLIST:
                //TODO Must order the cursor by the order of the playlist's track arrangement.

        }

        return getAllSongsSearchable(querySelection);
    }

    /**
     * Helper method for getPlaybackCursor(). Returns the correct
     * cursor retrieval method for the specified playback/fragment
     * route in the specified library.
     */
    private Cursor getPlaybackCursorInLibraryHelper(String querySelection, int fragmentId) {
        switch (fragmentId) {
            case Common.PLAY_ALL_BY_ARTIST:
            case Common.PLAY_ALL_BY_ALBUM_ARTIST:
            case Common.PLAY_ALL_BY_ALBUM:
            case Common.PLAY_ALL_IN_GENRE:
            case Common.PLAY_ALL_IN_FOLDER:
                querySelection += " ORDER BY " + MUSIC_LIBRARY_TABLE + "." + SONG_TRACK_NUMBER + "*1 ASC";
                break;
            case Common.PLAY_ALL_SONGS:
                querySelection += " ORDER BY " + MUSIC_LIBRARY_TABLE + "." + SONG_TITLE + " ASC";
                break;
            case Common.PLAY_ALL_IN_PLAYLIST:
                //TODO Must order the cursor by the order of the playlist's track arrangement.
        }

        return getAllSongsInLibrarySearchable(querySelection);
    }

    /**
     * Returns a cursor of songs sorted by their track number. Used for
     */
    
    /**
     * Returns a selection cursor of all unique artists.
     */
    public Cursor getAllUniqueArtists(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ARTIST + "), " 
    								 + _ID + ", " + SONG_FILE_PATH + ", " + ARTIST_ART_LOCATION 
    								 + ", " + BLACKLIST_STATUS + ", " + ALBUMS_COUNT + ", "
    								 + SONG_SOURCE + ", " + SONG_ALBUM_ART_PATH + ", " 
    								 + SONG_DURATION + " FROM " + MUSIC_LIBRARY_TABLE 
    								 + " WHERE " + BLACKLIST_STATUS + "=" + "'" 
    								 + "0" + "'" + selection + " GROUP BY " 
    								 + SONG_ARTIST + " ORDER BY " + SONG_ARTIST
    								 + " ASC";
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a selection cursor of all unique artists in the 
     * specified library. The library should be specified in the 
     * selection parameter.
     */
    public Cursor getAllUniqueArtistsInLibrary(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ARTIST + "), " 
    								 + MUSIC_LIBRARY_TABLE + "." + _ID + ", " 
    								 + SONG_FILE_PATH + ", " + ARTIST_ART_LOCATION + ", "
    								 + SONG_SOURCE + ", " + ALBUMS_COUNT + ", " + SONG_DURATION + ", "
    								 + SONG_ALBUM_ART_PATH + " FROM " + MUSIC_LIBRARY_TABLE 
    								 + " INNER JOIN " + DBAccessHelper.LIBRARY_NAME 
    								 + " ON (" + MUSIC_LIBRARY_TABLE + "." + _ID + "=" 
    								 + DBAccessHelper.LIBRARY_NAME + "." 
    								 + DBAccessHelper.SONG_ID + ") WHERE " 
    								 + MUSIC_LIBRARY_TABLE + "." + BLACKLIST_STATUS + "=" 
    								 + "'" + "0" + "'" + selection + " GROUP BY " 
    								 + MUSIC_LIBRARY_TABLE + "." + SONG_ARTIST + " ORDER BY " 
    								 + MUSIC_LIBRARY_TABLE + "." + SONG_ARTIST
    								 + " ASC" ;
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a cursor of all songs by the specified artist.
     */
    public Cursor getAllSongsByArtist(String artistName) {
    	String selection = SONG_ARTIST + "=" + "'" + artistName.replace("'", "''") + "'";
    	return getDatabase().query(MUSIC_LIBRARY_TABLE, null, selection, null, null, null, null);
    	
    }
    
    /**
     * Returns a selection cursor of all unique album artists.
     */
    public Cursor getAllUniqueAlbumArtists(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ALBUM_ARTIST + "), " 
    								 + _ID + ", " + SONG_FILE_PATH + ", " + ARTIST_ART_LOCATION 
    								 + ", " + BLACKLIST_STATUS + ", " + ALBUMS_COUNT + ", " + SONG_SOURCE + ", "
    								 + SONG_ALBUM_ART_PATH + ", " + SONG_DURATION + " FROM " 
    								 + MUSIC_LIBRARY_TABLE + " WHERE " + BLACKLIST_STATUS 
    								 + "=" + "'" + "0" + "'" + selection + " GROUP BY " 
    								 + SONG_ALBUM_ARTIST + " ORDER BY " + SONG_ALBUM_ARTIST
    								 + " ASC";
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a selection cursor of all unique album artists in the 
     * specified library. The library should be specified in the 
     * selection parameter.
     */
    public Cursor getAllUniqueAlbumArtistsInLibrary(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ALBUM_ARTIST + "), " 
    								 + MUSIC_LIBRARY_TABLE + "." + _ID + ", " 
    								 + SONG_FILE_PATH + ", " + ARTIST_ART_LOCATION + ", "
    								 + SONG_SOURCE + ", " + SONG_DURATION + ", " + ALBUMS_COUNT + ", "
    								 + SONG_ALBUM_ART_PATH + " FROM " + MUSIC_LIBRARY_TABLE 
    								 + " INNER JOIN " + DBAccessHelper.LIBRARY_NAME + " ON (" 
    								 + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + DBAccessHelper.LIBRARY_NAME + "." 
    								 + DBAccessHelper.SONG_ID + ") WHERE " 
    								 + MUSIC_LIBRARY_TABLE + "." + BLACKLIST_STATUS + "=" + "'" 
    								 + "0" + "'" + selection + " GROUP BY " + MUSIC_LIBRARY_TABLE 
    								 + "." + SONG_ALBUM_ARTIST + " ORDER BY " + MUSIC_LIBRARY_TABLE 
    								 + "." + SONG_ALBUM_ARTIST
    								 + " ASC" ;
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a cursor with all unique albums by an album artist.
     */
    public Cursor getAllUniqueAlbumsByAlbumArtist(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ALBUM + "), " + 
    								 _ID + ", " + SONG_ARTIST + ", " + SONG_FILE_PATH + ", " + SONG_ALBUM_ARTIST +
    								 ", " + SONG_YEAR + ", " + SONG_SOURCE + ", " + SONG_DURATION + ", " + SONG_ID + ", " +
    								 LOCAL_COPY_PATH + ", " + SONG_ALBUM_ART_PATH + ", " + SONG_TITLE +
    	    						 ", " + SONG_ALBUM + ", " + SONG_GENRE + ", " + SONGS_COUNT + " FROM " +
    								 MUSIC_LIBRARY_TABLE +" WHERE " + BLACKLIST_STATUS + "=" + "'" + 
    								 "0" + "'" + selection + " GROUP BY " + 
    								 SONG_ALBUM + " ORDER BY " + SONG_YEAR
    								 + "*1 ASC";
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a cursor with all unique albums by an album artist, in the specified library.
     */
    public Cursor getAllUniqueAlbumsByAlbumArtistInLibrary(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ALBUM + "), " + MUSIC_LIBRARY_TABLE + "." +
									 _ID + ", " + SONG_ARTIST + ", " + SONG_ALBUM_ARTIST + ", " + SONG_FILE_PATH + ", " + LOCAL_COPY_PATH +
									 ", " + SONG_YEAR + ", " + SONG_SOURCE + ", " + SONG_DURATION + ", " + SONGS_COUNT + ", " +
									 SONG_ALBUM_ART_PATH + ", " + SONG_TITLE + ", " + SONG_ALBUM + ", " + SONG_GENRE + " FROM " + 
									 MUSIC_LIBRARY_TABLE + " INNER JOIN " + LIBRARIES_TABLE + " ON (" 
									 + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + LIBRARIES_TABLE + "." 
									 + SONG_ID + ") WHERE " + BLACKLIST_STATUS + "=" + "'" + 
									 "0" + "'" + selection + " GROUP BY " + SONG_ALBUM + " ORDER BY " + SONG_YEAR
									 + "*1 ASC";
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a selection cursor of all unique albums.
     */
    public Cursor getAllUniqueAlbums(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ALBUM + "), " + 
    								 _ID + ", " + SONG_ARTIST + ", " + SONG_FILE_PATH + ", " + BLACKLIST_STATUS + ", " + 
    								 SONG_ALBUM_ART_PATH + ", " + SONG_SOURCE + ", " + SONG_ALBUM_ARTIST + ", " + SONG_DURATION +
    								 " FROM " + MUSIC_LIBRARY_TABLE + " WHERE " + 
    								 BLACKLIST_STATUS + "=" + "'" + 
    								 "0" + "'" + selection + " GROUP BY " + 
    								 SONG_ALBUM + " ORDER BY " + SONG_ALBUM
    								 + " ASC";
    			
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a selection cursor of all unique albums in the 
     * specified library. The library should be specified in the 
     * selection parameter.
     */
    public Cursor getAllUniqueAlbumsInLibrary(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ALBUM + "), " + 
									 MUSIC_LIBRARY_TABLE + "." + _ID + ", " + SONG_FILE_PATH + ", " + SONG_ALBUM_ARTIST + ", "
									 + SONG_SOURCE + ", " + SONG_DURATION + ", " + SONG_ALBUM_ART_PATH + ", " + SONG_ARTIST + " FROM " + MUSIC_LIBRARY_TABLE 
									 + " INNER JOIN " + DBAccessHelper.LIBRARY_NAME + " ON (" 
									 + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + DBAccessHelper.LIBRARY_NAME + "." 
									 + DBAccessHelper.SONG_ID + ") WHERE " + MUSIC_LIBRARY_TABLE + "." + 
									 BLACKLIST_STATUS + "=" + "'" + "0" + "'" + selection + " GROUP BY " + 
									 MUSIC_LIBRARY_TABLE + "." + SONG_ALBUM + " ORDER BY " + MUSIC_LIBRARY_TABLE + "." + SONG_ALBUM
									 + " ASC" ;
    			
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    }
    
    /** 
     * Returns a cursor of all songs in an album. The album 
     * should be passed in via the selection parameter.
     */
    public Cursor getSongsInAlbum(String selection, String[] projection) {
        return getDatabase().query(MUSIC_LIBRARY_TABLE, projection, selection, null, null, null, SONG_YEAR);
    }
    
    /**
     * Returns a selection cursor of all songs in the database. 
     * This method can also be used to search all songs if a 
     * valid selection parameter is passed.
     */
    public Cursor getAllSongsSearchable(String selection) {
        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + " WHERE " +
        					 BLACKLIST_STATUS + "=" + "'0'" + selection;

        return getDatabase().rawQuery(selectQuery, null);
    }
    
    /**
     * Returns a selection cursor of all songs in the 
     * specified library. The library should be specified in the 
     * selection parameter.
     */
    public Cursor getAllSongsInLibrarySearchable(String selection) {
    	String selectQuery = "SELECT * FROM " + MUSIC_LIBRARY_TABLE 
							  + " INNER JOIN " + LIBRARY_NAME + " ON (" 
							  + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + LIBRARY_NAME + "." 
							  + SONG_ID + ") WHERE " + MUSIC_LIBRARY_TABLE + "." + 
							  BLACKLIST_STATUS + "=" + "'" + "0" + "'" + selection;
    	
        return getDatabase().rawQuery(selectQuery, null);
    }
    
    /**
     * Returns a cursor of all songs in the specified album by the 
     * specified artist.
     */
    public Cursor getAllSongsInAlbum(String albumName, String artistName) {
    	String selection = SONG_ALBUM + "=" + "'" 
    					 + albumName.replace("'", "''") 
    					 + "'" + " AND " + SONG_ARTIST 
    					 + "=" + "'" + artistName.replace("'", "''") 
    					 + "'";
    	
    	return getDatabase().query(MUSIC_LIBRARY_TABLE, null, selection, null, null, null, null);
    	
    }
    
    /**
     * Returns a selection cursor of all unique genres.
     */
    public Cursor getAllUniqueGenres(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_GENRE + "), " + 
    								 _ID + ", " + SONG_FILE_PATH + ", " + SONG_ALBUM_ART_PATH
    								 + ", " + SONG_DURATION + ", " + SONG_SOURCE + ", " + GENRE_SONG_COUNT + " FROM " + 
    								 MUSIC_LIBRARY_TABLE + " WHERE " + 
    								 BLACKLIST_STATUS + "=" + "'" + 
    								 "0" + "'" + selection + " GROUP BY " + 
    								 SONG_GENRE + " ORDER BY " + SONG_GENRE 
    								 + " ASC";
    			
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a selection cursor of all unique genres in the 
     * specified library. The library should be specified in the 
     * selection parameter.
     */
    public Cursor getAllUniqueGenresInLibrary(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_GENRE + "), "+ MUSIC_LIBRARY_TABLE + "." +
									 _ID + ", " + SONG_FILE_PATH + ", " + SONG_ALBUM_ART_PATH + ", " + SONG_DURATION
									 + ", " + SONG_SOURCE + ", " + GENRE_SONG_COUNT + " FROM " + MUSIC_LIBRARY_TABLE 
									 + " INNER JOIN " + LIBRARIES_TABLE + " ON (" 
									 + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + LIBRARIES_TABLE + "." 
									 + SONG_ID + ") WHERE " + 
    								 BLACKLIST_STATUS + "=" + "'" + 
    								 "0" + "'" + selection + " GROUP BY " + 
    								 SONG_GENRE + " ORDER BY " + SONG_GENRE 
    								 + " ASC";
    			
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a cursor with all the songs in the specified genre.
     */
    public Cursor getAllSongsInGenre(String selection) {
    	String selectQuery = "SELECT * FROM " + MUSIC_LIBRARY_TABLE
    					   + " WHERE " + BLACKLIST_STATUS + "=" + "'"
    					   + "0" + "'" + selection + " ORDER BY " + SONG_ALBUM + " ASC, " 
    					   + SONG_TRACK_NUMBER + "*1 ASC";

    	return getDatabase().rawQuery(selectQuery, null);
    	
    }
    
    /**
     * Returns a cursor of all the songs in an album by a specific artist.
     */
    public Cursor getAllSongsInAlbumByArtist(String selection) {
        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + " WHERE " +
        					 BLACKLIST_STATUS + "=" + "'0'" + selection +
        					 " ORDER BY " + SONG_TRACK_NUMBER + "*1 ASC";
        
        return getDatabase().rawQuery(selectQuery, null);
    }
    
    /**
     * Returns a cursor of all the songs in an album by a specific artist, within the specified library.
     */
    public Cursor getAllSongsInAlbumByArtistInLibrary(String selection) {
        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + " INNER JOIN " + LIBRARIES_TABLE + " ON (" 
				 		   + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + LIBRARIES_TABLE + "." 
				 		   + SONG_ID + ") WHERE " +
				 		   BLACKLIST_STATUS + "=" + "'0'" + selection +
				 		   " ORDER BY " + SONG_TRACK_NUMBER + "*1 ASC";
        
        return getDatabase().rawQuery(selectQuery, null);
     
    }
    
    /**
     * Returns a list of all the songs in an album within a specific genre.
     */
    public Cursor getAllSongsInAlbumInGenre(String selection) {
        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + " WHERE " +
        					 BLACKLIST_STATUS + "=" + "'0'" + selection +
        					 " ORDER BY " + SONG_TRACK_NUMBER + "*1 ASC";
        					 
        return getDatabase().rawQuery(selectQuery, null);
    }
    
    /**
     * Returns a list of all the songs in an album by a specific artist, within the specified library.
     */
    public Cursor getAllSongsByInAlbumInArtistInLibrary(String selection) {
        String selectQuery = "SELECT  * FROM " +  LIBRARIES_TABLE + " INNER JOIN " + DBAccessHelper.LIBRARY_NAME + " ON (" 
				 		   + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + DBAccessHelper.LIBRARY_NAME + "." 
				 		   + DBAccessHelper.SONG_ID + ") WHERE " +
				 		   BLACKLIST_STATUS + "=" + "'0'" + selection +
				 		   " ORDER BY " + SONG_TRACK_NUMBER + "*1 ASC";
     
        return getDatabase().rawQuery(selectQuery, null);
    }
    
    /**
     * Returns a list of all the songs in an album in a genre, within the specified library.
     */
    public Cursor getAllSongsByInAlbumInGenreInLibrary(String selection) {

        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + " INNER JOIN " + DBAccessHelper.LIBRARY_NAME + " ON (" 
				 		   + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + DBAccessHelper.LIBRARY_NAME + "." 
				 		   + DBAccessHelper.SONG_ID + ") WHERE " +
				 		   BLACKLIST_STATUS + "=" + "'0'" + selection +
				 		   " ORDER BY " + SONG_TRACK_NUMBER + "*1 ASC";
     
        return getDatabase().rawQuery(selectQuery, null);
    }
    
    /**
     * Returns a list of all the songs in an album by a specific album artist.
     */
    public Cursor getAllSongsInAlbumByAlbumArtist(String selection) {

        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + " WHERE " +
        					 BLACKLIST_STATUS + "=" + "'0'" + selection +
        					 " ORDER BY " + SONG_TRACK_NUMBER + "*1 ASC";
        
        return getDatabase().rawQuery(selectQuery, null);
        
    }
    
    /**
     * Returns a cursor of all the songs in an album by a specific artist, within the specified library.
     */
    public Cursor getAllSongsInAlbumByAlbumArtistInLibrary(String selection) {

        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + " INNER JOIN " + DBAccessHelper.LIBRARY_NAME + " ON (" 
				 		   + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + DBAccessHelper.LIBRARY_NAME + "." 
				 		   + DBAccessHelper.SONG_ID + ") WHERE " +
				 		   BLACKLIST_STATUS + "=" + "'0'" + selection +
				 		   " ORDER BY " + SONG_TRACK_NUMBER + "*1 ASC";
     
        return getDatabase().rawQuery(selectQuery, null);
        
    }
    
    /**
     * Returns a list of all the songs in an album by an album artist, within the specified library.
     */
    public Cursor getAllSongsByAlbumArtistInLibrary(String selection) {

        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + " INNER JOIN " + DBAccessHelper.LIBRARY_NAME + " ON (" 
				 		   + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + DBAccessHelper.LIBRARY_NAME + "." 
				 		   + DBAccessHelper.SONG_ID + ") WHERE " +
				 		   BLACKLIST_STATUS + "=" + "'0'" + selection +
				 		   " ORDER BY " + SONG_ALBUM + " ASC, " + SONG_TRACK_NUMBER + "*1 ASC";
     
        return getDatabase().rawQuery(selectQuery, null);
    }
    
    /**
     * Returns a cursor of all locally stored files on the device.
     */
    public Cursor getAllLocalSongs() {
    	String where = SONG_SOURCE + "='local'";
    	String[] columns = { SONG_FILE_PATH };
    	
    	return getDatabase().query(MUSIC_LIBRARY_TABLE, columns, where, null, null, null, null);
    	
    }
    
    /**
     * Deletes all Google Play Music entries in the table.
     */
    public void deleteAllGooglePlayMusicSongs() {
    	String where = SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'";
    	getDatabase().delete(MUSIC_LIBRARY_TABLE, where, null);
    }
    
    /**
     * Returns the number of songs in the specified genre.
     */
    public int getGenreSongCount(String genreName) {
    	String selection = SONG_GENRE + "=" + "'" + genreName.replace("'", "''") + "'";
    	Cursor cursor = getDatabase().query(MUSIC_LIBRARY_TABLE, null, selection, null, null, null, null);
    	
    	int songCount = cursor.getCount();
    	cursor.close();
    	return songCount;
    	
    }
    
    /**
     * Insert the number of songs within a specifed genre.
     */
    public void insertNumberOfSongsInGenre(String genre, int songCount) {
    	ContentValues values = new ContentValues();
		values.put(DBAccessHelper.GENRE_SONG_COUNT, songCount);
		String where = DBAccessHelper.SONG_GENRE + "=" + "'" + genre + "'";
		
		getDatabase().update(MUSIC_LIBRARY_TABLE, 
				  				 values, 
				  				 where, 
				  				 null);
		
    }
    
    /**
     * Returns a song based on its file path.
     */
    public Cursor getSongFromFilePath(String filePath) {
        String selection = SONG_FILE_PATH + "=" + "'" + filePath.replace("'", "''") + "'";
        return getDatabase().query(MUSIC_LIBRARY_TABLE, null, selection, null, null, null, null);
        
    }
    
    /**
     * Updates a song's "scanned" flag during the scanning process.
     */
    public void updateScannedFlag(String filePath) {
        String selection = SONG_FILE_PATH + "=" + "'" + filePath.replace("'", "''") + "'";
        
        ContentValues values = new ContentValues();
        values.put(SONG_SCANNED, "TRUE");
        
        getDatabase().update(MUSIC_LIBRARY_TABLE, values, selection, null);
     
    }
    
    /**
     * Deletes all songs whose "scanned" flag is false.
     */
    public void deleteAllUnscannedSongs() {
        String selection = SONG_SCANNED + "=" + "'FALSE'";
        getDatabase().delete(MUSIC_LIBRARY_TABLE, selection, null);
        
    }
    
    /**
     * Deletes a song that has the specified file path.
     */
    public void deleteSongByFilePath(String filePath) {
        String selection = SONG_FILE_PATH + "=" + "'" + filePath.replace("'", "''") +"'";
        getDatabase().delete(MUSIC_LIBRARY_TABLE, selection, null);
        
    }
    
    /**
     * Resets the SONG_SCANNED flag for all songs.
     */
    public void resetSongScannedFlags() {
    	ContentValues values = new ContentValues();
    	values.put(SONG_SCANNED, "FALSE");
    	
    	getDatabase().update(MUSIC_LIBRARY_TABLE, values, null, null);

    }
    
    /**
     * Returns a cursor of all songs in the specified playlist, with an additional selection parameter.
     */
    public Cursor getAllSongsInPlaylistSearchable(String selection) {
    	/*String selectQuery = "SELECT * FROM " + MUSIC_LIBRARY_TABLE
							  + " INNER JOIN " + DBAccessHelper.MUSIC_LIBRARY_PLAYLISTS_NAME + " ON (" 
							  + MUSIC_LIBRARY_TABLE + "." + SONG_FILE_PATH + "=" 
							  + DBAccessHelper.MUSIC_LIBRARY_PLAYLISTS_NAME + "." 
							  + DBAccessHelper.PLAYLIST_SONG_FILE_PATH + ") WHERE " + MUSIC_LIBRARY_TABLE + "."
							  + BLACKLIST_STATUS + "=" + "'" + "0" + "'" + selection + " ORDER BY " 
							  + DBAccessHelper.MUSIC_LIBRARY_PLAYLISTS_NAME 
							  + "." + DBAccessHelper.PLAYLIST_ORDER + "*1 ASC" ;
    	
        return getDatabase().rawQuery(selectQuery, null);*/
    	return null;

    }
    
    /**
     * Returns a cursor with the top 25 played tracks in the library.
     */
    public Cursor getTop25PlayedTracks(String selection) {
    	return getDatabase().query(MUSIC_LIBRARY_TABLE, 
								 	   null, 
								 	   selection, 
								 	   null, 
								 	   null,
								 	   null,
								 	   SONG_PLAY_COUNT + "*1 DESC",
								 	   "25");
    	
    }
    
    /**
     * Returns a cursor with all songs, ordered by their add date.
     */
    public Cursor getRecentlyAddedSongs(String selection) {
    	return getDatabase().query(MUSIC_LIBRARY_TABLE,
    							 	   null,
    							 	   selection,
    							 	   null,
    							 	   null,
    							 	   null,
    							 	   ADDED_TIMESTAMP + "*1 DESC",
    								   "25");
    	
    }
    
    /**
     * Returns a cursor with all songs, ordered by their rating.
     */
    public Cursor getTopRatedSongs(String selection) {
    	return getDatabase().query(MUSIC_LIBRARY_TABLE,
    							 	   null,
    							 	   selection,
    							 	   null,
    							 	   null,
    							 	   null,
    							 	   RATING + "*1 DESC",
    							 	   "25");
    	
    }
    
    /**
     * Returns a cursor with all songs, ordered by their last played timestamp.
     */
    public Cursor getRecentlyPlayedSongs(String selection) {
    	return getDatabase().query(MUSIC_LIBRARY_TABLE,
    							 	   null,
    							 	   selection,
    							 	   null,
    							 	   null,
    							 	   null,
    							 	   LAST_PLAYED_TIMESTAMP + "*1 DESC",
    							 	   "25");

    }
    
    /**
     * Returns the local copy path for the specified song.
     */
    public String getLocalCopyPath(String songID) {
    	String[] columns = { _ID, LOCAL_COPY_PATH };
    	String where = SONG_ID + "=" + "'" + songID.replace("'", "''") + "'" + " AND " +
    				   SONG_SOURCE + "=" + "'GOOGLE_PLAY_MUSIC'";
    	
    	Cursor cursor = getDatabase().query(MUSIC_LIBRARY_TABLE, columns, where, null, null, null, null);
    	String localCopyPath = null;
    	if (cursor!=null) {
    		if (cursor.getCount() > 0) {
    			cursor.moveToFirst();
    			localCopyPath = cursor.getString(cursor.getColumnIndex(LOCAL_COPY_PATH));
    			
    		}
    		
    	}
    	
    	return localCopyPath;
    			 
    }
    
    /**
     * Saves the last playback position for the specified song.
     */
    public void setLastPlaybackPosition(String songId, long lastPlaybackPosition) {
    	if (songId!=null) {
    		songId = songId.replace("'", "''");
    	} else {
    		return;
    	}
    	
    	String where = SONG_ID + "=" + "'" + songId + "'";
    	ContentValues values = new ContentValues();
    	values.put(SAVED_POSITION, lastPlaybackPosition);
    	
    	getDatabase().update(MUSIC_LIBRARY_TABLE, values, where, null);
    	
    }
    
    /**
     * Sets the blacklist status of the specified artist.
     */
    public void setBlacklistForArtist(String artistName, boolean blacklist) {
    	String where = SONG_ARTIST + "=" + "'" + artistName.replace("'", "''") + "'";
    	ContentValues values = new ContentValues();
    	values.put(BLACKLIST_STATUS, blacklist);
    	getDatabase().update(MUSIC_LIBRARY_TABLE, values, where, null);
    	
    }
    
    /**
     * Sets the blacklist status of the specified album artist.
     */
    public void setBlacklistForAlbumArtist(String albumArtistName, boolean blacklist) {
    	String where = SONG_ALBUM_ARTIST + "=" + "'" + albumArtistName.replace("'", "''") + "'";
    	ContentValues values = new ContentValues();
    	values.put(BLACKLIST_STATUS, blacklist);
    	getDatabase().update(MUSIC_LIBRARY_TABLE, values, where, null);
    	
    }
    
    /**
     * Sets the blacklist status of the specified album.
     */
    public void setBlacklistForAlbum(String albumName, String artistName, boolean blacklist) {
    	String where = SONG_ALBUM + "=" + "'" + albumName.replace("'", "''") + "'"
    				 + " AND " + SONG_ARTIST + "=" + "'" + artistName.replace("'", "''");
    	ContentValues values = new ContentValues();
    	values.put(BLACKLIST_STATUS, blacklist);
    	getDatabase().update(MUSIC_LIBRARY_TABLE, values, where, null);
    	
    }
    
    /**
     * Sets the blacklist status of the specified song.
     */
    public void setBlacklistForSong(String songId, boolean blacklist) {
    	String where = SONG_ID + "=" + "'" + songId + "'";
    	ContentValues values = new ContentValues();
    	values.put(BLACKLIST_STATUS, blacklist);
    	getDatabase().update(MUSIC_LIBRARY_TABLE, values, where, null);
    	
    }
    
    /**
     * Returns the album art path of the specified song.
     */
    public String getAlbumArtBySongId(String songId) {
    	String where = SONG_ID + "=" + "'" + songId + "'";
    	Cursor cursor = getDatabase().query(MUSIC_LIBRARY_TABLE, 
    											new String[] { _ID, SONG_ALBUM_ART_PATH }, 
    											where, 
    											null, 
    											null, 
    											null, 
    											null);
    	
    	if (cursor!=null) {
    		cursor.moveToFirst();
    		String albumArtPath = cursor.getString(cursor.getColumnIndex(SONG_ALBUM_ART_PATH));
    		cursor.close();
    		return albumArtPath;
    	} else {    		
    		return null;
    	}
    	
    }
    
    /**
     * Returns a cursor of all the songs in the current table.
     */
    public Cursor getAllSongs() {
        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + " WHERE " +
        					 BLACKLIST_STATUS + "=" + "'0'" + " ORDER BY " + SONG_TITLE + " ASC";
        
        return getDatabase().rawQuery(selectQuery, null);
     
    }
    
    /**
     * Returns the rating for the specified song.
     */
    public int getSongRating(String songId) {
    	String where = SONG_ID + "=" + "'" + songId + "'";
    	Cursor cursor = getDatabase().query(MUSIC_LIBRARY_TABLE, 
    										    new String[] { _ID, SONG_RATING }, 
    										    where, 
    										    null, 
    										    null, 
    										    null, 
    										    null);
    	
    	int songRating = 0;
    	if (cursor!=null) {
    		songRating = cursor.getInt(cursor.getColumnIndex(SONG_RATING));
    		cursor.close();
    	}
    	
    	return songRating;
    	
    }
    
    /**
     * Sets the rating for the specified song.
     */
    public void setSongRating(String songId, int rating) {
    	String where = SONG_ID + "=" + "'" + songId + "'";
    	ContentValues values = new ContentValues();
    	values.put(SONG_RATING, rating);
    	getDatabase().update(MUSIC_LIBRARY_TABLE, values, where, null);
    	
    }
    
    /**
     * Returns a cursor with all the albums in the specified genre.
     */
    public Cursor getAllUniqueAlbumsInGenre(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ALBUM + "), " + 
				 _ID + ", " + SONG_ARTIST + ", " + SONG_FILE_PATH + ", " + 
    			 BLACKLIST_STATUS + ", " + SONG_GENRE + ", " + SONG_YEAR + ", " +
				 SONG_ALBUM_ART_PATH + ", " + SONG_SOURCE + ", " + SONGS_COUNT + ", " +
    			 SONG_ALBUM_ARTIST + ", " + SONG_DURATION + ", " + LOCAL_COPY_PATH
				 + " FROM " + MUSIC_LIBRARY_TABLE + " WHERE " + 
				 BLACKLIST_STATUS + "=" + "'" + 
				 "0" + "'" + selection + " GROUP BY " + 
				 SONG_ALBUM + " ORDER BY " + SONG_ALBUM
				 + " ASC";

    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a cursor with unique albums in the specified genre, within the specified library.
     */
    public Cursor getAllUniqueAlbumsInGenreInLibrary(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ALBUM + "), " + 
									 MUSIC_LIBRARY_TABLE + "." + _ID + ", " + SONG_FILE_PATH + ", " + SONG_ALBUM_ARTIST + ", "
									 + SONG_SOURCE + ", " + SONG_DURATION + ", " + SONG_ALBUM_ART_PATH + ", " + SONG_ARTIST 
									 + ", " + SONG_GENRE + ", " + SONG_YEAR + ", " + SONGS_COUNT + ", " + LOCAL_COPY_PATH + " FROM " + MUSIC_LIBRARY_TABLE
									 + " INNER JOIN " + LIBRARIES_TABLE + " ON (" 
									 + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + LIBRARIES_TABLE + "." 
									 + SONG_ID + ") WHERE " + MUSIC_LIBRARY_TABLE + "." + 
									 BLACKLIST_STATUS + "=" + "'" + "0" + "'" + selection + " GROUP BY " + 
									 MUSIC_LIBRARY_TABLE + "." + SONG_ALBUM + " ORDER BY " + MUSIC_LIBRARY_TABLE + "." + SONG_ALBUM
									 + " ASC";

    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a cursor of all blacklisted artists.
     */
    public Cursor getBlacklistedArtists() {
    	String query = "SELECT DISTINCT(" + SONG_ARTIST + "), " + 
						_ID + ", " + SONG_FILE_PATH + ", " + 
						SONG_ALBUM_ART_PATH + ", " + SONG_SOURCE + ", " + SONG_ALBUM_ARTIST +
						" FROM " + MUSIC_LIBRARY_TABLE + " WHERE " + 
						BLACKLIST_STATUS + "=" + "'" + 
						"1" + "'" + " GROUP BY " + 
						SONG_ALBUM + " ORDER BY " + SONG_ALBUM
						+ " ASC";
    	
    	return getDatabase().rawQuery(query, null);
    	
    }
    
    /**
     * Returns a cursor of all blacklisted albmums.
     */
    public Cursor getBlacklistedAlbums() {
    	String query = "SELECT DISTINCT(" + SONG_ALBUM + "), " + 
						_ID + ", " + SONG_ARTIST + ", " + SONG_FILE_PATH + ", " + 
						SONG_ALBUM_ART_PATH + ", " + SONG_SOURCE + ", " + SONG_ALBUM_ARTIST +
						" FROM " + MUSIC_LIBRARY_TABLE + " WHERE " + 
						BLACKLIST_STATUS + "=" + "'" + 
						"1" + "'" + " GROUP BY " + 
						SONG_ALBUM + " ORDER BY " + SONG_ALBUM
						+ " ASC";
    	
    	return getDatabase().rawQuery(query, null);
    	
    }
    
    /**
     * Returns a list of all blacklisted songs.
     */
    public Cursor getAllBlacklistedSongs() {
        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + 
        					 " WHERE " + BLACKLIST_STATUS + "=" + "'1'" + 
        					 " ORDER BY " + SONG_TITLE + " ASC";
     
        return getDatabase().rawQuery(selectQuery, null);
        
    }
    
    /**
     * Returns a list of all the albums sorted by name.
     */
    public Cursor getAllAlbumsOrderByName() {
        String selectQuery = "SELECT DISTINCT(" + SONG_ALBUM + "), " + 
							 _ID + ", " + SONG_ARTIST + ", " + SONG_FILE_PATH + ", " + 
							 SONG_ALBUM_ART_PATH + ", " + SONG_SOURCE + ", " + SONG_ALBUM_ARTIST +
							 " FROM " + MUSIC_LIBRARY_TABLE + " WHERE " + 
							 BLACKLIST_STATUS + "=" + "'" + 
							 "0" + "'" + " GROUP BY " + 
							 SONG_ALBUM + " ORDER BY " + SONG_ALBUM
							 + " ASC";
     
        return getDatabase().rawQuery(selectQuery, null);
        
    }
    
    /**
     * Returns a list of all the artists sorted by name.
     */
    public Cursor getAllArtistsOrderByName() {

        String selectQuery = "SELECT DISTINCT(" + SONG_ARTIST + "), " + 
							 _ID + ", " + SONG_ARTIST + ", " + SONG_FILE_PATH + ", " + 
							 SONG_ALBUM_ART_PATH + ", " + SONG_SOURCE + ", " + SONG_ALBUM_ARTIST +
							 " FROM " + MUSIC_LIBRARY_TABLE + " WHERE " + 
							 BLACKLIST_STATUS + "=" + "'" + 
							 "0" + "'" + " GROUP BY " + 
							 SONG_ARTIST + " ORDER BY " + SONG_ARTIST
							 + " ASC";
     
        return getDatabase().rawQuery(selectQuery, null);
        
    }
    
    /**
     * Returns a cursor with the specified song.
     */
    public Cursor getSongById(String songID) {
    	String selection = SONG_ID + "=" + "'" +  songID + "'";
    	return getDatabase().query(MUSIC_LIBRARY_TABLE, null, selection, null, null, null, null);
	 
    }
    
    /**
     * Returns a list of all the songs by an album artist.
     */
    public Cursor getAllSongsByAlbumArtist(String selection) {
        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + " WHERE " +
        					 BLACKLIST_STATUS + "=" + "'0'" + selection +
        					 " ORDER BY " + SONG_TRACK_NUMBER + "*1 ASC";
        
        return getDatabase().rawQuery(selectQuery, null);
        
    }
    
    //Updates the blacklist statuses of the songs specified in the HashMap.
    public void batchUpdateSongBlacklist(HashMap<String, Boolean> songIdBlacklistStatusPair) {
    	
    	//Retrieve the list of all keys (songIds) within the HashMap.
    	String[] songIdsArray = new String[songIdBlacklistStatusPair.size()];
    	songIdBlacklistStatusPair.keySet().toArray(songIdsArray);
    	
    	for (int i=0; i < songIdsArray.length; i++) {
    		String songId = songIdsArray[i];
    		boolean blacklistStatus = songIdBlacklistStatusPair.get(songId);
    		
    		ContentValues values = new ContentValues();
    		values.put(BLACKLIST_STATUS, blacklistStatus);
    		
    		String where = _ID + "=" + "'" + songId + "'";
    		getDatabase().update(MUSIC_LIBRARY_TABLE, values, where, null);
    		
    	}

    }
    
    /**
     * Returns a HashMap of all the songIds and their blacklist status.
     */
    public HashMap<String, Boolean> getAllSongIdsBlacklistStatus() {
    	HashMap<String, Boolean> songIdBlacklistStatusPair = new HashMap<String, Boolean>();
    	
    	String[] columns = { _ID, BLACKLIST_STATUS };
    	Cursor cursor = getDatabase().query(MUSIC_LIBRARY_TABLE, columns, null, null, null, null, null);

        if (cursor==null)
            return null;

    	if (cursor.getCount() > 0) {
    		for (int i=0; i < cursor.getCount(); i++) {
    			cursor.moveToPosition(i);
    			String songId = cursor.getString(cursor.getColumnIndex(_ID));
    			boolean blacklistStatus = cursor.getString(cursor.getColumnIndex(BLACKLIST_STATUS)).equals("true");
    			songIdBlacklistStatusPair.put(songId, blacklistStatus);
    		}
    		
    	}
    	

    	cursor.close();
    	return songIdBlacklistStatusPair;
    }
    
    /**
     * Returns a cursor with unique albums within the database, regardless of the blacklist status.
     */
    public Cursor getAllUniqueAlbumsNoBlacklist(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ALBUM + "), " + 
    								 _ID + ", " + SONG_ARTIST + ", " + SONG_FILE_PATH + ", " + BLACKLIST_STATUS + ", " + 
    								 SONG_ALBUM_ART_PATH + ", " + SONG_SOURCE + ", " + SONG_ALBUM_ARTIST +
    								 " FROM " + MUSIC_LIBRARY_TABLE + " GROUP BY " + 
    								 SONG_ALBUM + " ORDER BY " + SONG_ALBUM
    								 + " ASC";
    			
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a cursor with unique artists within the database, regardless of the blacklist status.
     */
    public Cursor getAllUniqueArtistsNoBlacklist(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ARTIST + "), " + 
    								 _ID + ", " + SONG_FILE_PATH + ", " + ARTIST_ART_LOCATION + ", " + BLACKLIST_STATUS + ", "
    								 + SONG_SOURCE + ", " + SONG_ALBUM_ART_PATH + " FROM " + MUSIC_LIBRARY_TABLE 
    								 + " GROUP BY " + SONG_ARTIST + " ORDER BY " + SONG_ARTIST + " ASC";
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a list of all songs irrespective of the blacklist status.
     */
    public Cursor getAllSongsNoBlacklist() {
        String selectQuery = "SELECT  * FROM " +  MUSIC_LIBRARY_TABLE + " ORDER BY " + SONG_TITLE + " ASC";
        return getDatabase().rawQuery(selectQuery, null);
        
    }
    
   /**
    * Returns a cursor with unique albums by an artist.
    */
    public Cursor getAllUniqueAlbumsByArtist(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ALBUM + "), " + 
    								 _ID + ", " + SONG_ARTIST + ", " + SONG_FILE_PATH + ", " + SONGS_COUNT +
    								 ", " + SONG_YEAR + ", " + SONG_SOURCE + ", " + SONG_DURATION + ", " +
    								 LOCAL_COPY_PATH + ", " + SONG_ALBUM_ART_PATH + ", " + SONG_TITLE +
    	    						 ", " + SONG_ALBUM + ", " + SONG_GENRE + " FROM " + 
    								 MUSIC_LIBRARY_TABLE +" WHERE " + BLACKLIST_STATUS + "=" + "'" + 
    								 "0" + "'" + selection + " GROUP BY " + 
    								 SONG_ALBUM + " ORDER BY " + SONG_YEAR
    								 + "*1 ASC";
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    	
    }
    
    /**
     * Returns a cursor with unique albums by an artist within the specified library.
     */
    public Cursor getAllUniqueAlbumsByArtistInLibrary(String selection) {
    	String selectDistinctQuery = "SELECT DISTINCT(" + SONG_ALBUM + "), " + MUSIC_LIBRARY_TABLE + "." +
									 _ID + ", " + SONG_ARTIST + ", " + SONG_FILE_PATH + ", " + LOCAL_COPY_PATH +
									 ", " + SONG_YEAR + ", " + SONG_SOURCE + ", " + SONG_DURATION + ", " + SONGS_COUNT + ", " +
									 SONG_ALBUM_ART_PATH + ", " + SONG_TITLE + ", " + SONG_ALBUM + ", " + SONG_GENRE + " FROM " + 
									 MUSIC_LIBRARY_TABLE + " INNER JOIN " + LIBRARIES_TABLE + " ON (" 
									 + MUSIC_LIBRARY_TABLE + "." + _ID + "=" + LIBRARIES_TABLE + "." 
									 + SONG_ID + ") WHERE " + BLACKLIST_STATUS + "=" + "'" + 
									 "0" + "'" + selection + " GROUP BY " + SONG_ALBUM + " ORDER BY " + SONG_YEAR
									 + "*1 ASC";
    	
    	return getDatabase().rawQuery(selectDistinctQuery, null);
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.DBHelpers;

import android.content.ContentResolver;
import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.provider.MediaStore;

/**
 * Helper class that contains methods that access 
 * Android's MediaStore. For methods that access 
 * Jams' private database, see DBAccessHelper.
 * 
 * @author Saravan Pantham
 */
public class MediaStoreAccessHelper {

	/* Hidden album artist field. See: http://stackoverflow.com/questions/20710542/
	 * why-doesnt-mediastore-audio-albums-external-content-uri-provide-an-accurate-al
	 */
	public static final String ALBUM_ARTIST = "album_artist";

	/**
	 * Queries MediaStore and returns a cursor with songs limited 
	 * by the selection parameter.
	 */
	public static Cursor getAllSongsWithSelection(Context context, 
												  String selection, 
												  String[] projection, 
												  String sortOrder) {
		
		ContentResolver contentResolver = context.getContentResolver();
		Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
		
		return contentResolver.query(uri, projection, selection, null, sortOrder);
		
	}
	
	/**
	 * Queries MediaStore and returns a cursor with all songs.
	 */
	public static Cursor getAllSongs(Context context, 
									 String[] projection, 
									 String sortOrder) {
		
		ContentResolver contentResolver = context.getContentResolver();
		Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
		String selection = MediaStore.Audio.Media.IS_MUSIC + "!= 0";
		
		return contentResolver.query(uri, null, selection, null, sortOrder);
		
	}
	
	/**
	 * Queries MediaStore and returns a cursor with all unique artists, 
	 * their ids, and their number of albums.
	 */
	public static Cursor getAllUniqueArtists(Context context) {
		ContentResolver contentResolver = context.getContentResolver();
		String[] projection = { MediaStore.Audio.Artists._ID, 
							    MediaStore.Audio.Artists.ARTIST, 
							    MediaStore.Audio.Artists.NUMBER_OF_ALBUMS };
		
		return contentResolver.query(MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI, 
									 projection, 
									 null, 
									 null, 
									 MediaStore.Audio.Artists.ARTIST + " ASC");
		
	}
	
	/**
	 * Queries MediaStore and returns a cursor with all unique albums, 
	 * their ids, and their number of songs.
	 */
	public static Cursor getAllUniqueAlbums(Context context) {
		ContentResolver contentResolver = context.getContentResolver();
		String[] projection = { MediaStore.Audio.Albums._ID, 
							    MediaStore.Audio.Albums.ALBUM, 
							    MediaStore.Audio.Albums.NUMBER_OF_SONGS };
		
		return contentResolver.query(MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI, 
									 projection, 
									 null, 
									 null, 
									 MediaStore.Audio.Albums.ALBUM + " ASC");
		
	}
	
	/**
	 * Queries MediaStore and returns a cursor with all unique genres 
	 * and their ids.
	 */
	public static Cursor getAllUniqueGenres(Context context) {
		ContentResolver contentResolver = context.getContentResolver();
		String[] projection = { MediaStore.Audio.Genres._ID, 
							    MediaStore.Audio.Genres.NAME };
		
		return contentResolver.query(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, 
									 projection, 
									 null, 
									 null, 
									 MediaStore.Audio.Genres.NAME + " ASC");
		
	}

    /**
     * Queries MediaStore and returns a cursor with all unique playlists.
     */
    public static Cursor getAllUniquePlaylists(Context context) {
        ContentResolver contentResolver = context.getContentResolver();
        String[] projection = { MediaStore.Audio.Playlists._ID,
                                MediaStore.Audio.Playlists.NAME };

        return contentResolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
                                     projection,
                                     null,
                                     null,
                                     MediaStore.Audio.Playlists.NAME + " ASC");

    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.DBHelpers;

import java.io.FileDescriptor;
import java.io.PrintWriter;
import java.util.Arrays;

import android.content.ContentResolver;
import android.content.Context;
import android.database.ContentObserver;
import android.database.Cursor;
import android.net.Uri;
import android.support.v4.content.AsyncTaskLoader;

/*********************************************************************************
 * Custom CursorLoader class that adds support for SQLite databases.
 * The default CursorLoader that's supplied through the Android
 * compatibility library only supports ContentProviders. 
 * 
 * Since this app maintains it's own music library/database and doesn't depend 
 * on Android's MediaStore ContentProvider, we need a way to channel 
 * queries directly to a raw SQLite database. This class simply replaces 
 * every instance of a ContentProvider query with queries that connect 
 * directly to an SQLite database.
 * 
 * @author Saravan Pantham
 *********************************************************************************/
public class SQLiteDBCursorLoader extends AsyncTaskLoader<Cursor> {
    final ForceLoadContentObserver mObserver;

    String mTableName;
    String[] mProjection;
    String mSelection;
    String[] mSelectionArgs;
    String mSortOrder;
    String mLimit = null;

    Cursor mCursor;
    boolean mDistinctPlaylists = false;
    boolean mDistinctGenres = false;
    String mDistinctField = "";

    /* Runs on a worker thread */
    @Override
    public Cursor loadInBackground() {
    	
    /*	//Retrieve the appropriate cursor based on @param mDistinctField;
    	Cursor cursor = null;
    	if (mDistinctField.equals("PLAYLISTS")) {
    		DBAccessHelper playlistsDBHelper = new DBAccessHelper(getContext());
    		cursor = playlistsDBHelper.getAllUniquePlaylists(mSelection);
    		
    	} else if (mDistinctField.equals("GENRES")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getAllUniqueGenres(mSelection);

    	} else if (mDistinctField.equals("ARTISTS")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getAllUniqueArtists(mSelection);
    		
    	} else if (mDistinctField.equals("ALBUMS")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getAllUniqueAlbums(mSelection);
    		
    	} else if (mDistinctField.equals("SONGS")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getAllSongsSearchable(mSelection);
    		
    	} else if (mDistinctField.equals("ARTISTS_FLIPPED")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getAllUniqueAlbumsByArtist(mSelection);
    		
    	} else if (mDistinctField.equals("ARTISTS_FLIPPED_SONGS")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getAllSongsByArtistAlbum(mSelection);
    		
    	} else if (mDistinctField.equals("ALBUMS_FLIPPED")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getAllSongsByArtistAlbum(mSelection);
    		
    	} else if (mDistinctField.equals("TOP_25_PLAYED")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getTop25PlayedTracks(mSelection);
    		
    	} else if (mDistinctField.equals("RECENTLY_ADDED")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getRecentlyAddedSongs(mSelection);
    		
    	} else if (mDistinctField.equals("TOP_RATED")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getTopRatedSongs(mSelection);
    		
    	} else if (mDistinctField.equals("RECENTLY_PLAYED")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getRecentlyPlayedSongs(mSelection);
    		
    	} else if (mDistinctField.equals("GENRES_FLIPPED")) {
    		DBAccessHelper dBHelper = new DBAccessHelper(getContext());
    		cursor = dBHelper.getAllSongsInGenre(mSelection);
    		
    	}
        
        if (cursor != null) {
            // Ensure the cursor window is filled
            cursor.getCount();
            registerContentObserver(cursor, mObserver);
        }*/
        
        return null;
    }

    /**
     * Registers an observer to get notifications from the content mApp
     * when the cursor needs to be refreshed.
     */
    void registerContentObserver(Cursor cursor, ContentObserver observer) {
        cursor.registerContentObserver(mObserver);
    }

    /* Runs on the UI thread */
    @Override
    public void deliverResult(Cursor cursor) {
        if (isReset()) {
            // An async query came in while the loader is stopped
            if (cursor != null) {
                cursor.close();
            }
            return;
        }
        Cursor oldCursor = mCursor;
        mCursor = cursor;

        if (isStarted()) {
            super.deliverResult(cursor);
        }

        if (oldCursor != null && oldCursor != cursor && !oldCursor.isClosed()) {
            oldCursor.close();
        }
    }

    /**
     * Creates an empty unspecified CursorLoader.  You must follow this with
     * calls to {@link #setUri(Uri)}, {@link #setSelection(String)}, etc
     * to specify the query to perform.
     */
    public SQLiteDBCursorLoader(Context context) {
        super(context);
        mObserver = new ForceLoadContentObserver();
    }

    /**
     * Creates a fully-specified CursorLoader.  See
     * {@link ContentResolver#query(Uri, String[], String, String[], String)
     * ContentResolver.query()} for documentation on the meaning of the
     * parameters.  These will be passed as-is to that call.
     */
    public SQLiteDBCursorLoader(Context context, String tableName, String[] projection, String selection,
            String[] selectionArgs, String sortOrder) {
        super(context);
        
        mObserver = new ForceLoadContentObserver();
        mTableName = tableName;
        mProjection = projection;
        mSelection = selection;
        mSelectionArgs = selectionArgs;
        mSortOrder = sortOrder;
    }
    
    /**
     * Creates a fully-specified CursorLoader.  See
     * {@link ContentResolver#query(Uri, String[], String, String[], String)
     * ContentResolver.query()} for documentation on the meaning of the
     * parameters.  These will be passed as-is to that call.
     */
    public SQLiteDBCursorLoader(Context context, String tableName, String[] projection, String selection,
            String[] selectionArgs, String sortOrder, String limit) {
        super(context);
        
        mObserver = new ForceLoadContentObserver();
        mTableName = tableName;
        mProjection = projection;
        mSelection = selection;
        mSelectionArgs = selectionArgs;
        mSortOrder = sortOrder;
        mLimit = limit;
    }
    
    /**
     * Creates a fully-specified, DISTINCT CursorLoader.  See
     * {@link ContentResolver#query(Uri, String[], String, String[], String)
     * ContentResolver.query()} for documentation on the meaning of the
     * parameters.  These will be passed as-is to that call.
     */
    public SQLiteDBCursorLoader(Context context, boolean distinctPlaylists) {
        super(context);
        
        mDistinctPlaylists = distinctPlaylists;
        mObserver = new ForceLoadContentObserver();

    }
    
    /**
     * Creates a fully-specified, DISTINCT CursorLoader.  See
     * {@link ContentResolver#query(Uri, String[], String, String[], String)
     * ContentResolver.query()} for documentation on the meaning of the
     * parameters.  These will be passed as-is to that call.
     * 
     * boolean dummy is a dummy variable, used to differentiate constructors.
     */
    public SQLiteDBCursorLoader(Context context, boolean distinctGenres, boolean dummy) {
        super(context);
        
        mDistinctGenres = distinctGenres;
        mObserver = new ForceLoadContentObserver();

    }
    
    /**
     * Creates a fully-specified, DISTINCT CursorLoader.  See
     * {@link ContentResolver#query(Uri, String[], String, String[], String)
     * ContentResolver.query()} for documentation on the meaning of the
     * parameters.  These will be passed as-is to that call.
     * 
     * boolean dummy is a dummy variable, used to differentiate constructors.
     */
    public SQLiteDBCursorLoader(Context context, String distinctField, String selection) {
        super(context);
        
        mDistinctField = distinctField;
        mSelection = selection;
        mObserver = new ForceLoadContentObserver();

    }

    /**
     * Starts an asynchronous load of the contacts list data. When the result is ready the callbacks
     * will be called on the UI thread. If a previous load has been completed and is still valid
     * the result may be passed to the callbacks immediately.
     *
     * Must be called from the UI thread
     */
    @Override
    protected void onStartLoading() {
        if (mCursor != null) {
            deliverResult(mCursor);
        }
        if (takeContentChanged() || mCursor == null) {
            forceLoad();
        }
    }

    /**
     * Must be called from the UI thread
     */
    @Override
    protected void onStopLoading() {
        // Attempt to cancel the current load task if possible.
        cancelLoad();
    }

    @Override
    public void onCanceled(Cursor cursor) {
        if (cursor != null && !cursor.isClosed()) {
            cursor.close();
        }
    }

    @Override
    protected void onReset() {
        super.onReset();
        
        // Ensure the loader is stopped
        onStopLoading();

        if (mCursor != null && !mCursor.isClosed()) {
            mCursor.close();
        }
        mCursor = null;
    }

    public String getTableName() {
        return mTableName;
    }

    public void setUri(String tableName) {
        mTableName = tableName;
    }

    public String[] getProjection() {
        return mProjection;
    }

    public void setProjection(String[] projection) {
        mProjection = projection;
    }

    public String getSelection() {
        return mSelection;
    }

    public void setSelection(String selection) {
        mSelection = selection;
    }

    public String[] getSelectionArgs() {
        return mSelectionArgs;
    }

    public void setSelectionArgs(String[] selectionArgs) {
        mSelectionArgs = selectionArgs;
    }

    public String getSortOrder() {
        return mSortOrder;
    }

    public void setSortOrder(String sortOrder) {
        mSortOrder = sortOrder;
    }

    @Override
    public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {
        super.dump(prefix, fd, writer, args);
        writer.print(prefix); writer.print("mUri="); writer.println(mTableName);
        writer.print(prefix); writer.print("mProjection=");
                writer.println(Arrays.toString(mProjection));
        writer.print(prefix); writer.print("mSelection="); writer.println(mSelection);
        writer.print(prefix); writer.print("mSelectionArgs=");
                writer.println(Arrays.toString(mSelectionArgs));
        writer.print(prefix); writer.print("mSortOrder="); writer.println(mSortOrder);
        writer.print(prefix); writer.print("mCursor="); writer.println(mCursor);
        writer.print(prefix); writer.print("mContentChanged="); //writer.println(mContentChanged);
    }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.support.v4.content.LocalBroadcastManager;
import android.view.View;
import android.view.ViewGroup;
import android.widget.RelativeLayout;
import android.widget.SeekBar;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.Views.RangeSeekBar;
import com.jams.music.player.Views.RangeSeekBar.OnRangeSeekBarChangeListener;

public class ABRepeatDialog extends DialogFragment {
	
	private Context mContext;
	private Common mApp;
	
	private int repeatPointA;
	private int repeatPointB;
	private int currentSongIndex;
	private int currentSongDurationMillis;
    private int currentSongDurationSecs;
	private SharedPreferences sharedPreferences;
	private BroadcastReceiver receiver;
	
	private TextView repeatSongATime;
	private TextView repeatSongBTime;
	private SeekBar seekBar;
	private RangeSeekBar<Integer> rangeSeekBar;
	private ViewGroup viewGroup;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		mContext = getActivity().getApplicationContext();
		mApp = (Common) mContext;
		
        receiver = new BroadcastReceiver() {
        	
            @Override
            public void onReceive(Context context, Intent intent) {
            	initRepeatSongRangeDialog();
            	
            }
            
        };
		
		sharedPreferences = getActivity().getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        View view = getActivity().getLayoutInflater().inflate(R.layout.fragment_repeat_song_range_dialog, null);
        currentSongIndex = mApp.getService().getCurrentSongIndex();

        repeatSongATime = (TextView) view.findViewById(R.id.repeat_song_range_A_time);
        repeatSongBTime = (TextView) view.findViewById(R.id.repeat_song_range_B_time);

        currentSongDurationMillis = (int) mApp.getService().getCurrentMediaPlayer().getDuration();
        currentSongDurationSecs = (int) currentSongDurationMillis/1000;
        
        //Remove the placeholder seekBar and replace it with the RangeSeekBar.
        seekBar = (SeekBar) view.findViewById(R.id.repeat_song_range_placeholder_seekbar);
        RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) seekBar.getLayoutParams();
        viewGroup = (ViewGroup) seekBar.getParent();
        viewGroup.removeView(seekBar);
        
        rangeSeekBar = new RangeSeekBar<Integer>(0, currentSongDurationSecs, getActivity());
        rangeSeekBar.setLayoutParams(params);
        viewGroup.addView(rangeSeekBar);
		
        if (sharedPreferences.getInt(Common.REPEAT_MODE, Common.REPEAT_OFF)==Common.A_B_REPEAT) {
        	repeatSongATime.setText(convertMillisToMinsSecs(mApp.getService().getRepeatSongRangePointA()));
        	repeatSongBTime.setText(convertMillisToMinsSecs(mApp.getService().getRepeatSongRangePointB()));

        	rangeSeekBar.setSelectedMinValue(mApp.getService().getRepeatSongRangePointA());
        	rangeSeekBar.setSelectedMaxValue(mApp.getService().getRepeatSongRangePointB());

            repeatPointA = mApp.getService().getRepeatSongRangePointA();
        	repeatPointB = mApp.getService().getRepeatSongRangePointB();
        } else {
        	repeatSongATime.setText("0:00");
        	repeatSongBTime.setText(convertMillisToMinsSecs(currentSongDurationMillis));
        	repeatPointA = 0;
        	repeatPointB = currentSongDurationMillis;
        }
        
        rangeSeekBar.setOnRangeSeekBarChangeListener(new OnRangeSeekBarChangeListener<Integer>() {
            @Override
            public void onRangeSeekBarValuesChanged(RangeSeekBar<?> bar, Integer minValue, Integer maxValue) {
            	repeatPointA = minValue*1000;
            	repeatPointB = maxValue*1000;
            	repeatSongATime.setText(convertMillisToMinsSecs(minValue*1000));
            	repeatSongBTime.setText(convertMillisToMinsSecs(maxValue*1000));
            }
            
        });
        
        //Set the dialog title.
        builder.setTitle(R.string.a_b_repeat);
        builder.setView(view);
        builder.setNegativeButton(R.string.cancel, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				// TODO Auto-generated method stub
				
			}

        });
        
        builder.setPositiveButton(R.string.repeat, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				if ((currentSongDurationSecs - repeatPointB) < mApp.getCrossfadeDuration()) {
					//Remove the crossfade handler.
					mApp.getService().getHandler().removeCallbacks(mApp.getService().startCrossFadeRunnable);
					mApp.getService().getHandler().removeCallbacks(mApp.getService().crossFadeRunnable);
				}
				
				mApp.broadcastUpdateUICommand(new String[] { Common.UPDATE_PLAYBACK_CONTROLS }, 
											  new String[] { "" });
				mApp.getService().setRepeatSongRange(repeatPointA, repeatPointB);
				mApp.getService().setRepeatMode(Common.A_B_REPEAT);
				
			}
        	
        });

        return builder.create();
    }
	
	public void initRepeatSongRangeDialog() {

        currentSongDurationMillis = (int) mApp.getService().getCurrentMediaPlayer().getDuration();
        currentSongDurationSecs = (int) currentSongDurationMillis/1000;
        
        RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) rangeSeekBar.getLayoutParams();
        viewGroup = (ViewGroup) rangeSeekBar.getParent();
        viewGroup.removeView(rangeSeekBar);
        
        rangeSeekBar = new RangeSeekBar<Integer>(0, currentSongDurationSecs, getActivity());
        rangeSeekBar.setLayoutParams(params);
        viewGroup.addView(rangeSeekBar);
		
        if (sharedPreferences.getInt(Common.REPEAT_MODE, Common.REPEAT_OFF)==Common.A_B_REPEAT) {
        	repeatSongATime.setText(convertMillisToMinsSecs(mApp.getService().getRepeatSongRangePointA()));
        	repeatSongBTime.setText(convertMillisToMinsSecs(mApp.getService().getRepeatSongRangePointB()));
        	rangeSeekBar.setSelectedMinValue(mApp.getService().getRepeatSongRangePointA());
        	rangeSeekBar.setSelectedMaxValue(mApp.getService().getRepeatSongRangePointB());
        	repeatPointA = mApp.getService().getRepeatSongRangePointA();
        	repeatPointB = mApp.getService().getRepeatSongRangePointB();
        } else {
        	repeatSongATime.setText("0:00");
        	repeatSongBTime.setText(convertMillisToMinsSecs(currentSongDurationMillis));
        	repeatPointA = 0;
        	repeatPointB = currentSongDurationMillis;
        }
        
        rangeSeekBar.setOnRangeSeekBarChangeListener(new OnRangeSeekBarChangeListener<Integer>() {

            @Override
            public void onRangeSeekBarValuesChanged(RangeSeekBar<?> bar, Integer minValue, Integer maxValue) {
            	repeatPointA = minValue*1000;
            	repeatPointB = maxValue*1000;
            	repeatSongATime.setText(convertMillisToMinsSecs(minValue*1000));
            	repeatSongBTime.setText(convertMillisToMinsSecs(maxValue*1000));
            }
            
        });
        
	}
	
	//Convert millisseconds to hh:mm:ss format.
    public static String convertMillisToMinsSecs(long milliseconds) {
    	
    	int secondsValue = (int) (milliseconds / 1000) % 60 ;
    	int minutesValue = (int) ((milliseconds / (1000*60)) % 60);
    	int hoursValue  = (int) ((milliseconds / (1000*60*60)) % 24);
    	
    	String seconds = "";
    	String minutes = "";
    	String hours = "";
    	
    	if (secondsValue < 10) {
    		seconds = "0" + secondsValue;
    	} else {
    		seconds = "" + secondsValue;
    	}

    	if (minutesValue < 10) {
    		minutes = "0" + minutesValue;
    	} else {
    		minutes = "" + minutesValue;
    	}
    	
    	if (hoursValue < 10) {
    		hours = "0" + hoursValue;
    	} else {
    		hours = "" + hoursValue;
    	}
    	
    	String output = "";
    	
    	if (hoursValue!=0) {
    		output = hours + ":" + minutes + ":" + seconds;
    	} else {
    		output = minutes + ":" + seconds;
    	}
    	
    	return output;
    }
    
	@Override
	public void onStart() {
	    super.onStart();
	    LocalBroadcastManager.getInstance(getActivity().getApplicationContext())
	    					 .registerReceiver((receiver), new IntentFilter("com.jams.music.player.UPDATE_NOW_PLAYING"));
	
	}

	@Override
	public void onStop() {
	    LocalBroadcastManager.getInstance(getActivity().getApplicationContext()).unregisterReceiver(receiver);
	    super.onStop();
	    
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.View;
import android.widget.EditText;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.EqualizerActivity.EqualizerActivity;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class AddEQPresetDialog extends DialogFragment {

	private Common mApp;
	private AddEQPresetDialog dialog;
	private View dialogView;
	private EditText newPresetNameField;
	private EqualizerActivity mEqualizerFragment;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		mApp = (Common) getActivity().getApplicationContext();
		mEqualizerFragment = (EqualizerActivity) getActivity();
		dialog = this;
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        dialogView = getActivity().getLayoutInflater().inflate(R.layout.add_new_equalizer_preset_dialog_layout, null);
        
        newPresetNameField = (EditText) dialogView.findViewById(R.id.new_preset_name_text_field);
        newPresetNameField.setTypeface(TypefaceHelper.getTypeface(getActivity(), "Roboto-Light"));
        newPresetNameField.setPaintFlags(newPresetNameField.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        //Set the dialog title.
        builder.setTitle(R.string.new_eq_preset);
        builder.setView(dialogView);
        builder.setNegativeButton(R.string.cancel, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialog.dismiss();
				
			}
        	
        });
        
        builder.setPositiveButton(R.string.done, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				
				//Get the preset name from the text field.
				String presetName = newPresetNameField.getText().toString();
				
				//Add the preset and it's values to the DB.
				mApp.getDBAccessHelper().addNewEQPreset(presetName, 
									  					mEqualizerFragment.getFiftyHertzLevel(), 
									  					mEqualizerFragment.getOneThirtyHertzLevel(), 
									  					mEqualizerFragment.getThreeTwentyHertzLevel(), 
									  					mEqualizerFragment.getEightHundredHertzLevel(), 
									  					mEqualizerFragment.getTwoKilohertzLevel(), 
									  					mEqualizerFragment.getFiveKilohertzLevel(), 
									  					mEqualizerFragment.getTwelvePointFiveKilohertzLevel(), 
									  					(short) mEqualizerFragment.getVirtualizerSeekBar().getProgress(), 
									  					(short) mEqualizerFragment.getBassBoostSeekBar().getProgress(), 
									  					(short) mEqualizerFragment.getReverbSpinner().getSelectedItemPosition());
				
				Toast.makeText(getActivity(), R.string.preset_saved, Toast.LENGTH_SHORT).show();
				dialog.dismiss();
			}
        	
        });

        return builder.create();
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import java.util.ArrayList;
import java.util.Arrays;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.graphics.Paint;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.View;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.MusicLibraryEditorActivity.LibraryLabelsAdapter;
import com.jams.music.player.MusicLibraryEditorActivity.MusicLibraryEditorActivity;

public class AddMusicLibraryDialog extends DialogFragment {

	private String libraryLabelID;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		libraryLabelID = "circle_blue_dark";
		View rootView = getActivity().getLayoutInflater().inflate(R.layout.dialog_add_music_library, null);
		TextView instructions = (TextView) rootView.findViewById(R.id.add_music_library_instructions);
		instructions.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		instructions.setPaintFlags(instructions.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		final ImageButton labelButton = (ImageButton) rootView.findViewById(R.id.add_music_library_label_button);
		final EditText musicLibraryName = (EditText) rootView.findViewById(R.id.add_music_library_text_field);
		musicLibraryName.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		musicLibraryName.setPaintFlags(musicLibraryName.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		labelButton.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				
				//Create a new array with a list of all the library labels.
				final Drawable[] labelsArray = { getActivity().getResources().getDrawable(R.drawable.circle_blue_dark),
											   	 getActivity().getResources().getDrawable(R.drawable.circle_blue_light),
											   	 getActivity().getResources().getDrawable(R.drawable.circle_green_dark),
											   	 getActivity().getResources().getDrawable(R.drawable.circle_green_light),
											   	 getActivity().getResources().getDrawable(R.drawable.circle_purple_dark),
											   	 getActivity().getResources().getDrawable(R.drawable.circle_purple_light),
											   	 getActivity().getResources().getDrawable(R.drawable.circle_red_dark),
											   	 getActivity().getResources().getDrawable(R.drawable.circle_red_light),
											   	 getActivity().getResources().getDrawable(R.drawable.circle_yellow_dark),
											   	 getActivity().getResources().getDrawable(R.drawable.circle_yellow_light) };
				
				//Create a new array with a list of all the library labels.
				final String[] labelsIdsArray = { "circle_blue_dark",
											   	  "circle_blue_light",
											   	  "circle_green_dark",
											   	  "circle_green_light",
											   	  "circle_purple_dark",
											   	  "circle_purple_light",
											   	  "circle_red_dark",
											   	  "circle_red_light",
											   	  "circle_yellow_dark",
											   	  "circle_yellow_light" };
				
				AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
				builder.setTitle(R.string.music_library_label);
				ArrayList<String> labelTitles = new ArrayList<String>();
				labelTitles.addAll(Arrays.asList(getActivity().getResources().getStringArray(R.array.library_labels)));
				builder.setAdapter(new LibraryLabelsAdapter(getActivity(), labelTitles), 
															new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						dialog.dismiss();
						libraryLabelID = labelsIdsArray[which];
						labelButton.setImageDrawable(labelsArray[which]);
						
					}
					
				});
				
				builder.create().show();
				
			}

			
		});
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.add_music_library);
        builder.setView(rootView);
        builder.setPositiveButton(R.string.ok, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int arg1) {
				String libraryName = musicLibraryName.getText().toString();
				
				Intent intent = new Intent(getActivity(), MusicLibraryEditorActivity.class);
				Bundle bundle = new Bundle();
				bundle.putString("LIBRARY_NAME", libraryName);
				bundle.putString("LIBRARY_ICON", libraryLabelID);
				intent.putExtras(bundle);
				startActivity(intent);
				
				dialog.dismiss();
				getActivity().finish();
				
			}
        	
        });
        
        builder.setNegativeButton(R.string.cancel, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int arg1) {
				dialog.dismiss();
				getActivity().finish();
				
			}
        	
        });
        
        return builder.create();
    }
	
	@Override
	public void onPause() {
		super.onPause();
		getActivity().finish();
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.View;
import android.widget.EditText;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncCreateNewPlaylistTask;
import com.jams.music.player.Helpers.TypefaceHelper;

public class AddToPlaylistDialog extends DialogFragment {

	private Context mContext;
	private String ADD_TYPE;
	private String ARTIST;
	private String ALBUM;
	private String ALBUM_ARTIST;
	private String SONG;
	private String GENRE;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		mContext = getActivity().getApplicationContext();
		
/*		//Retrieve the arguments.
		ADD_TYPE = getArguments().getString("ADD_TYPE");
		
		if (ADD_TYPE.equals("ARTIST")) {
			ARTIST = getArguments().getString("ARTIST");
		} else if (ADD_TYPE.equals("ALBUM_ARTIST")) {
			ALBUM_ARTIST = getArguments().getString("ALBUM_ARTIST");
		} else if (ADD_TYPE.equals("ALBUM")) {
			ARTIST = getArguments().getString("ARTIST");
			ALBUM = getArguments().getString("ALBUM");
		} else if (ADD_TYPE.equals("SONG")) {
			ARTIST = getArguments().getString("ARTIST");
			ALBUM = getArguments().getString("ALBUM");
			SONG = getArguments().getString("SONG");
		} else if (ADD_TYPE.equals("GENRE")) {
			GENRE = getArguments().getString("GENRE");
		} else if (ADD_TYPE.equals("ALBUM_BY_ALBUM_ARTIST")) {
			ALBUM = getArguments().getString("ALBUM");
			ALBUM_ARTIST = getArguments().getString("ALBUM_ARTIST");
		}*/
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        /*String columns[] = { DBAccessHelper.PLAYLIST_NAME, DBAccessHelper._ID,
        					 DBAccessHelper.PLAYLIST_FILE_PATH, DBAccessHelper.PLAYLIST_SOURCE,
        					 DBAccessHelper.PLAYLIST_ID };
        MatrixCursor matrixCursor = new MatrixCursor(columns);
        matrixCursor.addRow(new String[] { getActivity().getResources().getString(R.string.new_playlist), "0", "0", "0", "0" });
        
        DBAccessHelper playlistsDBHelper = new DBAccessHelper(getActivity()
        																				    .getApplicationContext());
        Cursor userPlaylistsCursor = playlistsDBHelper.getAllUniqueUserPlaylists();
        final MergeCursor mergeCursor = new MergeCursor(new Cursor[] { matrixCursor, userPlaylistsCursor });
        
        //Set the dialog title.
        builder.setTitle(R.string.add_to_playlist);
        builder.setCursor(mergeCursor, new DialogInterface.OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				//Index 0 is the dummy playlist that will open the "New Playlist" dialog.
				if (which==0) {
					showNewPlaylistDialog();
				} else {
					mergeCursor.moveToPosition(which);
					String playlistName = mergeCursor.getString(mergeCursor.getColumnIndex(DBAccessHelper.PLAYLIST_NAME));
					String playlistId = mergeCursor.getString(mergeCursor.getColumnIndex(DBAccessHelper.PLAYLIST_ID));

					AsyncAddSongsToPlaylistTask task = new AsyncAddSongsToPlaylistTask(mContext,
																					   playlistName,
																					   playlistId,
																					   ARTIST,
																					   ALBUM,
																					   SONG,
																					   GENRE,
																					   ALBUM_ARTIST, 
																					   ADD_TYPE);
					task.execute();
					
				}
				
			}
        	
        }, DBAccessHelper.PLAYLIST_NAME);*/

        return builder.create();
    }

	//Displays the "Add New Playlist" dialog.
	public void showNewPlaylistDialog() {
		View dialogView = getActivity().getLayoutInflater().inflate(R.layout.add_new_playlist_dialog_layout, null);
		final EditText newPlaylistEditText = (EditText) dialogView.findViewById(R.id.new_playlist_name_text_field);
		newPlaylistEditText.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		newPlaylistEditText.setPaintFlags(newPlaylistEditText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
		builder.setTitle(R.string.new_playlist);
		builder.setView(dialogView);
		builder.setPositiveButton(R.string.ok, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				//Retrieve the name of the new playlist.
				String playlistName = newPlaylistEditText.getText().toString();
				AsyncCreateNewPlaylistTask task = new AsyncCreateNewPlaylistTask(mContext, 
																				 playlistName, 
																				 ARTIST, 
																				 ALBUM, 
																				 SONG, 
																				 GENRE, 
																				 ALBUM_ARTIST,
																				 ADD_TYPE);
				task.execute();
				dialog.dismiss();
				
			}
			
		});
		
		builder.setNegativeButton(R.string.cancel, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				dialog.dismiss();
				
			}
			
		});
		
		builder.create().show();
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.widget.Toast;

import com.jams.music.player.R;

/*********************************************************
 * Allows the user to select where they want to load album 
 * art images from.
 * 
 * @author Saravan Pantham
 *********************************************************/
public class AlbumArtSourceDialog extends DialogFragment {

	private Context mContext;
	private AlbumArtSourceDialog dialog;
	private SharedPreferences sharedPreferences;
	private int userSelection = 0;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		mContext = getActivity().getApplicationContext();
		dialog = this;
		sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		
		String[] albumArtSources = getActivity().getResources().getStringArray(R.array.album_art_sources);
		
        //Check which frequency is currently selected and set the appropriate flag.
        if (sharedPreferences.getInt("ALBUM_ART_SOURCE", 0)==0) {
        	userSelection = 0;
        } else if (sharedPreferences.getInt("ALBUM_ART_SOURCE", 0)==1) {
        	userSelection = 1;
        } else if (sharedPreferences.getInt("ALBUM_ART_SOURCE", 0)==2) {
        	userSelection = 2;
        } else if (sharedPreferences.getInt("ALBUM_ART_SOURCE", 0)==3) {
        	userSelection = 3;
        }
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        builder.setTitle(R.string.album_art_sources);
        builder.setSingleChoiceItems(albumArtSources, userSelection, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int which) {

				//Update the SharedPreferences entry based on the user's selection.
				if (which==0) {
					//"Prefer embedded art"
					sharedPreferences.edit().putInt("ALBUM_ART_SOURCE", 0).commit();
				} else if (which==1) {
					//"Prefer folder art"
					sharedPreferences.edit().putInt("ALBUM_ART_SOURCE", 1).commit();
				} else if (which==2) {
					//"Use embedded art only"
					sharedPreferences.edit().putInt("ALBUM_ART_SOURCE", 2).commit();
				} else if (which==3) {
					//"User folder art only"
					sharedPreferences.edit().putInt("ALBUM_ART_SOURCE", 3).commit();
				}
				
				//Rescan for album art.
				//Seting the "RESCAN_ALBUM_ART" flag to true will force MainActivity to rescan the folders.
				sharedPreferences.edit().putBoolean("RESCAN_ALBUM_ART", true).commit();
				
				//Restart the app.
				final Intent i = getActivity().getBaseContext()
						                      .getPackageManager()
						                      .getLaunchIntentForPackage(getActivity().getBaseContext().getPackageName());
				
				i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
				getActivity().finish();
				startActivity(i);
				
				dialog.dismiss();
				getActivity().finish();
				Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_LONG).show();
				
			}
        	
        });

        return builder.create();
        
    }
	
	@Override
	public void onDestroy() {
		super.onDestroy();
		getActivity().finish();
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.os.Bundle;

import com.jams.music.player.R;
import com.jams.music.player.SettingsActivity.PreferenceDialogLauncherActivity;
import com.jams.music.player.Utils.Common;

public class ApplicationThemeDialog extends DialogFragment {

	private Activity parentActivity;
    private Common mApp;
	private int selectedThemeIndex;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		parentActivity = getActivity();
        mApp = (Common) parentActivity.getApplicationContext();
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        
        //Check which theme is currently selected and set the appropriate flag.
        if (mApp.getCurrentTheme()==Common.LIGHT_THEME) {
        	selectedThemeIndex = 0;
        } else if (mApp.getCurrentTheme()==Common.DARK_THEME) {
        	selectedThemeIndex = 1;
        }

        //Set the dialog title.
        builder.setTitle(R.string.app_theme);
        builder.setSingleChoiceItems(R.array.app_theme_choices, selectedThemeIndex, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {

				PreferenceDialogLauncherActivity activity = new PreferenceDialogLauncherActivity();
				if (which==0) {
					mApp.getSharedPreferences().edit().putInt(Common.CURRENT_THEME, Common.LIGHT_THEME).commit();
                    mApp.initDisplayImageOptions();
					
					Intent i = parentActivity.getBaseContext()
											 .getPackageManager()
											 .getLaunchIntentForPackage(parentActivity.getBaseContext()
													 								  .getPackageName());
					
					i.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | 
							   Intent.FLAG_ACTIVITY_NEW_TASK | 
							   Intent.FLAG_ACTIVITY_CLEAR_TASK);
					activity.finish();
					startActivity(i);
					
				} else if (which==1) {
					mApp.getSharedPreferences().edit().putInt(Common.CURRENT_THEME, Common.DARK_THEME).commit();
                    mApp.initDisplayImageOptions();
					
					Intent i = parentActivity.getBaseContext()
											 .getPackageManager()
											 .getLaunchIntentForPackage(parentActivity.getBaseContext()
													 								  .getPackageName());
	
					i.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | 
							   Intent.FLAG_ACTIVITY_NEW_TASK | 
							   Intent.FLAG_ACTIVITY_CLEAR_TASK);
					activity.finish();
					startActivity(i);
	
				}
				
			}
        	
        });

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.jams.music.player.R;
import com.jams.music.player.BlacklistManagerActivity.BlacklistManagerActivity;

/*******************************************************
 * Allows the user to select the type of elements that 
 * he/she wants to manage a blacklist for.
 * 
 * @author Saravan Pantham
 *******************************************************/
public class BlacklistManagerDialog extends DialogFragment { 
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		String[] blacklistManagerChoices = { getActivity().getResources().getString(R.string.manage_blacklisted_artists),
											 getActivity().getResources().getString(R.string.manage_blacklisted_albums), 
											 getActivity().getResources().getString(R.string.manage_blacklisted_songs), 
											 getActivity().getResources().getString(R.string.manage_blacklisted_playlists) };

        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.blacklist_manager);
        builder.setItems(blacklistManagerChoices, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				Bundle bundle = new Bundle();
				
				if (which==0) {
					bundle.putString("MANAGER_TYPE", "ARTISTS");
				} else if (which==1) {
					bundle.putString("MANAGER_TYPE", "ALBUMS");
				} else if (which==2) {
					bundle.putString("MANAGER_TYPE", "SONGS");
				} else if (which==3) {
					bundle.putString("MANAGER_TYPE", "PLAYLISTS");
				}
				
				dialog.dismiss();
				Intent intent = new Intent(getActivity(), BlacklistManagerActivity.class);
				intent.putExtras(bundle);
				startActivity(intent);
				
			}
        	
        });

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import java.util.ArrayList;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

/*******************************************************
 * Displays a list of blacklisted elements (which are 
 * specified by the user). All elements are checked by 
 * default, indicating that they are currently black-
 * listed. Unchecking an item's checkbox will remove 
 * that element from the blacklist.
 * 
 * @author Saravan Pantham
 *******************************************************/
public class BlacklistedElementsDialog extends DialogFragment { 
	
	//Temp array that holds the checkbox statuses in the ListView.
	private Common mApp;
	private static ArrayList<Boolean> checkboxStatuses = new ArrayList<Boolean>();
	private static String MANAGER_TYPE;
	private Cursor cursor;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		mApp = (Common) getActivity().getApplicationContext();
		
		final BlacklistedElementsDialog dialog = this;
		MANAGER_TYPE = getArguments().getString("MANAGER_TYPE");
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        
        //Get a cursor with a list of blacklisted elements.
        if (MANAGER_TYPE.equals("ARTISTS")) {
            builder.setTitle(R.string.blacklisted_artists);
        	cursor = mApp.getDBAccessHelper().getBlacklistedArtists();

        } else if (MANAGER_TYPE.equals("ALBUMS")) {
            builder.setTitle(R.string.blacklisted_albums);
        	cursor = mApp.getDBAccessHelper().getBlacklistedAlbums();
        	
        } else if (MANAGER_TYPE.equals("SONGS")) {
            builder.setTitle(R.string.blacklisted_songs);
        	cursor = mApp.getDBAccessHelper().getAllBlacklistedSongs();
        	
        } else if (MANAGER_TYPE.equals("PLAYLISTS")) {
            builder.setTitle(R.string.blacklisted_playlists);
        	/*DBAccessHelper playlistsDBHelper = new DBAccessHelper(getActivity());
        	cursor = playlistsDBHelper.getAllBlacklistedPlaylists();*/
        	
        } else {
        	Toast.makeText(getActivity(), R.string.error_occurred, Toast.LENGTH_LONG).show();
        	return builder.create();
        }
        
        //Dismiss the dialog if there are no blacklisted elements.
        if (cursor.getCount()==0) {
        	Toast.makeText(getActivity(), R.string.no_blacklisted_items_found, Toast.LENGTH_LONG).show();
        	return builder.create();
        }

        //Loop through checkboxStatuses and insert "TRUE" at every position by default.
        for (int i=0; i < cursor.getCount(); i++) {
        	checkboxStatuses.add(true);
        }

        View rootView = this.getLayoutInflater(savedInstanceState).inflate(R.layout.fragment_blacklist_manager, null);
        TextView blacklistManagerInfoText = (TextView) rootView.findViewById(R.id.blacklist_manager_info_text);
        ListView blacklistManagerListView = (ListView) rootView.findViewById(R.id.blacklist_manager_list);
        
        blacklistManagerInfoText.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
        blacklistManagerInfoText.setPaintFlags(blacklistManagerInfoText.getPaintFlags()
        									   | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        blacklistManagerListView.setFastScrollEnabled(true);
        BlacklistedElementsAdapter adapter = new BlacklistedElementsAdapter(getActivity(), cursor);
        blacklistManagerListView.setAdapter(adapter);
        
        builder.setView(rootView);
        builder.setNegativeButton(R.string.cancel, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialog.dismiss();
				
			}
        	
        });
        
        builder.setPositiveButton(R.string.done, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				//Loop through checkboxStatuses and unblacklist the elements that have been unchecked.
				for (int i=0; i < checkboxStatuses.size(); i++) {
					
					cursor.moveToPosition(i);
					if (checkboxStatuses.get(i)==true) {
						//The item is still blacklisted.
						continue;
					} else {
						//The item has been unblacklisted.
				        if (MANAGER_TYPE.equals("ARTISTS")) {
				        	mApp.getDBAccessHelper().setBlacklistForArtist(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ARTIST)), false);
				        	
				        } else if (MANAGER_TYPE.equals("ALBUMS")) {
				        	mApp.getDBAccessHelper().setBlacklistForAlbum(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ALBUM)), 
				        										cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ARTIST)), 
				        										false);

				        } else if (MANAGER_TYPE.equals("SONGS")) {
				        	mApp.getDBAccessHelper().setBlacklistForSong(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH)), false);

				        } else if (MANAGER_TYPE.equals("PLAYLISTS")) {
				        	/*DBAccessHelper playlistsDBHelper = new DBAccessHelper(getActivity());
				        	playlistsDBHelper.unBlacklistPlaylist(cursor.getString(cursor.getColumnIndex(DBAccessHelper.PLAYLIST_BLACKLIST_STATUS)));*/

				        }
						
					}
					
				}
				
				dialog.dismiss();
				
			}
        	
        });
        
        return builder.create();
    }
	
	//Adapter subclass for the Blacklists ListView.
	static class BlacklistedElementsAdapter extends SimpleCursorAdapter {
		
		private Cursor mCursor = null;
		private String elementName = "";
		private String artistName = "";
		
	    public BlacklistedElementsAdapter(Context context, Cursor cursor) {
	        super(context, -1, null, new String[] {}, new int[] {}, 0);
	        mCursor = cursor;
	        
	    }

	    @Override
		public View getView(final int position, View convertView, ViewGroup parent) {
		    BlacklistManagerHolder holder = null;

			if (convertView == null) {
				convertView = LayoutInflater.from(mContext).inflate(R.layout.blacklist_manager_list_layout, parent, false);

				holder = new BlacklistManagerHolder();
				holder.blacklistedElementName = (TextView) convertView.findViewById(R.id.blacklist_manager_element_name);
				holder.blacklistedArtistName = (TextView) convertView.findViewById(R.id.blacklist_manager_artist);

				convertView.setTag(holder);
			} else {
			    holder = (BlacklistManagerHolder) convertView.getTag();
			}
			
			//Retrieve the UI element values based on the manager type.
			mCursor.moveToPosition(position);
			if (MANAGER_TYPE.equals("ARTISTS")) {
				elementName = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ARTIST));
			} else if (MANAGER_TYPE.equals("ALBUMS")) {
				elementName = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ALBUM));
				artistName = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ARTIST));
			} else if (MANAGER_TYPE.equals("SONGS")) {
				elementName = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_TITLE));
				artistName = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ARTIST));
			} else if (MANAGER_TYPE.equals("PLAYLISTS")) {
				/*elementName = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.PLAYLIST_NAME));
				artistName = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.NUMBER_OF_SONGS));*/
			}

			//Set element name.
			holder.blacklistedElementName.setText(elementName);

			holder.blacklistedElementName.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
			holder.blacklistedElementName.setPaintFlags(holder.blacklistedElementName.getPaintFlags() | 
													    Paint.SUBPIXEL_TEXT_FLAG | 
													    Paint.ANTI_ALIAS_FLAG);
			
			//Hide the artist textview if we're not dealing with blacklisted albums, songs, or playlists.
	        if (MANAGER_TYPE.equals("ARTIST")) {
	        	holder.blacklistedArtistName.setVisibility(View.GONE);
	        } else {
	        	
				holder.blacklistedArtistName.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
				holder.blacklistedArtistName.setPaintFlags(holder.blacklistedArtistName.getPaintFlags() | 
														    Paint.SUBPIXEL_TEXT_FLAG | 
														    Paint.ANTI_ALIAS_FLAG);
				
				holder.blacklistedArtistName.setText(artistName);
				
	        }
			
			return convertView;
		}
	
	}
	 
	static class BlacklistManagerHolder {
	    public TextView blacklistedElementName;
	    public TextView blacklistedArtistName;
	}
	
	@Override
	public void onPause() {
		super.onPause();
		
		if (this.isRemoving()) {
			cursor.close();
		}
		
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.SharedPreferences;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.FragmentTransaction;
import android.view.View;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;

public class CautionEditAlbumsDialog extends DialogFragment {

	private Activity parentActivity;
	private DialogFragment dialogFragment;
	private View rootView;
	private TextView cautionText;
	private TextView dontShowAgainText;
	private CheckBox dontShowAgainCheckbox;
	
	private String album;
	private String artist;
	private String callingActivity;
	
	private SharedPreferences sharedPreferences;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		parentActivity = getActivity();
		dialogFragment = this;
		
		album = this.getArguments().getString("ALBUM");
		artist = this.getArguments().getString("ARTIST");
		callingActivity = this.getArguments().getString("CALLING_FRAGMENT");
		
		rootView = (View) parentActivity.getLayoutInflater().inflate(R.layout.fragment_caution_edit_albums, null);
		
		cautionText = (TextView) rootView.findViewById(R.id.caution_text);
        cautionText.setText(R.string.caution_albums_text);
		cautionText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		cautionText.setPaintFlags(cautionText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		sharedPreferences = getActivity().getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		
		dontShowAgainText = (TextView) rootView.findViewById(R.id.dont_show_again_text);
		dontShowAgainText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		dontShowAgainText.setPaintFlags(dontShowAgainText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		dontShowAgainCheckbox = (CheckBox) rootView.findViewById(R.id.dont_show_again_checkbox);
		dontShowAgainCheckbox.setChecked(true);
		sharedPreferences.edit().putBoolean("SHOW_ALBUM_EDIT_CAUTION", false).commit();
		
		dontShowAgainCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton arg0, boolean isChecked) {
				
				if (isChecked==true) {
					sharedPreferences.edit().putBoolean("SHOW_ALBUM_EDIT_CAUTION", false).commit();
				} else {
					sharedPreferences.edit().putBoolean("SHOW_ALBUM_EDIT_CAUTION", true).commit();
				}
				
			}
			
		});
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.caution);
        builder.setView(rootView);
        builder.setNegativeButton(R.string.no, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();
				
			}
        	
        });
        
        builder.setPositiveButton(R.string.yes, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();
				
				FragmentTransaction ft = getFragmentManager().beginTransaction();
				Bundle bundle = new Bundle();
				bundle.putString("EDIT_TYPE", "ALBUM");
				bundle.putString("ALBUM", album);
				bundle.putString("ARTIST", artist);
				bundle.putString("CALLING_FRAGMENT", callingActivity);
				ID3sAlbumEditorDialog dialog = new ID3sAlbumEditorDialog();
				dialog.setArguments(bundle);
				dialog.show(ft, "id3EditorDialog");
				
			}
        	
        });

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.SharedPreferences;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.FragmentTransaction;
import android.view.View;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;

public class CautionEditArtistsDialog extends DialogFragment {

	private Activity parentActivity;
	private DialogFragment dialogFragment;
	private View rootView;
	private TextView cautionText;
	
	private String EDIT_TYPE;
	private String ARTIST;
	
	private TextView dontShowAgainText;
	private CheckBox dontShowAgainCheckbox;
	private SharedPreferences sharedPreferences;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		parentActivity = getActivity();
		dialogFragment = this;
		
		EDIT_TYPE = this.getArguments().getString("EDIT_TYPE");
		ARTIST = this.getArguments().getString("ARTIST");
		
		rootView = (View) parentActivity.getLayoutInflater().inflate(R.layout.fragment_caution_edit_artists, null);
		
		cautionText = (TextView) rootView.findViewById(R.id.caution_text);
		cautionText.setText(R.string.caution_artists_text);
		cautionText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		cautionText.setPaintFlags(cautionText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		sharedPreferences = getActivity().getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		sharedPreferences.edit().putBoolean("SHOW_ARTIST_EDIT_CAUTION", false).commit();
		
		dontShowAgainText = (TextView) rootView.findViewById(R.id.dont_show_again_text);
		dontShowAgainText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		dontShowAgainText.setPaintFlags(dontShowAgainText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		dontShowAgainCheckbox = (CheckBox) rootView.findViewById(R.id.dont_show_again_checkbox);
		dontShowAgainCheckbox.setChecked(true);
		
		dontShowAgainCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton arg0, boolean isChecked) {
				
				if (isChecked==true) {
					sharedPreferences.edit().putBoolean("SHOW_ARTIST_EDIT_CAUTION", false).commit();
				} else {
					sharedPreferences.edit().putBoolean("SHOW_ARTIST_EDIT_CAUTION", true).commit();
				}
				
			}
			
		});
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.caution);
        builder.setView(rootView);
        builder.setNegativeButton(R.string.no, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();
				
			}
        	
        });
        
        builder.setPositiveButton(R.string.yes, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();
				
				FragmentTransaction ft = getFragmentManager().beginTransaction();
				Bundle bundle = new Bundle();
				bundle.putString("EDIT_TYPE", EDIT_TYPE);
				bundle.putString("ARTIST", ARTIST);
				ID3sArtistEditorDialog dialog = new ID3sArtistEditorDialog();
				dialog.setArguments(bundle);
				dialog.show(ft, "id3ArtistEditorDialog");
				
			}
        	
        });

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.jams.music.player.R;

public class CoverArtStyleDialog extends DialogFragment {

	private Activity parentActivity;
	private int selectedThemeIndex;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		parentActivity = getActivity();
		
		final SharedPreferences sharedPreferences = parentActivity.
											  getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        
        //Check which style is currently selected and set the appropriate flag.
        if (sharedPreferences.getString("COVER_ART_STYLE", "CARD_STYLE").equals("CARD_STYLE")) {
        	selectedThemeIndex = 0;
        } else {
        	selectedThemeIndex = 1;
        }

        //Set the dialog title.
        builder.setTitle(R.string.cover_art_style);
        builder.setSingleChoiceItems(R.array.cover_art_style_choices, selectedThemeIndex, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				
				if (which==0) {
					sharedPreferences.edit().putString("COVER_ART_STYLE", "CARD_STYLE").commit();

				} else if (which==1) {
					sharedPreferences.edit().putString("COVER_ART_STYLE", "FILL_SCREEN").commit();

				}
				
				dialog.dismiss();
				getActivity().finish();
				
			}
        	
        });

        return builder.create();
    }
	
	@Override
	public void onPause() {
		super.onPause();
		
		getActivity().finish();
		
	}
	
	@Override
	public void onDestroy() {
		super.onDestroy();
		
		getActivity().finish();
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import java.util.ArrayList;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.mobeta.android.dslv.DragSortListView;
import com.mobeta.android.dslv.SimpleFloatViewManager;

@SuppressLint("DefaultLocale")
public class CustomizeScreensDialog extends DialogFragment {

	private Activity parentActivity;
	private DialogFragment dialogFragment;
	private View rootView;
	private TextView customizeScreensText;
	private DragSortListView listView;
	public static CustomizeScreensListAdapter adapter;
	private ArrayList<String> screenTitlesList = new ArrayList<String>();
	private SharedPreferences sharedPreferences;
	
	String page1;
	String page2;
	String page3;
	String page4;
	String page5;
	String page6;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		parentActivity = getActivity();
		dialogFragment = (DialogFragment) getFragmentManager().findFragmentByTag("customizeScreensDialog");
		
		sharedPreferences = parentActivity.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		
		rootView = (View) parentActivity.getLayoutInflater().inflate(R.layout.customize_screens_layout, null);
		
		customizeScreensText = (TextView) rootView.findViewById(R.id.customize_screens_text);
		customizeScreensText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		customizeScreensText.setPaintFlags(customizeScreensText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		//Populate the arraylists with the settings saved in SharedPreferences.
		page1 = sharedPreferences.getString("PAGE_1", getResources().getString(R.string.artists_caps));
		page2 = sharedPreferences.getString("PAGE_2", getResources().getString(R.string.albums_caps));
		page3 = sharedPreferences.getString("PAGE_3", getResources().getString(R.string.songs_caps));
		page4 = sharedPreferences.getString("PAGE_4", getResources().getString(R.string.playlists_caps));
		page5 = sharedPreferences.getString("PAGE_5", getResources().getString(R.string.genres_caps));
		page6 = sharedPreferences.getString("PAGE_6", getResources().getString(R.string.folders_caps));
		
		if (!page1.equals("null") || !page1.equals(null)) {
			screenTitlesList.add(page1);
		}
		
		if (!page2.equals("null") || !page2.equals(null)) {
			screenTitlesList.add(page2);
		}
		
		if (!page3.equals("null") || !page3.equals(null)) {
			screenTitlesList.add(page3);
		}
		
		if (!page4.equals("null") || !page4.equals(null)) {
			screenTitlesList.add(page4);
		}
		
		if (!page5.equals("null") || !page5.equals(null)) {
			screenTitlesList.add(page5);
		}
		
		if (!page6.equals("null") || !page6.equals(null)) {
			screenTitlesList.add(page6);
		}

		listView = (DragSortListView) rootView.findViewById(R.id.customize_screens_listview);
		adapter = new CustomizeScreensListAdapter(parentActivity, screenTitlesList);
		listView.setAdapter(adapter);
		listView.setDropListener(onDrop);
		SimpleFloatViewManager simpleFloatViewManager = new SimpleFloatViewManager(listView);
		simpleFloatViewManager.setBackgroundColor(Color.TRANSPARENT);
		listView.setFloatViewManager(simpleFloatViewManager);
			
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.customize_screens);
        builder.setView(rootView);
        builder.setPositiveButton(R.string.done, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();
				
				//adapter.getItem(i) will get us the order for the screens.
				sharedPreferences.edit().putString("PAGE_1", adapter.getItem(0).toString().toUpperCase()).commit();
				sharedPreferences.edit().putString("PAGE_2", adapter.getItem(1).toString().toUpperCase()).commit();
				sharedPreferences.edit().putString("PAGE_3", adapter.getItem(2).toString().toUpperCase()).commit();
				sharedPreferences.edit().putString("PAGE_4", adapter.getItem(3).toString().toUpperCase()).commit();
				sharedPreferences.edit().putString("PAGE_5", adapter.getItem(4).toString().toUpperCase()).commit();
				sharedPreferences.edit().putString("PAGE_6", adapter.getItem(5).toString().toUpperCase()).commit();
				
				Toast.makeText(parentActivity, R.string.changes_saved, Toast.LENGTH_SHORT).show();
				
				//Restart the app.
				Intent i = parentActivity.getBaseContext()
										 .getPackageManager()
										 .getLaunchIntentForPackage(parentActivity.getBaseContext()
												 								  .getPackageName());
				
				i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
				dialogFragment.dismiss();
				getActivity().finish();
				startActivity(i);
				
			}
        	
        });

        return builder.create();
    }
	
    private DragSortListView.DropListener onDrop = new DragSortListView.DropListener() {
    	
        @Override
        public void drop(int from, int to) {
            if (from!=to) {
                String item = adapter.getItem(from);
                adapter.remove(item);
                adapter.insert(item, to);
                
            }
            
        }
        
    };
    
    public static class CustomizeScreensListAdapter extends ArrayAdapter<String> {

    	private Context mContext;
    	private ArrayList<String> mScreensList;
    	
    	private TextView screenTitle;
       
        public CustomizeScreensListAdapter(Context context, ArrayList<String> screensList) {
        	
        	super(context, R.id.customize_screens_title, screensList);
        	
        	mContext = context;
        	mScreensList = screensList;

        }
        
        public View getView(final int position, View convertView, ViewGroup parent){

    		View v = convertView;

    		if (v == null) {
    			LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    			v = inflater.inflate(R.layout.customize_screens_listview_layout, null);
    		}
    		
    		screenTitle = (TextView) v.findViewById(R.id.customize_screens_title);

    		screenTitle.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
    		screenTitle.setPaintFlags(screenTitle.getPaintFlags()
    										 | Paint.ANTI_ALIAS_FLAG
    										 | Paint.SUBPIXEL_TEXT_FLAG);		
    		
    		screenTitle.setText(mScreensList.get(position));
    		
    		return v;

    	}
       
    }
    
	@Override
	public void onDestroy() {
		super.onDestroy();
		
		getActivity().finish();
		
	}
	
	@Override
	public void onPause() {
		super.onPause();
		
		getActivity().finish();
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.ContentResolver;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.graphics.Paint;
import android.os.Bundle;
import android.provider.MediaStore;
import android.support.v4.app.DialogFragment;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncDeletePlaylistTask;
import com.jams.music.player.Utils.TypefaceProvider;

public class DeletePlaylistWarningDialog extends DialogFragment {

	private Activity parentActivity;
	private DialogFragment dialogFragment;
	private View rootView;
	private TextView cautionText;
	private String mPlaylistId;
	private String mPlaylistFilePath;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		parentActivity = getActivity();
		dialogFragment = this;
		
		mPlaylistId = getArguments().getString("PLAYLIST_ID");
		mPlaylistFilePath = getArguments().getString("PLAYLIST_FILE_PATH");
		
		rootView = (View) parentActivity.getLayoutInflater().inflate(R.layout.fragment_delete_playlists_warning, null);
		
		cautionText = (TextView) rootView.findViewById(R.id.warning_text);
		cautionText.setText(R.string.delete_playlist_warning);
		cautionText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		cautionText.setPaintFlags(cautionText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.warning);
        builder.setView(rootView);
        builder.setNegativeButton(R.string.cancel, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();
				
			}
        	
        });
        
        builder.setPositiveButton(R.string.delete, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();

				if (mPlaylistId!=null && !mPlaylistId.isEmpty()) {
					try {
						deleteMediaStorePlaylist(mPlaylistId);
					} catch (Exception e) {
						e.printStackTrace();
					}
					
					AsyncDeletePlaylistTask task = new AsyncDeletePlaylistTask(parentActivity.getApplicationContext(), 
																			   mPlaylistId,
																			   mPlaylistFilePath);
					task.execute();
					
				} else {
					//Notify the user that they can't delete a smart playlist.
					Toast.makeText(parentActivity, R.string.playlist_cannot_be_deleted, Toast.LENGTH_LONG).show();
					
				}
				
			}
        	
        });

        return builder.create();
    }
	
    private void deleteMediaStorePlaylist(String playlistId) {
    	try {
    	    ContentResolver resolver = getActivity().getContentResolver();
    	    String where = MediaStore.Audio.Playlists._ID + "=?";
    	    String[] whereVal = { playlistId }; 
    	    resolver.delete(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, where, whereVal);     
    	} catch (Exception e) {
    		e.printStackTrace();
    	}
    	
    }
	
}
*/

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.View;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;

public class DeterminateProgressDialog extends DialogFragment {

	private Activity parentActivity;
	public static DeterminateProgressDialog dialog;
	public static TextView progressText;
	public static ProgressBar progressBar;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		parentActivity = getActivity();
		dialog = this;
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        
        String title = getArguments().getString("TITLE");
        String text = getArguments().getString("TEXT");
        
        View progressView = parentActivity.getLayoutInflater().inflate(R.layout.determinate_progress_dialog, null);
        progressText = (TextView) progressView.findViewById(R.id.determinate_progress_dialog_text);
        progressText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
        progressText.setPaintFlags(progressText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        progressText.setText(text);
        
        progressBar = (ProgressBar) progressView.findViewById(R.id.determinate_progress_dialog_bar);
        
        builder.setTitle(title);
        builder.setView(progressView);

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.database.Cursor;
import android.media.audiofx.Equalizer;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncApplyEQToAlbumTask;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.EqualizerActivity.EqualizerActivity;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.Utils.Common;

public class EQAlbumsListDialog extends DialogFragment {

	private Common mApp;
	private EqualizerActivity mEqualizerFragment;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		mApp = (Common) getActivity().getApplicationContext();
		mEqualizerFragment = (EqualizerActivity) getActivity();
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Get a cursor with the list of all albums.
        final Cursor cursor = mApp.getDBAccessHelper().getAllAlbumsOrderByName();
        
        //Set the dialog title.
        builder.setTitle(R.string.apply_to);
        builder.setCursor(cursor, new DialogInterface.OnClickListener() {
			
			@Override
			public void onClick(DialogInterface dialog, int which) {
				cursor.moveToPosition(which);
				String albumName = cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ALBUM));
				AsyncApplyEQToAlbumTask task = new AsyncApplyEQToAlbumTask(getActivity(), 
																		   albumName, 
																		   mEqualizerFragment.getFiftyHertzLevel(), 
																		   mEqualizerFragment.getOneThirtyHertzLevel(), 
																		   mEqualizerFragment.getThreeTwentyHertzLevel(), 
																		   mEqualizerFragment.getEightHundredHertzLevel(), 
																		   mEqualizerFragment.getTwoKilohertzLevel(), 
																		   mEqualizerFragment.getFiveKilohertzLevel(), 
																		   mEqualizerFragment.getTwelvePointFiveKilohertzLevel(), 
																		   (short) mEqualizerFragment.getVirtualizerSeekBar().getProgress(), 
																		   (short) mEqualizerFragment.getBassBoostSeekBar().getProgress(), 
																		   (short) mEqualizerFragment.getReverbSpinner().getSelectedItemPosition());
				
				task.execute(new String[] { "" + which });
				
				if (cursor!=null)
					cursor.close();
				
				//Hide the equalizer fragment.
				getActivity().finish();
				
			}
			
		}, DBAccessHelper.SONG_ALBUM);

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.database.Cursor;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncApplyEQToArtistTask;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.EqualizerActivity.EqualizerActivity;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.Utils.Common;

public class EQArtistsListDialog extends DialogFragment {

	private Common mApp;
	private EqualizerActivity mEqualizerFragment;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		mApp = (Common) getActivity().getApplicationContext();
		mEqualizerFragment = (EqualizerActivity) getActivity();
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Get a cursor with the list of all artists.
        final Cursor cursor = mApp.getDBAccessHelper().getAllArtistsOrderByName();
        
        //Set the dialog title.
        builder.setTitle(R.string.apply_to);
        builder.setCursor(cursor, new DialogInterface.OnClickListener() {
			
			@Override
			public void onClick(DialogInterface dialog, int which) {
				cursor.moveToPosition(which);
				String songArtist = cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ARTIST));
				AsyncApplyEQToArtistTask task = new AsyncApplyEQToArtistTask(getActivity(), 
																			 songArtist, 
																			 mEqualizerFragment.getFiftyHertzLevel(), 
															  				 mEqualizerFragment.getOneThirtyHertzLevel(), 
															  				 mEqualizerFragment.getThreeTwentyHertzLevel(), 
															  				 mEqualizerFragment.getEightHundredHertzLevel(), 
															  				 mEqualizerFragment.getTwoKilohertzLevel(), 
															  				 mEqualizerFragment.getFiveKilohertzLevel(), 
															  				 mEqualizerFragment.getTwelvePointFiveKilohertzLevel(), 
															  				 (short) mEqualizerFragment.getVirtualizerSeekBar().getProgress(), 
															  				 (short) mEqualizerFragment.getBassBoostSeekBar().getProgress(), 
															  				 (short) mEqualizerFragment.getReverbSpinner().getSelectedItemPosition());
				
				task.execute(new String[] { "" + which });
				
				if (cursor!=null)
					cursor.close();
				
				//Hide the equalizer fragment.
				getActivity().finish();

			}
			
		}, DBAccessHelper.SONG_ARTIST);

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.database.Cursor;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncApplyEQToGenreTask;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.EqualizerActivity.EqualizerActivity;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.Utils.Common;

public class EQGenresListDialog extends DialogFragment {

	private Common mApp;
	private EqualizerActivity mEqualizerFragment;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		mApp = (Common) getActivity().getApplicationContext();
		mEqualizerFragment = (EqualizerActivity) getActivity();
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Get a cursor with the list of all the unique genres.
        final Cursor cursor = mApp.getDBAccessHelper().getAllUniqueGenres("");
        
        //Set the dialog title.
        builder.setTitle(R.string.apply_to);
        builder.setCursor(cursor, new DialogInterface.OnClickListener() {
			
			@Override
			public void onClick(DialogInterface dialog, int which) {
				cursor.moveToPosition(which);
				String genreName = cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_GENRE));
				AsyncApplyEQToGenreTask task = new AsyncApplyEQToGenreTask(getActivity(), 
																		   genreName, 
																		   mEqualizerFragment.getFiftyHertzLevel(), 
														  				   mEqualizerFragment.getOneThirtyHertzLevel(), 
														  				   mEqualizerFragment.getThreeTwentyHertzLevel(), 
														  				   mEqualizerFragment.getEightHundredHertzLevel(), 
														  				   mEqualizerFragment.getTwoKilohertzLevel(), 
														  				   mEqualizerFragment.getFiveKilohertzLevel(), 
														  				   mEqualizerFragment.getTwelvePointFiveKilohertzLevel(), 
														  				   (short) mEqualizerFragment.getVirtualizerSeekBar().getProgress(), 
														  				   (short) mEqualizerFragment.getBassBoostSeekBar().getProgress(), 
														  			       (short) mEqualizerFragment.getReverbSpinner().getSelectedItemPosition());
				
				task.execute(new String[] { "" + which });
				
				if (cursor!=null)
					cursor.close();

                //Hide the equalizer fragment.
                getActivity().finish();
				
			}
			
		}, DBAccessHelper.SONG_GENRE);

        return builder.create();
    }
	
}
							

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.jams.music.player.EqualizerActivity.EqualizerActivity;
import com.jams.music.player.Utils.Common;

public class EQPlaylistsListDialog extends DialogFragment {

	private Common mApp;
	private Activity parentActivity;
	private EqualizerActivity mFragment;
	
	public EQPlaylistsListDialog() {
		super();
	}
	
	public EQPlaylistsListDialog(EqualizerActivity fragment) {
		mFragment = fragment;
	}
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		mApp = (Common) getActivity().getApplicationContext();
		parentActivity = getActivity();		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        /*//Get a cursor with the list of all user-created playlists.
        final Cursor cursor = mApp.getDBAccessHelper().getAllUniqueUserPlaylists();
        
        //Set the dialog title.
        builder.setTitle(R.string.apply_to);
        builder.setCursor(cursor, new DialogInterface.OnClickListener() {
			
			@Override
			public void onClick(DialogInterface dialog, int which) {
				
				cursor.moveToPosition(which);
				AsyncApplyEQToPlaylistTask task = new AsyncApplyEQToPlaylistTask(parentActivity, mFragment, cursor.getString(
																								 			cursor.getColumnIndex(
																								 			DBAccessHelper.PLAYLIST_NAME)));
				
				task.execute(new String[] { "" + which });
				
			}
			
		}, DBAccessHelper.PLAYLIST_NAME);
*/
        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import java.util.HashSet;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.database.Cursor;
import android.os.AsyncTask;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.MusicLibraryEditorActivity.EditDeleteMusicLibraryAdapter;
import com.jams.music.player.MusicLibraryEditorActivity.MusicLibraryEditorActivity;
import com.jams.music.player.Utils.Common;

public class EditDeleteMusicLibraryDialog extends DialogFragment {
	
	private static Common mApp;
	private String operation;
	private Cursor cursor;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		mApp = (Common) getActivity().getApplicationContext();
		AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
		
		//Get the operation that needs to be performed (edit vs. delete).
		operation = getArguments().getString("OPERATION");
		if (operation.equals("EDIT")) {
			builder.setTitle(R.string.edit_music_library);
		} else {
			builder.setTitle(R.string.delete_music_library);
		}
		
		//Get a cursor with a list of all the music libraries on the device.
		cursor = mApp.getDBAccessHelper().getAllUniqueUserLibraries(getActivity().getApplicationContext());
		
		if (cursor.getCount()==0) {
			getActivity().finish();
			Toast.makeText(getActivity(), R.string.no_music_libraries_found, Toast.LENGTH_SHORT).show();
		}
		
		builder.setAdapter(new EditDeleteMusicLibraryAdapter(getActivity(), cursor), new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				//Get the name of the library that has just been clicked. Also get its lable color code.
				cursor.moveToPosition(which);
				String libraryName = cursor.getString(cursor.getColumnIndex(DBAccessHelper.LIBRARY_NAME));
				String libraryColorCode = cursor.getString(cursor.getColumnIndex(DBAccessHelper.LIBRARY_TAG));
				
				if (operation.equals("DELETE")) {
					//Loop through the DB and look for entries that have the specified name and color code. Delete those entries.
					mApp.getDBAccessHelper().deleteLibrary(libraryName, libraryColorCode);
					
					//Display a toast message.
					String toastMessage = getActivity().getResources().getString(R.string.deleted) + " " + libraryName;
					Toast.makeText(getActivity(), toastMessage, Toast.LENGTH_LONG).show();
					
				} else {
					AsyncGetLibrarySongIdsTask task = new AsyncGetLibrarySongIdsTask(getActivity().getApplicationContext(),
																					 libraryName,
																					 libraryColorCode);
					task.execute();
					
				}
				
				dialog.dismiss();
			}
			
		});
        
        return builder.create();
    }
	
	@Override
	public void onPause() {
		super.onPause();
		
		if (cursor!=null) {
			cursor.close();
			cursor = null;
		}
		
		getActivity().finish();
		
	}

	/******************************************************************************
	 * This asynchronous task retrieves the list of all song IDs within a library.
	 ******************************************************************************/
	static class AsyncGetLibrarySongIdsTask extends AsyncTask<String, String, String> {
		
		private Context mContext;
		private String mLibraryName;
		private String mLibraryColorCode;
		private HashSet<String> songIdsHashSet = new HashSet<String>();
		
		public AsyncGetLibrarySongIdsTask(Context context, String libraryName, String libraryColorCode) {
			mContext = context;
			mLibraryName = libraryName;
			mLibraryColorCode = libraryColorCode;
			
		}
		
		@Override
		protected String doInBackground(String... arg0) {
			songIdsHashSet = mApp.getDBAccessHelper().getAllSongIdsInLibrary(mLibraryName, mLibraryColorCode);
			return null;
		}
		
		@Override
		public void onPostExecute(String result) {
			super.onPostExecute(result);
			//Launch the music library editor activity.
			Intent intent = new Intent(mContext, MusicLibraryEditorActivity.class);
			Bundle bundle = new Bundle();
			bundle.putString("LIBRARY_NAME", mLibraryName);
			bundle.putString("LIBRARY_ICON", mLibraryColorCode);
			bundle.putSerializable("SONG_IDS_HASH_SET", songIdsHashSet);
			intent.putExtras(bundle);
			intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
			mContext.startActivity(intent);
			
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.jams.music.player.R;

public class EditGooglePlayMusicTagsDialog extends DialogFragment {
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		final DialogFragment dialog = this;
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.google_play_music_no_asterisk);
        builder.setMessage(getResources().getString(R.string.edit_google_play_music_tags_unsupported));
        builder.setNegativeButton(R.string.ok, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialog.dismiss();
				
			}
        	
        });
        
        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.SharedPreferences;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.FragmentActivity;
import android.view.View;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncGoogleMusicAuthenticationTask;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class GooglePlayMusicAuthenticationDialog extends DialogFragment {

	private FragmentActivity parentActivity;
	private SharedPreferences sharedPreferences;
	private Account account;
	private boolean mFirstRun;
	private TextView infoText;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		parentActivity = getActivity();
		AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
		sharedPreferences = parentActivity.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		View rootView = parentActivity.getLayoutInflater().inflate(R.layout.dialog_google_authentication_layout, null);
		
		//Check if this dialog was called from the Welcome sequence.
		mFirstRun = getArguments().getBoolean(Common.FIRST_RUN);
		
		infoText = (TextView) rootView.findViewById(R.id.google_authentication_dialog_text);
		infoText.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		infoText.setPaintFlags(infoText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        final AccountManager accountManager = AccountManager.get(getActivity().getApplicationContext());
        final Account[] accounts = accountManager.getAccountsByType("com.google");
        final int size = accounts.length;
        String[] accountNames = new String[size];
        
        for (int i=0; i < size; i++) {
        	accountNames[i] = accounts[i].name;
        }
        
        //Set the dialog title.
        builder.setTitle(R.string.sign_in_google_play_music);
        builder.setCancelable(false);
        builder.setItems(accountNames, new DialogInterface.OnClickListener() {
			
			@Override
			public void onClick(DialogInterface dialog, int which) {
				account = accounts[which];
				sharedPreferences.edit().putString("GOOGLE_PLAY_MUSIC_ACCOUNT", account.name).commit();
				AsyncGoogleMusicAuthenticationTask task = new AsyncGoogleMusicAuthenticationTask(parentActivity.getApplicationContext(), 
																								 parentActivity,
																								 mFirstRun,
																								 account.name);
				
				task.execute();

			}
			
		});
        
        

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.AsyncTask;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.View;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.audio.exceptions.CannotReadException;
import org.jaudiotagger.audio.exceptions.CannotWriteException;
import org.jaudiotagger.audio.exceptions.InvalidAudioFrameException;
import org.jaudiotagger.audio.exceptions.ReadOnlyFileException;
import org.jaudiotagger.tag.FieldDataInvalidException;
import org.jaudiotagger.tag.FieldKey;
import org.jaudiotagger.tag.KeyNotFoundException;
import org.jaudiotagger.tag.Tag;
import org.jaudiotagger.tag.TagException;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.NoSuchElementException;

public class ID3sAlbumEditorDialog extends DialogFragment {

	private static Activity parentActivity;
	private static Common mApp;
	private DialogFragment dialogFragment;
	private View rootView;
	
	private TextView titleText;
	private TextView artistText;
	private TextView albumText;
	private TextView albumArtistText;
	private TextView genreText;
	private TextView producerText;
	private TextView yearText;
	private TextView trackText;
	private TextView ofText;
	private TextView commentsText;

	private EditText titleEditText;
	private EditText artistEditText;
	private EditText albumEditText;
	private EditText albumArtistEditText;
	private EditText genreEditText;
	private EditText producerEditText;
	private EditText yearEditText;
	private EditText trackEditText;
	private EditText trackTotalEditText;
	private EditText commentsEditText;
	
	private CheckBox titleCheckbox;
	private CheckBox artistCheckbox;
	private CheckBox albumCheckbox;
	private CheckBox albumArtistCheckbox;
	private CheckBox genreCheckbox;
	private CheckBox producerCheckbox;
	private CheckBox yearCheckbox;
	private CheckBox trackCheckbox;
	private CheckBox commentCheckbox;
	
	private boolean titleEdited = false;
	private boolean artistEdited = false;
	private boolean albumEdited = false;
	private boolean albumArtistEdited = false;
	private boolean genreEdited = false;
	private boolean producerEdited = false;
	private boolean yearEdited = false;
	private boolean trackEdited = false;
	private boolean commentEdited = false;
	
	private String ARTIST;
	private String ALBUM;
	private String CALLING_FRAGMENT;
	
	private ArrayList<String> titlesList;
	private ArrayList<String> artistsList;
	private ArrayList<String> albumsList;
	private ArrayList<String> albumArtistsList;
	private ArrayList<String> genresList;
	private ArrayList<String> producersList;
	private ArrayList<String> yearsList;
	private ArrayList<String> trackNumbersList;
	private ArrayList<String> totalTracksList;
	private ArrayList<String> commentsList;
	private ArrayList<String> songURIsList;
	private static ArrayList<String> songSourcesList;
	private static ArrayList<String> songIdsList;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		mApp = (Common) getActivity().getApplicationContext();
		parentActivity = getActivity();
		dialogFragment = this;
		
		titlesList = new ArrayList<String>();
		artistsList = new ArrayList<String>();
		albumsList = new ArrayList<String>();
		albumArtistsList = new ArrayList<String>();
		genresList = new ArrayList<String>();
		producersList = new ArrayList<String>();
		yearsList = new ArrayList<String>();
		trackNumbersList = new ArrayList<String>();
		totalTracksList = new ArrayList<String>();
		commentsList = new ArrayList<String>();
		songURIsList = new ArrayList<String>();
		songSourcesList = new ArrayList<String>();
		songIdsList = new ArrayList<String>();
		
		rootView = (View) parentActivity.getLayoutInflater().inflate(R.layout.fragment_edit_id3_artist_album_dialog, null);
		
		titleText = (TextView) rootView.findViewById(R.id.edit_title_text);
		artistText = (TextView) rootView.findViewById(R.id.edit_artist_text);
		albumText = (TextView) rootView.findViewById(R.id.edit_album_text);
		albumArtistText = (TextView) rootView.findViewById(R.id.edit_album_artist_text);
		genreText = (TextView) rootView.findViewById(R.id.edit_genre_text);
		producerText = (TextView) rootView.findViewById(R.id.edit_producer_text);
		yearText = (TextView) rootView.findViewById(R.id.edit_year_text);
		trackText = (TextView) rootView.findViewById(R.id.edit_track_text);
		ofText = (TextView) rootView.findViewById(R.id.text_of);
		commentsText = (TextView) rootView.findViewById(R.id.edit_comment_text);
		
		titleEditText = (EditText) rootView.findViewById(R.id.edit_title_field);
		artistEditText = (EditText) rootView.findViewById(R.id.edit_artist_field);
		albumEditText = (EditText) rootView.findViewById(R.id.edit_album_field);
		albumArtistEditText = (EditText) rootView.findViewById(R.id.edit_album_artist_field);
		genreEditText = (EditText) rootView.findViewById(R.id.edit_genre_field);
		producerEditText = (EditText) rootView.findViewById(R.id.edit_producer_field);
		yearEditText = (EditText) rootView.findViewById(R.id.edit_year_field);
		trackEditText = (EditText) rootView.findViewById(R.id.edit_track_field);
		trackTotalEditText = (EditText) rootView.findViewById(R.id.edit_track_total_field);
		commentsEditText = (EditText) rootView.findViewById(R.id.edit_comment_field);
		
		titleCheckbox = (CheckBox) rootView.findViewById(R.id.title_checkbox);
		artistCheckbox = (CheckBox) rootView.findViewById(R.id.artist_checkbox);
		albumCheckbox = (CheckBox) rootView.findViewById(R.id.album_checkbox);
		albumArtistCheckbox = (CheckBox) rootView.findViewById(R.id.album_artist_checkbox);
		genreCheckbox = (CheckBox) rootView.findViewById(R.id.genre_checkbox);
		producerCheckbox = (CheckBox) rootView.findViewById(R.id.producer_checkbox);
		yearCheckbox = (CheckBox) rootView.findViewById(R.id.year_checkbox);
		trackCheckbox = (CheckBox) rootView.findViewById(R.id.track_checkbox);
		commentCheckbox = (CheckBox) rootView.findViewById(R.id.comment_checkbox);
		
		titleText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		artistText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumArtistText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		genreText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		producerText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		yearText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		trackText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		ofText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		commentsText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		
		titleText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		artistText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		albumText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		albumArtistText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		genreText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		producerText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		yearText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		trackText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		ofText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		commentsText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		
		titleEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		artistEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumArtistEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		genreEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		producerEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		yearEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		trackEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		trackTotalEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		commentsEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		
		titleEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		artistEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		albumEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		albumArtistEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		genreEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		producerEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		yearEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		trackEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		trackTotalEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		commentsEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		//Keep all the fields locked by default.
		titleCheckbox.setChecked(false);
		artistCheckbox.setChecked(false);
		albumCheckbox.setChecked(false);
		albumArtistCheckbox.setChecked(false);
		genreCheckbox.setChecked(false);
		producerCheckbox.setChecked(false);
		yearCheckbox.setChecked(false);
		trackCheckbox.setChecked(false);
		commentCheckbox.setChecked(false);
		
		//Disable all EditTexts by default.
		titleEditText.setEnabled(false);
		artistEditText.setEnabled(false);
		albumEditText.setEnabled(false);
		albumArtistEditText.setEnabled(false);
		genreEditText.setEnabled(false);
		producerEditText.setEnabled(false);
		yearEditText.setEnabled(false);
		trackEditText.setEnabled(false);
		commentsEditText.setEnabled(false);
		
		//Register click registers on each checkbox.
		titleCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {

				if (checked==true) {
					titleEdited = true;
					titleEditText.setEnabled(true);
				} else {
					titleEdited = false;
					titleEditText.setEnabled(false);
				}
				
			}
			
		});
		
		artistCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					artistEdited = true;
					artistEditText.setEnabled(true);;
				} else {
					artistEdited = false;
					artistEditText.setEnabled(false);
				}
				
			}
			
		});
		
		albumArtistCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					albumEdited = true;
					albumEditText.setEnabled(true);;
				} else {
					albumEdited = false;
					albumEditText.setEnabled(false);
				}
				
			}
			
		});
		
		albumCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					albumArtistEdited = true;
					albumArtistEditText.setEnabled(true);;
				} else {
					albumArtistEdited = false;
					albumArtistEditText.setEnabled(false);
				}
				
			}
			
		});
		
		genreCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					genreEdited = true;
					genreEditText.setEnabled(true);;
				} else {
					genreEdited = false;
					genreEditText.setEnabled(false);
				}
				
			}
			
		});
		
		producerCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					producerEdited = true;
					producerEditText.setEnabled(true);;
				} else {
					producerEdited = false;
					producerEditText.setEnabled(false);
				}
				
			}
			
		});
		
		yearCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					yearEdited = true;
					yearEditText.setEnabled(true);;
				} else {
					yearEdited = false;
					yearEditText.setEnabled(false);
				}
				
			}
			
		});
		
		trackCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					trackEdited = true;
					trackEditText.setEnabled(true);;
				} else {
					trackEdited = false;
					trackEditText.setEnabled(false);
				}
				
			}
			
		});
		
		commentCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					commentEdited = true;
					commentsEditText.setEnabled(true);;
				} else {
					commentEdited = false;
					commentsEditText.setEnabled(false);
				}
				
			}
			
		});
		
		//Get the album and artist name.
		ARTIST = getArguments().getString("ARTIST");
		ALBUM = getArguments().getString("ALBUM");
		CALLING_FRAGMENT = getArguments().getString("CALLING_FRAGMENT");
		
		if (ARTIST!=null && ALBUM!=null) {
			songURIsList = getAllSongsInAlbum(ALBUM, ARTIST);
			
			//Populate the ArrayLists with the song tags.
			try {
				getSongTags(songURIsList);
			} catch (CannotReadException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TagException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (ReadOnlyFileException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidAudioFrameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			//Now check if any of the ArrayLists contain the same exact elements.
			boolean titlesSame = checkIfAllElementsEqual(titlesList);
			boolean artistsSame = checkIfAllElementsEqual(artistsList);
			boolean albumsSame = checkIfAllElementsEqual(albumsList);
			boolean albumArtistsSame = checkIfAllElementsEqual(albumArtistsList);
			boolean genresSame = checkIfAllElementsEqual(genresList);
			boolean producersSame = checkIfAllElementsEqual(producersList);
			boolean yearsSame = checkIfAllElementsEqual(yearsList);
			boolean tracksSame = checkIfAllElementsEqual(trackNumbersList);
			boolean totalTracksSame = checkIfAllElementsEqual(totalTracksList);
			boolean commentsSame = checkIfAllElementsEqual(commentsList);
			
			//Populate the EditTexts.
			setEditorFields(titlesSame, titlesList, titleEditText);
			setEditorFields(artistsSame, artistsList, artistEditText);
			setEditorFields(albumsSame, albumsList, albumEditText);
			setEditorFields(albumArtistsSame, albumArtistsList, albumArtistEditText);
			setEditorFields(genresSame, genresList, genreEditText);
			setEditorFields(producersSame, producersList, producerEditText);
			setEditorFields(yearsSame, yearsList, yearEditText);
			setEditorFields(tracksSame, trackNumbersList, trackEditText);
			setEditorFields(totalTracksSame, totalTracksList, trackTotalEditText);
			setEditorFields(commentsSame, commentsList, commentsEditText);
			
		}
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.edit_tags);
        builder.setView(rootView);
        builder.setNeutralButton(R.string.save, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				AsyncSaveAlbumTagsTask asyncSaveAlbumTagsTask = new AsyncSaveAlbumTagsTask(getActivity(), getActivity());
				asyncSaveAlbumTagsTask.execute();
        	
			}
	        
        });
        
        builder.setNegativeButton(R.string.cancel, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				clearArrayLists();
				dialogFragment.dismiss();
				
			}
        	
        });

        return builder.create();
			
	}
	
	public static ArrayList<String> getAllSongsInAlbum(String albumName, String artistName) {
		ArrayList<String> songURIsList = new ArrayList<String>();
		
		//Escape any rogue apostrophes.
		if (albumName.contains("'")) {
			albumName = albumName.replace("'", "''");
		}
		
		if (artistName.contains("'")) {
			artistName = artistName.replace("'", "''");
		}
		
		String selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + albumName + "'" + " AND "
						 + DBAccessHelper.SONG_ARTIST + "=" + "'" + artistName + "'" + " AND "
						 + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
		
		Cursor cursor = mApp.getDBAccessHelper().getAllSongsByAlbumArtist(selection);
		cursor.moveToFirst();
		if (cursor.getCount()!=0) {
			
			do {
				songURIsList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH)));
				songSourcesList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_SOURCE)));
				songIdsList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ID)));
			} while (cursor.moveToNext());
			
		}
		
		cursor.close();
		return songURIsList;
	}
	
	public static ArrayList<String> getAllSongsByArtist(String artistName) {
		ArrayList<String> songURIsList = new ArrayList<String>();

		//Escape any rogue apostrophes.
		if (artistName.contains("'")) {
			artistName = artistName.replace("'", "''");
		}
		
		String selection = DBAccessHelper.SONG_ARTIST + "=" + "'" + artistName + "'"
						 + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
		
		String[] projection = { DBAccessHelper._ID, DBAccessHelper.SONG_FILE_PATH, 
								DBAccessHelper.SONG_SOURCE, DBAccessHelper.SONG_ID };
		
		Cursor cursor = mApp.getDBAccessHelper().getWritableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
															 projection,
															 selection, 
															 null, 
															 null, 
															 null, 
															 null);
		
		cursor.moveToFirst();
		if (cursor.getCount()!=0) {
			
			do {
				songURIsList.add(cursor.getString(1));
				songSourcesList.add(cursor.getString(2));
				songIdsList.add(cursor.getString(3));
			} while (cursor.moveToNext());
			
		}
		
		cursor.close();
		return songURIsList;
	}
	
	//This method loops through all the songs and saves their tags into ArrayLists.
	public void getSongTags(ArrayList<String> dataURIsList) throws CannotReadException, 
																   IOException, 
																   TagException, 
																   ReadOnlyFileException, 
																   InvalidAudioFrameException {

		Cursor cursor = null;
		for (int i=0; i < dataURIsList.size(); i++) {
			
			//Check if the song is from Google Play Music.
			if (songSourcesList.get(i).equals(DBAccessHelper.GMUSIC)) {
				
				String songId = songIdsList.get(i);
				cursor = mApp.getDBAccessHelper().getSongById(songId);
				cursor.moveToFirst();
				
				titlesList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_TITLE)));
				artistsList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ARTIST)));
				albumsList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ALBUM)));
				albumArtistsList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ALBUM_ARTIST)));
				genresList.add("");
				producersList.add("");
				yearsList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_YEAR)));
				trackNumbersList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_TRACK_NUMBER)));
				totalTracksList.add("");
				commentsList.add("");
				
			} else {
				File file = null;
				try {
					file = new File(dataURIsList.get(i));
				} catch (Exception e) {
					e.printStackTrace();
					continue;
				}
				AudioFile audioFile = AudioFileIO.read(file);
				
				titlesList.add(audioFile.getTag().getFirst(FieldKey.TITLE));
				artistsList.add(audioFile.getTag().getFirst(FieldKey.ARTIST));
				albumsList.add(audioFile.getTag().getFirst(FieldKey.ALBUM));
				albumArtistsList.add(audioFile.getTag().getFirst(FieldKey.ALBUM_ARTIST));
				genresList.add(audioFile.getTag().getFirst(FieldKey.GENRE));
				producersList.add(audioFile.getTag().getFirst(FieldKey.PRODUCER));
				yearsList.add(audioFile.getTag().getFirst(FieldKey.YEAR));
				trackNumbersList.add(audioFile.getTag().getFirst(FieldKey.TRACK));
				totalTracksList.add(audioFile.getTag().getFirst(FieldKey.TRACK_TOTAL));
				commentsList.add(audioFile.getTag().getFirst(FieldKey.COMMENT));
				
			}
			
		}
		
		if (cursor!=null) {
			cursor.close();
			cursor = null;
		}
		
	}
	
	//This method goes through the inputted ArrayList and checks if all its elements are the same.
	public static boolean checkIfAllElementsEqual(ArrayList<String> list) {
		
		if (list.size()!=0) {
			String firstElement = list.get(0);
			
			for (int i=0; i < list.size(); i++) {
				if (!firstElement.equals(list.get(i))) {
					return false;
				}
				
			}
			
			return true;
		}
		
		return false;	
	}
	
	//This method sets the specified EditText values based on the boolean parameter.
	public static void setEditorFields(boolean allElementsSame, ArrayList<String> list, EditText editText) {
		
		if (allElementsSame==true) {
			editText.setText(list.get(0));
		} else {
			editText.setText(R.string.varies_by_song);
		}
		
	}
	
	//This AsyncTask gathers all the tags, iterates through each song, and saves them.
	class AsyncSaveAlbumTagsTask extends AsyncTask<String, String, String> {
		
		private Context mContext;
		private Activity mActivity;
		private ProgressDialog pd;
		private int i = 0;
		
		private String songTitle;
		private String songArtist;
		private String songAlbum;
		private String songAlbumArtist;
		private String songComposer;
		private String songProducer;
		private String songTrackNumber;
		private String songTrackTotals;
		private String songComments;
		private String songYear;
		
		public AsyncSaveAlbumTagsTask(Activity activity, Context context) {
			mContext = context;
			mActivity = activity;
		}
		
		@Override
		protected void onPreExecute() {
			super.onPreExecute();
			pd = new ProgressDialog(mActivity);
			pd.setTitle(R.string.saving_album_info);
			pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
			pd.setIndeterminate(false);
			pd.setMax(songURIsList.size());
			pd.show();
			
			//Retrieve the strings from the EditText fields.
			if (titleEdited) {
				songTitle = titleEditText.getText().toString();	
				songTitle = songTitle.replace("'", "''");
			} else {
				songTitle = null;
			}
			
			if (artistEdited) {
				songArtist = artistEditText.getText().toString();
				songArtist = songArtist.replace("'", "''");
			} else {
				songArtist = null;
			}
			
			if (albumEdited) {
				songAlbum = albumEditText.getText().toString();
				songAlbum = songAlbum.replace("'", "''");
			} else {
				songAlbum = null;
			}
			
			if (albumArtistEdited) {
				songAlbumArtist = albumArtistEditText.getText().toString();
				songAlbumArtist = songAlbumArtist.replace("'", "''");
			} else {
				songAlbumArtist = null;
			}
			
			if (genreEdited) {
				songComposer = genreEditText.getText().toString();
				songComposer = songComposer.replace("'", "''");
			} else {
				songComposer = null;
			}
			
			if (producerEdited) {
				songProducer = producerEditText.getText().toString();
				songProducer = songProducer.replace("'", "''");
			} else {
				songProducer = null;
			}
			
			if (trackEdited) {
				songTrackNumber = trackEditText.getText().toString();
				songTrackNumber = songTrackNumber.replace("'", "''");
				songTrackTotals = trackTotalEditText.getText().toString();
				songTrackTotals = songTrackTotals.replace("'", "''");
			} else {
				songTrackNumber = null;
				songTrackTotals = null;
			}
			
			if (commentEdited) {
				songComments = commentsEditText.getText().toString();
				songComments = songComments.replace("'", "''");
			} else {
				songComments = null;
			}
			
			if (yearEdited) {
				songYear = yearEditText.getText().toString();
				songYear = songYear.replace("'", "''");
			} else {
				songYear = null;
			}
			
		}
		
		@Override
		protected String doInBackground(String... arg0) {
			
			for (i=0; i < songURIsList.size(); i++) {
				publishProgress(new String[] {});
				
				//Check if the current song is from Google Play Music.
				if (songSourcesList.get(i).equals(DBAccessHelper.GMUSIC)) {
					continue;
/*					String songId = songIdsList.get(i);
					
					try {
						String result = GMusicClientCalls.editTrackInfo(4, mContext, songId, songTitle, 
																   songAlbum, songArtist, songAlbumArtist, 
																   null, songComposer, songYear, 
																   songTrackNumber, songTrackTotals);
						Log.e("DEBUG", ">>>RESULT: " + result);
						
						 ==================================================
						 * ==================================================
						 * ==================================================
						 * MUST UPDATE THE DATABASE =========================
						 * ==================================================
						 * ==================================================
						 
						
					} catch (JSONException e) {
						e.printStackTrace();
						continue;
					}*/
					
				} else {
					File file = null;
					try {
						file = new File(songURIsList.get(i));
					} catch (Exception e) {
						e.printStackTrace();
						continue;
					}
					AudioFile audioFile = null;
					
					try {
						audioFile = AudioFileIO.read(file);
					} catch (CannotReadException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (TagException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (ReadOnlyFileException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (InvalidAudioFrameException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					Tag tag = audioFile.getTag();
					
					//Update the DB entries.
					if (tag!=null) {
						//Escape any rogue apostrophes.
						String uri = songURIsList.get(i);
						
						if (uri.contains("'")) {
							uri = uri.replace("'", "''");
						}
						
						String whereClause = DBAccessHelper.SONG_FILE_PATH + "=" + "'" + uri + "'";
						ContentValues values = new ContentValues();
						
						if (titleEdited==false) {
							//Don't do anything here. The user didn't change the title.
						} else {
							try {
								tag.setField(FieldKey.TITLE, songTitle);
							} catch (KeyNotFoundException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (FieldDataInvalidException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (NoSuchElementException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
							values.put(DBAccessHelper.SONG_TITLE, songTitle);
							
						}
						
						if (albumEdited==false) {
							//Don't do anything here. The user didn't change the album.
						} else {
							try {
								tag.setField(FieldKey.ALBUM, songAlbum);
							} catch (KeyNotFoundException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (FieldDataInvalidException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (NoSuchElementException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
							values.put(DBAccessHelper.SONG_ALBUM, songAlbum);
							
						}
						
						if (artistEdited==false) {
							//Don't do anything here. The user didn't change the artist.
						} else {
							try {
								tag.setField(FieldKey.ARTIST, songArtist);
							} catch (KeyNotFoundException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (FieldDataInvalidException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (NoSuchElementException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
							values.put(DBAccessHelper.SONG_ARTIST, songArtist);
							
						}
						
						if (albumArtistEdited==false) {
							//Don't do anything here. The user didn't change the album artist.
						} else {
							try {
								tag.setField(FieldKey.ALBUM_ARTIST, songAlbumArtist);
							} catch (KeyNotFoundException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (FieldDataInvalidException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (NoSuchElementException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
							values.put(DBAccessHelper.SONG_ALBUM_ARTIST, songAlbumArtist);
							
						}
						
						if (genreEdited==false) {
							//Don't do anything here. The user didn't change the genre.
						} else {
							try {
								tag.setField(FieldKey.GENRE, songComposer);
							} catch (KeyNotFoundException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (FieldDataInvalidException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (NoSuchElementException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
						if (producerEdited==false) {
							//Don't do anything here. The user didn't change the producer.
						} else {
							try {
								tag.setField(FieldKey.PRODUCER, songProducer);
							} catch (KeyNotFoundException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (FieldDataInvalidException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (NoSuchElementException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
						if (yearEdited==false) {
							//Don't do anything here. The user didn't change the year.
						} else {
							try {
								tag.setField(FieldKey.YEAR, songYear);
							} catch (KeyNotFoundException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (FieldDataInvalidException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (NoSuchElementException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (NumberFormatException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
							values.put(DBAccessHelper.SONG_YEAR, songYear);
							
						}
						
						if (trackEdited==false) {
							//Don't do anything here. The user didn't change the track number.
						} else {
							try {
								tag.setField(FieldKey.TRACK, songTrackNumber);
							} catch (KeyNotFoundException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (FieldDataInvalidException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (NoSuchElementException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (NumberFormatException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
							values.put(DBAccessHelper.SONG_TRACK_NUMBER, songTrackNumber);
							
						}
						
						try {
							tag.setField(FieldKey.TRACK_TOTAL, songTrackTotals);
						} catch (KeyNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (FieldDataInvalidException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NoSuchElementException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NumberFormatException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
						if (commentEdited==false) {
							//Don't do anything here. The user didn't change the comments.
						} else {
							try {
								tag.setField(FieldKey.COMMENT, songComments);
							} catch (KeyNotFoundException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (FieldDataInvalidException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (NoSuchElementException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
						try {
							audioFile.commit();
						} catch (CannotWriteException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
						//Write the values to the DB.
						try {
							mApp.getDBAccessHelper().getWritableDatabase().update(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
									  values, 
									  whereClause, 
									  null);

							
						} catch (Exception e) {
							e.printStackTrace();
						}
						
					} else {
						Toast.makeText(mContext, R.string.unable_to_edit_album_tags, Toast.LENGTH_SHORT).show();
					}

				}
				
			}
			return null;
		}
		
		@Override
		protected void onProgressUpdate(String... values) {
			super.onProgressUpdate(values);
			pd.setProgress(i);
			String message = mContext.getResources().getString(R.string.saving_song_info_for) + " " + titlesList.get(i) + ".";
			pd.setMessage(message);
			
		}
		
		@Override
		protected void onPostExecute(String result) {
			super.onPostExecute(result);
			pd.dismiss();
			
/*			if (CALLING_FRAGMENT.equals("ALBUMS_FRAGMENT")) {

			} else if (CALLING_FRAGMENT.equals("ALBUM_ARTISTS_FLIPPED_FRAGMENT")) {
				AlbumArtistsFlippedFragment.getCursor();
				AlbumArtistsFlippedFragment.albumArtistsFlippedListViewAdapter.notifyDataSetChanged();
			} else if (CALLING_FRAGMENT.equals("GENRES_FLIPPED_FRAGMENT")) {
				GenresFlippedFragment.getCursor();
				GenresFlippedFragment.genresFlippedListViewAdapter.notifyDataSetChanged();
			} else {
				ArtistsFlippedFragment.artistsFlippedListView.setAdapter(null);
				ArtistsFlippedFragment.getCursor();
				ArtistsFlippedFragment.artistsFlippedListViewAdapter = new ArtistsFlippedListViewAdapter(mContext, ArtistsFlippedFragment.cursor);
				ArtistsFlippedFragment.artistsFlippedListView.setAdapter(ArtistsFlippedFragment.artistsFlippedListViewAdapter);
				ArtistsFlippedFragment.artistsFlippedListView.invalidate();
			}*/
			
			//Delete all the contents of the ArrayLists.
			clearArrayLists();
			dialogFragment.dismiss();
			Toast.makeText(parentActivity, R.string.changes_saved, Toast.LENGTH_SHORT).show();
			
		}
		
	}
	
	public void clearArrayLists() {
		if (titlesList!=null) {
			titlesList.clear();
			titlesList = null;
		}
		
		if (artistsList!=null) {
			artistsList.clear();
			artistsList = null;
		}
		
		if (albumsList!=null) {
			albumsList.clear();
			albumsList = null;
		}
		
		if (albumArtistsList!=null) {
			albumArtistsList.clear();
			albumArtistsList = null;
		}
		
		if (genresList!=null) {
			genresList.clear();
			genresList = null;
		}
		
		if (producersList!=null) {
			producersList.clear();
			producersList = null;
		}
		
		if (yearsList!=null) {
			yearsList.clear();
			yearsList = null;
		}
		
		if (trackNumbersList!=null) {
			trackNumbersList.clear();
			trackNumbersList = null;
		}
		
		if (totalTracksList!=null) {
			totalTracksList.clear();
			totalTracksList = null;
		}
		
		if (commentsList!=null) {
			commentsList.clear();
			commentsList = null;
		}
		
		if (songURIsList!=null) {
			songURIsList.clear();
			songURIsList = null;
		}
		
		if (songSourcesList!=null) {
			songSourcesList.clear();
			songSourcesList = null;
		}
		
		if (songIdsList!=null) {
			songIdsList.clear();
			songIdsList = null;
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.NoSuchElementException;

import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.audio.exceptions.CannotReadException;
import org.jaudiotagger.audio.exceptions.CannotWriteException;
import org.jaudiotagger.audio.exceptions.InvalidAudioFrameException;
import org.jaudiotagger.audio.exceptions.ReadOnlyFileException;
import org.jaudiotagger.tag.FieldDataInvalidException;
import org.jaudiotagger.tag.FieldKey;
import org.jaudiotagger.tag.KeyNotFoundException;
import org.jaudiotagger.tag.Tag;
import org.jaudiotagger.tag.TagException;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.AsyncTask;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.View;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.MainActivity.MainActivity;

public class ID3sArtistEditorDialog extends DialogFragment {

	private Context mContext;
	private static Activity parentActivity;
	private DialogFragment dialogFragment;
	private View rootView;
	
	private TextView titleText;
	private TextView artistText;
	private TextView albumText;
	private TextView albumArtistText;
	private TextView genreText;
	private TextView producerText;
	private TextView yearText;
	private TextView trackText;
	private TextView ofText;
	private TextView commentsText;

	private EditText titleEditText;
	private EditText artistEditText;
	private EditText albumEditText;
	private EditText albumArtistEditText;
	private EditText genreEditText;
	private EditText producerEditText;
	private EditText yearEditText;
	private EditText trackEditText;
	private EditText trackTotalEditText;
	private EditText commentsEditText;
	
	private CheckBox titleCheckbox;
	private CheckBox artistCheckbox;
	private CheckBox albumCheckbox;
	private CheckBox albumArtistCheckbox;
	private CheckBox genreCheckbox;
	private CheckBox producerCheckbox;
	private CheckBox yearCheckbox;
	private CheckBox trackCheckbox;
	private CheckBox commentCheckbox;
	
	private boolean titleEdited = false;
	private boolean artistEdited = false;
	private boolean albumEdited = false;
	private boolean albumArtistEdited = false;
	private boolean genreEdited = false;
	private boolean producerEdited = false;
	private boolean yearEdited = false;
	private boolean trackEdited = false;
	private boolean commentEdited = false;
	
	private String ARTIST;
	
	private ArrayList<String> titlesList = new ArrayList<String>();
	private ArrayList<String> artistsList = new ArrayList<String>();
	private ArrayList<String> albumsList = new ArrayList<String>();
	private ArrayList<String> albumArtistsList = new ArrayList<String>();
	private ArrayList<String> genresList = new ArrayList<String>();
	private ArrayList<String> producersList = new ArrayList<String>();
	private ArrayList<String> yearsList = new ArrayList<String>();
	private ArrayList<String> trackNumbersList = new ArrayList<String>();
	private ArrayList<String> totalTracksList = new ArrayList<String>();
	private ArrayList<String> commentsList = new ArrayList<String>();
	private ArrayList<String> songURIsList = new ArrayList<String>();
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		mContext = getActivity();
		parentActivity = getActivity();
		dialogFragment = this;
		
		//Get the artist name.
		ARTIST = getArguments().getString("ARTIST");
		
		rootView = (View) parentActivity.getLayoutInflater().inflate(R.layout.fragment_edit_id3_artist_album_dialog, null);
		
		titleText = (TextView) rootView.findViewById(R.id.edit_title_text);
		artistText = (TextView) rootView.findViewById(R.id.edit_artist_text);
		albumText = (TextView) rootView.findViewById(R.id.edit_album_text);
		albumArtistText = (TextView) rootView.findViewById(R.id.edit_album_artist_text);
		genreText = (TextView) rootView.findViewById(R.id.edit_genre_text);
		producerText = (TextView) rootView.findViewById(R.id.edit_producer_text);
		yearText = (TextView) rootView.findViewById(R.id.edit_year_text);
		trackText = (TextView) rootView.findViewById(R.id.edit_track_text);
		ofText = (TextView) rootView.findViewById(R.id.text_of);
		commentsText = (TextView) rootView.findViewById(R.id.edit_comment_text);
		
		titleEditText = (EditText) rootView.findViewById(R.id.edit_title_field);
		artistEditText = (EditText) rootView.findViewById(R.id.edit_artist_field);
		albumEditText = (EditText) rootView.findViewById(R.id.edit_album_field);
		albumArtistEditText = (EditText) rootView.findViewById(R.id.edit_album_artist_field);
		genreEditText = (EditText) rootView.findViewById(R.id.edit_genre_field);
		producerEditText = (EditText) rootView.findViewById(R.id.edit_producer_field);
		yearEditText = (EditText) rootView.findViewById(R.id.edit_year_field);
		trackEditText = (EditText) rootView.findViewById(R.id.edit_track_field);
		trackTotalEditText = (EditText) rootView.findViewById(R.id.edit_track_total_field);
		commentsEditText = (EditText) rootView.findViewById(R.id.edit_comment_field);
		
		titleCheckbox = (CheckBox) rootView.findViewById(R.id.title_checkbox);
		artistCheckbox = (CheckBox) rootView.findViewById(R.id.artist_checkbox);
		albumCheckbox = (CheckBox) rootView.findViewById(R.id.album_checkbox);
		albumArtistCheckbox = (CheckBox) rootView.findViewById(R.id.album_artist_checkbox);
		genreCheckbox = (CheckBox) rootView.findViewById(R.id.genre_checkbox);
		producerCheckbox = (CheckBox) rootView.findViewById(R.id.producer_checkbox);
		yearCheckbox = (CheckBox) rootView.findViewById(R.id.year_checkbox);
		trackCheckbox = (CheckBox) rootView.findViewById(R.id.track_checkbox);
		commentCheckbox = (CheckBox) rootView.findViewById(R.id.comment_checkbox);
		
		titleText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		artistText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumArtistText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		genreText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		producerText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		yearText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		trackText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		ofText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		commentsText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		
		titleText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		artistText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		albumText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		albumArtistText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		genreText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		producerText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		yearText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		trackText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		ofText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		commentsText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		
		titleEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		artistEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumArtistEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		genreEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		producerEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		yearEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		trackEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		trackTotalEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		commentsEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		
		titleEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		artistEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		albumEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		albumArtistEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		genreEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		producerEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		yearEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		trackEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		trackTotalEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		commentsEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		//Keep all the fields locked by default.
		titleCheckbox.setChecked(false);
		artistCheckbox.setChecked(false);
		albumCheckbox.setChecked(false);
		albumArtistCheckbox.setChecked(false);
		genreCheckbox.setChecked(false);
		producerCheckbox.setChecked(false);
		yearCheckbox.setChecked(false);
		trackCheckbox.setChecked(false);
		commentCheckbox.setChecked(false);
		
		//Disable all EditTexts by default.
		titleEditText.setEnabled(false);
		artistEditText.setEnabled(false);
		albumEditText.setEnabled(false);
		albumArtistEditText.setEnabled(false);
		genreEditText.setEnabled(false);
		producerEditText.setEnabled(false);
		yearEditText.setEnabled(false);
		trackEditText.setEnabled(false);
		commentsEditText.setEnabled(false);
		
		//Register click registers on each checkbox.
		titleCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {

				if (checked==true) {
					titleEdited = true;
					titleEditText.setEnabled(true);
				} else {
					titleEdited = false;
					titleEditText.setEnabled(false);
				}
				
			}
			
		});
		
		artistCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					artistEdited = true;
					artistEditText.setEnabled(true);;
				} else {
					artistEdited = false;
					artistEditText.setEnabled(false);
				}
				
			}
			
		});
		
		albumArtistCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					albumEdited = true;
					albumEditText.setEnabled(true);;
				} else {
					albumEdited = false;
					albumEditText.setEnabled(false);
				}
				
			}
			
		});
		
		albumCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					albumArtistEdited = true;
					albumArtistEditText.setEnabled(true);;
				} else {
					albumArtistEdited = false;
					albumArtistEditText.setEnabled(false);
				}
				
			}
			
		});
		
		genreCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					genreEdited = true;
					genreEditText.setEnabled(true);;
				} else {
					genreEdited = false;
					genreEditText.setEnabled(false);
				}
				
			}
			
		});
		
		producerCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					producerEdited = true;
					producerEditText.setEnabled(true);;
				} else {
					producerEdited = false;
					producerEditText.setEnabled(false);
				}
				
			}
			
		});
		
		yearCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					yearEdited = true;
					yearEditText.setEnabled(true);;
				} else {
					yearEdited = false;
					yearEditText.setEnabled(false);
				}
				
			}
			
		});
		
		trackCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					trackEdited = true;
					trackEditText.setEnabled(true);;
				} else {
					trackEdited = false;
					trackEditText.setEnabled(false);
				}
				
			}
			
		});
		
		commentCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					commentEdited = true;
					commentsEditText.setEnabled(true);;
				} else {
					commentEdited = false;
					commentsEditText.setEnabled(false);
				}
				
			}
			
		});

		if (ARTIST!=null) {
			songURIsList = getAllSongsByArtist(ARTIST);
			
			//Populate the ArrayLists with the song tags.
			try {
				getSongTags(songURIsList);
			} catch (CannotReadException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TagException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (ReadOnlyFileException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidAudioFrameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			//Now check if any of the ArrayLists contain the same exact elements.
			boolean titlesSame = checkIfAllElementsEqual(titlesList);
			boolean artistsSame = checkIfAllElementsEqual(artistsList);
			boolean albumsSame = checkIfAllElementsEqual(albumsList);
			boolean albumArtistsSame = checkIfAllElementsEqual(albumArtistsList);
			boolean genresSame = checkIfAllElementsEqual(genresList);
			boolean producersSame = checkIfAllElementsEqual(producersList);
			boolean yearsSame = checkIfAllElementsEqual(yearsList);
			boolean tracksSame = checkIfAllElementsEqual(trackNumbersList);
			boolean totalTracksSame = checkIfAllElementsEqual(totalTracksList);
			boolean commentsSame = checkIfAllElementsEqual(commentsList);
			
			//Populate the EditTexts.
			setEditorFields(titlesSame, titlesList, titleEditText);
			setEditorFields(artistsSame, artistsList, artistEditText);
			setEditorFields(albumsSame, albumsList, albumEditText);
			setEditorFields(albumArtistsSame, albumArtistsList, albumArtistEditText);
			setEditorFields(genresSame, genresList, genreEditText);
			setEditorFields(producersSame, producersList, producerEditText);
			setEditorFields(yearsSame, yearsList, yearEditText);
			setEditorFields(tracksSame, trackNumbersList, trackEditText);
			setEditorFields(totalTracksSame, totalTracksList, trackTotalEditText);
			setEditorFields(commentsSame, commentsList, commentsEditText);
			
		}
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.edit_tags);
        builder.setView(rootView);
        builder.setPositiveButton(R.string.save, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();
				AsyncSaveArtistTagsTask asyncSaveArtistTagsTask = new AsyncSaveArtistTagsTask(getActivity(), getActivity());
				asyncSaveArtistTagsTask.execute();
        	
			}
	        
        });
        
        builder.setNegativeButton(R.string.cancel, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				dialog.dismiss();
				
			}
        	
        });

        return builder.create();
			
	}
	
	public static ArrayList<String> getAllSongsInAlbum(String albumName, String artistName) {
		ArrayList<String> songURIsList = new ArrayList<String>();
		
		DBAccessHelper dbHelper = new DBAccessHelper(parentActivity);
		
		//Escape any rogue apostrophes.
		if (albumName.contains("'")) {
			albumName = albumName.replace("'", "''");
		}
		
		if (artistName.contains("'")) {
			artistName = artistName.replace("'", "''");
		}
		
		String selection = DBAccessHelper.SONG_ALBUM + "=" + "'" + albumName + "'" + " AND "
						 + DBAccessHelper.SONG_ARTIST + "=" + "'" + artistName + "'" + " AND "
						 + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
		
		String[] projection = { DBAccessHelper._ID, DBAccessHelper.SONG_FILE_PATH };
		
		Cursor cursor = dbHelper.getWritableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
															 projection,
															 selection, 
															 null, 
															 null, 
															 null, 
															 null);
		
		cursor.moveToFirst();
		
		if (cursor.getCount()!=0) {
			
			songURIsList.add(cursor.getString(1));
			
			while (cursor.moveToNext()) {
				songURIsList.add(cursor.getString(1));
				
			}
			
		}
		
		cursor.close();
		
		return songURIsList;
		
	}
	
	public static ArrayList<String> getAllSongsByArtist(String artistName) {
		ArrayList<String> songURIsList = new ArrayList<String>();
		
		DBAccessHelper dbHelper = new DBAccessHelper(parentActivity);
		
		//Escape any rogue apostrophes.
		if (artistName.contains("'")) {
			artistName = artistName.replace("'", "''");
		}
		
		String selection = DBAccessHelper.SONG_ARTIST + "=" + "'" + artistName + "'"
						 + " AND " + DBAccessHelper.SONG_SOURCE + "<>" + "'GOOGLE_PLAY_MUSIC'";
		
		String[] projection = { DBAccessHelper._ID, DBAccessHelper.SONG_FILE_PATH };
		
		Cursor cursor = dbHelper.getWritableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
															 projection,
															 selection, 
															 null, 
															 null, 
															 null, 
															 null);
		
		cursor.moveToFirst();
		
		if (cursor.getCount()!=0) {
			
			songURIsList.add(cursor.getString(1));
			
			while (cursor.moveToNext()) {
				songURIsList.add(cursor.getString(1));
				
			}
			
		}
		
		cursor.close();
		
		return songURIsList;
		
	}
	
	//This method loops through all the songs and saves their tags into ArrayLists.
	public void getSongTags(ArrayList<String> dataURIsList) throws CannotReadException, 
																   IOException, 
																   TagException, 
																   ReadOnlyFileException, 
																   InvalidAudioFrameException {
		
		for (int i=0; i < dataURIsList.size(); i++) {
			
			try {
				File file = new File(dataURIsList.get(i));
				AudioFile audioFile = AudioFileIO.read(file);
				
				titlesList.add(audioFile.getTag().getFirst(FieldKey.TITLE));
				artistsList.add(audioFile.getTag().getFirst(FieldKey.ARTIST));
				albumsList.add(audioFile.getTag().getFirst(FieldKey.ALBUM));
				albumArtistsList.add(audioFile.getTag().getFirst(FieldKey.ALBUM_ARTIST));
				genresList.add(audioFile.getTag().getFirst(FieldKey.GENRE));
				producersList.add(audioFile.getTag().getFirst(FieldKey.PRODUCER));
				yearsList.add(audioFile.getTag().getFirst(FieldKey.YEAR));
				trackNumbersList.add(audioFile.getTag().getFirst(FieldKey.TRACK));
				totalTracksList.add(audioFile.getTag().getFirst(FieldKey.TRACK_TOTAL));
				commentsList.add(audioFile.getTag().getFirst(FieldKey.COMMENT));
				
			} catch (Exception e) {
				e.printStackTrace();
				continue;
			}
			
		}
		
	}
	
	//This method goes through the inputted ArrayList and checks if all its elements are the same.
	public static boolean checkIfAllElementsEqual(ArrayList<String> list) {
		
		if (list.size()!=0) {
			String firstElement = list.get(0);
			
			for (int i=0; i < list.size(); i++) {
				if (!firstElement.equals(list.get(i))) {
					return false;
				}
				
			}
			
			return true;
		}
		
		return false;
		
	}
	
	//This method sets the specified EditText values based on the boolean parameter.
	public static void setEditorFields(boolean allElementsSame, ArrayList<String> list, EditText editText) {
		
		if (allElementsSame==true) {
			editText.setText(list.get(0));
		} else {
			editText.setText(R.string.varies_by_song);
		}
		
	}
	
	class AsyncSaveArtistTagsTask extends AsyncTask<String, String, String> {

		private Context mContext;
		private Activity mActivity;
		private ProgressDialog pd;
		private int i = 0;
		
		private String songTitle;
		private String songArtist;
		private String songAlbum;
		private String songAlbumArtist;
		private String songComposer;
		private String songProducer;
		private String songTrackNumber;
		private String songTrackTotals;
		private String songComments;
		private String songYear;
		
		public AsyncSaveArtistTagsTask(Context context, Activity activity) {
			mContext = context;
			mActivity = activity;
		}

		@Override
		protected void onPreExecute() {
			super.onPreExecute();
			
			pd = new ProgressDialog(mActivity);
			pd.setTitle(R.string.saving_artist_info);
			pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
			pd.setIndeterminate(false);
			pd.setMax(songURIsList.size());
			pd.show();
			
			//Retrieve the strings from the EditText fields.
			if (titleEdited) {
				songTitle = titleEditText.getText().toString();	
				songTitle = songTitle.replace("'", "''");
			} else {
				songTitle = null;
			}
			
			if (artistEdited) {
				songArtist = artistEditText.getText().toString();
				songArtist = songArtist.replace("'", "''");
			} else {
				songArtist = null;
			}
			
			if (albumEdited) {
				songAlbum = albumEditText.getText().toString();
				songAlbum = songAlbum.replace("'", "''");
			} else {
				songAlbum = null;
			}
			
			if (albumArtistEdited) {
				songAlbumArtist = albumArtistEditText.getText().toString();
				songAlbumArtist = songAlbumArtist.replace("'", "''");
			} else {
				songAlbumArtist = null;
			}
			
			if (genreEdited) {
				songComposer = genreEditText.getText().toString();
				songComposer = songComposer.replace("'", "''");
			} else {
				songComposer = null;
			}
			
			if (producerEdited) {
				songProducer = producerEditText.getText().toString();
				songProducer = songProducer.replace("'", "''");
			} else {
				songProducer = null;
			}
			
			if (trackEdited) {
				songTrackNumber = trackEditText.getText().toString();
				songTrackNumber = songTrackNumber.replace("'", "''");
				songTrackTotals = trackTotalEditText.getText().toString();
				songTrackTotals = songTrackTotals.replace("'", "''");
			} else {
				songTrackNumber = null;
				songTrackTotals = null;
			}
			
			if (commentEdited) {
				songComments = commentsEditText.getText().toString();
				songComments = songComments.replace("'", "''");
			} else {
				songComments = null;
			}
			
			if (yearEdited) {
				songYear = yearEditText.getText().toString();
				songYear = songYear.replace("'", "''");
			} else {
				songYear = null;
			}
			
		}
		
		@Override
		protected String doInBackground(String... arg0) {

			//Create DB instances.
			DBAccessHelper dbHelper = new DBAccessHelper(mContext.getApplicationContext());
			
			for (i=0; i < songURIsList.size(); i++) {
				publishProgress(new String[] {});
				File file = null;
				try {
					file = new File(songURIsList.get(i));
				} catch (Exception e) {
					e.printStackTrace();
					continue;
				}
				AudioFile audioFile = null;
				
				try {
					audioFile = AudioFileIO.read(file);
				} catch (CannotReadException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (TagException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (ReadOnlyFileException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (InvalidAudioFrameException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				//Escape any rogue apostrophes.
				String uri = songURIsList.get(i);
				
				if (uri!=null) {
					if (uri.contains("'")) {
						uri = uri.replace("'", "''");
					}
					
				} else {
					continue;
				}

				Tag tag = audioFile.getTag();
				
				if (tag!=null) {
					String whereClause = DBAccessHelper.SONG_FILE_PATH + "=" + "'" + uri + "'";
					ContentValues values = new ContentValues();
					
					if (titleEdited==false) {
						//Don't do anything here. The user didn't change the title.
					} else {
						try {
							tag.setField(FieldKey.TITLE, songTitle);
						} catch (KeyNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (FieldDataInvalidException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NoSuchElementException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
						values.put(DBAccessHelper.SONG_TITLE, songTitle);
						
					}
					
					if (albumEdited==false) {
						//Don't do anything here. The user didn't change the album.
					} else {
						try {
							tag.setField(FieldKey.ALBUM, songAlbum);
						} catch (KeyNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (FieldDataInvalidException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NoSuchElementException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
						values.put(DBAccessHelper.SONG_ALBUM, songAlbum);
						
					}
					
					if (artistEdited==false) {
						//Don't do anything here. The user didn't change the artist.
					} else {
						try {
							tag.setField(FieldKey.ARTIST, songArtist);
						} catch (KeyNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (FieldDataInvalidException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NoSuchElementException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
						values.put(DBAccessHelper.SONG_ARTIST, songArtist);
						
					}
					
					if (albumArtistEdited==false) {
						//Don't do anything here. The user didn't change the album artist.
					} else {
						try {
							tag.setField(FieldKey.ALBUM_ARTIST, songAlbumArtist);
						} catch (KeyNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (FieldDataInvalidException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NoSuchElementException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
						values.put(DBAccessHelper.SONG_ALBUM_ARTIST, songAlbumArtist);
						
					}
					
					if (genreEdited==false) {
						//Don't do anything here. The user didn't change the genre.
					} else {
						try {
							tag.setField(FieldKey.GENRE, songComposer);
						} catch (KeyNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (FieldDataInvalidException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NoSuchElementException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
					if (producerEdited==false) {
						//Don't do anything here. The user didn't change the producer.
					} else {
						try {
							tag.setField(FieldKey.PRODUCER, songProducer);
						} catch (KeyNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (FieldDataInvalidException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NoSuchElementException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
					if (yearEdited==false) {
						//Don't do anything here. The user didn't change the year.
					} else {
						try {
							tag.setField(FieldKey.YEAR, songYear);
						} catch (KeyNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (FieldDataInvalidException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NoSuchElementException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NumberFormatException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
						values.put(DBAccessHelper.SONG_YEAR, songYear);
						
					}
					
					if (trackEdited==false) {
						//Don't do anything here. The user didn't change the track number.
					} else {
						try {
							tag.setField(FieldKey.TRACK, songTrackNumber);
						} catch (KeyNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (FieldDataInvalidException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NoSuchElementException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NumberFormatException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
						values.put(DBAccessHelper.SONG_TRACK_NUMBER, songTrackNumber);
						
					}
					
					try {
						tag.setField(FieldKey.TRACK_TOTAL, songTrackTotals);
					} catch (KeyNotFoundException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (FieldDataInvalidException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (NoSuchElementException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (NumberFormatException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if (commentEdited==false) {
						//Don't do anything here. The user didn't change the comments.
					} else {
						try {
							tag.setField(FieldKey.COMMENT, songComments);
						} catch (KeyNotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (FieldDataInvalidException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (NoSuchElementException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
					try {
						audioFile.commit();
					} catch (CannotWriteException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					//Write the values to the DB.
					try {
						dbHelper.getWritableDatabase().update(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
															  values, 
															  whereClause, 
															  null);

						dbHelper.close();
						dbHelper = null;
						
					} catch (Exception e) {
						e.printStackTrace();
					}
					
				} else {
					Toast.makeText(mContext, R.string.unable_to_edit_artist_tags, Toast.LENGTH_SHORT).show();
				}
				
			}
			
			return null;
		}
		
		@Override
		protected void onProgressUpdate(String... values) {
			super.onProgressUpdate(values);
			pd.setProgress(i);
			String message = mContext.getResources().getString(R.string.saving_song_info_for) + " " + titlesList.get(i) + ".";
			pd.setMessage(message);
			
		}
		
		@Override
		protected void onPostExecute(String result) {
			super.onPostExecute(result);
			pd.dismiss();
			
			try {

			} catch (Exception e) {
				e.printStackTrace();
			}
			
			//Delete all the contents of the ArrayLists.
			clearArrayLists();
			dialogFragment.dismiss();
			Toast.makeText(parentActivity, R.string.changes_saved, Toast.LENGTH_SHORT).show();
			
		}
		
	}


	public void clearArrayLists() {
		if (titlesList!=null) {
			titlesList.clear();
			titlesList = null;
		}
		
		if (artistsList!=null) {
			artistsList.clear();
			artistsList = null;
		}
		
		if (albumsList!=null) {
			albumsList.clear();
			albumsList = null;
		}
		
		if (albumArtistsList!=null) {
			albumArtistsList.clear();
			albumArtistsList = null;
		}
		
		if (genresList!=null) {
			genresList.clear();
			genresList = null;
		}
		
		if (producersList!=null) {
			producersList.clear();
			producersList = null;
		}
		
		if (yearsList!=null) {
			yearsList.clear();
			yearsList = null;
		}
		
		if (trackNumbersList!=null) {
			trackNumbersList.clear();
			trackNumbersList = null;
		}
		
		if (totalTracksList!=null) {
			totalTracksList.clear();
			totalTracksList = null;
		}
		
		if (commentsList!=null) {
			commentsList.clear();
			commentsList = null;
		}
		
		if (songURIsList!=null) {
			songURIsList.clear();
			songURIsList = null;
		}
		
		/*if (songSourcesList!=null) {
			songSourcesList.clear();
			songSourcesList = null;
		}
		
		if (songIdsList!=null) {
			songIdsList.clear();
			songIdsList = null;
		}*/
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.View;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.R;

import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.audio.exceptions.CannotReadException;
import org.jaudiotagger.audio.exceptions.CannotWriteException;
import org.jaudiotagger.audio.exceptions.InvalidAudioFrameException;
import org.jaudiotagger.audio.exceptions.ReadOnlyFileException;
import org.jaudiotagger.tag.FieldDataInvalidException;
import org.jaudiotagger.tag.FieldKey;
import org.jaudiotagger.tag.KeyNotFoundException;
import org.jaudiotagger.tag.Tag;
import org.jaudiotagger.tag.TagException;

import java.io.File;
import java.io.IOException;
import java.util.NoSuchElementException;

public class ID3sSongEditorDialog extends DialogFragment {
	
	private Context mContext;
	private static Activity parentActivity;
	private DialogFragment dialogFragment;
	private View rootView;
	
	private TextView titleText;
	private TextView artistText;
	private TextView albumText;
	private TextView albumArtistText;
	private TextView genreText;
	private TextView producerText;
	private TextView yearText;
	private TextView trackText;
	private TextView ofText;
	private TextView commentsText;

	private EditText titleEditText;
	private EditText artistEditText;
	private EditText albumEditText;
	private EditText albumArtistEditText;
	private EditText genreEditText;
	private EditText producerEditText;
	private EditText yearEditText;
	private EditText trackEditText;
	private EditText trackTotalEditText;
	private EditText commentsEditText;
	
	private CheckBox titleCheckbox;
	private CheckBox artistCheckbox;
	private CheckBox albumCheckbox;
	private CheckBox albumArtistCheckbox;
	private CheckBox genreCheckbox;
	private CheckBox producerCheckbox;
	private CheckBox yearCheckbox;
	private CheckBox trackCheckbox;
	private CheckBox commentCheckbox;
	
	private boolean titleEdited = false;
	private boolean artistEdited = false;
	private boolean albumEdited = false;
	private boolean albumArtistEdited = false;
	private boolean genreEdited = false;
	private boolean producerEdited = false;
	private boolean yearEdited = false;
	private boolean trackEdited = false;
	private boolean commentEdited = false;
	
	private String SONG_URI;
	private String CALLING_FRAGMENT;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		mContext = getActivity();
		parentActivity = getActivity();
		dialogFragment = this;
		
		rootView = (View) parentActivity.getLayoutInflater().inflate(R.layout.fragment_edit_id3_artist_album_dialog, null);
		
		titleText = (TextView) rootView.findViewById(R.id.edit_title_text);
		artistText = (TextView) rootView.findViewById(R.id.edit_artist_text);
		albumText = (TextView) rootView.findViewById(R.id.edit_album_text);
		albumArtistText = (TextView) rootView.findViewById(R.id.edit_album_artist_text);
		genreText = (TextView) rootView.findViewById(R.id.edit_genre_text);
		producerText = (TextView) rootView.findViewById(R.id.edit_producer_text);
		yearText = (TextView) rootView.findViewById(R.id.edit_year_text);
		trackText = (TextView) rootView.findViewById(R.id.edit_track_text);
		ofText = (TextView) rootView.findViewById(R.id.text_of);
		commentsText = (TextView) rootView.findViewById(R.id.edit_comment_text);
		
		titleEditText = (EditText) rootView.findViewById(R.id.edit_title_field);
		artistEditText = (EditText) rootView.findViewById(R.id.edit_artist_field);
		albumEditText = (EditText) rootView.findViewById(R.id.edit_album_field);
		albumArtistEditText = (EditText) rootView.findViewById(R.id.edit_album_artist_field);
		genreEditText = (EditText) rootView.findViewById(R.id.edit_genre_field);
		producerEditText = (EditText) rootView.findViewById(R.id.edit_producer_field);
		yearEditText = (EditText) rootView.findViewById(R.id.edit_year_field);
		trackEditText = (EditText) rootView.findViewById(R.id.edit_track_field);
		trackTotalEditText = (EditText) rootView.findViewById(R.id.edit_track_total_field);
		commentsEditText = (EditText) rootView.findViewById(R.id.edit_comment_field);
		
		titleCheckbox = (CheckBox) rootView.findViewById(R.id.title_checkbox);
		artistCheckbox = (CheckBox) rootView.findViewById(R.id.artist_checkbox);
		albumCheckbox = (CheckBox) rootView.findViewById(R.id.album_checkbox);
		albumArtistCheckbox = (CheckBox) rootView.findViewById(R.id.album_artist_checkbox);
		genreCheckbox = (CheckBox) rootView.findViewById(R.id.genre_checkbox);
		producerCheckbox = (CheckBox) rootView.findViewById(R.id.producer_checkbox);
		yearCheckbox = (CheckBox) rootView.findViewById(R.id.year_checkbox);
		trackCheckbox = (CheckBox) rootView.findViewById(R.id.track_checkbox);
		commentCheckbox = (CheckBox) rootView.findViewById(R.id.comment_checkbox);
		
		titleText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		artistText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumArtistText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		genreText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		producerText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		yearText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		trackText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		ofText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		commentsText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		
		titleText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		artistText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		albumText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		albumArtistText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		genreText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		producerText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		yearText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		trackText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		ofText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		commentsText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		
		titleEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		artistEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		albumArtistEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		genreEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		producerEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		yearEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		trackEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		trackTotalEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		commentsEditText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		
		titleEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		artistEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		albumEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		albumArtistEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		genreEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		producerEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		yearEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		trackEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		trackTotalEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		commentsEditText.setPaintFlags(titleText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		//Keep all the fields locked by default.
		titleCheckbox.setChecked(false);
		artistCheckbox.setChecked(false);
		albumCheckbox.setChecked(false);
		albumArtistCheckbox.setChecked(false);
		genreCheckbox.setChecked(false);
		producerCheckbox.setChecked(false);
		yearCheckbox.setChecked(false);
		trackCheckbox.setChecked(false);
		commentCheckbox.setChecked(false);
		
		//Disable all EditTexts by default.
		titleEditText.setEnabled(false);
		artistEditText.setEnabled(false);
		albumEditText.setEnabled(false);
		albumArtistEditText.setEnabled(false);
		genreEditText.setEnabled(false);
		producerEditText.setEnabled(false);
		yearEditText.setEnabled(false);
		trackEditText.setEnabled(false);
		commentsEditText.setEnabled(false);
		
		//Register click registers on each checkbox.
		titleCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {

				if (checked==true) {
					titleEdited = true;
					titleEditText.setEnabled(true);
				} else {
					titleEdited = false;
					titleEditText.setEnabled(false);
				}
				
			}
			
		});
		
		artistCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					artistEdited = true;
					artistEditText.setEnabled(true);;
				} else {
					artistEdited = false;
					artistEditText.setEnabled(false);
				}
				
			}
			
		});
		
		albumArtistCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					albumEdited = true;
					albumEditText.setEnabled(true);;
				} else {
					albumEdited = false;
					albumEditText.setEnabled(false);
				}
				
			}
			
		});
		
		albumCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					albumArtistEdited = true;
					albumArtistEditText.setEnabled(true);;
				} else {
					albumArtistEdited = false;
					albumArtistEditText.setEnabled(false);
				}
				
			}
			
		});
		
		genreCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					genreEdited = true;
					genreEditText.setEnabled(true);;
				} else {
					genreEdited = false;
					genreEditText.setEnabled(false);
				}
				
			}
			
		});
		
		producerCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					producerEdited = true;
					producerEditText.setEnabled(true);;
				} else {
					producerEdited = false;
					producerEditText.setEnabled(false);
				}
				
			}
			
		});
		
		yearCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					yearEdited = true;
					yearEditText.setEnabled(true);;
				} else {
					yearEdited = false;
					yearEditText.setEnabled(false);
				}
				
			}
			
		});
		
		trackCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					trackEdited = true;
					trackEditText.setEnabled(true);;
				} else {
					trackEdited = false;
					trackEditText.setEnabled(false);
				}
				
			}
			
		});
		
		commentCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean checked) {
				
				if (checked==true) {
					commentEdited = true;
					commentsEditText.setEnabled(true);;
				} else {
					commentEdited = false;
					commentsEditText.setEnabled(false);
				}
				
			}
			
		});
		
		//Get the song uri.
		SONG_URI = getArguments().getString("SONG");
		
		//Get the calling Fragment and retrieve the child view from it.
		CALLING_FRAGMENT = getArguments().getString("CALLING_FRAGMENT");
		
		if (SONG_URI!=null) {
			
			//Populate the ArrayLists with the song tags.
			try {
				getSongTags(SONG_URI);
			} catch (CannotReadException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TagException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (ReadOnlyFileException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidAudioFrameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.edit_tags);
        builder.setView(rootView);
        builder.setPositiveButton(R.string.save, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();
				boolean saveSucceeded = saveSongTags(SONG_URI);
					
				//Check if the write operations succeeded. If they didn't, display an error message.
				if (saveSucceeded==true) {
					Toast.makeText(getActivity().getApplicationContext(), R.string.song_tags_saved, Toast.LENGTH_SHORT).show();
					
/*					//Reinitialize the calling fragment.
					if (CALLING_FRAGMENT.equals("SONGS_FRAGMENT")) {


					} else if (CALLING_FRAGMENT.equals("ARTISTS_FLIPPED_SONGS_FRAGMENT")) {
						//ArtistsFlippedSongsFragment.getCursor();
						ArtistsFlippedSongsFragment.songsListViewAdapter.notifyDataSetChanged();
					} else if (CALLING_FRAGMENT.equals("ALBUMS_FLIPPED_FRAGMENT")) {
						AlbumsFlippedFragment.getCursor();
						AlbumsFlippedFragment.albumsFlippedListViewAdapter.notifyDataSetChanged();
					} else if (CALLING_FRAGMENT.equals("ALBUM_ARTISTS_FLIPPED_SONGS_FRAGMENT")) {
						AlbumArtistsFlippedSongsFragment.getCursor();
						AlbumArtistsFlippedSongsFragment.songsListViewAdapter.notifyDataSetChanged();
					} else if (CALLING_FRAGMENT.equals("GENRES_FLIPPED_SONGS_FRAGMENT")) {
						GenresFlippedFragment.getCursor();
						GenresFlippedFragment.genresFlippedListViewAdapter.notifyDataSetChanged();
					}*/
					
				} else {
					Toast.makeText(parentActivity, R.string.error_occurred_tags, Toast.LENGTH_LONG).show();
				}
				
			}
	        
        });
        
        builder.setNegativeButton(R.string.cancel, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				dialog.dismiss();
				
			}
        	
        });

        return builder.create();
			
	}
	
	//This method loops through all the songs and saves their tags into ArrayLists.
	public void getSongTags(String uri) throws CannotReadException, 
											   IOException, 
											   TagException, 
											   ReadOnlyFileException, 
											   InvalidAudioFrameException {
			
		File file = new File(uri);
		AudioFile audioFile = AudioFileIO.read(file);
		
		if (audioFile!=null && audioFile.getTag()!=null) {
			titleEditText.setText(audioFile.getTag().getFirst(FieldKey.TITLE));
			artistEditText.setText(audioFile.getTag().getFirst(FieldKey.ARTIST));
			albumEditText.setText(audioFile.getTag().getFirst(FieldKey.ALBUM));
			albumArtistEditText.setText(audioFile.getTag().getFirst(FieldKey.ALBUM_ARTIST));
			genreEditText.setText(audioFile.getTag().getFirst(FieldKey.GENRE));
			producerEditText.setText(audioFile.getTag().getFirst(FieldKey.PRODUCER));
			yearEditText.setText(audioFile.getTag().getFirst(FieldKey.YEAR));
			trackEditText.setText(audioFile.getTag().getFirst(FieldKey.TRACK));
			trackTotalEditText.setText(audioFile.getTag().getFirst(FieldKey.TRACK_TOTAL));
			commentsEditText.setText(audioFile.getTag().getFirst(FieldKey.COMMENT));
			
		}

	}
	
	//This method is called if the user touches the 'OK' button when they're editing an individual song's tags.
	public boolean saveSongTags(String uri) {
		
		File file = new File(uri);
		AudioFile audioFile = null;
		
		//Update the DB entries.
		DBAccessHelper dbHelper = new DBAccessHelper(mContext.getApplicationContext());
		
		//Escape any rogue apostrophes.
		if (SONG_URI.contains("'")) {
			SONG_URI = SONG_URI.replace("'", "''");
		}
		
		String whereClause = DBAccessHelper.SONG_FILE_PATH + "=" + "'" + SONG_URI + "'";
		
		ContentValues values = new ContentValues();
		
		try {
			audioFile = AudioFileIO.read(file);
		} catch (CannotReadException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TagException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ReadOnlyFileException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvalidAudioFrameException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		Tag tag = audioFile.getTag();
		
		if (tag!=null) {
			if (titleEdited==false) {
				//Don't do anything here. The user didn't change the title.
			} else {
				try {
					tag.setField(FieldKey.TITLE, titleEditText.getText().toString());
				} catch (KeyNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (FieldDataInvalidException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (NoSuchElementException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				String title = titleEditText.getText().toString();
				if (title.contains("'")) {
					title = title.replace("'", "''");
				}
				
				values.put(DBAccessHelper.SONG_TITLE, title);
				
			}
			
			if (albumEdited==false) {
				//Don't do anything here. The user didn't change the album.
			} else {
				try {
					tag.setField(FieldKey.ALBUM, albumEditText.getText().toString());
				} catch (KeyNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (FieldDataInvalidException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (NoSuchElementException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				String album = albumEditText.getText().toString();
				if (album.contains("'")) {
					album = album.replace("'", "''");
				}
				
				values.put(DBAccessHelper.SONG_ALBUM, album);
				
			}
			
			if (artistEdited==false) {
				//Don't do anything here. The user didn't change the artist.
			} else {
				try {
					tag.setField(FieldKey.ARTIST, artistEditText.getText().toString());
				} catch (KeyNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (FieldDataInvalidException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (NoSuchElementException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				String artist = artistEditText.getText().toString();
				if (artist.contains("'")) {
					artist = artist.replace("'", "''");
				}
				
				values.put(DBAccessHelper.SONG_ARTIST, artist);
				
			}
			
			if (albumArtistEdited==false) {
				//Don't do anything here. The user didn't change the album artist.
			} else {
				try {
					tag.setField(FieldKey.ALBUM_ARTIST, albumArtistEditText.getText().toString());
				} catch (KeyNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (FieldDataInvalidException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (NoSuchElementException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				String albumArtist = albumArtistEditText.getText().toString();
				if (albumArtist.contains("'")) {
					albumArtist = albumArtist.replace("'", "''");
				}
				values.put(DBAccessHelper.SONG_ALBUM_ARTIST, albumArtist);
				
			}
			
			if (genreEdited==false) {
				//Don't do anything here. The user didn't change the genre.
			} else {
				try {
					tag.setField(FieldKey.GENRE, genreEditText.getText().toString());
				} catch (KeyNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (FieldDataInvalidException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (NoSuchElementException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
			}
			
			if (producerEdited==false) {
				//Don't do anything here. The user didn't change the producer.
			} else {
				try {
					tag.setField(FieldKey.PRODUCER, producerEditText.getText().toString());
				} catch (KeyNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (FieldDataInvalidException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (NoSuchElementException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
			}
			
			if (yearEdited==false) {
				//Don't do anything here. The user didn't change the year.
			} else {
				try {
					tag.setField(FieldKey.YEAR, yearEditText.getText().toString());
				} catch (KeyNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (FieldDataInvalidException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (NoSuchElementException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (NumberFormatException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				String year = yearEditText.getText().toString();
				if (year.contains("'")) {
					year = year.replace("'", "''");
				}
				
				values.put(DBAccessHelper.SONG_YEAR, year);
				
			}
			
			if (trackEdited==false) {
				//Don't do anything here. The user didn't change the track number.
			} else {
				try {
					tag.setField(FieldKey.TRACK, trackEditText.getText().toString());
				} catch (KeyNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (FieldDataInvalidException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (NoSuchElementException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (NumberFormatException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				String track = trackEditText.getText().toString();
				if (track.contains("'")) {
					track = track.replace("'", "''");
				}
				
				values.put(DBAccessHelper.SONG_TRACK_NUMBER, track);
				
			}
			
			try {
				tag.setField(FieldKey.TRACK_TOTAL, trackTotalEditText.getText().toString());
			} catch (KeyNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (FieldDataInvalidException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (NoSuchElementException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (NumberFormatException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			if (commentEdited==false) {
				//Don't do anything here. The user didn't change the comments.
			} else {
				try {
					tag.setField(FieldKey.COMMENT, commentsEditText.getText().toString());
				} catch (KeyNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (FieldDataInvalidException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (NoSuchElementException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
			}
			
			try {
				audioFile.commit();
			} catch (CannotWriteException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			//Write the values to the DB.
			if (values.size()!=0) {
				//Write the values to the DB.
				try {
					dbHelper.getWritableDatabase().update(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
														  values, 
														  whereClause, 
														  null);

					dbHelper.close();
					dbHelper = null;
					
				} catch (Exception e) {
					e.printStackTrace();
				}
				
			}
			
		} else {
			Toast.makeText(mContext, R.string.unable_to_edit_song_tags, Toast.LENGTH_SHORT).show();
		}

		return true;
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;

import com.jams.music.player.R;

public class InvalidFileDialog extends DialogFragment {

	private String fileName;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		fileName = getArguments().getString("FILE_NAME");
		
		final DialogFragment dialog = this;
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.error);
        builder.setMessage(fileName + " " + getResources().getString(R.string.invalid_file_message));
        builder.setNegativeButton(R.string.ok, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialog.dismiss();
				
			}
        	
        });
        
        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.text.Html;
import android.text.method.LinkMovementMethod;
import android.view.View;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;

public class LicensesDialog extends DialogFragment {

	private Activity parentActivity;
	private DialogFragment dialogFragment;
	private View rootView;
	private TextView creativeCommonsLink;
	private TextView creativeCommonsInfo;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		parentActivity = getActivity();
		dialogFragment = (DialogFragment) getFragmentManager().findFragmentByTag("licensesDialog");
		
		rootView = (View) parentActivity.getLayoutInflater().inflate(R.layout.licenses_dialog_layout, null);
		
		creativeCommonsLink = (TextView) rootView.findViewById(R.id.creative_commons_link);
		creativeCommonsLink.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		creativeCommonsLink.setText(Html.fromHtml("<a href=\"http://creativecommons.org/licenses/by-sa/3.0/legalcode\">Creative Commons ShareALike 3.0 License</a> "));
		creativeCommonsLink.setMovementMethod(LinkMovementMethod.getInstance());
		
		creativeCommonsInfo = (TextView) rootView.findViewById(R.id.licenses_text);
		creativeCommonsInfo.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.licenses);
        builder.setView(rootView);
        builder.setPositiveButton(R.string.done, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();
				getActivity().finish();
				
			}
        	
        });

        return builder.create();
    }
	
	@Override
	public void onDestroy() {
		super.onDestroy();
		
		getActivity().finish();
		
	}
	
	@Override
	public void onPause() {
		super.onPause();
		
		getActivity().finish();
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.SharedPreferences;
import android.os.Bundle;

import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.SettingsActivity.SettingsActivity;
import com.jams.music.player.SettingsActivity.SettingsAppearanceFragment;

public class NowPlayingColorSchemesDialog extends DialogFragment {

	private Activity parentActivity;
	private int selectedThemeIndex;
	private DialogFragment dialogFragment;
	
	private static final String NOW_PLAYING_COLOR = "NOW_PLAYING_COLOR";
	private static final String BLUE = "BLUE";
	private static final String RED = "RED";
	private static final String GREEN = "GREEN";
	private static final String ORANGE = "ORANGE";
	private static final String PURPLE = "PURPLE";
	private static final String MAGENTA = "MAGENTA";
	private static final String GRAY = "GRAY";
	private static final String WHITE = "WHITE";
	private static final String BLACK = "BLACK";
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

        parentActivity = getActivity();
        dialogFragment = (DialogFragment) getFragmentManager().findFragmentByTag("colorSchemesDialog");

        final SharedPreferences sharedPreferences = parentActivity.
                getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);

        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Check which theme is currently selected and set the appropriate flag.
        if (sharedPreferences.getString(NOW_PLAYING_COLOR, BLUE).equals(WHITE)) {
            selectedThemeIndex = 0;
        } else if (sharedPreferences.getString(NOW_PLAYING_COLOR, BLUE).equals(GRAY)) {
            selectedThemeIndex = 1;

        } else if (sharedPreferences.getString(NOW_PLAYING_COLOR, BLUE).equals(BLUE)) {
            selectedThemeIndex = 2;

        } else if (sharedPreferences.getString(NOW_PLAYING_COLOR, BLUE).equals(RED)) {
            selectedThemeIndex = 3;

        } else if (sharedPreferences.getString(NOW_PLAYING_COLOR, BLUE).equals(GREEN)) {
            selectedThemeIndex = 4;

        } else if (sharedPreferences.getString(NOW_PLAYING_COLOR, BLUE).equals(ORANGE)) {
            selectedThemeIndex = 5;

        } else if (sharedPreferences.getString(NOW_PLAYING_COLOR, BLUE).equals(PURPLE)) {
            selectedThemeIndex = 6;

        } else if (sharedPreferences.getString(NOW_PLAYING_COLOR, BLUE).equals(MAGENTA)) {
            selectedThemeIndex = 7;

        } else if (sharedPreferences.getString(NOW_PLAYING_COLOR, BLUE).equals(BLACK)) {
            selectedThemeIndex = 8;

        } else {
            selectedThemeIndex = 0;
        }

        //Set the dialog title.
        builder.setTitle(R.string.now_playing_color_scheme);
        builder.setSingleChoiceItems(R.array.now_playing_color_schemes, selectedThemeIndex, new OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {

                if (which == 0) {
                    sharedPreferences.edit().putString(NOW_PLAYING_COLOR, WHITE).commit();
                    dialog.dismiss();
                } else if (which == 1) {
                    sharedPreferences.edit().putString(NOW_PLAYING_COLOR, GRAY).commit();
                    dialog.dismiss();
                } else if (which == 2) {
                    sharedPreferences.edit().putString(NOW_PLAYING_COLOR, BLUE).commit();
                    dialog.dismiss();
                } else if (which == 3) {
                    sharedPreferences.edit().putString(NOW_PLAYING_COLOR, RED).commit();
                    dialog.dismiss();
                } else if (which == 4) {
                    sharedPreferences.edit().putString(NOW_PLAYING_COLOR, GREEN).commit();
                    dialog.dismiss();
                } else if (which == 5) {
                    sharedPreferences.edit().putString(NOW_PLAYING_COLOR, ORANGE).commit();
                    dialog.dismiss();
                } else if (which == 6) {
                    sharedPreferences.edit().putString(NOW_PLAYING_COLOR, PURPLE).commit();
                    dialog.dismiss();
                } else if (which == 7) {
                    sharedPreferences.edit().putString(NOW_PLAYING_COLOR, MAGENTA).commit();
                    dialog.dismiss();
                } else if (which == 8) {
                    sharedPreferences.edit().putString(NOW_PLAYING_COLOR, BLACK).commit();
                    dialog.dismiss();
                }

                getActivity().getActionBar().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(getActivity()));
                getActivity().getWindow().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(getActivity()));

            }

        });

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.View;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.R;

import java.io.File;

public class RenamePlaylistDialog extends DialogFragment {

	private Activity parentActivity;
	private RenamePlaylistDialog dialog;
	private View dialogView;
	private TextView playlistInfo;
	private EditText playlistNameField;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		parentActivity = getActivity();
		dialog = this;

		//Retrieve the arguments.
		final String PLAYLIST_NAME = getArguments().getString("PLAYLIST_NAME");
		final String PLAYLIST_FILE_PATH = getArguments().getString("PLAYLIST_FILE_PATH");
		final String PLAYLIST_FOLDER_PATH = getArguments().getString("PLAYLIST_FOLDER_PATH");
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        dialogView = parentActivity.getLayoutInflater().inflate(R.layout.rename_playlist_dialog_layout, null);
        
        playlistInfo = (TextView) dialogView.findViewById(R.id.rename_playlist_info);
        playlistInfo.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
        playlistInfo.setPaintFlags(playlistInfo.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        playlistNameField = (EditText) dialogView.findViewById(R.id.rename_playlist_text_field);
        playlistNameField.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
        playlistNameField.setPaintFlags(playlistNameField.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        playlistNameField.setText(PLAYLIST_NAME);
        
        //Set the dialog title.
        builder.setTitle(R.string.rename_playlist);
        builder.setView(dialogView);
        builder.setNegativeButton(R.string.cancel, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialog.dismiss();
				
			}
        	
        });
        
        builder.setPositiveButton(R.string.done, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				
				//Create a File that points to the playlist on the filesystem.
				File file = new File(PLAYLIST_FILE_PATH);
				
				//Retrieve the name and file path for the playlist.
				String playlistName = playlistNameField.getText().toString();
				
				//Replace illegal characters in the playlistName.
				if (playlistName.contains("/")) {
					playlistName = playlistName.replace("/", "_");
				}
				
				if (playlistName.contains("\\")) {
					playlistName = playlistName.replace("\\", "_");
				}
				
				//Create another File that points to the renamed playlist file.
				File newFile = new File(PLAYLIST_FOLDER_PATH + "/" + playlistName + ".m3u");
				file.renameTo(newFile);

				/*//Update the database with the new file path and playlist name.
				DBAccessHelper playlistsDBHelper = new DBAccessHelper(parentActivity);
				playlistsDBHelper.renamePlaylist(PLAYLIST_FILE_PATH, playlistName, newFile.getAbsolutePath());
				
				//Delete any instances of the old DB entries.
				playlistsDBHelper.deleteSpecificPlaylist(PLAYLIST_NAME, PLAYLIST_FILE_PATH);*/
				
				Toast.makeText(parentActivity, R.string.playlist_renamed, Toast.LENGTH_SHORT).show();
				
				//Refresh the playlists list view.
				//PlaylistsFragment playlistsFragment = new PlaylistsFragment();
				//playlistsFragment.refreshPlaylists();
				
				//playlistsDBHelper.close();
				dialog.dismiss();
			}
        	
        });

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.widget.Toast;

import com.jams.music.player.R;

public class ScanFrequencyDialog extends DialogFragment {

	private Activity parentActivity;
	private int selectedIndex;
	
	private static final String SCAN_FREQUENCY = "SCAN_FREQUENCY";
	
	private static boolean CALLED_FROM_WELCOME = false;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

		parentActivity = getActivity();
		
		final SharedPreferences sharedPreferences = parentActivity.
											  getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        
        CALLED_FROM_WELCOME = this.getArguments().getBoolean("CALLED_FROM_WELCOME");
        
        //Check which theme is currently selected and set the appropriate flag.
        if (sharedPreferences.getInt(SCAN_FREQUENCY, 5)==0) {
        	selectedIndex = 0;
        } else if (sharedPreferences.getInt(SCAN_FREQUENCY, 5)==1) {
        	selectedIndex = 1;
        } else if (sharedPreferences.getInt(SCAN_FREQUENCY, 5)==2) {
        	selectedIndex = 2;
        } else if (sharedPreferences.getInt(SCAN_FREQUENCY, 5)==3) {
        	selectedIndex = 3;
        } else if (sharedPreferences.getInt(SCAN_FREQUENCY, 5)==4) {
        	selectedIndex = 4;
        } else if (sharedPreferences.getInt(SCAN_FREQUENCY, 5)==5) {
        	selectedIndex = 5;
        }

        /*************************************************************************************************
         * Scan Frequency Settings:
         * 
         * 0: Scan at every startup.
         * 1: Scan at every 3 startups.
         * 2: Scan at every 5 startups.
         * 3: Scan at every 10 startups.
         * 4: Scan at every 20 startups.
         * 5: Scan Manually.
         *************************************************************************************************/
        
        //Set the dialog title.
        builder.setTitle(R.string.scan_frequency);
        builder.setSingleChoiceItems(R.array.scan_frequency_choices, selectedIndex, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				
				if (which==0) {
					sharedPreferences.edit().putInt(SCAN_FREQUENCY, 5).commit();
					
					dialog.dismiss();
					getActivity().finish();
					Toast.makeText(parentActivity, R.string.changes_saved, Toast.LENGTH_SHORT).show();
					
				} else if (which==1) {
					sharedPreferences.edit().putInt(SCAN_FREQUENCY, 1).commit();
					
					dialog.dismiss();
					getActivity().finish();
					Toast.makeText(parentActivity, R.string.changes_saved, Toast.LENGTH_SHORT).show();
					
				} else if (which==2) {
					sharedPreferences.edit().putInt(SCAN_FREQUENCY, 2).commit();
					
					dialog.dismiss();
					getActivity().finish();
					Toast.makeText(parentActivity, R.string.changes_saved, Toast.LENGTH_SHORT).show();
					
				} else if (which==3) {
					sharedPreferences.edit().putInt(SCAN_FREQUENCY, 3).commit();
					
					dialog.dismiss();
					getActivity().finish();
					Toast.makeText(parentActivity, R.string.changes_saved, Toast.LENGTH_SHORT).show();
					
				} else if (which==4) {
					sharedPreferences.edit().putInt(SCAN_FREQUENCY, 4).commit();
					
					dialog.dismiss();
					getActivity().finish();
					Toast.makeText(parentActivity, R.string.changes_saved, Toast.LENGTH_SHORT).show();
					
				} else if (which==5) {
					sharedPreferences.edit().putInt(SCAN_FREQUENCY, 5).commit();
					
					dialog.dismiss();
					getActivity().finish();
					Toast.makeText(parentActivity, R.string.changes_saved, Toast.LENGTH_SHORT).show();
					
				}
				
			}
        	
        });

        return builder.create();
    }
	
	@Override
	public void onPause() {
		super.onPause();
		
		if (CALLED_FROM_WELCOME==false) {
			getActivity().finish();
		}
		
	}
	
	@Override
	public void onDestroy() {
		super.onDestroy();
		
		if (CALLED_FROM_WELCOME==false) {
			getActivity().finish();
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import java.io.File;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.os.Environment;
import android.support.v4.app.DialogFragment;
import android.view.View;
import android.widget.TextView;

import com.jams.music.player.R;

public class TrialExpiryDialog extends DialogFragment {

	private Activity parentActivity;
	private DialogFragment dialogFragment;
	private TextView trialExpiryText;
	private TextView daysTextView;
	private TextView numberOfDaysLeftTextView;
	private TextView trialCounterDummyInfoTextView;
	
	private SharedPreferences sharedPreferences;
	private boolean EXPIRED_FLAG = false;
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		parentActivity = getActivity();
		dialogFragment = this;
		
		View rootView = (View) parentActivity.getLayoutInflater().inflate(R.layout.trial_expiry_dialog, null);
		sharedPreferences = getActivity().getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		
		//Check if the BETA version has expired.
        File file = new File(Environment.getExternalStorageDirectory() + "/.beta2");
        if (file.exists()) {
        	//The app has expired.
        	EXPIRED_FLAG = true;
        } else {
        	EXPIRED_FLAG = false;
        }
        
/*        //Change the dialog message based on the expiry status of the app.
        if (EXPIRED_FLAG==true) {
    		trialExpiryText = (TextView) rootView.findViewById(R.id.beta_version_will_expire);
    		trialExpiryText.setText(R.string.beta_has_expired);
    		trialExpiryText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
    		trialExpiryText.setPaintFlags(trialExpiryText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
    		
    		numberOfDaysLeftTextView = (TextView) rootView.findViewById(R.id.beta_expire_day_count);
    		numberOfDaysLeftTextView.setVisibility(View.GONE);
    		
    		daysTextView = (TextView) rootView.findViewById(R.id.beta_days_text);
    		daysTextView.setVisibility(View.GONE);
    		
    		trialCounterDummyInfoTextView = (TextView) rootView.findViewById(R.id.beta_trial_dummy_info_text);
    		trialCounterDummyInfoTextView.setVisibility(View.GONE);
    		
        } else {
    		trialExpiryText = (TextView) rootView.findViewById(R.id.beta_version_will_expire);
    		trialExpiryText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
    		trialExpiryText.setPaintFlags(trialExpiryText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
    		
    		numberOfDaysLeftTextView = (TextView) rootView.findViewById(R.id.beta_expire_day_count);
    		numberOfDaysLeftTextView.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
    		numberOfDaysLeftTextView.setPaintFlags(numberOfDaysLeftTextView.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
    		
    		trialCounterDummyInfoTextView = (TextView) rootView.findViewById(R.id.beta_trial_dummy_info_text);
    		trialCounterDummyInfoTextView.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
    		trialCounterDummyInfoTextView.setPaintFlags(trialCounterDummyInfoTextView.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
    		
    		//Calculate the number of days left.
    		Date date = new Date();
    		//1296000000 ms = 15 days.
    		long expiryDate = sharedPreferences.getLong("EXPIRY_DATE", date.getTime() + 1296000000);
    		long currentDate = date.getTime();
    		long millisLeft = expiryDate - currentDate;
    		long daysLeft = TimeUnit.MILLISECONDS.toDays(millisLeft);
    		numberOfDaysLeftTextView.setText("" + daysLeft);
    		
    		daysTextView = (TextView) rootView.findViewById(R.id.beta_days_text);
    		daysTextView.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
    		daysTextView.setPaintFlags(daysTextView.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        }*/
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(R.string.app_name);
        builder.setView(rootView);
        builder.setPositiveButton(R.string.ok, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();
				
				if (EXPIRED_FLAG==true) {
					getActivity().finish();
				}
				
			}
        	
        });

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.view.View;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;

public class ViewPlaylistInformationDialog extends DialogFragment {

	private Activity parentActivity;
	private DialogFragment dialogFragment;
	private View rootView;

	private TextView playlistNameText;
	private TextView playlistFormatText;
	private TextView playlistLocationText;
	private TextView playlistNumberOfSongsText;
	private TextView playlistLastModifiedText;
	private TextView playlistAddedToLibraryText;
	private TextView playlistCreatedText;
	
	private TextView playlistNameValue;
	private TextView playlistFormatValue;
	private TextView playlistLocationValue;
	private TextView playlistNumberOfSongsValue;
	private TextView playlistLastModifiedValue;
	private TextView playlistAddedToLibraryValue;
	private TextView playlistCreatedValue;
	
	private String playlistName = "";
	private String playlistFilePath = "";
	private String playlistFormat = "";
	private String playlistNumberOfSongs = "";
	private String playlistLastModified = "";
	private String playlistAddedToLibrary = "";
	private String playlistCreated = "";
	
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
		
		parentActivity = getActivity();
		dialogFragment = this;
		
		rootView = (View) parentActivity.getLayoutInflater().inflate(R.layout.dialog_playlist_information, null);
		
		playlistName = getArguments().getString("PLAYLIST_NAME");
		playlistFilePath = getArguments().getString("PLAYLIST_FILE_PATH");
		
		//Header text declarations.
		playlistNameText = (TextView) rootView.findViewById(R.id.playlist_name_text);
		playlistNameText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistNameText.setPaintFlags(playlistNameText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		
		playlistFormatText = (TextView) rootView.findViewById(R.id.playlist_format_text);
		playlistFormatText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistFormatText.setPaintFlags(playlistFormatText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		
		playlistLocationText = (TextView) rootView.findViewById(R.id.playlist_location_text);
		playlistLocationText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistLocationText.setPaintFlags(playlistLocationText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		
		playlistNumberOfSongsText = (TextView) rootView.findViewById(R.id.playlist_number_of_songs_text);
		playlistNumberOfSongsText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistNumberOfSongsText.setPaintFlags(playlistNumberOfSongsText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		
		playlistLastModifiedText = (TextView) rootView.findViewById(R.id.playlist_last_modified_text);
		playlistLastModifiedText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistLastModifiedText.setPaintFlags(playlistLastModifiedText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		
		playlistAddedToLibraryText = (TextView) rootView.findViewById(R.id.playlist_added_to_library_text);
		playlistAddedToLibraryText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistAddedToLibraryText.setPaintFlags(playlistAddedToLibraryText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		
		playlistCreatedText = (TextView) rootView.findViewById(R.id.playlist_created_text);
		playlistCreatedText.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistCreatedText.setPaintFlags(playlistCreatedText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG | Paint.FAKE_BOLD_TEXT_FLAG);
		
		//Values declarations.
		playlistNameValue = (TextView) rootView.findViewById(R.id.playlist_name_value);
		playlistNameValue.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistNameValue.setPaintFlags(playlistNameValue.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		playlistFormatValue = (TextView) rootView.findViewById(R.id.playlist_format_value);
		playlistFormatValue.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistFormatValue.setPaintFlags(playlistFormatValue.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		playlistLocationValue = (TextView) rootView.findViewById(R.id.playlist_location_value);
		playlistLocationValue.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistLocationValue.setPaintFlags(playlistLocationValue.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		playlistNumberOfSongsValue = (TextView) rootView.findViewById(R.id.playlist_number_of_songs_value);
		playlistNumberOfSongsValue.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistNumberOfSongsValue.setPaintFlags(playlistNumberOfSongsValue.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		playlistLastModifiedValue = (TextView) rootView.findViewById(R.id.playlist_last_modified_value);
		playlistLastModifiedValue.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistLastModifiedValue.setPaintFlags(playlistLastModifiedValue.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		playlistAddedToLibraryValue = (TextView) rootView.findViewById(R.id.playlist_added_to_library_value);
		playlistAddedToLibraryValue.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistAddedToLibraryValue.setPaintFlags(playlistAddedToLibraryValue.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		playlistCreatedValue = (TextView) rootView.findViewById(R.id.playlist_created_value);
		playlistCreatedValue.setTypeface(TypefaceHelper.getTypeface(parentActivity, "RobotoCondensed-Light"));
		playlistCreatedValue.setPaintFlags(playlistCreatedValue.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		//Set the playlist name and the file format.
		playlistNameValue.setText(playlistName);
		
		int extensionDotIndex = playlistFilePath.lastIndexOf(".");
		
		String extension = "";
		if (!playlistFilePath.isEmpty()) {
			extension = playlistFilePath.substring(extensionDotIndex, playlistFilePath.length());
		} else {
			extension = "Unknown";
		}
		playlistFormatValue.setText(extension);
		
		/*//Retrieve the information that needs to tbe displayed in the dialog.
		DBAccessHelper dbHelper = new DBAccessHelper(parentActivity);
		Cursor cursor = dbHelper.getPlaylistByFilePath(playlistFilePath);
		
		if (cursor.getCount() > 0) {
			//Get the number of songs in the playlist.
			playlistNumberOfSongs = cursor.getCount() + "";
			playlistNumberOfSongsValue.setText(playlistNumberOfSongs);
			
			//Get the date that the playlist was added to the library.
			cursor.moveToFirst();
			
			//Note that addTime isn't the actual "Last modification" date. It's actually the date the playlist was added to the library.
			long addTime = cursor.getLong(cursor.getColumnIndex(DBAccessHelper.PLAYLIST_LAST_MODIFIED));
			Date addDate = new Date(addTime);
			
			SimpleDateFormat addDateFormat = new SimpleDateFormat("MM/dd/yyyy HH:mm aa", Locale.getDefault());
			addDateFormat.setTimeZone(TimeZone.getDefault());
			playlistAddedToLibrary = addDateFormat.format(addDate);
			
			playlistAddedToLibraryValue.setText(playlistAddedToLibrary);
			
		}
		
		//Get a File that points to the playlist file on the filesystem.
		File file = new File(playlistFilePath);
		long lastModifiedTime = file.lastModified();
		
		if (lastModifiedTime==0) {
			playlistLastModifiedValue.setText("Unknown");
		} else {
			Date lastModifiedDate = new Date(lastModifiedTime);
			
			SimpleDateFormat lastModifiedDateFormat = new SimpleDateFormat("MM/dd/yyyy HH:mm aa", Locale.getDefault());
			lastModifiedDateFormat.setTimeZone(TimeZone.getDefault());
			
			playlistLastModified = lastModifiedDateFormat.format(lastModifiedDate);
			playlistLastModifiedValue.setText(playlistLastModified);
			playlistCreatedValue.setText(playlistLastModified);
		}*/
		
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

        //Set the dialog title.
        builder.setTitle(playlistName);
        builder.setView(rootView);
        builder.setNegativeButton(R.string.done, new OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
				dialogFragment.dismiss();
				
			}
        	
        });

        return builder.create();
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Drawers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Paint;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.MainActivity.MainActivity;
import com.jams.music.player.Utils.Common;

public class InnerNavigationDrawerFragment extends Fragment {

    private Common mApp;
	private ListView browsersListView;
	private ListView librariesListView;
	private TextView browsersHeaderText;
	private TextView librariesHeaderText;
	public static ImageView librariesColorTagImageView;
	private ImageView librariesIcon;
	
	private Cursor cursor;
	private DBAccessHelper userLibrariesDBHelper;

	@SuppressLint("NewApi")
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		View rootView = inflater.inflate(R.layout.navigation_drawer_layout, null);
		mApp = (Common) getActivity().getApplicationContext();
		
		browsersListView = (ListView) rootView.findViewById(R.id.browsers_list_view);
		librariesListView = (ListView) rootView.findViewById(R.id.libraries_list_view);
		browsersHeaderText = (TextView) rootView.findViewById(R.id.browsers_header_text);
		librariesHeaderText = (TextView) rootView.findViewById(R.id.libraries_header_text);
		librariesColorTagImageView = (ImageView) rootView.findViewById(R.id.library_color_tag);
		librariesIcon = (ImageView) rootView.findViewById(R.id.libraries_icon);
		librariesIcon.setImageResource(UIElementsHelper.getIcon(getActivity(), "libraries"));
		
		Drawable backgroundDrawable;
		if (mApp.getCurrentTheme()== Common.DARK_THEME) {
			backgroundDrawable = new ColorDrawable(0x191919);
		} else {
			backgroundDrawable = getResources().getDrawable(R.drawable.holo_white_selector);
		}
		
		int currentAPI = android.os.Build.VERSION.SDK_INT;
		if (currentAPI < android.os.Build.VERSION_CODES.JELLY_BEAN) {
			rootView.setBackgroundDrawable(backgroundDrawable);
		} else {
			rootView.setBackground(backgroundDrawable);
		}
		
		//Set the header text fonts/colors.
		browsersHeaderText.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		librariesHeaderText.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		browsersHeaderText.setPaintFlags(browsersHeaderText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.FAKE_BOLD_TEXT_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		librariesHeaderText.setPaintFlags(librariesHeaderText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.FAKE_BOLD_TEXT_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		//Apply the Browser ListView's adapter.
		List<String> titles = Arrays.asList(getActivity().getResources().getStringArray(R.array.sliding_menu_array));
		NavigationDrawerAdapter slidingMenuAdapter = new NavigationDrawerAdapter(getActivity(), new ArrayList<String>(titles));
		browsersListView.setAdapter(slidingMenuAdapter);
		browsersListView.setOnItemClickListener(browsersClickListener);
		setListViewHeightBasedOnChildren(browsersListView);
		
		/*//Apply the Libraries ListView's adapter.
		userLibrariesDBHelper = new DBAccessHelper(getActivity().getApplicationContext());
		cursor = userLibrariesDBHelper.getAllUniqueLibraries();
		NavigationDrawerLibrariesAdapter slidingMenuLibrariesAdapter = new NavigationDrawerLibrariesAdapter(getActivity(), cursor);
		librariesListView.setAdapter(slidingMenuLibrariesAdapter);
		setListViewHeightBasedOnChildren(librariesListView);*/
		librariesListView.setVisibility(View.GONE);
		librariesHeaderText.setVisibility(View.GONE);
		librariesIcon.setVisibility(View.GONE);

		return rootView;
	}
	
	private OnItemClickListener browsersClickListener = new OnItemClickListener() {

		@Override
		public void onItemClick(AdapterView<?> adapterView, View view, int position, long dbID) {
			Intent intent = null;
			switch (position) {
			case 0:
				intent = new Intent(getActivity(), MainActivity.class);
				intent.putExtra("TARGET_FRAGMENT", "ARTISTS");
				//intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
				startActivity(intent);
				break;
			case 1:
				intent = new Intent(getActivity(), MainActivity.class);
				intent.putExtra("TARGET_FRAGMENT", "ALBUM_ARTISTS");
				//intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
				startActivity(intent);
				break;
			case 2:
				intent = new Intent(getActivity(), MainActivity.class);
				intent.putExtra("TARGET_FRAGMENT", "ALBUMS");
				//intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
				startActivity(intent);
				break;
			case 3:
				intent = new Intent(getActivity(), MainActivity.class);
				intent.putExtra("TARGET_FRAGMENT", "SONGS");
				//intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
				startActivity(intent);
				break;
			case 4:
				intent = new Intent(getActivity(), MainActivity.class);
				intent.putExtra("TARGET_FRAGMENT", "PLAYLISTS");
				//intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
				startActivity(intent);
				break;
			case 5:
				intent = new Intent(getActivity(), MainActivity.class);
				intent.putExtra("TARGET_FRAGMENT", "GENRES");
				//intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
				startActivity(intent);
				break;
			case 6:
				intent = new Intent(getActivity(), MainActivity.class);
				intent.putExtra("TARGET_FRAGMENT", "FOLDERS");
				//intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
				startActivity(intent);
				break;
			}
			
		}
		
	};
	
    public static void setListViewHeightBasedOnChildren(ListView listView) {
        ListAdapter listAdapter = listView.getAdapter(); 
        if (listAdapter == null) {
            // pre-condition
            return;
        }

        int totalHeight = 0;
        for (int i = 0; i < listAdapter.getCount(); i++) {
            View listItem = listAdapter.getView(i, null, listView);
            listItem.measure(0, 0);
            totalHeight += listItem.getMeasuredHeight();
        }

        ViewGroup.LayoutParams params = listView.getLayoutParams();
        params.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1));
        listView.setLayoutParams(params);
        listView.requestLayout();
    }
    
    @Override
    public void onDestroyView() {
    	super.onDestroyView();
    	
    	if (cursor!=null) {
    		cursor.close();
    		cursor = null;
    	}
		
    	if (userLibrariesDBHelper!=null) {
    		userLibrariesDBHelper.close();
    		userLibrariesDBHelper = null;
    	}
		
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Drawers;

import java.util.ArrayList;

import android.content.Context;
import android.content.SharedPreferences;
import android.graphics.Paint;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.MainActivity.MainActivity;
import com.jams.music.player.Utils.Common;

public class NavigationDrawerAdapter extends ArrayAdapter<String> {

	private Context mContext;
	private SharedPreferences sharedPreferences;
	private ArrayList<String> mTitlesList;
   
    public NavigationDrawerAdapter(Context context, ArrayList<String> titlesList) {
    	super(context, R.layout.sliding_menu_browsers_layout, titlesList);
    	mContext = context;
    	mTitlesList = titlesList;
    	sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    }
    
    @Override
    public View getView(final int position, View convertView, ViewGroup parent) {
    	
    	SongsListViewHolder holder = null;
		if (convertView == null) {	
			convertView = LayoutInflater.from(mContext).inflate(R.layout.sliding_menu_browsers_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.title = (TextView) convertView.findViewById(R.id.nav_drawer_item_title);
			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}

		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
		holder.title.setText(mTitlesList.get(position));
		holder.title.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
		
		//Highlight the current browser.
		int[] colors = UIElementsHelper.getQuickScrollColors(mContext);
		if (MainActivity.mCurrentFragmentId==Common.ARTISTS_FRAGMENT && 
			mTitlesList.get(position).equals(mContext.getResources().getString(R.string.artists))) {
			holder.title.setTextColor(colors[0]);
		} else if (MainActivity.mCurrentFragmentId==Common.ALBUM_ARTISTS_FRAGMENT &&
				   mTitlesList.get(position).equals(mContext.getResources().getString(R.string.album_artists))) {
			holder.title.setTextColor(colors[0]);
		} else if (MainActivity.mCurrentFragmentId==Common.ALBUMS_FRAGMENT &&
				   mTitlesList.get(position).equals(mContext.getResources().getString(R.string.albums))) {
			holder.title.setTextColor(colors[0]);
		} else if (MainActivity.mCurrentFragmentId==Common.SONGS_FRAGMENT &&
				   mTitlesList.get(position).equals(mContext.getResources().getString(R.string.songs))) {
			holder.title.setTextColor(colors[0]);
		} else if (MainActivity.mCurrentFragmentId==Common.PLAYLISTS_FRAGMENT &&
				   mTitlesList.get(position).equals(mContext.getResources().getString(R.string.playlists))) {
			holder.title.setTextColor(colors[0]);
		} else if (MainActivity.mCurrentFragmentId==Common.GENRES_FRAGMENT &&
				   mTitlesList.get(position).equals(mContext.getResources().getString(R.string.genres))) {
			holder.title.setTextColor(colors[0]);
		} else if (MainActivity.mCurrentFragmentId==Common.FOLDERS_FRAGMENT &&
				   mTitlesList.get(position).equals(mContext.getResources().getString(R.string.folders))) {
			holder.title.setTextColor(colors[0]);
		}
		
		return convertView;

	}
    
	static class SongsListViewHolder {
	    public TextView title;
	}
   
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Drawers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.RelativeLayout;
import android.widget.Spinner;
import android.widget.TextView;

import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.MainActivity.MainActivity;
import com.jams.music.player.SettingsActivity.SettingsActivity;
import com.jams.music.player.SettingsActivity.SettingsActivity____;
import com.jams.music.player.Utils.Common;

public class NavigationDrawerFragment extends Fragment {
	
	private Context mContext;
	private Common mApp;

    private RelativeLayout mLibraryPickerLayout;
    private TextView mLibraryPickerHeaderText;
    private Spinner mLibraryPickerSpinner;
	private ListView browsersListView;
	
	private Cursor cursor;
    private int mCurrentLibraryPosition;
	private NavigationDrawerLibrariesAdapter mLibrariesAdapter;
	private NavigationDrawerAdapter mBrowsersAdapter;
	private Handler mHandler;

	@SuppressWarnings("deprecation")
	@SuppressLint("NewApi")
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		
		mContext = getActivity();
		mApp = (Common) mContext.getApplicationContext();
		mHandler = new Handler();

		View rootView = inflater.inflate(R.layout.navigation_drawer_layout, null);
		rootView.setBackgroundColor(UIElementsHelper.getBackgroundColor(mContext));

		browsersListView = (ListView) rootView.findViewById(R.id.browsers_list_view);
        mLibraryPickerLayout = (RelativeLayout) rootView.findViewById(R.id.library_picker_layout);
        mLibraryPickerSpinner = (Spinner) rootView.findViewById(R.id.library_picker_spinner);
        mLibraryPickerHeaderText = (TextView) rootView.findViewById(R.id.library_picker_header_text);
        mLibraryPickerHeaderText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
		
		//Apply the Browser ListView's adapter.
		List<String> titles = Arrays.asList(getActivity().getResources().getStringArray(R.array.sliding_menu_array));
		mBrowsersAdapter = new NavigationDrawerAdapter(getActivity(), new ArrayList<String>(titles));
		browsersListView.setAdapter(mBrowsersAdapter);
		browsersListView.setOnItemClickListener(browsersClickListener);
		setListViewHeightBasedOnChildren(browsersListView);

		//Apply the Libraries ListView's adapter.
        cursor = mApp.getDBAccessHelper().getAllUniqueLibraries();
        mLibrariesAdapter = new NavigationDrawerLibrariesAdapter(getActivity(), cursor);
        mLibraryPickerSpinner.setAdapter(mLibrariesAdapter);
        mLibraryPickerSpinner.setSelection(mApp.getCurrentLibraryIndex());
        mLibraryPickerSpinner.setOnItemSelectedListener(librariesItemSelectedListener);

        browsersListView.setDividerHeight(0);

        //KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            int navBarHeight = Common.getNavigationBarHeight(mContext);
            if (browsersListView!=null) {
                browsersListView.setPadding(0, 0, 0, navBarHeight);
                browsersListView.setClipToPadding(false);
            }

        }

		return rootView;
	}

    private AdapterView.OnItemSelectedListener librariesItemSelectedListener = new AdapterView.OnItemSelectedListener() {

        @Override
        public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {

            if (mApp.getCurrentLibraryIndex()==position)
                return;

            mApp.getSharedPreferences().edit().putString(Common.CURRENT_LIBRARY,
                                                         (String) view.getTag(R.string.library_name)).commit();

            mApp.getSharedPreferences().edit().putInt(Common.CURRENT_LIBRARY_POSITION, position).commit();

            //Update the fragment.
            ((MainActivity) getActivity()).loadFragment(null);

            //Reset the ActionBar after 500ms.
            mHandler.postDelayed(new Runnable() {

                @Override
                public void run() {
                    getActivity().invalidateOptionsMenu();

                }

            }, 500);

        }

        @Override
        public void onNothingSelected(AdapterView<?> parent) {

        }

    };

	private OnItemClickListener browsersClickListener = new OnItemClickListener() {

		@Override
		public void onItemClick(AdapterView<?> adapterView, View view, int position, long dbID) {
			switch (position) {
			case 0:
				((MainActivity) getActivity()).setCurrentFragmentId(Common.ARTISTS_FRAGMENT);
				break;
			case 1:
				((MainActivity) getActivity()).setCurrentFragmentId(Common.ALBUM_ARTISTS_FRAGMENT);
				break;
			case 2:
				((MainActivity) getActivity()).setCurrentFragmentId(Common.ALBUMS_FRAGMENT);
				break;
			case 3:
				((MainActivity) getActivity()).setCurrentFragmentId(Common.SONGS_FRAGMENT);
				break;
			case 4:
				((MainActivity) getActivity()).setCurrentFragmentId(Common.PLAYLISTS_FRAGMENT);
				break;
			case 5:
				((MainActivity) getActivity()).setCurrentFragmentId(Common.GENRES_FRAGMENT);
				break;
			case 6:
				((MainActivity) getActivity()).setCurrentFragmentId(Common.FOLDERS_FRAGMENT);
				break;
            case 7:
                Intent intent = new Intent(getActivity(), SettingsActivity.class);
                startActivity(intent);
                break;
			}
			
			//Update the adapter to reflect the new fragment.
			List<String> titles = Arrays.asList(getActivity().getResources().getStringArray(R.array.sliding_menu_array));
			mBrowsersAdapter = new NavigationDrawerAdapter(getActivity(), new ArrayList<String>(titles));
			browsersListView.setAdapter(mBrowsersAdapter);
			
			//Update the fragment.
			((MainActivity) getActivity()).loadFragment(null);
			
			//Reset the ActionBar after 500ms.
			mHandler.postDelayed(new Runnable() {

				@Override
				public void run() {
					getActivity().invalidateOptionsMenu();
					
				}
				
			}, 500);

		}
		
	};
	
	/**
	 * Clips ListViews to fit within the drawer's boundaries.
	 */
    public static void setListViewHeightBasedOnChildren(ListView listView) {
        ListAdapter listAdapter = listView.getAdapter(); 
        if (listAdapter == null) {
            // pre-condition
            return;
        }

        int totalHeight = 0;
        for (int i = 0; i < listAdapter.getCount(); i++) {
            View listItem = listAdapter.getView(i, null, listView);
            listItem.measure(0, 0);
            totalHeight += listItem.getMeasuredHeight();
        }

        ViewGroup.LayoutParams params = listView.getLayoutParams();
        params.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1));
        listView.setLayoutParams(params);
        listView.requestLayout();
    }
    
    @Override
    public void onDestroyView() {
    	super.onDestroyView();
    	
    	if (cursor!=null) {
    		cursor.close();
    		cursor = null;
    	}
		
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Drawers;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Paint;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.SpinnerAdapter;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;

public class NavigationDrawerLibrariesAdapter extends SimpleCursorAdapter implements SpinnerAdapter {
	
	private Context mContext;
	private SharedPreferences sharedPreferences;
    private LibrariesListViewHolder holder = null;
	
    public NavigationDrawerLibrariesAdapter(Context context, Cursor cursor) {
        super(context, R.layout.sliding_menu_list_layout, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    }

    /**
     * This method returns the view for the selected view.
     */
    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        Cursor c = (Cursor) getItem(position);

		if (convertView == null) {
			convertView = LayoutInflater.from(mContext).inflate(R.layout.sliding_menu_list_layout, parent, false);
			holder = new LibrariesListViewHolder();

			holder.tagColor = (ImageView) convertView.findViewById(R.id.sliding_menu_libraries_icon);
			holder.title = (TextView) convertView.findViewById(R.id.sliding_menu_list_item);

            holder.title.setTextColor(0xFFFFFFFF);
            holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			convertView.setTag(holder);
		} else {
		    holder = (LibrariesListViewHolder) convertView.getTag();
		}
		
		//Retrieve the library's parameters.
		String libraryName = c.getString(c.getColumnIndex(DBAccessHelper.LIBRARY_NAME));
		String libraryColorCode = c.getString(c.getColumnIndex(DBAccessHelper.LIBRARY_TAG));

		//Construct the library color tag drawable from the given color code string.
        int colorCodeDrawableID = 0;
        try {
            colorCodeDrawableID = mContext.getResources().getIdentifier(libraryColorCode, "drawable", mContext.getPackageName());
        } catch (Exception e) {
            e.printStackTrace();
        }

        //Set the tag for this child view. The key is required to be an application-defined key.
        convertView.setTag(R.string.library_name, libraryName);
        convertView.setTag(R.string.library_color_code, libraryColorCode);

        holder.title.setText(libraryName);
        holder.tagColor.setImageResource(colorCodeDrawableID);

		return convertView;
	}

    /**
     * This method returns the view for the drop down menu list.
     */
    @Override
    public View getDropDownView(int position, View convertView, ViewGroup parent) {
        Cursor c = (Cursor) getItem(position);

        if (convertView == null) {
            convertView = LayoutInflater.from(mContext).inflate(R.layout.sliding_menu_list_layout, parent, false);
            holder = new LibrariesListViewHolder();

            holder.tagColor = (ImageView) convertView.findViewById(R.id.sliding_menu_libraries_icon);
            holder.title = (TextView) convertView.findViewById(R.id.sliding_menu_list_item);

            holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
            convertView.setTag(holder);
        } else {
            holder = (LibrariesListViewHolder) convertView.getTag();
        }

        //Retrieve the library's parameters.
        String libraryName = c.getString(c.getColumnIndex(DBAccessHelper.LIBRARY_NAME));
        String libraryColorCode = c.getString(c.getColumnIndex(DBAccessHelper.LIBRARY_TAG));

        //Construct the library color tag drawable from the given color code string.
        int colorCodeDrawableID = 0;
        try {
            colorCodeDrawableID = mContext.getResources().getIdentifier(libraryColorCode, "drawable", mContext.getPackageName());
        } catch (Exception e) {
            e.printStackTrace();
        }

        //Set the tag for this child view. The key is required to be an application-defined key.
        convertView.setTag(R.string.library_name, libraryName);
        convertView.setTag(R.string.library_color_code, libraryColorCode);

        holder.title.setText(libraryName);
        holder.tagColor.setImageResource(colorCodeDrawableID);

        return convertView;
    }

	static class LibrariesListViewHolder {
	    public ImageView tagColor;
	    public TextView title;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Drawers;

import android.content.Context;
import android.graphics.Paint;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.SongHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

import java.util.ArrayList;

public class QueueDrawerAdapter extends ArrayAdapter<Integer> {

    private Context mContext;
    private Common mApp;
    private int[] mColors;

    public QueueDrawerAdapter(Context context, ArrayList<Integer> playbackIndecesList) {
        super(context, R.layout.queue_drawer_list_layout, playbackIndecesList);

        mContext = context;
        mApp = (Common) mContext.getApplicationContext();
        mColors = UIElementsHelper.getQuickScrollColors(context);
    }

    public View getView(final int position, View convertView, ViewGroup parent){

        QueueDrawerHolder holder;
        if (convertView==null) {
            convertView = LayoutInflater.from(mContext)
                                        .inflate(R.layout.queue_drawer_list_layout, parent, false);

            holder = new QueueDrawerHolder();
            holder.songTitleText = (TextView) convertView.findViewById(R.id.queue_song_title);
            holder.artistText = (TextView) convertView.findViewById(R.id.queue_song_artist);
            holder.removeSong = (ImageView) convertView.findViewById(R.id.queue_remove_song);

            holder.songTitleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
            holder.artistText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
            holder.songTitleText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
            holder.artistText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));

            convertView.setTag(holder);
        } else {
            holder = (QueueDrawerHolder) convertView.getTag();
        }

        //Get the song's basic info.
        SongHelper songHelper = new SongHelper();
        songHelper.populateBasicSongData(mContext, position);

        holder.songTitleText.setText(songHelper.getTitle());
        holder.artistText.setText(songHelper.getArtist());

        //Apply the item's colors.
        try {
            if (position==mApp.getService().getCurrentSongIndex()) {
                holder.songTitleText.setTextColor(mColors[0]);
                holder.artistText.setTextColor(mColors[0]);
            } else if (mApp.getCurrentTheme()==Common.LIGHT_THEME) {
                holder.songTitleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
                holder.artistText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
            } else if (mApp.getCurrentTheme()==Common.DARK_THEME) {
                holder.songTitleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
                holder.artistText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        return convertView;
    }

    class QueueDrawerHolder {
        public TextView songTitleText;
        public TextView artistText;
        public ImageView removeSong;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Drawers;

import android.annotation.SuppressLint;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.graphics.Color;
import android.graphics.Paint;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.content.LocalBroadcastManager;
import android.view.HapticFeedbackConstants;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.ScaleAnimation;
import android.widget.AdapterView;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.R;
import com.jams.music.player.Services.AudioPlaybackService;
import com.jams.music.player.Utils.Common;
import com.mobeta.android.dslv.DragSortListView;
import com.mobeta.android.dslv.SimpleFloatViewManager;

public class QueueDrawerFragment extends Fragment {
	
	private Context mContext;
	private Common mApp;

    private RelativeLayout mMiniPlayerLayout;
    private ImageView mMiniPlayerAlbumArt;
    private RelativeLayout mPlayPauseBackground;
    private ImageButton mPlayPauseButton;
    private ImageButton mNextButton;
    private ImageButton mPreviousButton;
    private TextView mTitleText;
    private TextView mSubText;

	private DragSortListView mListView;
    private QueueDrawerAdapter mListViewAdapter;
    private TextView mEmptyInfoText;

    private boolean mInitListViewParams = true;
    private boolean mDrawerOpen = false;

    @SuppressWarnings("deprecation")
	@SuppressLint("NewApi")
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		
		mContext = getActivity();
		mApp = (Common) mContext.getApplicationContext();

		View rootView = inflater.inflate(R.layout.fragment_queue_drawer, null);
		if (mApp.getCurrentTheme()==Common.LIGHT_THEME) {
			rootView.setBackgroundColor(0xFFFFFFFF);
		} else {
			rootView.setBackgroundColor(0xFF191919);
		}

        mMiniPlayerLayout = (RelativeLayout) rootView.findViewById(R.id.queue_drawer_mini_player_layout);
        mMiniPlayerAlbumArt = (ImageView) rootView.findViewById(R.id.queue_drawer_album_art);
        mPlayPauseBackground = (RelativeLayout) rootView.findViewById(R.id.playPauseButtonBackground);
        mPlayPauseButton = (ImageButton) rootView.findViewById(R.id.playPauseButton);
        mNextButton = (ImageButton) rootView.findViewById(R.id.nextButton);
        mPreviousButton = (ImageButton) rootView.findViewById(R.id.previousButton);
        mTitleText = (TextView) rootView.findViewById(R.id.songName);
        mSubText = (TextView) rootView.findViewById(R.id.artistAlbumName);
        mListView = (DragSortListView) rootView.findViewById(R.id.queue_drawer_list_view);
        mEmptyInfoText = (TextView) rootView.findViewById(R.id.queue_drawer_empty_text);

        mPlayPauseBackground.setBackgroundResource(UIElementsHelper.getShadowedCircle(mContext));
        mPlayPauseButton.setId(R.drawable.pause_light);

        mTitleText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        mSubText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        mEmptyInfoText.setTypeface(TypefaceHelper.getTypeface(getActivity(), "Roboto-Regular"));

        //Set the click listeners.
        mMiniPlayerLayout.setOnClickListener(mOnClickMiniPlayer);
        mPlayPauseBackground.setOnClickListener(playPauseClickListener);
        mPlayPauseButton.setOnClickListener(playPauseClickListener);
        mNextButton.setOnClickListener(mOnClickNextListener);
        mPreviousButton.setOnClickListener(mOnClickPreviousListener);

        //Restrict all touch events to this fragment.
        rootView.setOnTouchListener(new View.OnTouchListener() {

            @Override
            public boolean onTouch(View v, MotionEvent event) {
                return true;
            }

        });

        //KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            int navBarHeight = Common.getNavigationBarHeight(mContext);
            if (mListView!=null) {
                mListView.setPadding(0, 0, 0, navBarHeight);
                mListView.setClipToPadding(false);
            }

        }

		return rootView;
	}

    /**
     * Broadcast receiver interface that will update this activity as necessary.
     */
    BroadcastReceiver mReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            Bundle bundle = intent.getExtras();

            if (bundle.containsKey(Common.UPDATE_PAGER_POSTIION)) {
                //Update the queue fragment with the new song info.
                initMiniPlayer();
                initListViewAdapter(false);

            }

            //Updates the playback control buttons.
            if (intent.hasExtra(Common.UPDATE_PLAYBACK_CONTROLS))
                setPlayPauseButton();

            if (bundle.containsKey(Common.SERVICE_STOPPING)) {
                showEmptyTextView();

            }

        }

    };

    /**
     * Helper method that checks whether the audio playback service
     * is running or not.
     */
    private void checkServiceRunning() {
        if (mApp.isServiceRunning() && mApp.getService().getCursor()!=null) {
            initMiniPlayer();
            setPlayPauseButton();
            initListViewAdapter(mInitListViewParams);
        } else {
            showEmptyTextView();
        }

    }

    /**
     * Initializes the mini player above the current queue.
     */
    private void initMiniPlayer() {
        mMiniPlayerLayout.setVisibility(View.VISIBLE);
        mMiniPlayerAlbumArt.setImageBitmap(mApp.getService().getCurrentSong().getAlbumArt());
        mTitleText.setText(mApp.getService().getCurrentSong().getTitle());
        mSubText.setText(mApp.getService().getCurrentSong().getAlbum() + " - " +
                         mApp.getService().getCurrentSong().getArtist());

    }

    /**
     * Initializes the drag sort list view.
     *
     * @param initViewParams Pass true if the ListView is being
     *                       initialized for the very first time
     *                       (dividers, background colors and other
     *                       layout settings will be applied). Pass
     *                       false if the list just needs to be updated
     *                       with the current song.
     */
	private void initListViewAdapter(boolean initViewParams) {

        if (initViewParams) {
            //Reset the initialization flag.
            mInitListViewParams = false;

            if (mApp.getCurrentTheme()==Common.DARK_THEME) {
                mListView.setDivider(mContext.getResources().getDrawable(R.drawable.list_divider));
            } else {
                mListView.setDivider(mContext.getResources().getDrawable(R.drawable.list_divider_light));
            }

            mListView.setDividerHeight(1);
            mListView.setFastScrollEnabled(true);

            //KitKat ListView margins.
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {

                //Calculate navigation bar height.
                int navigationBarHeight = 0;
                int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
                if (resourceId > 0) {
                    navigationBarHeight = getResources().getDimensionPixelSize(resourceId);
                }

                mListView.setClipToPadding(false);
                mListView.setPadding(0, 0, 0, navigationBarHeight);

            }

        }

        mListViewAdapter = new QueueDrawerAdapter(mContext, mApp.getService().getPlaybackIndecesList());
        mListView.setAdapter(mListViewAdapter);
        mListView.setOnItemClickListener(onClick);
        mListView.setDropListener(onDrop);
        mListView.setRemoveListener(onRemove);

        SimpleFloatViewManager simpleFloatViewManager = new SimpleFloatViewManager(mListView);
        simpleFloatViewManager.setBackgroundColor(Color.TRANSPARENT);
        mListView.setFloatViewManager(simpleFloatViewManager);

        mListView.setVisibility(View.VISIBLE);
        mEmptyInfoText.setVisibility(View.INVISIBLE);

        /*
         * If the drawer is open, the user is probably scrolling through
         * the list already, so don't move the list to the new position.
         */
        if (!isDrawerOpen())
            mListView.setSelection(mApp.getService().getCurrentSongIndex());

    }

    /**
     * Sets the play/pause button states.
     */
    private void setPlayPauseButton() {
        if (mApp.isServiceRunning()) {
            if (mApp.getService().isPlayingMusic())
                animatePlayToPause();
            else
                animatePauseToPlay();

        }

    }

    /**
     * Animates the play button to a pause button.
     */
    private void animatePlayToPause() {

        //Check to make sure the current icon is the play icon.
        if (mPlayPauseButton.getId()!=R.drawable.play_light)
            return;

        //Fade out the play button.
        final ScaleAnimation scaleOut = new ScaleAnimation(1.0f, 0.0f, 1.0f, 0.0f,
                mPlayPauseButton.getWidth()/2,
                mPlayPauseButton.getHeight()/2);
        scaleOut.setDuration(150);
        scaleOut.setInterpolator(new AccelerateInterpolator());


        //Scale in the pause button.
        final ScaleAnimation scaleIn = new ScaleAnimation(0.0f, 1.0f, 0.0f, 1.0f,
                mPlayPauseButton.getWidth()/2,
                mPlayPauseButton.getHeight()/2);
        scaleIn.setDuration(150);
        scaleIn.setInterpolator(new DecelerateInterpolator());

        scaleOut.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mPlayPauseButton.setImageResource(R.drawable.pause_light);
                mPlayPauseButton.setPadding(0, 0, 0, 0);
                mPlayPauseButton.startAnimation(scaleIn);
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

        });

        scaleIn.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mPlayPauseButton.setScaleX(1.0f);
                mPlayPauseButton.setScaleY(1.0f);
                mPlayPauseButton.setId(R.drawable.pause_light);
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

        });

        mPlayPauseButton.startAnimation(scaleOut);
    }

    /**
     * Animates the pause button to a play button.
     */
    private void animatePauseToPlay() {

        //Check to make sure the current icon is the pause icon.
        if (mPlayPauseButton.getId()!=R.drawable.pause_light)
            return;

        //Scale out the pause button.
        final ScaleAnimation scaleOut = new ScaleAnimation(1.0f, 0.0f, 1.0f, 0.0f,
                mPlayPauseButton.getWidth()/2,
                mPlayPauseButton.getHeight()/2);
        scaleOut.setDuration(150);
        scaleOut.setInterpolator(new AccelerateInterpolator());


        //Scale in the play button.
        final ScaleAnimation scaleIn = new ScaleAnimation(0.0f, 1.0f, 0.0f, 1.0f,
                mPlayPauseButton.getWidth()/2,
                mPlayPauseButton.getHeight()/2);
        scaleIn.setDuration(150);
        scaleIn.setInterpolator(new DecelerateInterpolator());

        scaleOut.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mPlayPauseButton.setImageResource(R.drawable.play_light);
                mPlayPauseButton.setPadding(0, 0, -5, 0);
                mPlayPauseButton.startAnimation(scaleIn);
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

        });

        scaleIn.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mPlayPauseButton.setScaleX(1.0f);
                mPlayPauseButton.setScaleY(1.0f);
                mPlayPauseButton.setId(R.drawable.play_light);
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

        });

        mPlayPauseButton.startAnimation(scaleOut);
    }

    /**
     * Click listener for the play/pause button.
     */
    private View.OnClickListener playPauseClickListener = new View.OnClickListener() {

        @Override
        public void onClick(View view) {

            //BZZZT! Give the user a brief haptic feedback touch response.
            view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);

            //Update the playback UI elements.
            if (mApp.getService().isPlayingMusic())
                animatePauseToPlay();
            else
                animatePlayToPause();

            /*
             * Toggle the playback state in a separate thread. This
             * will allow the play/pause button animation to remain
             * buttery smooth.
             */
            new AsyncTask() {

                @Override
                protected Object doInBackground(Object[] params) {
                    mApp.getService().togglePlaybackState();
                    return null;
                }

            }.execute();

        }

    };

    /**
     * Click listener for the previous button.
     */
    private View.OnClickListener mOnClickPreviousListener = new View.OnClickListener() {

        @Override
        public void onClick(View arg0) {
            mApp.getService().skipToPreviousTrack();

        }

    };

    /**
     * Click listener for the next button.
     */
    private View.OnClickListener mOnClickNextListener = new View.OnClickListener() {

        @Override
        public void onClick(View arg0) {
            mApp.getService().skipToNextTrack();

        }

    };

    /**
     * Called if the audio playback service is not running.
     */
    public void showEmptyTextView() {
        mMiniPlayerLayout.setVisibility(View.GONE);
        mListView.setVisibility(View.INVISIBLE);
        mEmptyInfoText.setVisibility(View.VISIBLE);

    }

    /**
     * Click listener for the mini player.
     */
    private View.OnClickListener mOnClickMiniPlayer = new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            Intent intent = new Intent(mContext, NowPlayingActivity.class);
            startActivity(intent);
        }

    };

    /**
     * Click listener for the ListView.
     */
    private AdapterView.OnItemClickListener onClick = new AdapterView.OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            if (mApp.isServiceRunning())
                mApp.getService().skipToTrack(position);

        }

    };

    /**
     * Drag and drop interface for the ListView.
     */
    private DragSortListView.DropListener onDrop = new DragSortListView.DropListener() {

        @Override
        public void drop(int from, int to) {
            if (from!=to) {
                int fromItem = mListViewAdapter.getItem(from);
                int toItem = mListViewAdapter.getItem(to);
                mListViewAdapter.remove(fromItem);
                mListViewAdapter.insert(fromItem, to);

                //If the current song was reordered, change currentSongIndex and update the next song.
                if (from==mApp.getService().getCurrentSongIndex()) {
                    mApp.getService().setCurrentSongIndex(to);

                    //Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                    mApp.getService().prepareAlternateMediaPlayer();
                    return;

                } else if (from > mApp.getService().getCurrentSongIndex() && to <= mApp.getService().getCurrentSongIndex()) {
                    //One of the next songs was moved to a position before the current song. Move currentSongIndex forward by 1.
                    mApp.getService().incrementCurrentSongIndex();
                    mApp.getService().incrementEnqueueReorderScalar();

                    //Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                    mApp.getService().prepareAlternateMediaPlayer();
                    return;

                } else if (from < mApp.getService().getCurrentSongIndex() && to==mApp.getService().getCurrentSongIndex()) {
                	/* One of the previous songs was moved to the current song's position (visually speaking,
                	 * the new song will look like it was placed right after the current song.
                	 */
                    mApp.getService().decrementCurrentSongIndex();
                    mApp.getService().decrementEnqueueReorderScalar();

                    //Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                    mApp.getService().prepareAlternateMediaPlayer();
                    return;

                } else if (from < mApp.getService().getCurrentSongIndex() && to > mApp.getService().getCurrentSongIndex()) {
                    //One of the previous songs was moved to a position after the current song. Move currentSongIndex back by 1.
                    mApp.getService().decrementCurrentSongIndex();
                    mApp.getService().decrementEnqueueReorderScalar();

                    //Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                    mApp.getService().prepareAlternateMediaPlayer();
                    return;

                }

                //If the next song was reordered, reload it with the new index.
                if (mApp.getService().getPlaybackIndecesList().size() > (mApp.getService().getCurrentSongIndex()+1)) {
                    if (fromItem==mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()+1) ||
                            toItem==mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()+1)) {

                        //Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                        mApp.getService().prepareAlternateMediaPlayer();

                    }

                } else {
                    //Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                    mApp.getService().prepareAlternateMediaPlayer();

                }

            }

            //Fire a broadcast that notifies all listeners that the current queue order has changed.
            String[] updateFlags = { Common.NEW_QUEUE_ORDER };
            String[] flagValues = { "" };
            mApp.broadcastUpdateUICommand(updateFlags, flagValues);

        }

    };

    /**
     * Click remove interface for the ListView.
     */
    private DragSortListView.RemoveListener onRemove = new DragSortListView.RemoveListener() {

        @Override
        public void remove(int which) {

            //Stop the service if we just removed the last (and only) song.
            if (mApp.getService().getPlaybackIndecesList().size()==1) {
                mContext.stopService(new Intent(mContext, AudioPlaybackService.class));
                return;
            }

            //If the song that was removed is the next song, reload it.
            if (mApp.getService().getPlaybackIndecesList().size() > (mApp.getService().getCurrentSongIndex()+1)) {
                if (mListViewAdapter.getItem(which)==mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()+1)) {

                    //Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                    mApp.getService().prepareAlternateMediaPlayer();

                } else if (mListViewAdapter.getItem(which)==mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex())) {
                    mApp.getService().incrementCurrentSongIndex();
                    mApp.getService().prepareMediaPlayer(mApp.getService().getCurrentSongIndex());
                    mApp.getService().decrementCurrentSongIndex();
                } else if (mListViewAdapter.getItem(which) < mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex())) {
                    mApp.getService().decrementCurrentSongIndex();
                }

            } else if (which==(mApp.getService().getPlaybackIndecesList().size()-1) &&
                    mApp.getService().getCurrentSongIndex()==(mApp.getService().getPlaybackIndecesList().size()-1)) {
                //The current song was the last one and it was removed. Time to back up to the previous song.
                mApp.getService().decrementCurrentSongIndex();
                mApp.getService().prepareMediaPlayer(mApp.getService().getCurrentSongIndex());
            } else {
                //Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                mApp.getService().prepareAlternateMediaPlayer();

            }

            //Remove the item from the adapter.
            mListViewAdapter.remove(mListViewAdapter.getItem(which));

        }

    };

    @Override
    public void onResume() {
        super.onResume();
        checkServiceRunning();
        mPlayPauseBackground.setBackgroundResource(UIElementsHelper.getShadowedCircle(mContext));
        mPlayPauseButton.setId(R.drawable.pause_light);

    }

    @Override
    public void onStart() {
        super.onStart();
        LocalBroadcastManager.getInstance(mContext)
                             .registerReceiver((mReceiver), new IntentFilter(Common.UPDATE_UI_BROADCAST));

    }

    @Override
    public void onStop() {
        LocalBroadcastManager.getInstance(mContext).unregisterReceiver(mReceiver);
        super.onStop();

    }

    public boolean isDrawerOpen() {
        return mDrawerOpen;
    }

    public void setIsDrawerOpen(boolean isOpen) {
        mDrawerOpen = isOpen;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.EqualizerActivity;

import java.util.ArrayList;

import android.app.AlertDialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.database.Cursor;
import android.graphics.Paint;
import android.media.audiofx.PresetReverb;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.content.LocalBroadcastManager;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.CompoundButton;
import android.widget.EditText;
import android.widget.RelativeLayout;
import android.widget.ScrollView;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;
import android.widget.ToggleButton;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncApplyEQToAllSongsTask;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Dialogs.EQAlbumsListDialog;
import com.jams.music.player.Dialogs.EQArtistsListDialog;
import com.jams.music.player.Dialogs.EQGenresListDialog;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.Views.VerticalSeekBar;

public class EqualizerActivity extends FragmentActivity {

	//Context.
	protected Context mContext;
	private Common mApp;
    private EqualizerActivity mFragment;

    //Equalizer container elements.
    private ScrollView mScrollView;

	// 50Hz equalizer controls.
	private VerticalSeekBar equalizer50HzSeekBar;
	private TextView text50HzGainTextView;
	private TextView text50Hz;

	// 130Hz equalizer controls.
	private VerticalSeekBar equalizer130HzSeekBar;
	private TextView text130HzGainTextView;
	private TextView text130Hz;

	// 320Hz equalizer controls.
	private VerticalSeekBar equalizer320HzSeekBar;
	private TextView text320HzGainTextView;
	private TextView text320Hz;

	// 800 Hz equalizer controls.
	private VerticalSeekBar equalizer800HzSeekBar;
	private TextView text800HzGainTextView;
	private TextView text800Hz;

	// 2 kHz equalizer controls.
	private VerticalSeekBar equalizer2kHzSeekBar;
	private TextView text2kHzGainTextView;
	private TextView text2kHz;

	// 5 kHz equalizer controls.
	private VerticalSeekBar equalizer5kHzSeekBar;
	private TextView text5kHzGainTextView;
	private TextView text5kHz;

	// 12.5 kHz equalizer controls.
	private VerticalSeekBar equalizer12_5kHzSeekBar;
	private TextView text12_5kHzGainTextView;
	private TextView text12_5kHz;

	// Equalizer preset controls.
	private RelativeLayout loadPresetButton;
	private RelativeLayout saveAsPresetButton;
	private RelativeLayout resetAllButton;
	private TextView loadPresetText;
	private TextView savePresetText;
	private TextView resetAllText;

	// Temp variables that hold the equalizer's settings.
	private int fiftyHertzLevel = 16;
	private int oneThirtyHertzLevel = 16;
	private int threeTwentyHertzLevel = 16;
	private int eightHundredHertzLevel = 16;
	private int twoKilohertzLevel = 16;
	private int fiveKilohertzLevel = 16;
	private int twelvePointFiveKilohertzLevel = 16;

	// Temp variables that hold audio fx settings.
	private int virtualizerLevel;
	private int bassBoostLevel;
	private int reverbSetting;
	
	//Audio FX elements.
	private SeekBar virtualizerSeekBar;
	private SeekBar bassBoostSeekBar;
	private Spinner reverbSpinner;
	private TextView virtualizerTitle;
	private TextView bassBoostTitle;
	private TextView reverbTitle;

    //Misc flags.
    private boolean mDoneButtonPressed = false;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        //Context.
        mContext = getApplicationContext();
        mApp = (Common) mContext.getApplicationContext();
        mFragment = this;

        setTheme();
        super.onCreate(savedInstanceState);
        setContentView(R.layout.fragment_equalizer);

        //Equalizer container elements.
        mScrollView = (ScrollView) findViewById(R.id.equalizerScrollView);
        mScrollView.setBackgroundColor(UIElementsHelper.getBackgroundColor(mContext));

        //50Hz equalizer controls.
        equalizer50HzSeekBar = (VerticalSeekBar) findViewById(R.id.equalizer50Hz);
        text50HzGainTextView = (TextView) findViewById(R.id.text50HzGain);
        text50Hz = (TextView) findViewById(R.id.text50Hz);

        //130Hz equalizer controls.
        equalizer130HzSeekBar = (VerticalSeekBar) findViewById(R.id.equalizer130Hz);
        text130HzGainTextView = (TextView) findViewById(R.id.text130HzGain);
        text130Hz = (TextView) findViewById(R.id.text130Hz);

        //320Hz equalizer controls.
        equalizer320HzSeekBar = (VerticalSeekBar) findViewById(R.id.equalizer320Hz);
        text320HzGainTextView = (TextView) findViewById(R.id.text320HzGain);
        text320Hz = (TextView) findViewById(R.id.text320Hz);

        //800Hz equalizer controls.
        equalizer800HzSeekBar = (VerticalSeekBar) findViewById(R.id.equalizer800Hz);
        text800HzGainTextView = (TextView) findViewById(R.id.text800HzGain);
        text800Hz = (TextView) findViewById(R.id.text800Hz);

        //2kHz equalizer controls.
        equalizer2kHzSeekBar = (VerticalSeekBar) findViewById(R.id.equalizer2kHz);
        text2kHzGainTextView = (TextView) findViewById(R.id.text2kHzGain);
        text2kHz = (TextView) findViewById(R.id.text2kHz);

        //5kHz equalizer controls.
        equalizer5kHzSeekBar = (VerticalSeekBar) findViewById(R.id.equalizer5kHz);
        text5kHzGainTextView = (TextView) findViewById(R.id.text5kHzGain);
        text5kHz = (TextView) findViewById(R.id.text5kHz);

        //12.5kHz equalizer controls.
        equalizer12_5kHzSeekBar = (VerticalSeekBar) findViewById(R.id.equalizer12_5kHz);
        text12_5kHzGainTextView = (TextView) findViewById(R.id.text12_5kHzGain);
        text12_5kHz = (TextView) findViewById(R.id.text12_5kHz);

        //Equalizer preset controls.
        loadPresetButton = (RelativeLayout) findViewById(R.id.loadPresetButton);
        saveAsPresetButton = (RelativeLayout) findViewById(R.id.saveAsPresetButton);
        resetAllButton = (RelativeLayout) findViewById(R.id.resetAllButton);
        loadPresetText = (TextView) findViewById(R.id.load_preset_text);
        savePresetText = (TextView) findViewById(R.id.save_as_preset_text);
        resetAllText = (TextView) findViewById(R.id.reset_all_text);

        //Audio FX elements.
        virtualizerSeekBar = (SeekBar) findViewById(R.id.virtualizer_seekbar);
        bassBoostSeekBar = (SeekBar) findViewById(R.id.bass_boost_seekbar);
        reverbSpinner = (Spinner) findViewById(R.id.reverb_spinner);
        virtualizerTitle = (TextView) findViewById(R.id.virtualizer_title_text);
        bassBoostTitle = (TextView) findViewById(R.id.bass_boost_title_text);
        reverbTitle = (TextView) findViewById(R.id.reverb_title_text);

        text50HzGainTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text130HzGainTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text320HzGainTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text800HzGainTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text2kHzGainTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text5kHzGainTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text12_5kHzGainTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text50Hz.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text130Hz.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text320Hz.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text800Hz.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text2kHz.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text5kHz.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        text12_5kHz.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));

        loadPresetText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Bold"));
        savePresetText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Bold"));
        resetAllText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Bold"));

        text50HzGainTextView.setPaintFlags(text50HzGainTextView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text130HzGainTextView.setPaintFlags(text130HzGainTextView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text320HzGainTextView.setPaintFlags(text320HzGainTextView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text800HzGainTextView.setPaintFlags(text130HzGainTextView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text2kHzGainTextView.setPaintFlags(text320HzGainTextView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text5kHzGainTextView.setPaintFlags(text130HzGainTextView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text12_5kHzGainTextView.setPaintFlags(text320HzGainTextView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text50Hz.setPaintFlags(text50Hz.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text130Hz.setPaintFlags(text130Hz.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text320Hz.setPaintFlags(text320Hz.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text800Hz.setPaintFlags(text800Hz.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text2kHz.setPaintFlags(text2kHz.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text5kHz.setPaintFlags(text5kHz.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        text12_5kHz.setPaintFlags(text12_5kHz.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);

        loadPresetText.setPaintFlags(text50HzGainTextView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        savePresetText.setPaintFlags(text50HzGainTextView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
        resetAllText.setPaintFlags(text50HzGainTextView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);

        text50HzGainTextView.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text130HzGainTextView.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text320HzGainTextView.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text800HzGainTextView.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text2kHzGainTextView.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text5kHzGainTextView.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text12_5kHzGainTextView.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text50Hz.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text130Hz.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text320Hz.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text800Hz.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text2kHz.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text5kHz.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        text12_5kHz.setTextColor(UIElementsHelper.getSmallTextColor(mContext));

        //Init reverb presets.
        ArrayList<String> reverbPresets = new ArrayList<String>();
        reverbPresets.add("None");
        reverbPresets.add("Large Hall");
        reverbPresets.add("Large Room");
        reverbPresets.add("Medium Hall");
        reverbPresets.add("Medium Room");
        reverbPresets.add("Small Room");
        reverbPresets.add("Plate");

        ArrayAdapter<String> dataAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_spinner_item, reverbPresets);
        dataAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        reverbSpinner.setAdapter(dataAdapter);

        //Set the max values for the seekbars.
        virtualizerSeekBar.setMax(1000);
        bassBoostSeekBar.setMax(1000);

        virtualizerTitle.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        virtualizerTitle.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        virtualizerTitle.setPaintFlags(virtualizerTitle.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);

        bassBoostTitle.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        bassBoostTitle.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        bassBoostTitle.setPaintFlags(bassBoostTitle.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);

        reverbTitle.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
        reverbTitle.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
        reverbTitle.setPaintFlags(reverbTitle.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);

        resetAllButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                //Reset all sliders to 0.
                equalizer50HzSeekBar.setProgressAndThumb(16);
                equalizer130HzSeekBar.setProgressAndThumb(16);
                equalizer320HzSeekBar.setProgressAndThumb(16);
                equalizer800HzSeekBar.setProgressAndThumb(16);
                equalizer2kHzSeekBar.setProgressAndThumb(16);
                equalizer5kHzSeekBar.setProgressAndThumb(16);
                equalizer12_5kHzSeekBar.setProgressAndThumb(16);
                virtualizerSeekBar.setProgress(0);
                bassBoostSeekBar.setProgress(0);
                reverbSpinner.setSelection(0, false);

                //Apply the new setings to the service.
                applyCurrentEQSettings();

                //Show a confirmation toast.
                Toast.makeText(mContext, R.string.eq_reset, Toast.LENGTH_SHORT).show();

            }

        });

        loadPresetButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                buildLoadPresetDialog().show();

            }

        });

        saveAsPresetButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                buildSavePresetDialog().show();

            }

        });

        equalizer50HzSeekBar.setOnSeekBarChangeListener(equalizer50HzListener);
        equalizer130HzSeekBar.setOnSeekBarChangeListener(equalizer130HzListener);
        equalizer320HzSeekBar.setOnSeekBarChangeListener(equalizer320HzListener);
        equalizer800HzSeekBar.setOnSeekBarChangeListener(equalizer800HzListener);
        equalizer2kHzSeekBar.setOnSeekBarChangeListener(equalizer2kHzListener);
        equalizer5kHzSeekBar.setOnSeekBarChangeListener(equalizer5kHzListener);
        equalizer12_5kHzSeekBar.setOnSeekBarChangeListener(equalizer12_5kHzListener);

        virtualizerSeekBar.setOnSeekBarChangeListener(virtualizerListener);
        bassBoostSeekBar.setOnSeekBarChangeListener(bassBoostListener);
        reverbSpinner.setOnItemSelectedListener(reverbListener);

        //Get the saved equalizer settings and apply them to the UI elements.
        new AsyncInitSlidersTask().execute();

    }

    /**
     * Sets the activity theme based on the user preference.
     */
    private void setTheme() {

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            if (mApp.getCurrentTheme()==Common.DARK_THEME) {
                setTheme(R.style.AppThemeNoTranslucentNav);
            } else {
                setTheme(R.style.AppThemeNoTranslucentNavLight);
            }

        } else {
            if (mApp.getCurrentTheme()==Common.DARK_THEME) {
                setTheme(R.style.AppTheme);
            } else {
                setTheme(R.style.AppThemeLight);
            }

        }

    }
	
	/**
	 * 50 Hz equalizer seekbar listener.
	 */
	private OnSeekBarChangeListener equalizer50HzListener = new OnSeekBarChangeListener() {

		@Override
		public void onProgressChanged(SeekBar arg0, int seekBarLevel, boolean changedByUser) {
			
			try {
				//Get the appropriate equalizer band.
				short sixtyHertzBand = mApp.getService().getEqualizerHelper().getCurrentEqualizer().getBand(50000);
				
				//Set the gain level text based on the slider position.
				if (seekBarLevel==16) {
					text50HzGainTextView.setText("0 dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(sixtyHertzBand, (short) 0);
				} else if (seekBarLevel < 16) {
					
					if (seekBarLevel==0) {
						text50HzGainTextView.setText("-" + "15 dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(sixtyHertzBand, (short) (-1500));
					} else {
						text50HzGainTextView.setText("-" + (16-seekBarLevel) + " dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(sixtyHertzBand, (short) -((16-seekBarLevel)*100));
					}
					
				} else if (seekBarLevel > 16) {
					text50HzGainTextView.setText("+" + (seekBarLevel-16) + " dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(sixtyHertzBand, (short) ((seekBarLevel-16)*100));
				}
				
				fiftyHertzLevel = seekBarLevel;
				
			} catch (Exception e) {
				e.printStackTrace();
			}
			
		}

		@Override
		public void onStartTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onStopTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}
		
	};
	
	/**
	 * 130 Hz equalizer seekbar listener.
	 */
	private OnSeekBarChangeListener equalizer130HzListener = new OnSeekBarChangeListener() {

		@Override
		public void onProgressChanged(SeekBar arg0, int seekBarLevel, boolean changedByUser) {
			
			try {
				//Get the appropriate equalizer band.
				short twoThirtyHertzBand = mApp.getService().getEqualizerHelper().getCurrentEqualizer().getBand(130000);
				
				//Set the gain level text based on the slider position.
				if (seekBarLevel==16) {
					text130HzGainTextView.setText("0 dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(twoThirtyHertzBand, (short) 0);
				} else if (seekBarLevel < 16) {
					
					if (seekBarLevel==0) {
						text130HzGainTextView.setText("-" + "15 dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(twoThirtyHertzBand, (short) (-1500));
					} else {
						text130HzGainTextView.setText("-" + (16-seekBarLevel) + " dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(twoThirtyHertzBand, (short) -((16-seekBarLevel)*100));
					}
					
				} else if (seekBarLevel > 16) {
					text130HzGainTextView.setText("+" + (seekBarLevel-16) + " dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(twoThirtyHertzBand, (short) ((seekBarLevel-16)*100));
				}
				
				oneThirtyHertzLevel = seekBarLevel;
				
			} catch (Exception e) {
				e.printStackTrace();
			}

		}

		@Override
		public void onStartTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onStopTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}
		
	};

	/**
	 * 320 Hz equalizer seekbar listener.
	 */
	private OnSeekBarChangeListener equalizer320HzListener = new OnSeekBarChangeListener() {

		@Override
		public void onProgressChanged(SeekBar arg0, int seekBarLevel, boolean changedByUser) {
			
			try {
				//Get the appropriate equalizer band.
				short nineTenHertzBand = mApp.getService().getEqualizerHelper().getCurrentEqualizer().getBand(320000);
				
				//Set the gain level text based on the slider position.
				if (seekBarLevel==16) {
					text320HzGainTextView.setText("0 dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(nineTenHertzBand, (short) 0);
				} else if (seekBarLevel < 16) {
					
					if (seekBarLevel==0) {
						text320HzGainTextView.setText("-" + "15 dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(nineTenHertzBand, (short) (-1500));
					} else {
						text320HzGainTextView.setText("-" + (16-seekBarLevel) + " dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(nineTenHertzBand, (short) -((16-seekBarLevel)*100));
					}
					
				} else if (seekBarLevel > 16) {
					text320HzGainTextView.setText("+" + (seekBarLevel-16) + " dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(nineTenHertzBand, (short) ((seekBarLevel-16)*100));
				}
				
				threeTwentyHertzLevel = seekBarLevel;
				
			} catch (Exception e) {
				e.printStackTrace();
			}
			
		}

		@Override
		public void onStartTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onStopTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}
		
	};
	
	/**
	 * 800 Hz equalizer seekbar listener.
	 */
	private OnSeekBarChangeListener equalizer800HzListener = new OnSeekBarChangeListener() {

		@Override
		public void onProgressChanged(SeekBar arg0, int seekBarLevel, boolean changedByUser) {
			
			try {
				//Get the appropriate equalizer band.
				short threeKiloHertzBand = mApp.getService().getEqualizerHelper().getCurrentEqualizer().getBand(800000);
				
				//Set the gain level text based on the slider position.
				if (seekBarLevel==16) {
					text800HzGainTextView.setText("0 dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(threeKiloHertzBand, (short) 0);
				} else if (seekBarLevel < 16) {
					
					if (seekBarLevel==0) {
						text800HzGainTextView.setText("-" + "15 dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(threeKiloHertzBand, (short) (-1500));
					} else {
						text800HzGainTextView.setText("-" + (16-seekBarLevel) + " dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(threeKiloHertzBand, (short) -((16-seekBarLevel)*100));
					}
					
				} else if (seekBarLevel > 16) {
					text800HzGainTextView.setText("+" + (seekBarLevel-16) + " dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(threeKiloHertzBand, (short) ((seekBarLevel-16)*100));
				}
				
				eightHundredHertzLevel = seekBarLevel;
				
			} catch (Exception e) {
				e.printStackTrace();
			}

		}

		@Override
		public void onStartTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onStopTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}
		
	};
	
	/**
	 * 2 kHz equalizer seekbar listener.
	 */
	private OnSeekBarChangeListener equalizer2kHzListener = new OnSeekBarChangeListener() {

		@Override
		public void onProgressChanged(SeekBar arg0, int seekBarLevel, boolean changedByUser) {
			
			try {
				//Get the appropriate equalizer band.
				short fourteenKiloHertzBand = mApp.getService().getEqualizerHelper().getCurrentEqualizer().getBand(2000000);
				
				//Set the gain level text based on the slider position.
				if (seekBarLevel==16) {
					text2kHzGainTextView.setText("0 dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(fourteenKiloHertzBand, (short) 0);
				} else if (seekBarLevel < 16) {
					
					if (seekBarLevel==0) {
						text2kHzGainTextView.setText("-" + "15 dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(fourteenKiloHertzBand, (short) (-1500));
					} else {
						text2kHzGainTextView.setText("-" + (16-seekBarLevel) + " dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(fourteenKiloHertzBand, (short) -((16-seekBarLevel)*100));
					}
					
				} else if (seekBarLevel > 16) {
					text2kHzGainTextView.setText("+" + (seekBarLevel-16) + " dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(fourteenKiloHertzBand, (short) ((seekBarLevel-16)*100));
				}
				
				twoKilohertzLevel = seekBarLevel;
				
			} catch (Exception e) {
				e.printStackTrace();
			}
			
		}

		@Override
		public void onStartTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onStopTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}
		
	};
	
	/**
	 * 5 kHz equalizer seekbar listener.
	 */
	private OnSeekBarChangeListener equalizer5kHzListener = new OnSeekBarChangeListener() {

		@Override
		public void onProgressChanged(SeekBar arg0, int seekBarLevel, boolean changedByUser) {
			
			try {
				//Get the appropriate equalizer band.
				short fiveKiloHertzBand = mApp.getService().getEqualizerHelper().getCurrentEqualizer().getBand(5000000);
				
				//Set the gain level text based on the slider position.
				if (seekBarLevel==16) {
					text5kHzGainTextView.setText("0 dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(fiveKiloHertzBand, (short) 0);
				} else if (seekBarLevel < 16) {
					
					if (seekBarLevel==0) {
						text5kHzGainTextView.setText("-" + "15 dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(fiveKiloHertzBand, (short) (-1500));
					} else {
						text5kHzGainTextView.setText("-" + (16-seekBarLevel) + " dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(fiveKiloHertzBand, (short) -((16-seekBarLevel)*100));
					}
					
				} else if (seekBarLevel > 16) {
					text5kHzGainTextView.setText("+" + (seekBarLevel-16) + " dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(fiveKiloHertzBand, (short) ((seekBarLevel-16)*100));
				}
				
				fiveKilohertzLevel = seekBarLevel;
				
			} catch (Exception e) {
				e.printStackTrace();
			}
			
		}

		@Override
		public void onStartTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onStopTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}
		
	};
	
	/**
	 * 12.5 kHz equalizer seekbar listener.
	 */
	private OnSeekBarChangeListener equalizer12_5kHzListener = new OnSeekBarChangeListener() {

		@Override
		public void onProgressChanged(SeekBar arg0, int seekBarLevel, boolean changedByUser) {
			
			try {
				//Get the appropriate equalizer band.
				short twelvePointFiveKiloHertzBand = mApp.getService().getEqualizerHelper().getCurrentEqualizer().getBand(9000000);
				
				//Set the gain level text based on the slider position.
				if (seekBarLevel==16) {
					text12_5kHzGainTextView.setText("0 dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(twelvePointFiveKiloHertzBand, (short) 0);
				} else if (seekBarLevel < 16) {
					
					if (seekBarLevel==0) {
						text12_5kHzGainTextView.setText("-" + "15 dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(twelvePointFiveKiloHertzBand, (short) (-1500));
					} else {
						text12_5kHzGainTextView.setText("-" + (16-seekBarLevel) + " dB");
						mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(twelvePointFiveKiloHertzBand, (short) -((16-seekBarLevel)*100));
					}
					
				} else if (seekBarLevel > 16) {
					text12_5kHzGainTextView.setText("+" + (seekBarLevel-16) + " dB");
					mApp.getService().getEqualizerHelper().getCurrentEqualizer().setBandLevel(twelvePointFiveKiloHertzBand, (short) ((seekBarLevel-16)*100));
				}
				
				twelvePointFiveKilohertzLevel = seekBarLevel;
				
			} catch (Exception e) {
				e.printStackTrace();
			}
			
		}

		@Override
		public void onStartTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onStopTrackingTouch(SeekBar arg0) {
			// TODO Auto-generated method stub
			
		}
		
	};
	
	/**
	 * Spinner listener for reverb effects.
	 */
	private OnItemSelectedListener reverbListener = new OnItemSelectedListener() {

		@Override
		public void onItemSelected(AdapterView<?> arg0, View arg1, int index, long arg3) {
			
			if (mApp.isServiceRunning())
				if (index==0) {
					mApp.getService().getEqualizerHelper().getCurrentReverb().setPreset(PresetReverb.PRESET_NONE);
					reverbSetting = 0;
				} else if (index==1) {
					mApp.getService().getEqualizerHelper().getCurrentReverb().setPreset(PresetReverb.PRESET_LARGEHALL);
					reverbSetting = 1;
				} else if (index==2) {
					mApp.getService().getEqualizerHelper().getCurrentReverb().setPreset(PresetReverb.PRESET_LARGEROOM);
					reverbSetting = 2;
				} else if (index==3) {
					mApp.getService().getEqualizerHelper().getCurrentReverb().setPreset(PresetReverb.PRESET_MEDIUMHALL);
					reverbSetting = 3;
				} else if (index==4) {
					mApp.getService().getEqualizerHelper().getCurrentReverb().setPreset(PresetReverb.PRESET_MEDIUMROOM);
					reverbSetting = 4;
				} else if (index==5) {
					mApp.getService().getEqualizerHelper().getCurrentReverb().setPreset(PresetReverb.PRESET_SMALLROOM);
					reverbSetting = 5;
				} else if (index==6) {
					mApp.getService().getEqualizerHelper().getCurrentReverb().setPreset(PresetReverb.PRESET_PLATE);
					reverbSetting = 6;
				}
			
			else
				reverbSetting = 0;
		}

		@Override
		public void onNothingSelected(AdapterView<?> arg0) {
			// TODO Auto-generated method stub
			
		}
    	
    };
    
    /**
     * Bass boost listener.
     */
    private OnSeekBarChangeListener bassBoostListener = new OnSeekBarChangeListener() {

		@Override
		public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) {
			mApp.getService().getEqualizerHelper().getCurrentBassBoost().setStrength((short) arg1);
			bassBoostLevel = (short) arg1;
			
		}

		@Override
		public void onStartTrackingTouch(SeekBar seekBar) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onStopTrackingTouch(SeekBar seekBar) {
			// TODO Auto-generated method stub
			
		}
	   
    };
    
    /**
     * Virtualizer listener.
     */
    private OnSeekBarChangeListener virtualizerListener = new OnSeekBarChangeListener() {

		@Override
		public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) {
			mApp.getService().getEqualizerHelper().getCurrentVirtualizer().setStrength((short) arg1);
			virtualizerLevel = (short) arg1;
		}

		@Override
		public void onStartTrackingTouch(SeekBar seekBar) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onStopTrackingTouch(SeekBar seekBar) {
			// TODO Auto-generated method stub
			
		}
	   
    };
    
	/**
	 * Builds the "Save Preset" dialog. Does not call the show() method, so you 
	 * should do this manually when calling this method.
	 * 
	 * @return A fully built AlertDialog reference.
	 */
	private AlertDialog buildSavePresetDialog() {
		
		AlertDialog.Builder builder = new AlertDialog.Builder(this);
        View dialogView = getLayoutInflater().inflate(R.layout.add_new_equalizer_preset_dialog_layout, null);
        
        final EditText newPresetNameField = (EditText) dialogView.findViewById(R.id.new_preset_name_text_field);
        newPresetNameField.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Light"));
        newPresetNameField.setPaintFlags(newPresetNameField.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        //Set the dialog title.
        builder.setTitle(R.string.save_preset);
        builder.setView(dialogView);
        builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int arg1) {
				dialog.dismiss();
				
			}
        	
        });
        
        builder.setPositiveButton(R.string.done, new DialogInterface.OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				
				//Get the preset name from the text field.
				String presetName = newPresetNameField.getText().toString();
				
				//Add the preset and it's values to the DB.
				mApp.getDBAccessHelper().addNewEQPreset(presetName, 
									  				    fiftyHertzLevel, 
									  				    oneThirtyHertzLevel, 
									  				    threeTwentyHertzLevel, 
									  				    eightHundredHertzLevel, 
									  				    twoKilohertzLevel, 
									  				    fiveKilohertzLevel, 
									  				    twelvePointFiveKilohertzLevel, 
									  				    (short) virtualizerSeekBar.getProgress(), 
									  				    (short) bassBoostSeekBar.getProgress(), 
									  				    (short) reverbSpinner.getSelectedItemPosition());
				
				Toast.makeText(mContext, R.string.preset_saved, Toast.LENGTH_SHORT).show();
				dialog.dismiss();
			}
        	
        });

        return builder.create();
        
	}
	
	/**
	 * Builds the "Load Preset" dialog. Does not call the show() method, so this 
	 * should be done manually after calling this method.
	 * 
	 * @return A fully built AlertDialog reference.
	 */
	private AlertDialog buildLoadPresetDialog() {
		AlertDialog.Builder builder = new AlertDialog.Builder(this);

        //Get a cursor with the list of EQ presets.
        final Cursor cursor = mApp.getDBAccessHelper().getAllEQPresets();
        
        //Set the dialog title.
        builder.setTitle(R.string.load_preset);
        builder.setCursor(cursor, new DialogInterface.OnClickListener() {
			
			@SuppressWarnings("unchecked")
			@Override
			public void onClick(DialogInterface dialog, int which) {
				cursor.moveToPosition(which);
				
				//Close the dialog.
				dialog.dismiss();
				
				//Pass on the equalizer values to the appropriate fragment.
				fiftyHertzLevel = cursor.getInt(cursor.getColumnIndex(DBAccessHelper.EQ_50_HZ));
				oneThirtyHertzLevel = cursor.getInt(cursor.getColumnIndex(DBAccessHelper.EQ_130_HZ));
				threeTwentyHertzLevel = cursor.getInt(cursor.getColumnIndex(DBAccessHelper.EQ_320_HZ));
				eightHundredHertzLevel = cursor.getInt(cursor.getColumnIndex(DBAccessHelper.EQ_800_HZ));
				twoKilohertzLevel = cursor.getInt(cursor.getColumnIndex(DBAccessHelper.EQ_2000_HZ));
				fiveKilohertzLevel = cursor.getInt(cursor.getColumnIndex(DBAccessHelper.EQ_5000_HZ));
				twelvePointFiveKilohertzLevel = cursor.getInt(cursor.getColumnIndex(DBAccessHelper.EQ_12500_HZ));
				virtualizerLevel = cursor.getShort(cursor.getColumnIndex(DBAccessHelper.VIRTUALIZER));
				bassBoostLevel = cursor.getShort(cursor.getColumnIndex(DBAccessHelper.BASS_BOOST));
				reverbSetting = cursor.getShort(cursor.getColumnIndex(DBAccessHelper.REVERB));
				
				//Save the new equalizer settings to the DB.
				@SuppressWarnings({ "rawtypes" })
				AsyncTask task = new AsyncTask() {

					@Override
					protected Object doInBackground(Object... arg0) {
						setEQValuesForSong(mApp.getService().getCurrentSong().getId());
						return null;
					}
					
					@Override
					public void onPostExecute(Object result) {
						super.onPostExecute(result);
						
						//Reinitialize the UI elements to apply the new equalizer settings.
						new AsyncInitSlidersTask().execute();
					}
					
				};
				task.execute();

				if (cursor!=null)
					cursor.close();
				
			}
			
		}, DBAccessHelper.PRESET_NAME);

        return builder.create();
        
	}
	
	/**
	 * Builds the "Apply To" dialog. Does not call the show() method, so you 
	 * should do this manually when calling this method.
	 * 
	 * @return A fully built AlertDialog reference.
	 */
	public AlertDialog buildApplyToDialog() {
		AlertDialog.Builder builder = new AlertDialog.Builder(this);

        //Set the dialog title.
        builder.setTitle(R.string.apply_to);
        builder.setCancelable(false);
        builder.setItems(R.array.apply_equalizer_to_array, new DialogInterface.OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				
				if (which==0) {
					setEQValuesForSong(mApp.getService().getCurrentSong().getId());
					Toast.makeText(mContext, R.string.eq_applied_to_current_song, Toast.LENGTH_SHORT).show();
					
					//Finish this activity.
                    finish();
					
				} else if (which==1) {	
					AsyncApplyEQToAllSongsTask task = new AsyncApplyEQToAllSongsTask(mContext, mFragment);
					task.execute();
					dialog.dismiss();

                    //Finish this activity.
                    finish();

				} else if (which==2) {
					FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
					EQArtistsListDialog artistDialog = new EQArtistsListDialog();
					artistDialog.show(ft, "eqArtistsListDialog");
					
					dialog.dismiss();

				} else if (which==3) {	
					FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
					EQAlbumsListDialog albumsDialog = new EQAlbumsListDialog();
					albumsDialog.show(ft, "eqAlbumsListDialog");
					
					dialog.dismiss();

				} else if (which==4) {
					FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
					EQGenresListDialog genresDialog = new EQGenresListDialog();
					genresDialog.show(ft, "eqGenresListDialog");
					
					dialog.dismiss();
					
				}
				
			}
        	
        });

        return builder.create(); 
	}
    
    /**
     * Saves the EQ settings to the database for the specified song.
     */
    public void setEQValuesForSong(String songId) {
    	
    	//Grab the EQ values for the specified song.
    	int[] currentEqValues = mApp.getDBAccessHelper().getSongEQValues(songId);
		
		//Check if a database entry already exists for this song.
		if (currentEqValues[10]==0) {
			//Add a new DB entry.
			mApp.getDBAccessHelper().addSongEQValues(songId, 
									 				 fiftyHertzLevel, 
									 				 oneThirtyHertzLevel, 
									 				 threeTwentyHertzLevel, 
									 				 eightHundredHertzLevel, 
									 				 twoKilohertzLevel, 
									 				 fiveKilohertzLevel,
									 				 twelvePointFiveKilohertzLevel,
									 				 virtualizerLevel, 
									 				 bassBoostLevel, 
									 				 reverbSetting);
		} else {
			//Update the existing entry.
			mApp.getDBAccessHelper().updateSongEQValues(songId, 
									 			   		fiftyHertzLevel, 
									 			   		oneThirtyHertzLevel, 
									 			   		threeTwentyHertzLevel, 
									 			   		eightHundredHertzLevel, 
									 			   		twoKilohertzLevel, 
									 			   		fiveKilohertzLevel, 
									 			   		twelvePointFiveKilohertzLevel, 
									 			   		virtualizerLevel, 
									 			   		bassBoostLevel, 
									 			   		reverbSetting);
		}

    }

    /**
     * Applies the current EQ settings to the service.
     */
    public void applyCurrentEQSettings() {
    	if (!mApp.isServiceRunning())
    		return;
		
		equalizer50HzListener.onProgressChanged(equalizer50HzSeekBar, equalizer50HzSeekBar.getProgress(), true);
		equalizer130HzListener.onProgressChanged(equalizer130HzSeekBar, equalizer130HzSeekBar.getProgress(), true);
		equalizer320HzListener.onProgressChanged(equalizer320HzSeekBar, equalizer320HzSeekBar.getProgress(), true);
		equalizer800HzListener.onProgressChanged(equalizer800HzSeekBar, equalizer800HzSeekBar.getProgress(), true);
		equalizer2kHzListener.onProgressChanged(equalizer2kHzSeekBar, equalizer2kHzSeekBar.getProgress(), true);
		equalizer5kHzListener.onProgressChanged(equalizer5kHzSeekBar, equalizer5kHzSeekBar.getProgress(), true);
		equalizer12_5kHzListener.onProgressChanged(equalizer12_5kHzSeekBar, equalizer12_5kHzSeekBar.getProgress(), true);
		
		virtualizerListener.onProgressChanged(virtualizerSeekBar, virtualizerSeekBar.getProgress(), true);
		bassBoostListener.onProgressChanged(bassBoostSeekBar, bassBoostSeekBar.getProgress(), true);
		reverbListener.onItemSelected(reverbSpinner, null, reverbSpinner.getSelectedItemPosition(), 0l);

    }
	
	/**
	 * Broadcast receiver that calls the methods that update the sliders with the 
	 * current song's EQ.
	 */
	BroadcastReceiver mReceiver = new BroadcastReceiver() {
		
		@Override
	    public void onReceive(Context context, Intent intent) {
			if (intent.hasExtra(Common.UPDATE_EQ_FRAGMENT)) {
				new AsyncInitSlidersTask().execute();
				
			}

            if (intent.hasExtra(Common.SERVICE_STOPPING)) {
                finish();
            }
			
		}
		
	};

    /**
     * Initializes the ActionBar.
     */
    private void showEqualizerActionBar(Menu menu) {

        //Set the Actionbar color.
        getActionBar().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));

        //Hide all menu items except the toggle button and "done" icon.
        menu.findItem(R.id.action_equalizer).setVisible(false);
        menu.findItem(R.id.action_pin).setVisible(false);
        menu.findItem(R.id.action_queue_drawer).setVisible(false);
        menu.findItem(R.id.action_settings).setVisible(false);
        menu.findItem(R.id.action_done).setVisible(true);

        /**
         * The Toggle button in the actionbar doesn't work at this point. The setChecked()
         * method doesn't do anything, so there's no way to programmatically set the
         * switch to its correct position when the equalizer fragment is first shown.
         * Users will just have to rely on the "Reset" button in the equalizer fragment
         * to effectively switch off the equalizer.
         */
        menu.findItem(R.id.action_equalizer_toggle).setVisible(false); //Hide the toggle for now.

		//Set the toggle listener.
		ToggleButton equalizerToggle = (ToggleButton) menu.findItem(R.id.action_equalizer_toggle)
									 		  			  .getActionView()
									 		  			  .findViewById(R.id.actionbar_toggle_switch);

		//Set the current state of the toggle.
		boolean toggleSetting = true;
		if (mApp.isEqualizerEnabled())
			toggleSetting = true;
		else
			toggleSetting = false;

        //Set the ActionBar title text color.
        int titleId = getResources().getIdentifier("action_bar_title", "id", "android");
        TextView abTitle = (TextView) findViewById(titleId);
        abTitle.setTextColor(0xFFFFFFFF);

		equalizerToggle.setChecked(toggleSetting);
		equalizerToggle.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton arg0, boolean state) {
				mApp.setIsEqualizerEnabled(state);

				if (state==true)
					applyCurrentEQSettings();

			}

		});

        getActionBar().setHomeButtonEnabled(false);
        getActionBar().setDisplayHomeAsUpEnabled(false);

    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.now_playing, menu);

        showEqualizerActionBar(menu);
        return super.onCreateOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        super.onOptionsItemSelected(item);
        switch (item.getItemId()) {
            case R.id.action_done:
                mDoneButtonPressed = true;
                buildApplyToDialog().show();
                return true;
            default:
                //Return false to allow the activity to handle the item click.
                return false;
        }

    }

    @Override
    public void onPause() {
    	super.onPause();

        //Save the EQ values for the current song.
        if (!mDoneButtonPressed) {
           setEQValuesForSong(mApp.getService().getCurrentSong().getId());
           Toast.makeText(mContext, R.string.eq_applied_to_current_song, Toast.LENGTH_SHORT).show();
        }

        finish();
    }
	
	@Override
	public void onStart() {
		super.onStart();
		
		//Initialize the broadcast manager that will listen for track changes.
    	LocalBroadcastManager.getInstance(mContext)
		 					 .registerReceiver((mReceiver), new IntentFilter(Common.UPDATE_UI_BROADCAST));
		
	}
	
	@Override
	public void onStop() {
		super.onStop();
		
		//Unregister the broadcast receivers.
    	LocalBroadcastManager.getInstance(mContext).unregisterReceiver(mReceiver);
	
	}
	
    /**
    * Retrieves the saved equalizer settings for the current song 
    * and applies them to the UI elements.
    */
	public class AsyncInitSlidersTask extends AsyncTask<Boolean, Boolean, Boolean> {
		
		int[] eqValues;
		
		@Override
		protected Boolean doInBackground(Boolean... params) {
			eqValues = mApp.getDBAccessHelper()
				 	   .getSongEQValues(mApp.getService()
						 			  		.getCurrentSong()
						 			  		.getId());
			
			return null;
		}
		
		@SuppressWarnings("unchecked")
		@Override
		public void onPostExecute(Boolean result) {
			super.onPostExecute(result);
			
			fiftyHertzLevel = eqValues[0];
			oneThirtyHertzLevel = eqValues[1];
			threeTwentyHertzLevel = eqValues[2];
			eightHundredHertzLevel = eqValues[3];
			twoKilohertzLevel = eqValues[4];
			fiveKilohertzLevel = eqValues[5];
			twelvePointFiveKilohertzLevel = eqValues[6];
			virtualizerLevel = eqValues[7];
			bassBoostLevel = eqValues[8];
			reverbSetting = eqValues[9];
			
			//Move the sliders to the equalizer settings.
			equalizer50HzSeekBar.setProgressAndThumb(fiftyHertzLevel);
			equalizer130HzSeekBar.setProgressAndThumb(oneThirtyHertzLevel);
			equalizer320HzSeekBar.setProgressAndThumb(threeTwentyHertzLevel);
			equalizer800HzSeekBar.setProgressAndThumb(eightHundredHertzLevel);
			equalizer2kHzSeekBar.setProgressAndThumb(twoKilohertzLevel);
			equalizer5kHzSeekBar.setProgressAndThumb(fiveKilohertzLevel);
			equalizer12_5kHzSeekBar.setProgressAndThumb(twelvePointFiveKilohertzLevel);
	        virtualizerSeekBar.setProgress(virtualizerLevel);
	        bassBoostSeekBar.setProgress(bassBoostLevel);
	        reverbSpinner.setSelection(reverbSetting, false);

			//50Hz Band.
			if (fiftyHertzLevel==16) {
				text50HzGainTextView.setText("0 dB");
			} else if (fiftyHertzLevel < 16) {
				
				if (fiftyHertzLevel==0) {
					text50HzGainTextView.setText("-" + "15 dB");
				} else {
					text50HzGainTextView.setText("-" + (16-fiftyHertzLevel) + " dB");
				}
				
			} else if (fiftyHertzLevel > 16) {
				text50HzGainTextView.setText("+" + (fiftyHertzLevel-16) + " dB");
			}
			
			//130Hz Band.
			if (oneThirtyHertzLevel==16) {
				text130HzGainTextView.setText("0 dB");
			} else if (oneThirtyHertzLevel < 16) {
				
				if (oneThirtyHertzLevel==0) {
					text130HzGainTextView.setText("-" + "15 dB");
				} else {
					text130HzGainTextView.setText("-" + (16-oneThirtyHertzLevel) + " dB");
				}
				
			} else if (oneThirtyHertzLevel > 16) {
				text130HzGainTextView.setText("+" + (oneThirtyHertzLevel-16) + " dB");
			}
			
			//320Hz Band.
			if (threeTwentyHertzLevel==16) {
				text320HzGainTextView.setText("0 dB");
			} else if (threeTwentyHertzLevel < 16) {
				
				if (threeTwentyHertzLevel==0) {
					text320HzGainTextView.setText("-" + "15 dB");
				} else {
					text320HzGainTextView.setText("-" + (16-threeTwentyHertzLevel) + " dB");
				}
				
			} else if (threeTwentyHertzLevel > 16) {
				text320HzGainTextView.setText("+" + (threeTwentyHertzLevel-16) + " dB");
			}
			
			//800Hz Band.
			if (eightHundredHertzLevel==16) {
				text800HzGainTextView.setText("0 dB");
			} else if (eightHundredHertzLevel < 16) {
				
				if (eightHundredHertzLevel==0) {
					text800HzGainTextView.setText("-" + "15 dB");
				} else {
					text800HzGainTextView.setText("-" + (16-eightHundredHertzLevel) + " dB");
				}
				
			} else if (eightHundredHertzLevel > 16) {
				text800HzGainTextView.setText("+" + (eightHundredHertzLevel-16) + " dB");
			}
			
			//2kHz Band.
			if (twoKilohertzLevel==16) {
				text2kHzGainTextView.setText("0 dB");
			} else if (twoKilohertzLevel < 16) {
				
				if (twoKilohertzLevel==0) {
					text2kHzGainTextView.setText("-" + "15 dB");
				} else {
					text2kHzGainTextView.setText("-" + (16-twoKilohertzLevel) + " dB");
				}
				
			} else if (twoKilohertzLevel > 16) {
				text2kHzGainTextView.setText("+" + (twoKilohertzLevel-16) + " dB");
			}
			
			//5kHz Band.
			if (fiveKilohertzLevel==16) {
				text5kHzGainTextView.setText("0 dB");
			} else if (fiveKilohertzLevel < 16) {
				
				if (fiveKilohertzLevel==0) {
					text5kHzGainTextView.setText("-" + "15 dB");
				} else {
					text5kHzGainTextView.setText("-" + (16-fiveKilohertzLevel) + " dB");
				}
				
			} else if (fiveKilohertzLevel > 16) {
				text5kHzGainTextView.setText("+" + (fiveKilohertzLevel-16) + " dB");
			}
			
			//12.5kHz Band.
			if (twelvePointFiveKilohertzLevel==16) {
				text12_5kHzGainTextView.setText("0 dB");
			} else if (twelvePointFiveKilohertzLevel < 16) {
				
				if (twelvePointFiveKilohertzLevel==0) {
					text12_5kHzGainTextView.setText("-" + "15 dB");
				} else {
					text12_5kHzGainTextView.setText("-" + (16-twelvePointFiveKilohertzLevel) + " dB");
				}
				
			} else if (twelvePointFiveKilohertzLevel > 16) {
				text12_5kHzGainTextView.setText("+" + (twelvePointFiveKilohertzLevel-16) + " dB");
			}
			
		}
		
	}

    /**
     * Getter methods.
     */
    
	public int getFiftyHertzLevel() {
		return fiftyHertzLevel;
	}

	public int getOneThirtyHertzLevel() {
		return oneThirtyHertzLevel;
	}

	public int getThreeTwentyHertzLevel() {
		return threeTwentyHertzLevel;
	}

	public int getEightHundredHertzLevel() {
		return eightHundredHertzLevel;
	}

	public int getTwoKilohertzLevel() {
		return twoKilohertzLevel;
	}

	public int getFiveKilohertzLevel() {
		return fiveKilohertzLevel;
	}

	public int getTwelvePointFiveKilohertzLevel() {
		return twelvePointFiveKilohertzLevel;
	}

	public int getVirtualizerLevel() {
		return virtualizerLevel;
	}

	public int getBassBoostLevel() {
		return bassBoostLevel;
	}
	
	public SeekBar getVirtualizerSeekBar() {
		return virtualizerSeekBar;
	}
	
	public SeekBar getBassBoostSeekBar() {
		return bassBoostSeekBar;
	}
	
	public Spinner getReverbSpinner() {
		return reverbSpinner;
	}

	/**
	 * Setter methods.
	 */
	
	public void setFiftyHertzLevel(int fiftyHertzLevel) {
		this.fiftyHertzLevel = fiftyHertzLevel;
	}

	public void setOneThirtyHertzLevel(int oneThirtyHertzLevel) {
		this.oneThirtyHertzLevel = oneThirtyHertzLevel;
	}

	public void setThreeTwentyHertzLevel(int threeTwentyHertzLevel) {
		this.threeTwentyHertzLevel = threeTwentyHertzLevel;
	}

	public void setEightHundredHertzLevel(int eightHundredHertzLevel) {
		this.eightHundredHertzLevel = eightHundredHertzLevel;
	}

	public void setTwoKilohertzLevel(int twoKilohertzLevel) {
		this.twoKilohertzLevel = twoKilohertzLevel;
	}

	public void setFiveKilohertzLevel(int fiveKilohertzLevel) {
		this.fiveKilohertzLevel = fiveKilohertzLevel;
	}

	public void setTwelvePointFiveKilohertzLevel(int twelvePointFiveKilohertzLevel) {
		this.twelvePointFiveKilohertzLevel = twelvePointFiveKilohertzLevel;
	}

	public void setVirtualizerLevel(int virtualizerLevel) {
		this.virtualizerLevel = virtualizerLevel;
	}

	public void setBassBoostLevel(int bassBoostLevel) {
		this.bassBoostLevel = bassBoostLevel;
	}
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.FoldersFragment;

import java.io.File;
import java.io.FileFilter;

public class FileExtensionFilter implements FileFilter {
    private char[][] extensions;

    public FileExtensionFilter(String[] extensions) {
        int length = extensions.length;
        this.extensions = new char[length][];
        
        for (String s : extensions) {
            this.extensions[--length] = s.toCharArray();
        }
        
    }

    @Override
    public boolean accept(File file) {
    	
        char[] path = file.getPath().toCharArray();
        for (char[] extension : extensions) {
        	
            if (extension.length > path.length) {
                continue;
            }
            
            int pStart = path.length - 1;
            int eStart = extension.length - 1;
            boolean success = true;
            
            for (int i = 0; i <= eStart; i++) {
                if ((path[pStart - i] | 0x20) != (extension[eStart - i] | 0x20)) {
                    success = false;
                    break;
                }
            }
            
            if (success) {
                return true;
            }

        }
        
        return false;
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.FoldersFragment;

import android.annotation.SuppressLint;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Parcelable;
import android.provider.MediaStore;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.TranslateAnimation;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.AsyncTasks.AsyncCopyMoveTask;
import com.jams.music.player.AsyncTasks.AsyncDeleteTask;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.MainActivity.MainActivity;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.comparator.NameFileComparator;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

/**
 * FilesFoldersFragment. Contained within MainActivity.
 * 
 * @author Saravan Pantham
 */
public class FilesFoldersFragment extends Fragment {

	//Context.
	private Context mContext;
	private FilesFoldersFragment mFilesFoldersFragment;
	private Common mApp;
	
	//UI Elements.
	private ListView listView;
	
	//Folder parameter ArrayLists.
	private String rootDir;
	public static String currentDir;
	private List<String> fileFolderNameList = null; 
	private List<String> fileFolderPathList = null;
	private List<String> fileFolderSizeList = null;
	private List<Integer> fileFolderTypeList = null;
	
	//File size/unit dividers
	private final long kiloBytes = 1024;
	private final long megaBytes = kiloBytes * kiloBytes;
	private final long gigaBytes = megaBytes * kiloBytes;
	private final long teraBytes = gigaBytes * kiloBytes;
	
	//List of subdirectories within a directory (Used by "Play Folder Recursively").
	private ArrayList<String> subdirectoriesList = new ArrayList<String>();
	
	//Flag that determines whether hidden files are displayed or not.
	private boolean SHOW_HIDDEN_FILES = false;

    //Temp file for copy/move operations.
    public File copyMoveSourceFile;

    //Flag that indicates if copyMoveSourceFile should be moved or copied.
    public boolean shouldMoveCopiedFile = false;
    public boolean mIsPasteShown = false;

    //HashMap to store the each folder's previous scroll/position state.
    private HashMap<String, Parcelable> mFolderStateMap;

	//Handler.
	private Handler mHandler = new Handler();

    public static final int FOLDER = 0;
    public static final int FILE = 1;
    public static final int AUDIO_FILE = 3;
    public static final int PICTURE_FILE = 4;
    public static final int VIDEO_FILE = 5;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_folders, container, false);
        mContext = getActivity().getApplicationContext();
        mFilesFoldersFragment = this;
        mApp = (Common) mContext;
        mFolderStateMap = new HashMap<String, Parcelable>();
        
        //Set the hidden files flag.
        SHOW_HIDDEN_FILES = mApp.getSharedPreferences().getBoolean("SHOW_HIDDEN_FILES", false);

        listView = (ListView) rootView.findViewById(R.id.folders_list_view);
        listView.setFastScrollEnabled(true);
        listView.setVisibility(View.INVISIBLE);
        
		//Set the background color based on the theme.
        rootView.setBackgroundColor(UIElementsHelper.getBackgroundColor(mContext));

        //Apply the ListView params.
        //Apply the ListViews' dividers.
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            listView.setDivider(mContext.getResources().getDrawable(R.drawable.icon_list_divider));
        } else {
            listView.setDivider(mContext.getResources().getDrawable(R.drawable.icon_list_divider_light));
        }

        listView.setDividerHeight(1);

		//KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT) {
        	int topPadding = Common.getStatusBarHeight(mContext);

            //Calculate navigation bar height.
            int navigationBarHeight = 0;
            int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
            if (resourceId > 0) {
                navigationBarHeight = getResources().getDimensionPixelSize(resourceId);
            }
            
            if (rootView!=null) {
            	rootView.setPadding(0, topPadding, 0, 0);
            }
            
            listView.setClipToPadding(false);
            listView.setPadding(0, 0, 0, navigationBarHeight);
        }

        rootDir = mApp.getSharedPreferences().getString("DEFAULT_FOLDER", Environment.getExternalStorageDirectory().getPath());
        currentDir = rootDir;
        mHandler.postDelayed(new Runnable() {

            @Override
            public void run() {
                slideUpListView();
            }

        }, 250);
        return rootView;
    }

    /**
     * Slides in the ListView.
     */
    private void slideUpListView() {

        getDir(rootDir, null);

        TranslateAnimation animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f,
                                                              Animation.RELATIVE_TO_SELF, 0.0f,
                                                              Animation.RELATIVE_TO_SELF, 2.0f,
                                                              Animation.RELATIVE_TO_SELF, 0.0f);

        animation.setDuration(600);
        animation.setInterpolator(new AccelerateDecelerateInterpolator());
        animation.setAnimationListener(new AnimationListener() {

            @Override
            public void onAnimationEnd(Animation arg0) {

            }

            @Override
            public void onAnimationRepeat(Animation arg0) {
                // TODO Auto-generated method stub

            }

            @Override
            public void onAnimationStart(Animation arg0) {
               listView.setVisibility(View.VISIBLE);

            }

        });

        listView.startAnimation(animation);
    }
    
    /**
     * Retrieves the folder hierarchy for the specified folder.
     *
     * @param dirPath The path of the new folder.
     * @param restoreState The state of the ListView that should be restored. Pass
     *                     null if the ListView's position should not be restored.
     */
    private void getDir(String dirPath, Parcelable restoreState) {
    	
        ((MainActivity) getActivity()).showFolderFragmentActionItems(dirPath,
                                                                     getActivity().getMenuInflater(),
                                                                     ((MainActivity) getActivity()).getMenu(),
                                                                     mIsPasteShown);

		fileFolderNameList = new ArrayList<String>();
		fileFolderPathList = new ArrayList<String>();
		fileFolderSizeList = new ArrayList<String>();
		fileFolderTypeList = new ArrayList<Integer>();
		
		File f = new File(dirPath);
		File[] files = f.listFiles();
		 
		if (files!=null) {
			
			//Sort the files by name.
			Arrays.sort(files, NameFileComparator.NAME_INSENSITIVE_COMPARATOR);
			
			for(int i=0; i < files.length; i++) {
				
				File file = files[i];
				if(file.isHidden()==SHOW_HIDDEN_FILES && file.canRead()) {
					
					if (file.isDirectory()) {

                        /*
						 * Starting with Android 4.2, /storage/emulated/legacy/...
						 * is a symlink that points to the actual directory where
						 * the user's files are stored. We need to detect the
						 * actual directory's file path here.
						 */
                        String filePath;
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1)
                            filePath = getRealFilePath(file.getAbsolutePath());
                        else
                            filePath = file.getAbsolutePath();

                        fileFolderPathList.add(filePath);
						fileFolderNameList.add(file.getName());
						File[] listOfFiles = file.listFiles();
						
						if (listOfFiles!=null) {
							fileFolderTypeList.add(FOLDER);
							if (listOfFiles.length==1) {
								fileFolderSizeList.add("" + listOfFiles.length + " item");
							} else {
								fileFolderSizeList.add("" + listOfFiles.length + " items");
							}
							
						} else {
							fileFolderTypeList.add(FOLDER);
							fileFolderSizeList.add("Unknown items");
						}
						
					} else {
						
						try {
							String path = file.getCanonicalPath();
							fileFolderPathList.add(path);
						} catch (IOException e) {
							continue;
						}
						
						fileFolderNameList.add(file.getName());
						String fileName = "";
						try {
							fileName = file.getCanonicalPath();
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
						//Add the file element to fileFolderTypeList based on the file type.
						if (getFileExtension(fileName).equalsIgnoreCase("mp3") ||
							getFileExtension(fileName).equalsIgnoreCase("3gp") ||
							getFileExtension(fileName).equalsIgnoreCase("mp4") ||
							getFileExtension(fileName).equalsIgnoreCase("m4a") ||
							getFileExtension(fileName).equalsIgnoreCase("aac") ||
							getFileExtension(fileName).equalsIgnoreCase("ts") ||
							getFileExtension(fileName).equalsIgnoreCase("flac") ||
							getFileExtension(fileName).equalsIgnoreCase("mid") ||
							getFileExtension(fileName).equalsIgnoreCase("xmf") ||
							getFileExtension(fileName).equalsIgnoreCase("mxmf") ||
							getFileExtension(fileName).equalsIgnoreCase("midi") ||
							getFileExtension(fileName).equalsIgnoreCase("rtttl") ||
							getFileExtension(fileName).equalsIgnoreCase("rtx") ||
							getFileExtension(fileName).equalsIgnoreCase("ota") ||
							getFileExtension(fileName).equalsIgnoreCase("imy") ||
							getFileExtension(fileName).equalsIgnoreCase("ogg") ||
							getFileExtension(fileName).equalsIgnoreCase("mkv") ||
							getFileExtension(fileName).equalsIgnoreCase("wav")) {
							
							//The file is an audio file.
							fileFolderTypeList.add(AUDIO_FILE);
							fileFolderSizeList.add("" + getFormattedFileSize(file.length()));
							
						} else if (getFileExtension(fileName).equalsIgnoreCase("jpg") ||
								   getFileExtension(fileName).equalsIgnoreCase("gif") ||
								   getFileExtension(fileName).equalsIgnoreCase("png") ||
								   getFileExtension(fileName).equalsIgnoreCase("bmp") ||
								   getFileExtension(fileName).equalsIgnoreCase("webp")) {
							
							//The file is a picture file.
							fileFolderTypeList.add(PICTURE_FILE);
							fileFolderSizeList.add("" + getFormattedFileSize(file.length()));
							
						} else if (getFileExtension(fileName).equalsIgnoreCase("3gp") ||
								   getFileExtension(fileName).equalsIgnoreCase("mp4") ||
								   getFileExtension(fileName).equalsIgnoreCase("3gp") ||
								   getFileExtension(fileName).equalsIgnoreCase("ts") ||
								   getFileExtension(fileName).equalsIgnoreCase("webm") ||
								   getFileExtension(fileName).equalsIgnoreCase("mkv")) {
							
							//The file is a video file.
							fileFolderTypeList.add(VIDEO_FILE);
							fileFolderSizeList.add("" + getFormattedFileSize(file.length()));
							
						} else {
							
							//We don't have an icon for this file type so give it the generic file flag.
							fileFolderTypeList.add(FILE);
							fileFolderSizeList.add("" + getFormattedFileSize(file.length()));
							
						}

					}
					
				} 
			
			}
			
		}
		
		FoldersListViewAdapter foldersListViewAdapter = new FoldersListViewAdapter(getActivity(),
                                                                                   this,
																				   fileFolderNameList,
																				   fileFolderTypeList, 
																				   fileFolderSizeList, 
																				   fileFolderPathList);
		
		listView.setAdapter(foldersListViewAdapter);
		foldersListViewAdapter.notifyDataSetChanged();

        //Restore the ListView's previous state.
        if (restoreState!=null) {
            listView.onRestoreInstanceState(restoreState);
        } else if (mFolderStateMap.containsKey(dirPath)) {
            listView.onRestoreInstanceState(mFolderStateMap.get(dirPath));
        }

        listView.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> arg0, View view, int index, long arg3) {

                //Store the current folder's state in the HashMap.
                if (mFolderStateMap.size()==3) {
                    mFolderStateMap.clear();
                }

                mFolderStateMap.put(currentDir, listView.onSaveInstanceState());

                String newPath = fileFolderPathList.get(index);
                if ((Integer) view.getTag(R.string.folder_list_item_type)==FOLDER)
                    currentDir = newPath;

                //Check if the selected item is a folder or a file.
                if (fileFolderTypeList.get(index)==FOLDER) {
                    getDir(newPath, null);
                } else {
                    int fileIndex = 0;
                    for (int i=0; i < index; i++) {
                        if (fileFolderTypeList.get(i)==AUDIO_FILE)
                            fileIndex++;
                    }

                    play(fileFolderTypeList.get(index), fileIndex, currentDir);
                }

            }

        });
		
    }

    /**
     * Refreshes the ListView with the current dataset.
     */
    public void refreshListView() {
        //Update the ListView.
        getDir(currentDir, listView.onSaveInstanceState());
    }

    /**
     * Resolves the /storage/emulated/legacy paths to
     * their true folder path representations. Required
     * for Nexii and other devices with no SD card.
     */
    @SuppressLint("SdCardPath")
    private String getRealFilePath(String filePath) {

        if (filePath.equals("/storage/emulated/0") ||
                filePath.equals("/storage/emulated/0/") ||
                filePath.equals("/storage/emulated/legacy") ||
                filePath.equals("/storage/emulated/legacy/") ||
                filePath.equals("/storage/sdcard0") ||
                filePath.equals("/storage/sdcard0/") ||
                filePath.equals("/sdcard") ||
                filePath.equals("/sdcard/") ||
                filePath.equals("/mnt/sdcard") ||
                filePath.equals("/mnt/sdcard/")) {

            return Environment.getExternalStorageDirectory().toString();
        }

        return filePath;
    }

    /**
     * Calculates the parent dir of the current dir and calls getDir().
     * Returns true if the parent dir is the rootDir
     */
    public boolean getParentDir() {

        if (currentDir.equals("/"))
            return true;

        //Get the current folder's parent folder.
        File currentFolder = new File(currentDir);
        String parentFolder = "";
        try {
            parentFolder = currentFolder.getParentFile().getCanonicalPath();
        } catch (Exception e) {
            e.printStackTrace();
        }

        FilesFoldersFragment.currentDir = parentFolder;
        getDir(parentFolder, null);
        return false;

    }

    /**
     * Takes in a file size value and formats it.
     */
    public String getFormattedFileSize(final long value) {
    	
    	final long[] dividers = new long[] { teraBytes, gigaBytes, megaBytes, kiloBytes, 1 };
        final String[] units = new String[] { "TB", "GB", "MB", "KB", "bytes" };
        
        if(value < 1) {
        	return "";
        }
        
        String result = null;
        for(int i = 0; i < dividers.length; i++) {
            final long divider = dividers[i];
            if(value >= divider) {
                result = format(value, divider, units[i]);
                break;
            }
            
        }
        
        return result;
    }

    public String format(final long value, final long divider, final String unit) {
        final double result = divider > 1 ? (double) value / (double) divider : (double) value;
        
        return new DecimalFormat("#,##0.#").format(result) + " " + unit;
    }
    
    public String getFileExtension(String fileName) {
        String fileNameArray[] = fileName.split("\\.");
        String extension = fileNameArray[fileNameArray.length-1];

        return extension;
        
    }
    
    /**
     * This method goes through a folder recursively and saves all its
     * subdirectories to an ArrayList (subdirectoriesList). 
     */
    public void iterateThruFolder(String path) {

        File root = new File(path);
        File[] list = root.listFiles();

        if (list==null) {
        	return;
        }

        for (File f : list) {
        	
            if (f.isDirectory()) {
                iterateThruFolder(f.getAbsolutePath());
                
                if (!subdirectoriesList.contains(f.getPath())) {
                	subdirectoriesList.add(f.getPath());
                }
                    
            }
            
        }
        
    }
    
    /**
     * Plays the specified file/folder.
     *
     * @param itemType Specifies whether the input path is a file path
     *                 or a folder path.
     * @param index The index of the first song to play. Pass 0 if itemType
     *              is FOLDER.
     * @param folderPath The path of the folder that should be played.
     */
    public void play(int itemType, int index, String folderPath) {
        //Build the query's selection clause.
        String querySelection = MediaStore.Audio.Media.DATA + " LIKE "
                + "'" + folderPath.replace("'", "''") + "/%'";

        //Exclude all subfolders from this playback sequence if we're playing a file.
        if (itemType==AUDIO_FILE) {
            for (int i = 0; i < fileFolderPathList.size(); i++) {
                if (fileFolderTypeList.get(i) == FOLDER)
                    querySelection += " AND " + MediaStore.Audio.Media.DATA + " NOT LIKE "
                            + "'" + fileFolderPathList.get(i).replace("'", "''") + "/%'";

            }

            mApp.getPlaybackKickstarter().initPlayback(mContext,
                                                       querySelection,
                                                       Common.PLAY_ALL_IN_FOLDER,
                                                       index,
                                                       true, false);

        } else if (itemType==FOLDER) {
            mApp.getPlaybackKickstarter().initPlayback(mContext,
                                                       querySelection,
                                                       Common.PLAY_ALL_IN_FOLDER,
                                                       index,
                                                       true, false);
        } else {
            Toast.makeText(mContext, R.string.cant_play_this_file, Toast.LENGTH_SHORT).show();
        }

    }

    /**
     * Displays a "Rename" dialog and renames the specified file/folder.
     *
     * @param path The path of the folder/file that needs to be renamed.
     */
    public void rename(String path) {

        final File renameFile = new File(path);
        final AlertDialog renameAlertDialog = new AlertDialog.Builder(getActivity()).create();
        final EditText fileEditText = new EditText(getActivity());

        fileEditText.setHint(R.string.file_name);
        fileEditText.setSingleLine(true);
        fileEditText.setText(renameFile.getName());

        renameAlertDialog.setView(fileEditText);
        renameAlertDialog.setTitle(R.string.rename);
        renameAlertDialog.setButton(DialogInterface.BUTTON_NEGATIVE,
                                    mContext.getResources().getString(R.string.cancel),
                                    new DialogInterface.OnClickListener() {

                                        @Override
                                        public void onClick(DialogInterface dialog, int which) {
                                            renameAlertDialog.dismiss();
                                        }

                                    });

        renameAlertDialog.setButton(DialogInterface.BUTTON_POSITIVE,
                                    mContext.getResources().getString(R.string.rename),
                                    new DialogInterface.OnClickListener() {

                                        @Override
                                        public void onClick(DialogInterface dialog, int which) {

                                            //Check if the new file name is empty.
                                            if (fileEditText.getText().toString().isEmpty()) {
                                                Toast.makeText(getActivity(), R.string.enter_a_name_for_folder, Toast.LENGTH_LONG).show();
                                            } else {

                                                File newNameFile = null;
                                                try {
                                                    newNameFile = new File(renameFile.getParentFile().getCanonicalPath() + "/" + fileEditText.getText().toString());
                                                } catch (IOException e) {
                                                    e.printStackTrace();
                                                    Toast.makeText(getActivity(), R.string.folder_could_not_be_renamed, Toast.LENGTH_LONG).show();
                                                    return;
                                                }

                                                try {
                                                    if (renameFile.isDirectory())
                                                        FileUtils.moveDirectory(renameFile, newNameFile);
                                                    else
                                                        FileUtils.moveFile(renameFile, newNameFile);

                                                } catch (IOException e) {
                                                    e.printStackTrace();
                                                    Toast.makeText(getActivity(), R.string.folder_could_not_be_renamed, Toast.LENGTH_LONG).show();
                                                    return;
                                                }

                                                Toast.makeText(getActivity(), R.string.folder_renamed, Toast.LENGTH_SHORT).show();
                                                renameAlertDialog.dismiss();
                                                refreshListView();

                                            }

                                        }

                                    });

        renameAlertDialog.show();

    }

    /**
     * Stores the specified file/folder's path in a temp variable and displays
     * the "Paste" option in the ActionBar.
     *
     * @param path The path of the file/folder to copy/move.
     * @param shouldMove Pass true if the file/folder should be moved instead of copied.
     */
    public void copyMove(String path, boolean shouldMove) {
        shouldMoveCopiedFile = shouldMove;
        copyMoveSourceFile = new File(path);
        if (!copyMoveSourceFile.exists()) {
            Toast.makeText(mContext, R.string.cant_copy_this_file_folder, Toast.LENGTH_SHORT).show();
            return;
        }

        //Show the paste option in the ActionBar.
        mIsPasteShown =  true;
        ((MainActivity) getActivity()).showFolderFragmentActionItems(currentDir,
                                                                     getActivity().getMenuInflater(),
                                                                     ((MainActivity) getActivity()).getMenu(),
                                                                     true);

    }

    /**
     * Pastes the specified file into the current directory.
     *
     * @param file The file to paste into the current directory.
     */
    public void pasteIntoCurrentDir(File file) {
        mIsPasteShown =  false;
        AsyncCopyMoveTask task = new AsyncCopyMoveTask(mContext, file, new File(currentDir + "/" + file.getName()),
                                                       this, shouldMoveCopiedFile);
        task.execute();
    }

    /**
     * Deletes the specified file.
     *
     * @param file The file to delete.
     */
    public void deleteFile(File file) {
        int fileType;
        if (file.isDirectory())
            fileType = FOLDER;
        else
            fileType = FILE;

        AsyncDeleteTask task = new AsyncDeleteTask(getActivity(), this, file, fileType);
        task.execute();
    }

    @Override
    public void onDestroyView() {
    	super.onDestroyView();
    	mContext = null;
    	listView = null;

    }
    
    /*
     * Getter methods. 
     */
    public String getCurrentDir() {
    	return currentDir;
    }
     
    /*
     * Setter methods.
     */
    public void setCurrentDir(String currentDir) {
    	this.currentDir = currentDir;
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.FoldersFragment;

import android.content.Context;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.PopupMenu;
import android.widget.TextView;

import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

import java.io.File;
import java.util.List;

public class FoldersListViewAdapter extends ArrayAdapter<String> {

	private Context mContext;
    private Common mApp;
    private FilesFoldersFragment mFragment;

    private int mItemType;
    private String mItemPath;
    private int mItemPosition;

	private List<String> mFileFolderNameList;
	private List<Integer> mFileFolderTypeList;
	private List<String> mFileFolderSizeList;
	private List<String> mFileFolderPathsList;
   
    public FoldersListViewAdapter(Context context,
                                  FilesFoldersFragment fragment,
    							  List<String> nameList, 
    							  List<Integer> fileFolderTypeList,
    							  List<String> sizeList, 
    							  List<String> fileFolderPathsList) {
    	
    	super(context, -1, nameList);
    	
    	mContext = context;
        mApp = (Common) mContext.getApplicationContext();
        mFragment = fragment;

    	mFileFolderNameList = nameList;
    	mFileFolderTypeList = fileFolderTypeList;
    	mFileFolderSizeList = sizeList;
    	mFileFolderPathsList = fileFolderPathsList;
    	
    }
    
    public View getView(int position, View convertView, ViewGroup parent) {
    	
    	FoldersViewHolder holder = null;
		if (convertView == null) {

            convertView = LayoutInflater.from(mContext).inflate(R.layout.list_view_item, parent, false);
            ListView.LayoutParams params = (ListView.LayoutParams) convertView.getLayoutParams();
            params.height = (int) mApp.convertDpToPixels(72.0f, mContext);
            convertView.setLayoutParams(params);

			holder = new FoldersViewHolder();
			holder.fileFolderIcon = (ImageView) convertView.findViewById(R.id.listViewLeftIcon);
			holder.fileFolderSizeText = (TextView) convertView.findViewById(R.id.listViewSubText);
			holder.fileFolderNameText = (TextView) convertView.findViewById(R.id.listViewTitleText);
            holder.overflowButton = (ImageButton) convertView.findViewById(R.id.listViewOverflow);
            holder.rightSubText = (TextView) convertView.findViewById(R.id.listViewRightSubText);

            holder.fileFolderIcon.setScaleX(0.5f);
            holder.fileFolderIcon.setScaleY(0.55f);
            holder.rightSubText.setVisibility(View.INVISIBLE);

			holder.fileFolderNameText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
			holder.fileFolderNameText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			
			holder.fileFolderSizeText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
			holder.fileFolderSizeText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));

            holder.overflowButton.setImageResource(UIElementsHelper.getIcon(mContext, "ic_action_overflow"));
            holder.overflowButton.setFocusable(false);
            holder.overflowButton.setFocusableInTouchMode(false);
			holder.overflowButton.setOnClickListener(overflowClickListener);

			convertView.setTag(holder);
		} else {
		    holder = (FoldersViewHolder) convertView.getTag();
		}
		
		holder.fileFolderNameText.setText(mFileFolderNameList.get(position));
		holder.fileFolderSizeText.setText(mFileFolderSizeList.get(position));
		
		//Set the icon based on whether the item is a folder or a file.
		if (mFileFolderTypeList.get(position)==FilesFoldersFragment.FOLDER) {
			holder.fileFolderIcon.setImageResource(R.drawable.icon_folderblue);
			convertView.setTag(R.string.folder_list_item_type, FilesFoldersFragment.FOLDER);
			convertView.setTag(R.string.folder_path, mFileFolderPathsList.get(position));
            convertView.setTag(R.string.position, position);

		} else if (mFileFolderTypeList.get(position)==FilesFoldersFragment.AUDIO_FILE) {
			holder.fileFolderIcon.setImageResource(R.drawable.icon_mp3);
			convertView.setTag(R.string.folder_list_item_type, FilesFoldersFragment.AUDIO_FILE);
			convertView.setTag(R.string.folder_path, mFileFolderPathsList.get(position));
            convertView.setTag(R.string.position, position);

		} else if (mFileFolderTypeList.get(position)==FilesFoldersFragment.PICTURE_FILE) {
			holder.fileFolderIcon.setImageResource(R.drawable.icon_png);
			convertView.setTag(R.string.folder_list_item_type, FilesFoldersFragment.PICTURE_FILE);
			convertView.setTag(R.string.folder_path, mFileFolderPathsList.get(position));
            convertView.setTag(R.string.position, position);

		} else if (mFileFolderTypeList.get(position)==FilesFoldersFragment.VIDEO_FILE) {
			holder.fileFolderIcon.setImageResource(R.drawable.icon_avi);
			convertView.setTag(R.string.folder_list_item_type, FilesFoldersFragment.VIDEO_FILE);
			convertView.setTag(R.string.folder_path, mFileFolderPathsList.get(position));
            convertView.setTag(R.string.position, position);

		} else {
			holder.fileFolderIcon.setImageResource(R.drawable.icon_default);
			convertView.setTag(R.string.folder_list_item_type, FilesFoldersFragment.FILE);
			convertView.setTag(R.string.folder_path, mFileFolderPathsList.get(position));
            convertView.setTag(R.string.position, position);

		}
    	
    	return convertView;
	}

    /**
     * Click listener for overflow button.
     */
    private View.OnClickListener overflowClickListener = new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            PopupMenu menu = new PopupMenu(mContext, v);
            menu.inflate(R.menu.file_folder_overflow_menu);
            menu.setOnMenuItemClickListener(popupMenuItemClickListener);
            mItemType = (Integer) ((View) v.getParent()).getTag(R.string.folder_list_item_type);
            mItemPath = (String) ((View) v.getParent()).getTag(R.string.folder_path);
            mItemPosition = (Integer) ((View) v.getParent()).getTag(R.string.position);
            menu.show();

        }

    };

    /**
     * Menu item click listener for the pop up menu.
     */
    private PopupMenu.OnMenuItemClickListener popupMenuItemClickListener = new PopupMenu.OnMenuItemClickListener() {

        @Override
        public boolean onMenuItemClick(MenuItem item) {

            switch(item.getItemId()) {
                case R.id.play:
                    int fileIndex;
                    String folderPath;
                    if (mItemType==FilesFoldersFragment.AUDIO_FILE) {
                        fileIndex = 0;
                        folderPath = FilesFoldersFragment.currentDir;
                        for (int i=0; i < mItemPosition; i++) {
                            if (mFileFolderTypeList.get(i)==FilesFoldersFragment.AUDIO_FILE)
                                fileIndex++;
                        }

                    } else {
                        fileIndex = 0;
                        folderPath = mItemPath;
                    }

                    mFragment.play(mItemType, fileIndex, folderPath);
                    break;
                case R.id.rename:
                    mFragment.rename(mItemPath);
                    break;
                case R.id.copy:
                    mFragment.copyMove(mItemPath, false);
                    break;
                case R.id.move:
                    mFragment.copyMove(mItemPath, true);
                    break;
                case R.id.delete:
                    mFragment.deleteFile(new File(mItemPath));
                    break;
            }

            return false;
        }

    };

    static class FoldersViewHolder {
    	public TextView fileFolderNameText;
    	public TextView fileFolderSizeText;
    	public ImageView fileFolderIcon;
        public ImageButton overflowButton;
        public TextView rightSubText;
    }
   
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GMusicHelpers;

import org.json.JSONObject;

// not used in the Android app
public class AddPlaylistResponse implements IJsonObject<AddPlaylistResponse>
{
	private String mId;
	private String mTitle;
	private boolean mSuccess;

	public final String getId()
	{
		return mId;
	}

	public final void setId(String id)
	{
		mId = id;
	}

	public final String getTitle()
	{
		return mTitle;
	}

	public final void setTitle(String title)
	{
		mTitle = title;
	}

	public final boolean isSuccess()
	{
		return mSuccess;
	}

	public final void setSuccess(boolean success)
	{
		mSuccess = success;
	}

	@Override
	public AddPlaylistResponse fromJsonObject(JSONObject jsonObject)
	{
		if(jsonObject != null)
		{
			mId = jsonObject.optString("id", null);
			mTitle = jsonObject.optString("title", null);
			mSuccess = jsonObject.optBoolean("success");
		}

		// return this object to allow chaining
		return this;
	}
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GMusicHelpers;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;

import org.apache.http.client.HttpClient;
import org.apache.http.cookie.Cookie;
import org.apache.http.entity.ByteArrayEntity;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.content.Context;
import android.text.TextUtils;

import com.loopj.android.http.PersistentCookieStore;
import com.loopj.android.http.RequestParams;

/*******************************************************************************
 * This class contains the MobileClient (preferred) and WebClient (deprecated) 
 * endpoints and method calls for Google Play Music. Retrieving the song stream 
 * URL and reordering songs in a playlist are the only operations that should 
 * be carried out using the WebClient protocol.
 * 
 * @author Saravan Pantham
 *******************************************************************************/
public class GMusicClientCalls {
	
	public static Context mContext;
	private static PersistentCookieStore mCookieStore;
	public static GMusicHttpClient mHttpClient;
	private static GMusicClientCalls mInstance;
	private static String mWebClientUserAgent;
	private static String mAuthToken;
	private static String mMobileClientUserAgent = "Android-Music/1301 (t03g JDQ39); gzip";
	public static JSONArray mPlaylistEntriesMutationsArray = new JSONArray();

	public static void createInstance(Context context) {
		getInstance(context);
	}

	public static GMusicClientCalls getInstance(Context context) {
		if(mInstance == null)
			mInstance = new GMusicClientCalls(context);
		
		return mInstance;
	}

	private GMusicClientCalls(Context context) {
		mHttpClient = new GMusicHttpClient();
		mContext = context;
		mCookieStore = new PersistentCookieStore(context.getApplicationContext());
		mHttpClient.setCookieStore(mCookieStore);
		mHttpClient.setUserAgent("");
	}
	
	/*************************************************
	 * Returns the raw HTTP client behind the custom 
	 * GMusicHTTPClient implementation.
	 * @return The raw HTTP client object.
	 *************************************************/
	public static final HttpClient getRawHttpClient() {
		return mHttpClient.getHttpClient();
	}

	/******************************************************************
	 * Sets the HTTP client's authorization header using the specified 
	 * authentication token. The header will be in the following form: 
	 * 
	 * "Authorization", "GoogleLogin auth=xxxxxxxxxxxxxx",
	 * 
	 * where "xxxxxxxxxxxxxxx" is the authentication token.
	 * 
	 * @param authToken The authentication token that will be used to 
	 * set the header.
	 ******************************************************************/
	public static final void setAuthorizationHeader(String authToken) {
		mAuthToken = authToken;
		mHttpClient.addHeader("Authorization", "GoogleLogin auth=" + mAuthToken);
	}
	
	/************************************************************************
	 * Resets the current HTTP client object by shutting it down and then 
	 * reinstantiating it. The old cookie store, user agent and authorization 
	 * header will be reused. This process will be done on a separate thread.
	 ************************************************************************/
	public static void resetHttpClient() {
		//Reset the HTTP Client on a separate thread.
		Thread thread = new Thread() {
			
			@Override
			public void run() {
				if (mHttpClient!=null) {
					mHttpClient.getHttpClient().getConnectionManager().shutdown();
					mHttpClient = new GMusicHttpClient();
					mHttpClient.setCookieStore(mCookieStore);
					mHttpClient.setUserAgent(mWebClientUserAgent);
					mHttpClient.addHeader("Authorization", "GoogleLogin auth=" + mAuthToken);
				}
				
			}
			
		};
		thread.start();
		
	}

	/*********************************************************
	 * Sets the user agent for webclient calls.
	 * 
	 * @param userAgent
	 *********************************************************/
	public static final void setWebClientUserAgent(String userAgent) {
		mWebClientUserAgent = userAgent;
		mHttpClient.setUserAgent(mWebClientUserAgent);
	}
	
	public static final GMusicHttpClient getHttpClient() {
		return mHttpClient;
	}
	
	/*************************************************
	 * Loops through the HTTP client's cookie store 
	 * and returns the value of the "xt" cookie.
	 * 
	 * @return Value of the "xt" cookie.
	 *************************************************/
	private static final String getXtCookieValue() {
		
		for(Cookie cookie : mCookieStore.getCookies()) {
			if(cookie.getName().equals("xt"))
				return cookie.getValue();
		}

		return null;
	}
	
	/*******************************************************************************
	 * Attempts to log the user into the "sj" (SkyJam) service using the provided
	 * authentication token. The authentication token is unique for each session 
	 * and user account. It can be obtained via the GoogleAuthUtil.getToken() 
	 * method. See AsyncGoogleMusicAuthenticationTask.java for the current
	 * implementation of this process. This method will return true if the login
	 * process succeeded. Returns false for any other type of failure.
	 * 
	 * @param context The context that will be used for the login process.
	 * @param authToken The authentication token that will be used to login. 
	 *******************************************************************************/
	public static final boolean login(Context context, String authToken) {
		
		if(!TextUtils.isEmpty(authToken))
		{
			JSONForm form = new JSONForm().close();
			GMusicClientCalls.setAuthorizationHeader(authToken);
			String response = mHttpClient.post(context, 
											   "https://play.google.com/music/listen?hl=en&u=0", 
											   new ByteArrayEntity(form.toString().getBytes()), 
											   form.getContentType());
			
			//Check if the required paramters are null.
			if (response!=null) {
				
				if (getXtCookieValue()!=null) {
					return true;
				} else {
					return false;
				}
				
			} else {
				return false;
			}

		} else {
			return false;
		}
		
	}

	/*****************************************************************
	 * Gets the URI of the song stream using the specified song Id. 
	 * The URI is dynamically generated by Google's servers and 
	 * expires after one minute of no usage. This method uses the 
	 * WebClient endpoint.
	 * 
	 * @param songId The id of the song that needs to be streamed.
	 * @return Returns the URI of the song stream.
	 * @throws JSONException
	 * @throws URISyntaxException
	 ******************************************************************/
	public static final URI getSongStream(String songId) 
							throws JSONException, URISyntaxException {

		RequestParams params = new RequestParams();
		params.put("u", "0");
		params.put("songid", songId);
		params.put("pt", "e");
		
		String response = mHttpClient.get("https://play.google.com/music/play", params);

		if (response!=null) {
			JSONObject jsonObject = new JSONObject(response);
			return new URI(jsonObject.optString("url", null));
		}
		
		return null;
	}

	/***************************************************************************************
	 * @deprecated The use of this method is highly discouraged as it sends/fetches large 
	 * amounts of data from Google's servers. All of this data is readily available via the 
	 * Google Play Music app's public ContentProvider. This method uses the WebClient 
	 * endpoint and is a helper method for getSongs().
	 * 
	 * @param context The context to use during the download process.
	 * @return
	 * @throws JSONException
	 ***************************************************************************************/
	public static final ArrayList<WebClientSongsSchema> getAllSongs(Context context) 
														throws JSONException {
		return getSongs(context, "");
	}

	/***************************************************************************************
	 * <p>
	 * Queries Google's servers for a list of all songs in the current Google account's 
	 * music library.
	 * </p>
	 * 
	 * @deprecated The use of this method is highly discouraged as it sends/fetches large 
	 * amounts of data from Google's servers. All of this data is readily available via the 
	 * Google Play Music app's public ContentProvider. This method uses the WebClient 
	 * endpoint.
	 * 
	 * @param context The context to use during the download process.
	 * @param continuationToken The token that will return the next set of songs (only 1000 
	 * songs are returned per request).
	 * @return
	 * @throws JSONException
	 ***************************************************************************************/
	public static final ArrayList<WebClientSongsSchema> getSongs(Context context, 
																 String continuationToken) 
																 throws JSONException {

		JSONForm form = new JSONForm();
		form.addField("json", "{\"continuationToken\":\"" + continuationToken + "\"}");
		form.close();

		String response = mHttpClient.post(context, 
										   "https://play.google.com/music/services/loadalltracks?u=0&xt=" + getXtCookieValue(), 
										   new ByteArrayEntity(form.toString().getBytes()), 
										   form.getContentType());
		
		JSONObject jsonObject = new JSONObject(response);
		WebClientPlaylistsSchema playlist = new WebClientPlaylistsSchema().fromJsonObject(jsonObject);

		ArrayList<WebClientSongsSchema> chunkedSongList = new ArrayList<WebClientSongsSchema>();
		chunkedSongList.addAll(playlist.getPlaylist());

		if(!TextUtils.isEmpty(playlist.getContinuationToken())) {
			chunkedSongList.addAll(getSongs(context, playlist.getContinuationToken()));
		}

		return chunkedSongList;
	}
	
	/****************************************************************************
	 * Creates a new, user generated playlist. This method only creates the 
	 * playlist; it does not add songs to the playlist.
	 * 
	 * @param context The context to use while creating the new playlist.
	 * @param playlistName The name of the new playlist.
	 * @return Returns the playlistId of the newly created playlist.
	 * @throws JSONException
	 * @throws IllegalArgumentException
	 ****************************************************************************/
	public final static String createPlaylist(Context context, String playlistName) 
							   throws JSONException, IllegalArgumentException {
		
		JSONObject jsonParam = new JSONObject();
		JSONArray mutationsArray = new JSONArray();
		JSONObject createObject = new JSONObject();

		createObject.put("lastModifiedTimestamp", "0");
		createObject.put("name", playlistName);
		createObject.put("creationTimestamp", "-1");
		createObject.put("type", "USER_GENERATED");
		createObject.put("deleted", false);
		
		mutationsArray.put(new JSONObject().put("create", createObject));
		jsonParam.put("mutations", mutationsArray);

		mHttpClient.setUserAgent(mMobileClientUserAgent);
		String result = mHttpClient.post(context, 
										 "https://www.googleapis.com/sj/v1.1/playlistbatch?alt=json&hl=en_US", 
										 new ByteArrayEntity(jsonParam.toString().getBytes()), 
										 "application/json");
		
		mHttpClient.setUserAgent(mWebClientUserAgent);
		return new JSONObject(result).optJSONArray("mutate_response")
									 .getJSONObject(0).optString("id");
	}

	/*****************************************************************************
	 * Creates a JSONObject object that contains the delete command for the 
	 * specified playlist and adds it to the JSONArray that will pass the the 
	 * command on to Google's servers. 
	 * 
	 * @param context The context to use while deleting the playlist.
	 * @param playlistId The playlistId of the playlist to delete.
	 * @throws JSONException
	 * @throws IllegalArgumentException
	 *****************************************************************************/
	public static final String deletePlaylist(Context context, String playlistId) 
							   throws JSONException, IllegalArgumentException {
		
		JSONObject jsonParam = new JSONObject();
		JSONArray mutationsArray = new JSONArray();
		
		mutationsArray.put(new JSONObject().put("delete", playlistId));
		jsonParam.put("mutations", mutationsArray);

		mHttpClient.setUserAgent(mMobileClientUserAgent);
		String result = mHttpClient.post(context, 
										 "https://www.googleapis.com/sj/v1.1/playlistbatch?alt=json&hl=en_US", 
										 new ByteArrayEntity(jsonParam.toString().getBytes()), 
										 "application/json");
		
		mHttpClient.setUserAgent(mWebClientUserAgent);
		return result;
	}
	
	/*****************************************************************************
	 * Creates a JSONObject object that contains the delete command for the 
	 * specified playlist entry.The object will be added to the JSONArray that 
	 * will be passed on to Google's servers. 
	 * 
	 * @param playlistId The playlistId of the playlist to delete.
	 * @throws JSONException
	 * @throws IllegalArgumentException
	 *****************************************************************************/
	public static final void putDeletePlaylistEntryRequest(String playlistEntryId) 
							 throws JSONException, IllegalArgumentException {
		
		JSONObject deleteObject = new JSONObject();
		deleteObject.put("delete", playlistEntryId);
		mPlaylistEntriesMutationsArray.put(deleteObject);
	}
	
	/*****************************************************************************
	 * Adds the specified JSONObject to mPlaylistEntriesMutationsArray. The added 
	 * JSONObject will be placed under the "create" key. The JSONObject should 
	 * contain valid info about the new playlist entry (song) that will be created.
	 * 
	 * @param createObject The JSONObject that contains the new playlist entry's 
	 * info and will be placed under the "create" key. 
	 *****************************************************************************/
	public static final void putCreatePlaylistEntryRequest(JSONObject createObject)
							 throws JSONException {
		mPlaylistEntriesMutationsArray.put(new JSONObject().put("create", createObject));
	}
	
	/*****************************************************************************
	 * Adds the specified JSONObject to mPlaylistEntriesMutationsArray. The added 
	 * JSONObject will be placed under the "update" key. The JSONObject should 
	 * contain valid info about the playlist entry that is being updated.
	 * 
	 * @param updateObject The JSONObject that contains the updated playlist entry's 
	 * info and will be placed under the "update" key. 
	 *****************************************************************************/
	public static final void putUpdatePlaylistEntryRequest(JSONObject updateObject)
							 throws JSONException {
		mPlaylistEntriesMutationsArray.put(new JSONObject().put("update", updateObject));
	}
	
	/******************************************************************************************
	 * Executes a single/batch modification operation on a playlist's entry(ies). This method 
	 * is a general purpose method that simply hits the MobileClient endpoints using
	 * mPlaylistEntriesMutationsArray. Supported mutation operations include "create", 
	 * "delete", and "update". 
	 * 
	 * @param context The context to use while carrying out the modification operation.
	 * @param mutationsArray The JSONArray that contains the mutations command to be 
	 * carried out.
	 * @return The JSON response as a String.
	 * @throws JSONException
	 * @throws IllegalArgumentException
	 ******************************************************************************************/
	public static final String modifyPlaylist(Context context) 
							   throws JSONException, IllegalArgumentException {
		
		JSONObject jsonParam = new JSONObject();
		jsonParam.put("mutations", mPlaylistEntriesMutationsArray);
		
		mHttpClient.setUserAgent(mMobileClientUserAgent);
		String result = mHttpClient.post(context, 
										 "https://www.googleapis.com/sj/v1.1/plentriesbatch?alt=json&hl=en_US", 
										 new ByteArrayEntity(jsonParam.toString().getBytes()), 
										 "application/json");
		
		mHttpClient.setUserAgent(mWebClientUserAgent);
		
		//Clear out and reset the mutationsArray now that we're done using it.
		mPlaylistEntriesMutationsArray = null;
		mPlaylistEntriesMutationsArray = new JSONArray();
		
		return result;
	}    
	
	/*******************************************************************************************
	 * Returns the number of elements in mPlaylistEntriesMutationsArray. Used to check if a 
	 * POST request should be sent to Google's servers.
	 *******************************************************************************************/
	public static int getQueuedMutationsCount() {
		return mPlaylistEntriesMutationsArray.length();
	}
	
	/*******************************************************************************************
	 * Sends a POST request to Google's servers and retrieves a JSONArray with all user 
	 * playlists. The JSONArray contains the fields of the playlist such as "id", "name", 
	 * "type", etc. (for a list of all response fields, see MobileClientPlaylistsSchema.java).
	 * 
	 * @return A JSONArray object that contains all user playlists and their fields.
	 * @param context The context to use while retrieving user playlists.
	 *******************************************************************************************/
	public static final JSONArray getUserPlaylistsMobileClient(Context context)
								  throws JSONException, IllegalArgumentException {
		
		JSONObject jsonRequestParams = new JSONObject();
		JSONArray playlistsJSONArray = new JSONArray();
		
		jsonRequestParams.put("max-results", 250);
		jsonRequestParams.put("start-token", "0");
		
		mHttpClient.setUserAgent(mMobileClientUserAgent);
		String result = mHttpClient.post(context, 
				 						 "https://www.googleapis.com/sj/v1.1/playlistfeed?alt=json&hl=en_US&tier=basic", 
				 						 new ByteArrayEntity(jsonRequestParams.toString().getBytes()), 
				 						 "application/json");
		
		JSONObject resultJSONObject = new JSONObject(result);
		JSONObject dataJSONObject = new JSONObject();
		
		if (resultJSONObject!=null) {
			dataJSONObject = resultJSONObject.optJSONObject("data");
		}
		
		if (dataJSONObject!=null) {
			playlistsJSONArray = dataJSONObject.getJSONArray("items");
		}
		
		return playlistsJSONArray;
	}
	
	/******************************************************************************************
	 * Retrieves a JSONAray with all songs in <i><b>every</b></i> playlist. The JSONArray 
	 * contains the fields of the songs such as "id", "clientId", "trackId", etc. (for a list 
	 * of all fields, see MobileClientPlaylistEntriesSchema.java). 
	 * 
	 * @deprecated This method is fully functional. However, there are issues with retrieving 
	 * the correct playlist entryIds. Specifically, the entryIds do not seem to work with 
	 * reordering playlists via the MobileClient mutations protocol. 
	 * 
	 * @return A JSONArray object that contains all songs and their fields within every playlist. 
	 * @param context The context to use while retrieving songs from the playlist.
	 ******************************************************************************************/
	public static final JSONArray getPlaylistEntriesMobileClient(Context context) 
								  throws JSONException, IllegalArgumentException {
		
		JSONArray playlistEntriesJSONArray = new JSONArray();
		JSONObject jsonRequestParams = new JSONObject();
		
		jsonRequestParams.put("max-results", 10000);
		jsonRequestParams.put("start-token", "0");
		
		mHttpClient.setUserAgent(mMobileClientUserAgent);
		String result = mHttpClient.post(context, 
				 						 "https://www.googleapis.com/sj/v1.1/plentryfeed?alt=json&hl=en_US&tier=basic", 
				 						 new ByteArrayEntity(jsonRequestParams.toString().getBytes()), 
				 						 "application/json");
		
		JSONObject resultJSONObject = new JSONObject(result);
		JSONObject dataJSONObject = new JSONObject();
		
		if (resultJSONObject!=null) {
			dataJSONObject = resultJSONObject.optJSONObject("data");
		}
		
		if (dataJSONObject!=null) {
			playlistEntriesJSONArray = dataJSONObject.getJSONArray("items");
		}
		
		return playlistEntriesJSONArray;
	}
	
	/**************************************************************************************************
	 * Retrieves a JSONAray with all songs within the <b><i>specified</b></i> playlist. The JSONArray 
	 * contains the fields of the songs such as "id", "clientId", "trackId", etc. (for a list 
	 * of all fields, see WebClientSongsSchema.java). Uses the WebClient endpoint.
	 * 
	 * @return A JSONArray object that contains the songs and their fields within the specified playlist.
	 * @param context The context to use while retrieving songs from the playlist.
	 * @param playlistId The id of the playlist we need to fetch the songs from.
	 **************************************************************************************************/
	public static final JSONArray getPlaylistEntriesWebClient(Context context, String playlistId) 
							      throws JSONException, IllegalArgumentException {
		
		JSONObject jsonParam = new JSONObject();
		jsonParam.putOpt("id", playlistId);

		JSONForm form = new JSONForm();
		form.addField("json", jsonParam.toString());
		form.close();
		
		mHttpClient.setUserAgent(mMobileClientUserAgent);
		String result = mHttpClient.post(context, 
										 "https://play.google.com/music/services/loadplaylist?u=0&xt=" + getXtCookieValue(), 
				 						 new ByteArrayEntity(form.toString().getBytes()), 
				 						 form.getContentType());
		
		JSONArray jsonArray = new JSONArray();
		JSONObject jsonObject = new JSONObject(result);
		
		if (jsonObject!=null) {
			jsonArray = jsonObject.getJSONArray("playlist");
		}
		
		return jsonArray;
	}
	
	/**************************************************************************************
	 * Reorders the specified song (within the specified playlist) to a new position.
	 * 
	 * @param context The context to use during the reordering process.
	 * @param playlistId The id of the playlist which contains the song to be reordered.
	 * @param movedSongId The id of the song that is being reordered.
	 * @param movedEntryId The entryId of the song that is being reordered.
	 * @param afterEntryId The entryId of the song that is before the new position.
	 * @param beforeEntryId The entryId of the song that is after the new position.
	 * @return Returns the JSON response of the reorder task.
	 * @throws JSONException
	 **************************************************************************************/
	public static final String reorderPlaylistEntryWebClient(Context context,
														String playlistId, 
														ArrayList<String> movedSongId, 
														ArrayList<String> movedEntryId,
														String afterEntryId, 
														String beforeEntryId) throws JSONException {
		
		JSONObject jsonParam = new JSONObject();
		jsonParam.put("playlistId", playlistId);
		jsonParam.put("movedSongIds", movedSongId);
		jsonParam.put("movedEntryIds", movedEntryId);
		jsonParam.put("afterEntryId", afterEntryId);
		jsonParam.put("beforeEntryId", beforeEntryId);
		
		String jsonParamString = jsonParam.toString();
		jsonParamString = jsonParamString.replace("\"[", "[\"");
		jsonParamString = jsonParamString.replace("]\"", "\"]");
		
		JSONForm form = new JSONForm();
		form.addField("json", jsonParamString);
		form.close();
		
		String result = mHttpClient.post(context, 
										 "https://play.google.com/music/services/changeplaylistorder?u=0&xt=" + getXtCookieValue(), 
										 new ByteArrayEntity(form.toString().getBytes()), 
										 form.getContentType());
		
		return result;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GMusicHelpers;

import org.apache.http.HttpEntity;

import android.content.Context;

import com.loopj.android.http.SyncHttpClient;

public class GMusicHttpClient extends SyncHttpClient
{

	public GMusicHttpClient()
	{
		super();
	}

	public String post(Context context, String url, HttpEntity entity, String contentType)
	{
		post(context, url, entity, contentType, responseHandler);
		return result;
	}

	@Override
	public String onRequestFailed(Throwable error, String content)
	{
		return null;
	}
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GMusicHelpers;

import java.util.ArrayList;

import org.json.JSONArray;

public interface IJsonArray<T> {
	ArrayList<T> fromJsonArray(JSONArray jsonArray);
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GMusicHelpers;

import org.json.JSONObject;

public interface IJsonObject<T> {
	T fromJsonObject(JSONObject jsonObject);
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GMusicHelpers;

import java.io.IOException;
import java.util.Map;

public class JSONForm {
	
	private StringBuilder mForm = new StringBuilder();
	private static final String TWO_HYPHENS = "--";
	private static final String CRLF = "\r\n";
	private final String mBoundary = "**** " + System.currentTimeMillis() + " ****";
	private final String mContentType = "multipart/form-data; boundary=" + mBoundary;
	private boolean isClosed;

	//This method will return itself (supports chaining with continuation tokens).
	public final JSONForm addFields(Map<String, String> fields) throws IOException {
		for(String key : fields.keySet()) {
			addField(key, fields.get(key));
		}

		return this;
	}

	//This method will return itself (supports chaining with continuation tokens).
	public final JSONForm addField(String key, String value) {
		if(!isClosed) {
			mForm.append(CRLF + TWO_HYPHENS + mBoundary + CRLF);
			mForm.append("Content-Disposition: form-data; name=\"");
			mForm.append(key);
			mForm.append("\"" + CRLF + CRLF);
			mForm.append(value);
		} else {
			throw new IllegalArgumentException("New fields cannot be added to the form after close() has been called.");
		}
			
		return this;
	}

	//This method will return itself (supports chaining with continuation tokens).
	public final JSONForm close() {
		if(!isClosed) {
			mForm.append(CRLF + TWO_HYPHENS + mBoundary + TWO_HYPHENS + CRLF);
			isClosed = true;
		}
		return this;
	}

	public final String getContentType() {
		return mContentType;
	}

	@Override
	public String toString() {
		return mForm.toString();
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GMusicHelpers;

import java.util.ArrayList;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

public class MobileClientPlaylistEntriesSchema implements IJsonObject<MobileClientPlaylistEntriesSchema>, IJsonArray<WebClientSongsSchema> {
	
	private String mKind;
	private String mId;
	private String mClientId;
	private String mPlaylistId;
	private String mTrackId;
	private String mCreationTimestamp;
	private String mLastModifiedTimestamp;
	private boolean mDeleted;
	private String mSource;

	public String getKind() {
		return mKind;
	}

	public void setKind(String kind) {
		this.mKind = kind;
	}
	
	public String getId() {
		return mId;
	}
	
	public void setId(String id) {
		this.mId = id;
	}

	public String getClientId() {
		return mClientId;
	}
	
	public void setClientId(String clientId) {
		this.mClientId = clientId;
	}
	
	public String getPlaylistId() {
		return mPlaylistId;
	}

	public void setPlaylistId(String playlistId) {
		this.mPlaylistId = playlistId;
	}
	
	public String getTrackId() {
		return mTrackId;
	}
	
	public void setTrackId(String trackId) {
		this.mTrackId = trackId;
	}

	public String getCreationTimestamp() {
		return mCreationTimestamp;
	}

	public void setCreationTimestamp(String creationTimestamp) {
		this.mCreationTimestamp = creationTimestamp;
	}

	public String getLastModifiedTimestamp() {
		return mLastModifiedTimestamp;
	}

	public void setLastModifiedTimestamp(String lastModifiedTimestamp) {
		this.mLastModifiedTimestamp = lastModifiedTimestamp;
	}

	public boolean isDeleted() {
		return mDeleted;
	}

	public void setDeleted(boolean deleted) {
		this.mDeleted = deleted;
	}
	
	public String getSource() {
		return mSource;
	}
	
	public void setSource(String source) {
		this.mSource = source;
	}

	@Override
	public MobileClientPlaylistEntriesSchema fromJsonObject(JSONObject jsonObject) {
		if(jsonObject != null) {
			mKind = jsonObject.optString("kind", null);
			mPlaylistId = jsonObject.optString("playlistId", null);
			mCreationTimestamp = jsonObject.optString("creationTimestamp");
			mLastModifiedTimestamp = jsonObject.optString("lastModifiedTimestamp", null);
			mDeleted = jsonObject.optBoolean("deleted");
			mClientId = jsonObject.optString("clientId");
			mTrackId = jsonObject.optString("trackId");
			mId = jsonObject.optString("id");
			mSource = jsonObject.optString("source");
		}

		//This method returns itself to support chaining.
		return this;
	}

	@Override
	public ArrayList<WebClientSongsSchema> fromJsonArray(JSONArray jsonArray) {
		
		ArrayList<WebClientSongsSchema> songList = new ArrayList<WebClientSongsSchema>();
		if(jsonArray != null && jsonArray.length() > 0) {
			for(int i = 0; i < jsonArray.length(); i++) {
				try {
					WebClientSongsSchema song = new WebClientSongsSchema().fromJsonObject(jsonArray.getJSONObject(i));
					songList.add(song);
					
				} catch(JSONException e) {
					e.printStackTrace();
				}
				
			}
			
		}
		return songList;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GMusicHelpers;

import java.util.ArrayList;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

public class MobileClientPlaylistsSchema implements IJsonObject<MobileClientPlaylistsSchema>, IJsonArray<WebClientSongsSchema> {
	
	private String mKind;
	private String mPlaylistId;
	private String mCreationTimestamp;
	private String mLastModifiedTimestamp;
	private String mRecentTimestamp;
	private boolean mDeleted;
	private String mName;
	private String mType;
	private String mShareToken;
	private String mOwnerName;
	private String mOwnerProfilePhotoUrl;
	private boolean mAccessControlled;
	private ArrayList<WebClientSongsSchema> mPlaylist;

	public String getKind() {
		return mKind;
	}

	public void setKind(String kind) {
		this.mKind = kind;
	}

	public String getPlaylistId() {
		return mPlaylistId;
	}

	public void setPlaylistId(String playlistId) {
		this.mPlaylistId = playlistId;
	}

	public String getCreationTimestamp() {
		return mCreationTimestamp;
	}

	public void setCreationTimestamp(String creationTimestamp) {
		this.mCreationTimestamp = creationTimestamp;
	}

	public String getLastModifiedTimestamp() {
		return mLastModifiedTimestamp;
	}

	public void setLastModifiedTimestamp(String lastModifiedTimestamp) {
		this.mLastModifiedTimestamp = lastModifiedTimestamp;
	}

	public String getRecentTimestamp() {
		return mRecentTimestamp;
	}

	public void setRecentTimestamp(String recentTimestamp) {
		this.mRecentTimestamp = recentTimestamp;
	}

	public boolean isDeleted() {
		return mDeleted;
	}

	public void setDeleted(boolean deleted) {
		this.mDeleted = deleted;
	}

	public String getName() {
		return mName;
	}

	public void setName(String name) {
		this.mName = name;
	}

	public String getType() {
		return mType;
	}

	public void setType(String type) {
		this.mType = type;
	}

	public String getShareToken() {
		return mShareToken;
	}

	public void setShareToken(String shareToken) {
		this.mShareToken = shareToken;
	}

	public String getOwnerName() {
		return mOwnerName;
	}

	public void setOwnerName(String ownerName) {
		this.mOwnerName = ownerName;
	}

	public String getOwnerProfilePhotoUrl() {
		return mOwnerProfilePhotoUrl;
	}

	public void setOwnerProfilePhotoUrl(String ownerProfilePhotoUrl) {
		this.mOwnerProfilePhotoUrl = ownerProfilePhotoUrl;
	}

	public boolean ismAccessControlled() {
		return mAccessControlled;
	}

	public void setAccessControlled(boolean accessControlled) {
		this.mAccessControlled = accessControlled;
	}

	public ArrayList<WebClientSongsSchema> getPlaylist() {
		return mPlaylist;
	}

	public void setPlaylist(ArrayList<WebClientSongsSchema> playlist) {
		this.mPlaylist = playlist;
	}

	@Override
	public MobileClientPlaylistsSchema fromJsonObject(JSONObject jsonObject) {
		if(jsonObject != null) {
			mKind = jsonObject.optString("kind", null);
			mPlaylistId = jsonObject.optString("id", null);
			mCreationTimestamp = jsonObject.optString("creationTimestamp");
			mLastModifiedTimestamp = jsonObject.optString("lastModifiedTimestamp", null);
			mRecentTimestamp = jsonObject.optString("recentTimestamp");
			mDeleted = jsonObject.optBoolean("deleted");
			mName = jsonObject.optString("name");
			mType = jsonObject.optString("type");
			mShareToken = jsonObject.optString("shareToken");
			mOwnerName = jsonObject.optString("ownerName");
			mOwnerProfilePhotoUrl = jsonObject.optString("ownerProfilePhotoUrl");
			mAccessControlled = jsonObject.optBoolean("accessControlled");
		}

		//This method returns itself to support chaining.
		return this;
	}

	@Override
	public ArrayList<WebClientSongsSchema> fromJsonArray(JSONArray jsonArray) {
		
		ArrayList<WebClientSongsSchema> songList = new ArrayList<WebClientSongsSchema>();
		if(jsonArray != null && jsonArray.length() > 0) {
			for(int i = 0; i < jsonArray.length(); i++) {
				try {
					WebClientSongsSchema song = new WebClientSongsSchema().fromJsonObject(jsonArray.getJSONObject(i));
					songList.add(song);
					
				} catch(JSONException e) {
					e.printStackTrace();
				}
				
			}
			
		}
		return songList;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GMusicHelpers;

import java.util.ArrayList;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

//not used in the Android app
public class QueryResults implements IJsonObject<QueryResults>, IJsonArray<WebClientSongsSchema>
{

	private ArrayList<WebClientSongsSchema> mArtists;
	private ArrayList<WebClientSongsSchema> mAlbums;
	private ArrayList<WebClientSongsSchema> mWebClientSongsSchemas;

	public ArrayList<WebClientSongsSchema> getArtists()
	{
		return mArtists;
	}

	public void setArtists(ArrayList<WebClientSongsSchema> artists)
	{
		mArtists = artists;
	}

	public ArrayList<WebClientSongsSchema> getAlbums()
	{
		return mAlbums;
	}

	public void setAlbums(ArrayList<WebClientSongsSchema> albums)
	{
		mAlbums = albums;
	}

	public ArrayList<WebClientSongsSchema> getWebClientSongsSchemas()
	{
		return mWebClientSongsSchemas;
	}

	public void setWebClientSongsSchemas(ArrayList<WebClientSongsSchema> songs)
	{
		mWebClientSongsSchemas = songs;
	}

	@Override
	public QueryResults fromJsonObject(JSONObject jsonObject)
	{
		if(jsonObject != null)
		{
			JSONArray jsonArray = jsonObject.optJSONArray("artists");
			mArtists = (ArrayList<WebClientSongsSchema>) fromJsonArray(jsonArray);

			jsonArray = jsonObject.optJSONArray("albums");
			mAlbums = (ArrayList<WebClientSongsSchema>) fromJsonArray(jsonArray);

			jsonArray = jsonObject.optJSONArray("songs");
			mWebClientSongsSchemas = (ArrayList<WebClientSongsSchema>) fromJsonArray(jsonArray);
		}

		// return this object to allow chaining
		return this;
	}

	@Override
	public ArrayList<WebClientSongsSchema> fromJsonArray(JSONArray jsonArray)
	{
		ArrayList<WebClientSongsSchema> songList = new ArrayList<WebClientSongsSchema>();
		if(jsonArray != null && jsonArray.length() > 0)
		{
			for(int i = 0; i < jsonArray.length(); i++)
			{
				try
				{
					WebClientSongsSchema song = new WebClientSongsSchema().fromJsonObject(jsonArray.getJSONObject(i));
					songList.add(song);
				}
				catch(JSONException e)
				{
					e.printStackTrace();
				}
			}
		}

		return songList;
	}
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GMusicHelpers;

import java.util.ArrayList;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

public class WebClientPlaylistsSchema implements IJsonObject<WebClientPlaylistsSchema>, IJsonArray<WebClientSongsSchema> {

	private String mTitle;
	private String mPlaylistId;
	private long mRequestTime;
	private String mContinuationToken;
	private boolean mDifferentialUpdate;
	private ArrayList<WebClientSongsSchema> mPlaylist;
	private boolean mContinuation;

	public String getTitle() {
		return mTitle;
	}

	public void setTitle(String title) {
		mTitle = title;
	}

	public String getPlaylistId() {
		return mPlaylistId;
	}

	public void setPlaylistId(String playlistId) {
		mPlaylistId = playlistId;
	}

	public long getRequestTime() {
		return mRequestTime;
	}

	public void setRequestTime(long requestTime) {
		mRequestTime = requestTime;
	}

	public String getContinuationToken() {
		return mContinuationToken;
	}

	public void setContinuationToken(String continuationToken) {
		mContinuationToken = continuationToken;
	}

	public boolean isDifferentialUpdate() {
		return mDifferentialUpdate;
	}

	public void setDifferentialUpdate(boolean differentialUpdate) {
		mDifferentialUpdate = differentialUpdate;
	}

	public ArrayList<WebClientSongsSchema> getPlaylist() {
		return mPlaylist;
	}

	public void setPlaylist(ArrayList<WebClientSongsSchema> playlist) {
		mPlaylist = playlist;
	}

	public boolean isContinuation() {
		return mContinuation;
	}

	public void setContinuation(boolean continuation) {
		mContinuation = continuation;
	}

	@Override
	public WebClientPlaylistsSchema fromJsonObject(JSONObject jsonObject) {
		if(jsonObject != null) {
			mTitle = jsonObject.optString("title", null);
			mPlaylistId = jsonObject.optString("playlistId", null);
			mRequestTime = jsonObject.optLong("requestTime");
			mContinuationToken = jsonObject.optString("continuationToken", null);
			mDifferentialUpdate = jsonObject.optBoolean("differentialUpdate");
			mContinuation = jsonObject.optBoolean("continuation");

			JSONArray songsArray = jsonObject.optJSONArray("playlist");
			mPlaylist = fromJsonArray(songsArray);
		}

		//This method returns itself to support chaining.
		return this;
	}

	@Override
	public ArrayList<WebClientSongsSchema> fromJsonArray(JSONArray jsonArray) {
		
		ArrayList<WebClientSongsSchema> songList = new ArrayList<WebClientSongsSchema>();
		if(jsonArray != null && jsonArray.length() > 0) {
			for(int i = 0; i < jsonArray.length(); i++) {
				try {
					WebClientSongsSchema song = new WebClientSongsSchema().fromJsonObject(jsonArray.getJSONObject(i));
					songList.add(song);
					
				} catch(JSONException e) {
					e.printStackTrace();
				}
				
			}
			
		}
		return songList;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GMusicHelpers;

import org.json.JSONObject;

public class WebClientSongsSchema implements IJsonObject<WebClientSongsSchema> {
	private int mTotalTracks;
	private boolean mSubjectToCuration;
	private String mName;
	private int mTotalDiscs;
	private String mTitleNorm;
	private String mAlbumNorm;
	private int mTrack;
	private String mAlbumArtUrl;
	private String mUrl;
	private long mCreationDate;
	private String mAlbumArtistNorm;
	private String mArtistNorm;
	private long mLastPlayed;
	private String mMatchedId;
	private int mType;
	private int mDisc;
	private String mGenre;
	private int mBeatsPerMinute;
	private String mAlbum;
	private String mId;
	private String mComposer;
	private String mTitle;
	private String mAlbumArtist;
	private int mYear;
	private String mArtist;
	private long mDurationMillis;
	private boolean mIsDeleted;
	private int mPlayCount;
	private String mRating;
	private String mComment;
	private String mPlaylistEntryId;

	public String getAlbum() {
		return mAlbum;
	}

	public String getAlbumArtist() {
		return mAlbumArtist;
	}

	public String getAlbumArtistNorm() {
		return mAlbumArtistNorm;
	}

	public String getAlbumArtUrl() {
		return mAlbumArtUrl;
	}

	public String getAlbumNorm() {
		return mAlbumNorm;
	}

	public String getArtist() {
		return mArtist;
	}

	public String getArtistNorm() {
		return mArtistNorm;
	}

	public int getBeatsPerMinute() {
		return mBeatsPerMinute;
	}

	public String getComment() {
		return mComment;
	}

	public String getComposer() {
		return mComposer;
	}

	public float getCreationDate() {
		return mCreationDate;
	}

	public int getDisc() {
		return mDisc;
	}

	public long getDurationMillis() {
		return mDurationMillis;
	}

	public String getGenre() {
		return mGenre;
	}

	public String getId() {
		return mId;
	}

	public double getLastPlayed() {
		return mLastPlayed;
	}

	public String getMatchedId() {
		return mMatchedId;
	}

	public String getName() {
		return mName;
	}

	public int getPlayCount() {
		return mPlayCount;
	}

	public String getRating() {
		return mRating;
	}

	public String getTitle() {
		return mTitle;
	}

	public String getTitleNorm() {
		return mTitleNorm;
	}

	public int getTotalDiscs() {
		return mTotalDiscs;
	}

	public int getTotalTracks() {
		return mTotalTracks;
	}

	public int getTrack() {
		return mTrack;
	}

	public int getType() {
		return mType;
	}

	public String getUrl() {
		return mUrl;
	}

	public int getYear() {
		return mYear;
	}
	
	public String getPlaylistEntryId() {
		return mPlaylistEntryId;
	}

	public boolean isDeleted() {
		return mIsDeleted;
	}

	public boolean isSubjectToCuration() {
		return mSubjectToCuration;
	}

	public void setAlbum(String album) {
		mAlbum = album;
	}

	public void setAlbumArtist(String albumArtist) {
		mAlbumArtist = albumArtist;
	}

	public void setAlbumArtistNorm(String albumArtistNorm) {
		mAlbumArtistNorm = albumArtistNorm;
	}

	public void setAlbumArtUrl(String albumArtUrl) {
		mAlbumArtUrl = albumArtUrl;
	}

	public void setAlbumNorm(String albumNorm) {
		mAlbumNorm = albumNorm;
	}

	public void setArtist(String artist) {
		mArtist = artist;
	}

	public void setArtistNorm(String artistNorm) {
		mArtistNorm = artistNorm;
	}

	public void setBeatsPerMinute(int beatsPerMinute) {
		mBeatsPerMinute = beatsPerMinute;
	}

	public void setComment(String comment) {
		mComment = comment;
	}

	public void setComposer(String composer) {
		mComposer = composer;
	}

	public void setCreationDate(long creationDate) {
		mCreationDate = creationDate;
	}

	public void setDeleted(boolean isDeleted) {
		mIsDeleted = isDeleted;
	}

	public void setDisc(int disc) {
		mDisc = disc;
	}

	public void setDurationMillis(long durationMillis) {
		mDurationMillis = durationMillis;
	}

	public void setGenre(String genre) {
		mGenre = genre;
	}

	public void setId(String id) {
		mId = id;
	}

	public void setLastPlayed(long lastPlayed) {
		mLastPlayed = lastPlayed;
	}

	public void setMatchedId(String matchedId) {
		mMatchedId = matchedId;
	}

	public void setName(String name) {
		mName = name;
	}

	public void setPlaycount(int playcount) {
		mPlayCount = playcount;
	}

	public void setRating(String rating) {
		mRating = rating;
	}

	public void setSubjectToCuration(boolean subjectToCuration) {
		mSubjectToCuration = subjectToCuration;
	}

	public void setTitle(String title) {
		mTitle = title;
	}

	public void setTitleNorm(String titleNorm) {
		mTitleNorm = titleNorm;
	}

	public void setTotalDiscs(int totalDiscs) {
		mTotalDiscs = totalDiscs;
	}

	public void setTotalTracks(int totalTracks) {
		mTotalTracks = totalTracks;
	}

	public void setTrack(int track) {
		mTrack = track;
	}

	public void setType(int type) {
		mType = type;
	}

	public void setUrl(String url) {
		mUrl = url;
	}

	public void setYear(int year) {
		mYear = year;
	}
	
	public void setEntryId(String playlistEntryId) {
		mPlaylistEntryId = playlistEntryId;
	}

	@Override
	public WebClientSongsSchema fromJsonObject(JSONObject jsonObject) {
		
		if(jsonObject != null) {
			mTotalTracks = jsonObject.optInt("totalTracks");
			mSubjectToCuration = jsonObject.optBoolean("subjectToCuration");
			mName = jsonObject.optString("name", null);
			mTotalDiscs = jsonObject.optInt("totalDiscs");
			mTitleNorm = jsonObject.optString("titleNorm", null);
			mAlbumNorm = jsonObject.optString("albumNorm", null);
			mTrack = jsonObject.optInt("track");
			mAlbumArtUrl = jsonObject.optString("albumArtUrl", null);
			mUrl = jsonObject.optString("url", null);
			mCreationDate = jsonObject.optLong("creationDate");
			mAlbumArtistNorm = jsonObject.optString("albumArtistNorm", null);
			mArtistNorm = jsonObject.optString("artistNorm", null);
			mLastPlayed = jsonObject.optLong("lastPlayed");
			mMatchedId = jsonObject.optString("matchedId", null);
			mType = jsonObject.optInt("type");
			mDisc = jsonObject.optInt("disc");
			mGenre = jsonObject.optString("genre", null);
			mBeatsPerMinute = jsonObject.optInt("beatsPerMinute");
			mAlbum = jsonObject.optString("album", null);
			mId = jsonObject.optString("id", null);
			mComposer = jsonObject.optString("composer", null);
			mTitle = jsonObject.optString("title", null);
			mAlbumArtist = jsonObject.optString("albumArtist", null);
			mYear = jsonObject.optInt("year");
			mArtist = jsonObject.optString("artist", null);
			mDurationMillis = jsonObject.optLong("durationMillis");
			mIsDeleted = jsonObject.optBoolean("deleted");
			mPlayCount = jsonObject.optInt("playCount");
			mRating = jsonObject.optString("rating", null);
			mComment = jsonObject.optString("comment", null);
			mPlaylistEntryId = jsonObject.optString("playlistEntryId");
		}

		//This method returns itself to support chaining.
		return this;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GridViewFragment;

import android.content.Context;
import android.content.res.Resources;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.Paint;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.widget.SimpleCursorAdapter;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.PopupMenu;
import android.widget.PopupMenu.OnMenuItemClickListener;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.andraskindler.quickscroll.Scrollable;
import com.jams.music.player.AsyncTasks.AsyncAddToQueueTask;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Dialogs.AddToPlaylistDialog;
import com.jams.music.player.Dialogs.CautionEditArtistsDialog;
import com.jams.music.player.Dialogs.ID3sArtistEditorDialog;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;
import com.squareup.picasso.Picasso;
import com.squareup.picasso.Target;

import java.util.HashMap;

/**
 * Generic GridView adapter for GridViewFragment.
 * 
 * @author Saravan Pantham
 */
public class GridViewCardsAdapter extends SimpleCursorAdapter implements Scrollable {
	
	private Context mContext;
	private Common mApp;
	private GridViewFragment mGridViewFragment;
    public static GridViewHolder mHolder = null;
    private String mName = "";
    private int mWidth;
    private int mHeight;
    
    //HashMap for DB column names.
    private HashMap<Integer, String> mDBColumnsMap;
    public static final int TITLE_TEXT = 0;
    public static final int SOURCE = 1;
    public static final int FILE_PATH = 2;
    public static final int ARTWORK_PATH = 3;
    public static final int FIELD_1 = 4; //Empty fields for other parameters.
    public static final int FIELD_2 = 5;
    public static final int FIELD_3 = 6;
    public static final int FIELD_4 = 7;
    public static final int FIELD_5 = 8;
    
    public GridViewCardsAdapter(Context context, GridViewFragment gridViewFragment,
                                HashMap<Integer, String> dbColumnsMap) {
    	
        super(context, -1, gridViewFragment.getCursor(), new String[] {}, new int[] {}, 0);
        mContext = context;
        mGridViewFragment = gridViewFragment;
        mApp = (Common) mContext.getApplicationContext();
        mDBColumnsMap = dbColumnsMap;

        //Calculate the height and width of each item image.
        DisplayMetrics metrics = Resources.getSystem().getDisplayMetrics();

        if (mApp.isTabletInPortrait()) {
            //3 column layout.
            mWidth = (metrics.widthPixels)/3;
            mHeight = mWidth + (mWidth/4);
        } else if (mApp.isPhoneInLandscape() || mApp.isTabletInLandscape()) {
            //4 column layout.
            mWidth = (metrics.widthPixels)/4;
            mHeight = mWidth + (mWidth/5);
        } else {
            //2 column layout.
            mWidth = (metrics.widthPixels)/2;
            mHeight = mWidth + (mWidth/3);
        }

    }
    
    /**
     * Quick scroll indicator implementation.
     */
    @Override
    public String getIndicatorForPosition(int childPosition, int groupPosition) {
    	Cursor c = (Cursor) getItem(childPosition);
    	String title = c.getString(c.getColumnIndex(mDBColumnsMap.get(TITLE_TEXT)));
    	if (title!=null && title.length() > 1)
    		return "  " + title.substring(0, 1) + "  ";
        else
    		return "  N/A  ";
    }
    
    /**
     * Returns the current position of the top view in the list/grid.
     */
	@Override
	public int getScrollPosition(int childPosition, int groupPosition) {
		// TODO Auto-generated method stub
		return childPosition;
	}

	/**
	 * Returns the individual row/child in the list/grid.
	 */
    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        Cursor c = (Cursor) getItem(position);

		if (convertView==null) {
			mHolder = new GridViewHolder();
            convertView = LayoutInflater.from(mContext).inflate(R.layout.grid_view_item, parent, false);

            mHolder.background = (RelativeLayout) convertView.findViewById(R.id.gridViewItemLayout);
            mHolder.textLayout = (RelativeLayout) convertView.findViewById(R.id.gridViewTextLayout);
			mHolder.gridViewArt = (ImageView) convertView.findViewById(R.id.gridViewImage);
			mHolder.titleText = (TextView) convertView.findViewById(R.id.gridViewTitleText);
            mHolder.subText = (TextView) convertView.findViewById(R.id.gridViewSubText);

			mHolder.overflowButton = (ImageButton) convertView.findViewById(R.id.gridViewOverflowButton);
            mHolder.overflowButton.setImageResource(UIElementsHelper.getIcon(mContext, "ic_action_overflow"));
			mHolder.overflowButton.setOnClickListener(overflowClickListener);
			mHolder.overflowButton.setFocusable(false);
			mHolder.overflowButton.setFocusableInTouchMode(false);

			mHolder.titleText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
            mHolder.subText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			
	        mHolder.gridViewArt.setScaleType(ImageView.ScaleType.CENTER_CROP);
            mHolder.gridViewArt.setImageResource(UIElementsHelper.getEmptyColorPatch(mContext));
            //mHolder.textLayout.setBackgroundColor(UIElementsHelper.getGridViewBackground(mContext));
            //mHolder.overflowButton.setBackgroundColor(UIElementsHelper.getGridViewBackground(mContext));
            mHolder.titleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
            mHolder.subText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));

            //Apply the ImageView's dimensions.
            RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mHolder.gridViewArt.getLayoutParams();
            params.width = mWidth;
            params.height = mWidth;
            mHolder.gridViewArt.setLayoutParams(params);

            //Apply the card's background.
            mHolder.background.setBackgroundResource(UIElementsHelper.getGridViewCardBackground(mContext));
			
			convertView.setTag(mHolder);
		} else {
		    mHolder = (GridViewHolder) convertView.getTag();
		}
		
		//Retrieve data from the cursor.
		String titleText = "";
		String source = "";
		String filePath = "";
		String artworkPath = "";
		String field1 = "";
		String field2 = "";
		String field3 = "";
		String field4 = "";
		String field5 = "";
		try {
			titleText = c.getString(c.getColumnIndex(mDBColumnsMap.get(TITLE_TEXT)));
			source = c.getString(c.getColumnIndex(mDBColumnsMap.get(SOURCE)));
			filePath = c.getString(c.getColumnIndex(mDBColumnsMap.get(FILE_PATH)));
			artworkPath = c.getString(c.getColumnIndex(mDBColumnsMap.get(ARTWORK_PATH)));
			field1 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_1)));
			field2 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_2)));
			field3 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_3)));
			field4 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_4)));
			field5 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_5)));
			
		} catch (NullPointerException e) {
			//e.printStackTrace();
		}
		
		//Set the tags for this grid item.
		convertView.setTag(R.string.title_text, titleText);
		convertView.setTag(R.string.song_source, source);
		convertView.setTag(R.string.song_file_path, filePath);
		convertView.setTag(R.string.album_art, artworkPath);
		convertView.setTag(R.string.field_1, field1);
		convertView.setTag(R.string.field_2, field2);
		convertView.setTag(R.string.field_3, field3);
		convertView.setTag(R.string.field_4, field4);
		convertView.setTag(R.string.field_5, field5);
		
		/*//Set the tags for this grid item's overflow button.
		mHolder.overflowButton.setTag(R.string.title_text, titleText);
		mHolder.overflowButton.setTag(R.string.source, source);
		mHolder.overflowButton.setTag(R.string.file_path, filePath);
		mHolder.overflowButton.setTag(R.string.field_1, field1);
		mHolder.overflowButton.setTag(R.string.field_2, field2);
		mHolder.overflowButton.setTag(R.string.field_3, field3);
		mHolder.overflowButton.setTag(R.string.field_4, field4);
		mHolder.overflowButton.setTag(R.string.field_5, field5);*/
		
		//Set the title text in the GridView.
		mHolder.titleText.setText(titleText);
        mHolder.subText.setText(field1);

		//Load the album art.
        mApp.getPicasso().load(artworkPath)
                         .placeholder(UIElementsHelper.getEmptyColorPatch(mContext))
                         .into(mHolder.gridViewArt);

        //Preload the next 6 album art images.
        for (int i=position; i < position+6; i++) {
            if (i >= mGridViewFragment.getCursor().getCount())
                break;

            Cursor tempCursor = (Cursor) getItem(i);
            mApp.getPicasso().load(tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH))).into(new Target() {

                @Override
                public void onBitmapLoaded(Bitmap bitmap, Picasso.LoadedFrom from) {

                }

                @Override
                public void onBitmapFailed(Drawable errorDrawable) {

                }

                @Override
                public void onPrepareLoad(Drawable placeHolderDrawable) {

                }

            });

        }

		return convertView;
	}

    /**
     * Click listener for overflow button.
     */
    private OnClickListener overflowClickListener = new OnClickListener() {

		@Override
		public void onClick(View v) {
			PopupMenu menu = new PopupMenu(mContext, v);
			menu.inflate(R.menu.artist_overflow_menu);
			menu.setOnMenuItemClickListener(popupMenuItemClickListener);
			mName = (String) v.getTag(R.string.artist);
		    menu.show();
			
		}
    	
    };
    
    /**
     * Menu item click listener for the pop up menu.
     */
    private OnMenuItemClickListener popupMenuItemClickListener = new OnMenuItemClickListener() {

		@Override
		public boolean onMenuItemClick(MenuItem item) {
			
			switch(item.getItemId()) {
        	case R.id.edit_artist_tags:
        		//Edit Artist Tags.
        		if (mApp.getSharedPreferences().getBoolean("SHOW_ARTIST_EDIT_CAUTION", true)==true) {
            		FragmentTransaction transaction = mGridViewFragment.getFragmentManager().beginTransaction();
            		Bundle bundle = new Bundle();
            		bundle.putString("EDIT_TYPE", "ARTIST");
            		bundle.putString("ARTIST", mName);
            		CautionEditArtistsDialog dialog = new CautionEditArtistsDialog();
            		dialog.setArguments(bundle);
            		dialog.show(transaction, "cautionArtistsDialog");
        		} else {
    				FragmentTransaction ft = mGridViewFragment.getFragmentManager().beginTransaction();
    				Bundle bundle = new Bundle();
    				bundle.putString("EDIT_TYPE", "ARTIST");
    				bundle.putString("ARTIST", mName);
    				ID3sArtistEditorDialog dialog = new ID3sArtistEditorDialog();
    				dialog.setArguments(bundle);
    				dialog.show(ft, "id3ArtistEditorDialog");
        		}
        		break;
        	case R.id.add_to_queue: 
        		//Add to Queue.
        		AsyncAddToQueueTask task = new AsyncAddToQueueTask(mContext,
        														   mGridViewFragment,
        														   "ARTIST",
        														   mName, 
        														   null,
        														   null, 
        														   null, 
        														   null,
        														   null,
        														   null);
        		task.execute();
        		break;
        	case R.id.play_next:
        		AsyncAddToQueueTask playNextTask = new AsyncAddToQueueTask(mContext,
																		   mGridViewFragment,
																		   "ARTIST",
																		   mName, 
																		   null,
																		   null, 
																		   null, 
																		   null,
																		   null,
																		   null);
        		playNextTask.execute(new Boolean[] { true });
        		break;
        	case R.id.add_to_playlist:
        		//Add to Playlist
        		FragmentTransaction ft = mGridViewFragment.getFragmentManager().beginTransaction();
				AddToPlaylistDialog dialog = new AddToPlaylistDialog();
				Bundle bundle = new Bundle();
				bundle.putString("ADD_TYPE", "ARTIST");
				bundle.putString("ARTIST", mName);
				dialog.setArguments(bundle);
				dialog.show(ft, "AddToPlaylistDialog");
				break;
        	case R.id.blacklist_artist:
        		//Blacklist Artist
        		mApp.getDBAccessHelper().setBlacklistForArtist(mName, true);
        		Toast.makeText(mContext, R.string.artist_blacklisted, Toast.LENGTH_SHORT).show();
        		
        		//Update the GridView.
        		mGridViewFragment.mHandler.post(mGridViewFragment.queryRunnable);
        		mGridViewFragment.getGridViewAdapter().notifyDataSetChanged();

        		break;
        	
			}
			
			return false;
		}
    	
    };

    /**
     * Holder subclass for GridViewAdapter.
     * 
     * @author Saravan Pantham
     */
	public static class GridViewHolder {
	    public ImageView gridViewArt;
	    public TextView titleText;
        public TextView subText;
	    public RelativeLayout background;
	    public RelativeLayout textLayout;
        public ImageButton overflowButton;

	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.GridViewFragment;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.BitmapFactory;
import android.graphics.Paint;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.support.v4.app.Fragment;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.TranslateAnimation;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.BaseAdapter;
import android.widget.GridView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.andraskindler.quickscroll.QuickScrollGridView;
import com.jams.music.player.BrowserSubGridActivity.BrowserSubGridActivity;
import com.jams.music.player.BrowserSubListActivity.BrowserSubListActivity;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.PauseOnScrollHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.MainActivity.MainActivity;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;
import com.nhaarman.listviewanimations.swinginadapters.prepared.SwingBottomInAnimationAdapter;

import java.util.HashMap;

/**
 * Generic, multipurpose GridView fragment.
 * 
 * @author Saravan Pantham
 */
public class GridViewFragment extends Fragment {
	
	private Context mContext;
	private GridViewFragment mFragment;
	private Common mApp;
	private View mRootView;
    private RelativeLayout mGridViewContainer;
	private int mFragmentId;
	
	private QuickScrollGridView mQuickScroll;
	private BaseAdapter mGridViewAdapter;
	private HashMap<Integer, String> mDBColumnsMap;
	private GridView mGridView;
	private TextView mEmptyTextView;
	
	public Handler mHandler = new Handler();
	private Cursor mCursor;
    private String mFragmentTitle;
	private String mQuerySelection = "";
	
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mRootView = inflater.inflate(R.layout.fragment_grid_view, container, false);
        mContext = getActivity().getApplicationContext();
	    mApp = (Common) mContext;
        mFragment = this;

        //Set the background color and the partial color bleed.
        mRootView.setBackgroundColor(UIElementsHelper.getBackgroundColor(mContext));

        //Grab the fragment. This will determine which data to load into the cursor.
        mFragmentId = getArguments().getInt(Common.FRAGMENT_ID);
        mFragmentTitle = getArguments().getString(MainActivity.FRAGMENT_HEADER);
        mDBColumnsMap = new HashMap<Integer, String>();
	    
        mQuickScroll = (QuickScrollGridView) mRootView.findViewById(R.id.quickscrollgrid);

		//Set the adapter for the outer gridview.
        mGridView = (GridView) mRootView.findViewById(R.id.generalGridView);
        mGridViewContainer = (RelativeLayout) mRootView.findViewById(R.id.fragment_grid_view_frontal_layout);
        mGridView.setVerticalScrollBarEnabled(false);

        //Set the number of gridview columns based on the screen density and orientation.
        if (mApp.isPhoneInLandscape() || mApp.isTabletInLandscape()) {
            mGridView.setNumColumns(4);
        } else if (mApp.isPhoneInPortrait()) {
            mGridView.setNumColumns(2);
        } else if (mApp.isTabletInPortrait()) {
            mGridView.setNumColumns(3);
        }

        //KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
        	int topPadding = Common.getStatusBarHeight(mContext);
            
            //Calculate navigation bar height.
            int navigationBarHeight = 0;
            int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
            if (resourceId > 0) {
                navigationBarHeight = getResources().getDimensionPixelSize(resourceId);
            }

            mGridViewContainer.setPadding(0, topPadding, 0, 0);
            mGridView.setClipToPadding(false);
            mGridView.setPadding(0, mGridView.getPaddingTop(), 0, navigationBarHeight);
            mQuickScroll.setPadding(0, 0, 0, navigationBarHeight);
            
        }

        //Set the empty views.
        mEmptyTextView = (TextView) mRootView.findViewById(R.id.empty_view_text);
	    mEmptyTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Light"));
	    mEmptyTextView.setPaintFlags(mEmptyTextView.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        //Create a set of options to optimize the bitmap memory usage.
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        options.inJustDecodeBounds = false;
        options.inPurgeable = true;
	    
        mHandler.postDelayed(queryRunnable, 250);
        return mRootView;
    }
    
    /**
     * Query runnable.
     */
    public Runnable queryRunnable = new Runnable() {

		@Override
		public void run() {
			new AsyncRunQuery().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
			
		}
    	
    };

    /**
     * Click listener for the "PLAY ALL" text.
     */
    private View.OnClickListener playAllClickListener = new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mApp.isShuffleOn())
                ((MainActivity) getActivity()).playAll(true);
            else
                ((MainActivity) getActivity()).playAll(false);

        }

    };
    
    /**
     * Item click listener for the GridView/ListView.
     */
    private OnItemClickListener onItemClickListener = new OnItemClickListener() {

		@Override
		public void onItemClick(AdapterView<?> arg0, View view, int index, long id) {

            //Determine the new activity's fragment id.
            int newFragmentId = getNewFragmentId();

            Intent intent;
            if (newFragmentId==Common.ALBUMS_FLIPPED_FRAGMENT) {
                intent = new Intent(mContext, BrowserSubListActivity.class);
            } else {
                intent = new Intent(mContext, BrowserSubGridActivity.class);
            }

            Bundle bundle = new Bundle();
            bundle.putString("headerImagePath", (String) view.getTag(R.string.album_art));
            bundle.putString("headerText", (String) view.getTag(R.string.title_text));
            bundle.putString("subText", (String) view.getTag(R.string.field_1));
            bundle.putInt("fragmentId", newFragmentId);

            intent.putExtras(bundle);
            startActivity(intent);
            getActivity().overridePendingTransition(R.anim.fade_in, R.anim.fade_out);

		}
    	
    };

    /**
     * Determines the next activity's fragment id based on the
     * current activity's fragment id.
     */
    private int getNewFragmentId() {
        switch (mFragmentId) {
            case Common.ARTISTS_FRAGMENT:
                return Common.ARTISTS_FLIPPED_FRAGMENT;
            case Common.ALBUM_ARTISTS_FRAGMENT:
                return Common.ALBUM_ARTISTS_FLIPPED_FRAGMENT;
            case Common.ALBUMS_FRAGMENT:
                return Common.ALBUMS_FLIPPED_FRAGMENT;
            case Common.GENRES_FRAGMENT:
                return Common.GENRES_FLIPPED_FRAGMENT;
            default:
                return -1;
        }

    }
    
    /**
     * Runs the correct DB query based on the passed in fragment id and 
     * displays the GridView.
     * 
     * @author Saravan Pantham
     */
    public class AsyncRunQuery extends AsyncTask<Void, Void, Void> {

		@Override
		protected Void doInBackground(Void... params) {
	        mCursor = mApp.getDBAccessHelper().getFragmentCursor(mContext, mQuerySelection, mFragmentId);
	        loadDBColumnNames();
	        
	        return null;
		}
		
		/**
		 * Populates the DB column names based on the specifed fragment id.
		 */
		private void loadDBColumnNames() {
			
			switch (mFragmentId) {
			case Common.ARTISTS_FRAGMENT:
				mDBColumnsMap.put(GridViewCardsAdapter.TITLE_TEXT, DBAccessHelper.SONG_ARTIST);
				mDBColumnsMap.put(GridViewCardsAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
				mDBColumnsMap.put(GridViewCardsAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
				mDBColumnsMap.put(GridViewCardsAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
                mDBColumnsMap.put(GridViewCardsAdapter.FIELD_1, DBAccessHelper.ALBUMS_COUNT);
				break;
			case Common.ALBUM_ARTISTS_FRAGMENT:
				mDBColumnsMap.put(GridViewCardsAdapter.TITLE_TEXT, DBAccessHelper.SONG_ALBUM_ARTIST);
				mDBColumnsMap.put(GridViewCardsAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
				mDBColumnsMap.put(GridViewCardsAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
				mDBColumnsMap.put(GridViewCardsAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
                mDBColumnsMap.put(GridViewCardsAdapter.FIELD_1, DBAccessHelper.ALBUMS_COUNT);
				break;
			case Common.ALBUMS_FRAGMENT:
				mDBColumnsMap.put(GridViewCardsAdapter.TITLE_TEXT, DBAccessHelper.SONG_ALBUM);
				mDBColumnsMap.put(GridViewCardsAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
				mDBColumnsMap.put(GridViewCardsAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
				mDBColumnsMap.put(GridViewCardsAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
                mDBColumnsMap.put(GridViewCardsAdapter.FIELD_1, DBAccessHelper.SONG_ARTIST);
				break;
			case Common.PLAYLISTS_FRAGMENT:
				break;
			case Common.GENRES_FRAGMENT:
                mDBColumnsMap.put(GridViewCardsAdapter.TITLE_TEXT, DBAccessHelper.SONG_GENRE);
                mDBColumnsMap.put(GridViewCardsAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
                mDBColumnsMap.put(GridViewCardsAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
                mDBColumnsMap.put(GridViewCardsAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
                mDBColumnsMap.put(GridViewCardsAdapter.FIELD_1, DBAccessHelper.GENRE_SONG_COUNT);
				break;
			case Common.FOLDERS_FRAGMENT:
				break;
			}
			
		}
    	
		@Override
		public void onPostExecute(Void result) {
			super.onPostExecute(result);
            mHandler.postDelayed(initGridView, 200);
			
		}
		
    }

    /**
     * Runnable that loads the GridView after a set interval.
     */
    private Runnable initGridView = new Runnable() {

        @Override
        public void run() {
            TranslateAnimation animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f,
					  											  Animation.RELATIVE_TO_SELF, 0.0f,
					  											  Animation.RELATIVE_TO_SELF, 2.0f,
					  											  Animation.RELATIVE_TO_SELF, 0.0f);

			animation.setDuration(150);
			animation.setInterpolator(new AccelerateDecelerateInterpolator());

            mGridViewAdapter = new GridViewCardsAdapter(mContext, mFragment, mDBColumnsMap);
            //mGridView.setAdapter(mGridViewAdapter);

            //GridView animation adapter.
            final SwingBottomInAnimationAdapter animationAdapter = new SwingBottomInAnimationAdapter(mGridViewAdapter, 100, 150);
            animationAdapter.setShouldAnimate(true);
            animationAdapter.setShouldAnimateFromPosition(0);
            animationAdapter.setAbsListView(mGridView);
            mGridView.setAdapter(animationAdapter);
            mGridView.setOnItemClickListener(onItemClickListener);

            //Init the quick scroll widget.
            mQuickScroll.init(QuickScrollGridView.TYPE_INDICATOR_WITH_HANDLE,
                              mGridView,
                              (GridViewCardsAdapter) mGridViewAdapter,
                              QuickScrollGridView.STYLE_HOLO);

            int[] quickScrollColors = UIElementsHelper.getQuickScrollColors(mContext);
            PauseOnScrollHelper scrollHelper = new PauseOnScrollHelper(mApp.getPicasso(), null, false, true);

            mQuickScroll.setOnScrollListener(scrollHelper);
            mQuickScroll.setPicassoInstance(mApp.getPicasso());
            mQuickScroll.setHandlebarColor(quickScrollColors[0], quickScrollColors[0], quickScrollColors[1]);
            mQuickScroll.setIndicatorColor(quickScrollColors[1], quickScrollColors[0], quickScrollColors[2]);
            mQuickScroll.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 48);

	        animation.setAnimationListener(new AnimationListener() {

				@Override
				public void onAnimationEnd(Animation arg0) {
					mQuickScroll.setVisibility(View.VISIBLE);
                    //animationAdapter.setShouldAnimate(false);

				}

				@Override
				public void onAnimationRepeat(Animation arg0) {
					// TODO Auto-generated method stub

				}

				@Override
				public void onAnimationStart(Animation arg0) {
					mGridView.setVisibility(View.VISIBLE);

				}

	        });

	        mGridView.startAnimation(animation);
        }

    };

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        mRootView = null;

        if (mCursor!=null) {
            mCursor.close();
            mCursor = null;
        }

        onItemClickListener = null;
        mGridView = null;
        mGridViewAdapter = null;
        mContext = null;
        mHandler = null;

    }

    @SuppressLint("NewApi")
    @Override
    public void onResume() {
        super.onResume();

        //Apply the ActionBar title.
        getActivity().getActionBar().setTitle(mFragmentTitle);

    }

    /*
     * Getter methods.
     */

	public GridViewCardsAdapter getGridViewAdapter() {
		return (GridViewCardsAdapter) mGridViewAdapter;
	}

	public GridView getGridView() {
		return mGridView;
	}

	public Cursor getCursor() {
		return mCursor;
	}

	/*
	 * Setter methods.
	 */
	
	public void setCursor(Cursor cursor) {
		this.mCursor = cursor;
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Helpers;

/**
 * Audio Manager helper class. 
 * 
 * @author Saravan Pantham
 */
public class AudioManagerHelper {

	private int mOriginalVolume;
	private boolean mHasAudioFocus = false;
	private boolean mAudioDucked = false;
	private int mTargetVolume;
	private int mCurrentVolume;
	private int mStepDownIncrement;
	private int mStepUpIncrement;
	
	/*
	 * Getter methods.
	 */
	
	public int getOriginalVolume() {
		return mOriginalVolume;
	}
	
	public boolean hasAudioFocus() {
		return mHasAudioFocus;
	}
	
	public boolean isAudioDucked() {
		return mAudioDucked;
	}
	
	public int getTargetVolume() {
		return mTargetVolume;
	}
	
	public int getCurrentVolume() {
		return mCurrentVolume;
	}
	
	public int getStepDownIncrement() {
		return mStepDownIncrement;
	}
	
	public int getStepUpIncrement() {
		return mStepUpIncrement;
	}
	
	/*
	 * Setter methods.
	 */
	
	public void setHasAudioFocus(boolean hasAudioFocus) {
		mHasAudioFocus = hasAudioFocus;
	}
	
	public void setOriginalVolume(int originalVolume) {
		this.mOriginalVolume = originalVolume;
	}
	
	public void setAudioDucked(boolean audioDucked) {
		this.mAudioDucked = audioDucked;
	}
	
	public void setTargetVolume(int targetVolume) {
		this.mTargetVolume = targetVolume;
	}
	
	public void setCurrentVolume(int currentVolume) {
		this.mCurrentVolume = currentVolume;
	}
	
	public void setStepDownIncrement(int stepDownIncrement) {
		this.mStepDownIncrement = stepDownIncrement;
	}
	
	public void setStepUpIncrement(int stepUpIncrement) {
		this.mStepUpIncrement = stepUpIncrement;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Helpers;

import android.content.Context;
import android.media.audiofx.BassBoost;
import android.media.audiofx.Equalizer;
import android.media.audiofx.PresetReverb;
import android.media.audiofx.Virtualizer;

import com.jams.music.player.Utils.Common;

/**
 * Equalizer helper class.
 * 
 * @author Saravan Pantham
 *
 */
public class EqualizerHelper {

	//Context and helper objects.
	Context mContext;
	Common mApp;
	
	//Equalizer objects.
	private Equalizer mEqualizer;
	private Equalizer mEqualizer2;
	private Virtualizer mVirtualizer;
	private Virtualizer mVirtualizer2;
	private BassBoost mBassBoost;
	private BassBoost mBassBoost2;
	private PresetReverb mReverb;
	private PresetReverb mReverb2;
	private boolean mIsEqualizerSupported = true;
	
	//Equalizer setting values.
	private int m50HzLevel = 16;
	private int m130HzLevel = 16;
	private int m320HzLevel = 16;
	private int m800HzLevel = 16;
	private int m2kHzLevel = 16;
	private int m5kHzLevel = 16;
	private int m12kHzLevel = 16;
	private short mVirtualizerLevel = 0;
	private short mBassBoostLevel = 0;
	private short mReverbSetting = 0;
	
	public EqualizerHelper(Context context, int audioSessionId1, 
						   int audioSessionId2, boolean equalizerEnabled) {
		
		//Context and helper objects.
		mContext = context.getApplicationContext();
		mApp = (Common) mContext;
		
		//Init mMediaPlayer's equalizer engine.
		mEqualizer = new Equalizer(0, audioSessionId1);
		mEqualizer.setEnabled(equalizerEnabled);
		
		//Init mMediaPlayer2's equalizer engine.
		mEqualizer2 = new Equalizer(0, audioSessionId2);
		mEqualizer2.setEnabled(equalizerEnabled);
		
		//Init mMediaPlayer's virtualizer engine.
		mVirtualizer = new Virtualizer(0, audioSessionId1);
		mVirtualizer.setEnabled(equalizerEnabled);
		
		//Init mMediaPlayer2's virtualizer engine.
		mVirtualizer2 = new Virtualizer(0, audioSessionId2);
		mVirtualizer2.setEnabled(equalizerEnabled);
		
		//Init mMediaPlayer's bass boost engine.
		mBassBoost = new BassBoost(0, audioSessionId1);
		mBassBoost.setEnabled(equalizerEnabled);
		
		//Init mMediaPlayer2's bass boost engine.
		mBassBoost2 = new BassBoost(0, audioSessionId2);
		mBassBoost2.setEnabled(equalizerEnabled);
		
		//Init mMediaPlayer's reverb engine.
		mReverb = new PresetReverb(0, audioSessionId1);
		mReverb.setEnabled(equalizerEnabled);
		
		//Init mMediaPlayer's reverb engine.
		mReverb2 = new PresetReverb(0, audioSessionId2);
		mReverb2.setEnabled(equalizerEnabled);
		
	}
	
	/**
	 * Releases all EQ objects and sets their references to null.
	 */
	public void releaseEQObjects() throws Exception {
		mEqualizer.release();
		mEqualizer2.release();
		mVirtualizer.release();
		mVirtualizer2.release();
		mBassBoost.release();
		mBassBoost2.release();
		mReverb.release();
		mReverb2.release();
		
		mEqualizer = null;
		mEqualizer2 = null;
		mVirtualizer = null;
		mVirtualizer2 = null;
		mBassBoost = null;
		mBassBoost2 = null;
		mReverb = null;
		mReverb2 = null;
		
	}
	
	/*
	 * Getter methods.
	 */
	
	public Equalizer getCurrentEqualizer() {
		if (mApp.getService().getCurrentMediaPlayer()==mApp.getService().getMediaPlayer())
			return getEqualizer();
		else
			return getEqualizer2();
	}
	
	public Equalizer getEqualizer() {
		return mEqualizer;
	}
	
	public Equalizer getEqualizer2() {
		return mEqualizer2;
	}
	
	public Virtualizer getCurrentVirtualizer() {
		if (mApp.getService().getCurrentMediaPlayer()==mApp.getService().getMediaPlayer())
			return getVirtualizer();
		else
			return getVirtualizer2();
	}
	
	public Virtualizer getVirtualizer() {
		return mVirtualizer;
	}
	
	public Virtualizer getVirtualizer2() {
		return mVirtualizer2;
	}
	
	public BassBoost getCurrentBassBoost() {
		if (mApp.getService().getCurrentMediaPlayer()==mApp.getService().getMediaPlayer())
			return getBassBoost();
		else
			return getBassBoost2();
	}
	
	public BassBoost getBassBoost() {
		return mBassBoost;
	}
	
	public BassBoost getBassBoost2() {
		return mBassBoost2;
	}
	
	public PresetReverb getCurrentReverb() {
		if (mApp.getService().getCurrentMediaPlayer()==mApp.getService().getMediaPlayer())
			return getReverb();
		else
			return getReverb2();
	}
	
	public PresetReverb getReverb() {
		return mReverb;
	}
	
	public PresetReverb getReverb2() {
		return mReverb2;
	}
	
	public int get50HzLevel() {
		return m50HzLevel;
	}
	
	public int get130HzLevel() {
		return m130HzLevel;
	}
	
	public int get320HzLevel() {
		return m320HzLevel;
	}
	
	public int get800HzLevel() {
		return m800HzLevel;
	}
	
	public int get2kHzLevel() {
		return m2kHzLevel;
	}
	
	public int get5kHzLevel() {
		return m5kHzLevel;
	}
	
	public int get12kHzLevel() {
		return m12kHzLevel;
	}
	
	public short getVirtualizerLevel() {
		return mVirtualizerLevel;
	}
	
	public short getBassBoostLevel() {
		return mBassBoostLevel;
	}
	
	public short getReverbSetting() {
		return mReverbSetting;
	}
	
	public boolean isEqualizerSupported() {
		return mIsEqualizerSupported;
	}
	
	/*
	 * Setter methods.
	 */
	
	public void setEqualizer(Equalizer equalizer) {
		mEqualizer = equalizer;
	}
	
	public void setEqualizer2(Equalizer equalizer2) {
		mEqualizer2 = equalizer2;
	}
	
	public void setVirtualizer(Virtualizer virtualizer) {
		mVirtualizer = virtualizer;
	}
	
	public void setVirtualizer2(Virtualizer virtualizer2) {
		mVirtualizer2 = virtualizer2;
	}
	
	public void setBassBoost(BassBoost bassBoost) {
		mBassBoost = bassBoost;
	}
	
	public void setBassBoost2(BassBoost bassBoost2) {
		mBassBoost2 = bassBoost2;
	}
	
	public void setReverb(PresetReverb reverb) {
		mReverb = reverb;
	}
	
	public void setReverb2(PresetReverb reverb2) {
		mReverb2 = reverb2;
	}
	
	public void set50HzLevel(int l50HzLevel) {
		m50HzLevel = l50HzLevel;
	}
	
	public void set130HzLevel(int l130HzLevel) {
		m130HzLevel = l130HzLevel;
	}
	
	public void set320HzLevel(int l320HzLevel) {
		m320HzLevel = l320HzLevel;
	}
	
	public void set800HzLevel(int l800HzLevel) {
		m800HzLevel = l800HzLevel;
	}
	
	public void set2kHzLevel(int l2kHzLevel) {
		m2kHzLevel = l2kHzLevel;
	}
	
	public void set5kHzLevel(int l5kHzLevel) {
		m5kHzLevel = l5kHzLevel;
	}
	
	public void set12kHzLevel(int l12kHzLevel) {
		m12kHzLevel = l12kHzLevel;
	}
	
	public void setVirtualizerLevel(short virtualizerLevel) {
		mVirtualizerLevel = virtualizerLevel;
	}
	
	public void setBassBoostLevel(short bassBoostLevel) {
		mBassBoostLevel = bassBoostLevel;
	}
	
	public void setReverbSetting(short reverbSetting) {
		mReverbSetting = reverbSetting;
	}	
	
	public void setIsEqualizerSupported(boolean isSupported) {
		mIsEqualizerSupported = isSupported;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Helpers;

import android.graphics.Bitmap;

/**
 * Helper class used to animate a thumbnail to a
 * larger, scaled-in version during an activity
 * transition.
 *
 * @author Saravan Pantham
 */
public class ImageViewCoordHelper {

    public String mAlbumArtPath;
    public Bitmap mThumbnail;

    public ImageViewCoordHelper(String albumArtPath, Bitmap thumbnail) {
        mAlbumArtPath = albumArtPath;
        mThumbnail = thumbnail;

    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Helpers;

import android.content.Context;
import android.util.Log;
import android.widget.AbsListView;
import com.squareup.picasso.Picasso;

public class PauseOnScrollHelper implements AbsListView.OnScrollListener {

    protected AbsListView.OnScrollListener delegate;
    protected Picasso picasso;
    private int previousScrollState = SCROLL_STATE_IDLE;
    private boolean scrollingFirstTime = true;
    private boolean pauseOnScroll = false;
    private boolean pauseOnFling = true;

    public PauseOnScrollHelper(Picasso picasso, AbsListView.OnScrollListener delegate,
                               boolean pauseOnScroll, boolean pauseOnFling) {
        this.delegate = delegate;
        this.picasso = picasso;
        this.pauseOnScroll = pauseOnScroll;
        this.pauseOnFling = pauseOnFling;
        picasso.continueDispatching();

    }

    public PauseOnScrollHelper(Picasso picasso, boolean pauseOnScroll, boolean pauseOnFling) {
        this(picasso, null, pauseOnScroll, pauseOnFling);
    }

    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) {

        if (scrollingFirstTime) {
            picasso.continueDispatching();
            scrollingFirstTime = false;
        }

        //Intercept this method here if we don't need imagel loading to be paused while scrolling.
        if (scrollState==SCROLL_STATE_TOUCH_SCROLL && pauseOnScroll==false) {
            return;
        }

        //Intercept this method here if we don't need imagel loading to be paused while flinging.
        if (scrollState==SCROLL_STATE_FLING && pauseOnFling==false) {
            return;
        }

        if (!isScrolling(scrollState) && isScrolling(previousScrollState)) {
            picasso.continueDispatching();
        }

        if (isScrolling(scrollState) && !isScrolling(previousScrollState)) {
            picasso.interruptDispatching();
        }

        previousScrollState = scrollState;

        // Forward to the delegate
        if (delegate != null) {
            delegate.onScrollStateChanged(view, scrollState);
        }

    }

    protected boolean isScrolling(int scrollState) {
        return scrollState == SCROLL_STATE_FLING || scrollState == SCROLL_STATE_TOUCH_SCROLL;
    }

    @Override
    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount,
                         int totalItemCount) {

        // Forward to the delegate
        if (delegate != null) {
            delegate.onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount);
        }

    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Helpers;

/**
 * Constructs SQLite raw queries for common 
 * operations.
 * 
 * @author Saravan Pantham
 */
public class QueryBuilderHelper {

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Helpers;

import android.content.ContentUris;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.GradientDrawable;
import android.net.Uri;
import android.provider.MediaStore;
import android.util.Log;

import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.DBHelpers.MediaStoreAccessHelper;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;
import com.squareup.picasso.Picasso;
import com.squareup.picasso.Target;
import com.squareup.picasso.Transformation;

import java.util.ArrayList;

/**
 * Helper class for the current song.
 * 
 * @author Saravan Pantham
 *
 */
public class SongHelper {

	private SongHelper mSongHelper;
	private Common mApp;
	private int mIndex;
	private boolean mIsCurrentSong = false;
	private boolean mIsAlbumArtLoaded = false;
	
	//Song parameters.
	private String mTitle;
	private String mArtist;
	private String mAlbum;
	private String mAlbumArtist;
	private String mDuration;
	private String mFilePath;
	private String mGenre;
	private String mId;
	private String mAlbumArtPath;
	private String mSource;
	private String mLocalCopyPath;
	private long mSavedPosition;
	private Bitmap mAlbumArt;
	
	private AlbumArtLoadedListener mAlbumArtLoadedListener;
	
	/**
	 * Interface that provides callbacks to the provided listener 
	 * once the song's album art has been loaded.
	 */
	public interface AlbumArtLoadedListener {
		
		/**
		 * Called once the album art bitmap is ready for use.
		 */
		public void albumArtLoaded();
	}
	
	/**
	 * Moves the specified cursor to the specified index and populates this 
	 * helper object with new song data.
	 * 
	 * @param context Context used to get a new Common object.
	 * @param index The index of the song.
     * @param albumArtTransformer The transformer to apply to the album art bitmap;
	 */
	public void populateSongData(Context context, int index, Transformation albumArtTransformer) {
		
		mSongHelper = this;
		mApp = (Common) context.getApplicationContext();
		mIndex = index;
		
		if (mApp.isServiceRunning()) {
			mApp.getService().getCursor().moveToPosition(mApp.getService().getPlaybackIndecesList().get(index));

            this.setId(mApp.getService().getCursor().getString(getIdColumnIndex()));
            this.setTitle(mApp.getService().getCursor().getString(getTitleColumnIndex()));
            this.setAlbum(mApp.getService().getCursor().getString(getAlbumColumnIndex()));
            this.setArtist(mApp.getService().getCursor().getString(getArtistColumnIndex()));
            this.setAlbumArtist(mApp.getService().getCursor().getString(getAlbumArtistColumnIndex()));
            this.setGenre(determineGenreName(context));
            this.setDuration(determineDuration());

            this.setFilePath(mApp.getService().getCursor().getString(getFilePathColumnIndex()));
            this.setAlbumArtPath(determineAlbumArtPath());
            this.setSource(determineSongSource());
            this.setLocalCopyPath(determineLocalCopyPath());
            this.setSavedPosition(determineSavedPosition());

            mApp.getPicasso()
                .load(getAlbumArtPath())
                .transform(albumArtTransformer)
                .into(imageLoadingTarget);

		}

	}

    /**
     * Moves the specified cursor to the specified index and populates this
     * helper object with new song data.
     *
     * @param context Context used to get a new Common object.
     * @param index The index of the song.
     */
    public void populateSongData(Context context, int index) {

        mSongHelper = this;
        mApp = (Common) context.getApplicationContext();
        mIndex = index;

        if (mApp.isServiceRunning()) {
            mApp.getService().getCursor().moveToPosition(mApp.getService().getPlaybackIndecesList().get(index));

            this.setId(mApp.getService().getCursor().getString(getIdColumnIndex()));
            this.setTitle(mApp.getService().getCursor().getString(getTitleColumnIndex()));
            this.setAlbum(mApp.getService().getCursor().getString(getAlbumColumnIndex()));
            this.setArtist(mApp.getService().getCursor().getString(getArtistColumnIndex()));
            this.setAlbumArtist(mApp.getService().getCursor().getString(getAlbumArtistColumnIndex()));
            this.setGenre(determineGenreName(context));
            this.setDuration(determineDuration());

            this.setFilePath(mApp.getService().getCursor().getString(getFilePathColumnIndex()));
            this.setAlbumArtPath(determineAlbumArtPath());
            this.setSource(determineSongSource());
            this.setLocalCopyPath(determineLocalCopyPath());
            this.setSavedPosition(determineSavedPosition());

            mApp.getPicasso()
                    .load(getAlbumArtPath())
                    .into(imageLoadingTarget);

        }

    }

    /**
     * Moves the specified cursor to the specified index and populates this
     * helper object with new song data. Note that this method only laods
     * the song's title and artist. All other fields are set to null. To
     * retrieve all song data, see populateSongData().
     *
     * @param context Context used to get a new Common object.
     * @param index The index of the song.
     */
    public void populateBasicSongData(Context context, int index) {

        mSongHelper = this;
        mApp = (Common) context.getApplicationContext();
        mIndex = index;

        if (mApp.isServiceRunning()) {
            mApp.getService().getCursor().moveToPosition(mApp.getService().getPlaybackIndecesList().get(index));

            this.setId(mApp.getService().getCursor().getString(getIdColumnIndex()));
            this.setTitle(mApp.getService().getCursor().getString(getTitleColumnIndex()));
            this.setAlbum(mApp.getService().getCursor().getString(getAlbumColumnIndex()));
            this.setArtist(mApp.getService().getCursor().getString(getArtistColumnIndex()));
            this.setAlbumArtist(mApp.getService().getCursor().getString(getAlbumArtistColumnIndex()));
            this.setGenre(determineGenreName(context));
            this.setDuration(determineDuration());

            this.setFilePath(mApp.getService().getCursor().getString(getFilePathColumnIndex()));
            this.setAlbumArtPath(determineAlbumArtPath());
            this.setSource(determineSongSource());
            this.setLocalCopyPath(determineLocalCopyPath());
            this.setSavedPosition(determineSavedPosition());

        }

    }

    /**
	 * Sets this helper object as the current song. This method 
	 * will check if the song's album art has already been loaded. 
	 * If so, the updateNotification() and updateWidget() methods 
	 * will be called. If not, they'll be called as soon as the 
	 * album art is loaded.
	 */
	public void setIsCurrentSong() {
		mIsCurrentSong = true;
		//The album art has already been loaded.
		if (mIsAlbumArtLoaded) {
			mApp.getService().updateNotification(this);
			mApp.getService().updateWidgets();
		} else {
			/* 
			 * The album art isn't ready yet. The listener will call 
			 * the updateNotification() and updateWidgets() methods.
			 */
		}
		
	}
	
	/**
	 * Image loading listener to store the current song's album art.
	 */
    Target imageLoadingTarget = new Target() {

        @Override
        public void onBitmapLoaded(Bitmap bitmap, Picasso.LoadedFrom from) {
            mIsAlbumArtLoaded = true;
            setAlbumArt(bitmap);
            if (getAlbumArtLoadedListener()!=null)
                getAlbumArtLoadedListener().albumArtLoaded();

            if (mIsCurrentSong) {
                mApp.getService().updateNotification(mSongHelper);
                mApp.getService().updateWidgets();

            }

        }

        @Override
        public void onBitmapFailed(Drawable errorDrawable) {
            setAlbumArt(null);
            onBitmapLoaded(mAlbumArt, null);

        }

        @Override
        public void onPrepareLoad(Drawable placeHolderDrawable) {
            mIsAlbumArtLoaded = false;

        }

    };

    private int getIdColumnIndex() {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ID);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty())
                //We're dealing with Jams' internal DB schema.
                return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ID);
            else
                //The current row is from MediaStore's DB schema.
                return mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media._ID);

        }

    }

    private int getFilePathColumnIndex() {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_FILE_PATH);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty())
                //We're dealing with Jams' internal DB schema.
                return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_FILE_PATH);
            else
                //The current row is from MediaStore's DB schema.
                return mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.DATA);

        }

    }

    private int getTitleColumnIndex() {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_TITLE);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty())
                //We're dealing with Jams' internal DB schema.
                return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_TITLE);
            else
                //The current row is from MediaStore's DB schema.
                return mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.TITLE);
        }

    }

    private int getArtistColumnIndex() {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ARTIST);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty())
                //We're dealing with Jams' internal DB schema.
                return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ARTIST);
            else
                //The current row is from MediaStore's DB schema.
                return mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.ARTIST);

        }

    }

    private int getAlbumColumnIndex() {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ALBUM);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty())
                //We're dealing with Jams' internal DB schema.
                return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ALBUM);
            else
                //The current row is from MediaStore's DB schema.
                return mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.ALBUM);

        }

    }

    private int getAlbumArtistColumnIndex() {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ALBUM_ARTIST);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty())
                //We're dealing with Jams' internal DB schema.
                return mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ALBUM_ARTIST);
            else
                //The current row is from MediaStore's DB schema.
                if (mApp.getService().getCursor().getColumnIndex(MediaStoreAccessHelper.ALBUM_ARTIST)!=-1)
                    return mApp.getService().getCursor().getColumnIndex(MediaStoreAccessHelper.ALBUM_ARTIST);
                else
                    return mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.ARTIST);

        }

    }

    private String determineGenreName(Context context) {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_GENRE);
            return mApp.getService().getCursor().getString(colIndex);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty()) {
                //We're dealing with Jams' internal DB schema.
                int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_GENRE);
                return mApp.getService().getCursor().getString(colIndex);

            } else {
                //The current row is from MediaStore's DB schema.
                return ""; //We're not using the genres field for now, so we'll leave it blank.

            }

        }

    }

    private String determineAlbumArtPath() {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH);
            return mApp.getService().getCursor().getString(colIndex);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty()) {
                //We're dealing with Jams' internal DB schema.
                int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH);
                return mApp.getService().getCursor().getString(colIndex);

            } else {
                //The current row is from MediaStore's DB schema.
                final Uri ART_CONTENT_URI = Uri.parse("content://media/external/audio/albumart");
                int albumIdColIndex = mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.ALBUM_ID);
                long albumId = mApp.getService().getCursor().getLong(albumIdColIndex);

                return ContentUris.withAppendedId(ART_CONTENT_URI, albumId).toString();

            }

        }

    }

    private String determineDuration() {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_DURATION);
            return mApp.getService().getCursor().getString(colIndex);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty()) {
                //We're dealing with Jams' internal DB schema.
                int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_DURATION);
                return mApp.getService().getCursor().getString(colIndex);

            } else {
                //The current row is from MediaStore's DB schema.
                int durationColIndex = mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.DURATION);
                long duration = mApp.getService().getCursor().getLong(durationColIndex);

                return mApp.convertMillisToMinsSecs(duration);

            }

        }

    }

    private String determineSongSource() {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_SOURCE);
            return mApp.getService().getCursor().getString(colIndex);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty()) {
                //We're dealing with Jams' internal DB schema.
                int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_SOURCE);
                return mApp.getService().getCursor().getString(colIndex);

            } else {
                //The current row is from MediaStore's DB schema.
                return DBAccessHelper.LOCAL;

            }

        }

    }

    private String determineLocalCopyPath() {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.LOCAL_COPY_PATH);
            return mApp.getService().getCursor().getString(colIndex);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty()) {
                //We're dealing with Jams' internal DB schema.
                int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.LOCAL_COPY_PATH);
                return mApp.getService().getCursor().getString(colIndex);

            } else {
                //The current row is from MediaStore's DB schema.
                int filePathColumnIndex = mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.DATA);
                return mApp.getService().getCursor().getString(filePathColumnIndex);

            }

        }

    }

    private long determineSavedPosition() {
        if (mApp.getService().getCursor().getColumnIndex(MediaStore.Audio.Media.IS_MUSIC)==-1) {
            //We're dealing with Jams' internal DB schema.
            int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SAVED_POSITION);
            return mApp.getService().getCursor().getLong(colIndex);
        } else {
            String isMusicColName = MediaStore.Audio.Media.IS_MUSIC;
            int isMusicColumnIndex = mApp.getService().getCursor().getColumnIndex(isMusicColName);

            //Check if the current row is from Jams' internal DB schema or MediaStore.
            if (mApp.getService().getCursor().getString(isMusicColumnIndex).isEmpty()) {
                //We're dealing with Jams' internal DB schema.
                int colIndex = mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SAVED_POSITION);
                return mApp.getService().getCursor().getLong(colIndex);

            } else {
                //The current row is from MediaStore's DB schema.
                return -1;

            }

        }

    }

    public int getSongIndex() {
        return mIndex;
    }

	public String getTitle() {
		return mTitle;
	}
	
	public void setTitle(String title) {
		mTitle = title;
	}
	
	public String getArtist() {
		return mArtist;
	}
	
	public void setArtist(String artist) {
		mArtist = artist;
	}
	
	public String getAlbum() {
		return mAlbum;
	}
	
	public void setAlbum(String album) {
		mAlbum = album;
	}
	
	public String getAlbumArtist() {
		return mAlbumArtist;
	}
	
	public void setAlbumArtist(String albumArtist) {
		mAlbumArtist = albumArtist;
	}
	
	public String getDuration() {
		return mDuration;
	}
	
	public void setDuration(String duration) {
		mDuration = duration;
	}
	
	public String getFilePath() {
		return mFilePath;
	}
	
	public String getLocalCopyPath() {
		return mLocalCopyPath;
	}
	
	public Bitmap getAlbumArt() {
		return mAlbumArt;
	}
	
	public void setFilePath(String filePath) {
		mFilePath = filePath;
	}
	
	public String getGenre() {
		return mGenre;
	}
	
	public void setGenre(String genre) {
		mGenre = genre;
	}
	
	public String getId() {
		return mId;
	}
	
	public void setId(String id) {
		mId = id;
	}
	
	public String getAlbumArtPath() {
		return mAlbumArtPath;
	}
	
	public void setAlbumArtPath(String albumArtPath) {
		mAlbumArtPath = albumArtPath;
	}
	
	public String getSource() {
		return mSource;
	}
	
	public void setSource(String source) {
		mSource = source;
	}

	public void setLocalCopyPath(String localCopyPath) {
		mLocalCopyPath = localCopyPath;
	}
	
	public void setAlbumArt(Bitmap albumArt) {
		mAlbumArt = albumArt;
	}
	
	public void setSavedPosition(long savedPosition) {
		mSavedPosition = savedPosition;
	}
	
	public long getSavedPosition() {
		return mSavedPosition;
	}
	
	public void setAlbumArtLoadedListener(AlbumArtLoadedListener listener) {
		mAlbumArtLoadedListener = listener;
	}
	
	public AlbumArtLoadedListener getAlbumArtLoadedListener() {
		return mAlbumArtLoadedListener;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Helpers;

import java.util.Hashtable;

import android.content.Context;
import android.graphics.Typeface;

//Caches the custom fonts in memory to improve rendering performance.
public class TypefaceHelper {

public static final String TYPEFACE_FOLDER = "fonts";
public static final String TYPEFACE_EXTENSION = ".ttf";

private static Hashtable<String, Typeface> sTypeFaces = new Hashtable<String, Typeface>(4);

	public static Typeface getTypeface(Context context, String fileName) {
		Typeface tempTypeface = sTypeFaces.get(fileName);
		
		if (tempTypeface==null) {
		    String fontPath = new StringBuilder(TYPEFACE_FOLDER).append('/')
		    													.append(fileName)
		    													.append(TYPEFACE_EXTENSION)
		    													.toString();
		    
		    tempTypeface = Typeface.createFromAsset(context.getAssets(), fontPath);
		    sTypeFaces.put(fileName, tempTypeface);
		}
		
		return tempTypeface;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Helpers;

import android.content.Context;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;

import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

/**
 * This class contains the static methods that return the appropriate UI 
 * elements/colors based on the selected theme (light or dark).
 *
 * @author Saravan Pantham
 */
public class UIElementsHelper {
	
	private static Common mApp;

	private static final String NOW_PLAYING_COLOR = "NOW_PLAYING_COLOR";
	private static final String BLUE = "BLUE";
	private static final String RED = "RED";
	private static final String GREEN = "GREEN";
	private static final String ORANGE = "ORANGE";
	private static final String PURPLE = "PURPLE";
	private static final String MAGENTA = "MAGENTA";
	private static final String GRAY = "GRAY";
	private static final String WHITE = "WHITE";
	private static final String BLACK = "BLACK";
	
	/**
	 * Text color.
	 */
	public static int getTextColor(Context context) {
		
		mApp = (Common) context.getApplicationContext();
		int color;
		
		//The gray theme needs its own colors regardless of the application theme.
		if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, "BLUE").equals("GRAY")) {
			
			color = Color.parseColor("#FFFFFF");
			
		} else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, "BLUE").equals("WHITE")) {
			
			color = Color.parseColor("#0F0F0F");
			
		} else {
			
			if (mApp.getCurrentTheme()==Common.DARK_THEME) {
				color = Color.parseColor("#FFFFFF");
			} else {
				color = Color.parseColor("#5F5F5F");
			}
			
		}
		
		return color;
		
	}
	
	/**
	 *  Text color. Plain and simple.
	 */
	public static int getThemeBasedTextColor(Context context) {
		mApp = (Common) context.getApplicationContext();
		int color;
		
		if (mApp.getCurrentTheme()==Common.DARK_THEME) {
			color = Color.parseColor("#DEDEDE");
		} else {
			color = Color.parseColor("#404040");
		}
		
		return color;
		
	}
	
	/**
	 * Small text color.
	 */
	public static int getSmallTextColor(Context context) {
		
		mApp = (Common) context.getApplicationContext();
		int color;
			
		if (mApp.getCurrentTheme()==Common.DARK_THEME) {
			color = Color.parseColor("#999999");
		} else {
			color = Color.parseColor("#7F7F7F");
		}

		return color;
		
	}
	
	/**
	 * Return a resource icon based on the current theme.
	 * If the theme is LIGHT_THEME, return an icon resource with the same file name.
	 * If the theme is DARK_THEME, return an icon resource with "_light" appended
	 * to the file name. Note that the actual theme that is applied and the suffix
	 * of the file name are flipped: DARK_THEME uses "xxx_light.png" while LIGHT_THEME
	 * uses "xxx.png".
	 */
	public static int getIcon(Context context, String iconName) {
		
		int resourceID = 0;
		mApp = (Common) context.getApplicationContext();
		
		if (!iconName.equals("")) {
				
            //We're using "cloud" and "pin" in the settings page so we don't want them to be affected by the player color.
            if (iconName.equals("cloud_settings") || iconName.equals("pin_settings") || iconName.equals("equalizer_settings")) {
                if (iconName.equals("cloud_settings")) {
                    iconName = "cloud";
                } else if (iconName.equals("pin_settings")) {
                    iconName = "pin";
                } else if (iconName.equals("equalizer_settings")) {
                    iconName = "equalizer";
                }

                if (mApp.getCurrentTheme()==Common.DARK_THEME) {
                    resourceID = context.getResources().getIdentifier(iconName + "_light", "drawable", context.getPackageName());
                } else {
                    resourceID = context.getResources().getIdentifier(iconName, "drawable", context.getPackageName());
                }

            } else {

                if (mApp.getCurrentTheme()==Common.DARK_THEME) {
                    resourceID = context.getResources().getIdentifier(iconName + "_light", "drawable", context.getPackageName());
                } else {
                    resourceID = context.getResources().getIdentifier(iconName, "drawable", context.getPackageName());
                }

            }
			
		}
		
		return resourceID;
		
	}

    /**
     * Returns the correct background for the GridView card based on the selected theme.
     */
    public static int getGridViewCardBackground(Context context) {
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            return context.getResources().getIdentifier("card_gridview_dark", "drawable", context.getPackageName());
        } else {
            return context.getResources().getIdentifier("card_gridview_light", "drawable", context.getPackageName());
        }

    }

    /**
     * Returns the correct background color for the GridView based on the selected theme.
     * Do not use this method if the GridView needs cards as its background.
     */
    public static int getGridViewBackground(Context context) {
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            return 0xFF131313;
        } else {
            return 0xFFFFFFFF;
        }

    }

    /**
     * Returns a semitransparent color layer that can be used as
     * background for text that needs to be overlayed on an image.
     */
    public static int getSemiTransparentLayerColor(Context context) {
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            return 0xEE232323;
        } else {
            return 0xEEFFFFFF;
        }

    }

	/**
	 * Background gradient in the flipped fragments' listviews.
	 * 
	 * NOTE: The dark theme now uses the default background. 
	 * 		 Only the light theme will use a custom background.
	 */
	public static Drawable getBackgroundGradientDrawable(Context context) {
		
		Drawable backgroundDrawable;
		mApp = (Common) context.getApplicationContext();
		
		if (mApp.getCurrentTheme()==Common.DARK_THEME) {
			backgroundDrawable = context.getResources().getDrawable(R.drawable.dark_gray_gradient);
		} else {
			backgroundDrawable = context.getResources().getDrawable(R.drawable.holo_white_selector);
		}
		
		return backgroundDrawable;
	}
	
	/**
	 * Returns the resource ID for the music player controls background
	 * in NowPlayingActivity.java.
	 */
	public static int getNowPlayingControlsBackground(Context context) {
		
		int resourceID = 0;
		mApp = (Common) context.getApplicationContext();
		
		if (mApp.getCurrentTheme()==Common.DARK_THEME) {
			resourceID = context.getResources().getIdentifier("now_playing_controls_background", "drawable", context.getPackageName());
		} else {
			resourceID = context.getResources().getIdentifier("now_playing_controls_background_light", "drawable", context.getPackageName());
		}
		
		return resourceID;
		
	}

	/**
	 * Returns the resource ID for the music player info (song, artist, album)
	 * background in NowPlayingActivity.java.
	 */
	public static int getNowPlayingInfoBackground(Context context) {
		
		int resourceID = 0;
		mApp = (Common) context.getApplicationContext();
		
		if (mApp.getCurrentTheme()==Common.DARK_THEME) {
			return R.drawable.solid_black_drawable;
		} else {
			resourceID = context.getResources().getIdentifier("now_playing_title_background_light", "drawable", context.getPackageName());
		}
		
		return resourceID;
		
	}
	
	/**
	 * Returns the background color for the Now Playing elements in NowPlayingQueueFragment. 
	 */
	public static int getNowPlayingQueueBackground(Context context) {
		int hexColor;
		mApp = (Common) context.getApplicationContext();
		
		if (mApp.getCurrentTheme()==Common.DARK_THEME) {
			hexColor = 0xFF3A3A3A;
		} else {
			hexColor = 0xFFDCDCDC;
		}
		
		return hexColor;
	}

	/**
	 * Returns the ActionBar color based on the selected color theme (not used for the player).
	 */
	public static Drawable getGeneralActionBarBackground(Context context) {
		
		mApp = (Common) context.getApplicationContext();
		
		Drawable drawable = new ColorDrawable(0xFFB0120A);
		if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(BLUE)) {
			drawable = new ColorDrawable(0xFF0099CC);
			
		} else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(RED)) {
			drawable = new ColorDrawable(0xFFB0120A);
			
		} else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(GREEN)) {
			drawable = new ColorDrawable(0xFF0A7E07);
			
		} else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(ORANGE)) {
			drawable = new ColorDrawable(0xFFEF6C00);
			
		} else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(PURPLE)) {
			drawable = new ColorDrawable(0xFF6A1B9A);
			
		} else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(MAGENTA)) {
			drawable = new ColorDrawable(0xFFC2185B);
			
		}
		
		return drawable;
		
	}

    /**
     * Returns the resource id of the shadowed circle drawable based on the selected theme.
     */
    public static int getShadowedCircle(Context context) {

        int resourceID = context.getResources().getIdentifier("shadowed_circle_red", "drawable", context.getPackageName());
        if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(BLUE)) {
            resourceID = context.getResources().getIdentifier("shadowed_circle_blue", "drawable", context.getPackageName());
        } else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(RED)) {
            resourceID = context.getResources().getIdentifier("shadowed_circle_red", "drawable", context.getPackageName());
        } else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(GREEN)) {
            resourceID = context.getResources().getIdentifier("shadowed_circle_green", "drawable", context.getPackageName());
        } else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(ORANGE)) {
            resourceID = context.getResources().getIdentifier("shadowed_circle_orange", "drawable", context.getPackageName());
        } else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(PURPLE)) {
            resourceID = context.getResources().getIdentifier("shadowed_circle_purple", "drawable", context.getPackageName());
        } else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(MAGENTA)) {
            resourceID = context.getResources().getIdentifier("shadowed_circle_magenta", "drawable", context.getPackageName());
        }

        return resourceID;
    }

	/**
	 * Returns an array of color values for the QuickScroll view.
	 */
	public static int[] getQuickScrollColors(Context context) {

		int[] colors = new int[3];
        colors[0] = 0xFFB0120A;
        colors[1] = 0x99B0120A;
        colors[2] = Color.WHITE;
		
		mApp = (Common) context.getApplicationContext();
		if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(BLUE)) {
			colors[0] = 0xFF0099CC;
			colors[1] = 0x990099CC;
			colors[2] = Color.WHITE;
			
		} else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(RED)) {
			colors[0] = 0xFFB0120A;
			colors[1] = 0x99B0120A;
			colors[2] = Color.WHITE;
			
		} else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(GREEN)) {
			colors[0] = 0xFF0A7E07;
			colors[1] = 0x990A7E07;
			colors[2] = Color.WHITE;
			
		} else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(ORANGE)) {
			colors[0] = 0xFFEF6C00;
			colors[1] = 0x99EF6C00;
			colors[2] = Color.WHITE;
			
		} else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(PURPLE)) {
			colors[0] = 0xFF6A1B9A;
			colors[1] = 0x996A1B9A;
			colors[2] = Color.WHITE;
			
		} else if (mApp.getSharedPreferences().getString(NOW_PLAYING_COLOR, BLUE).equals(MAGENTA)) {
			colors[0] = 0xFFC2185B;
			colors[1] = 0x99C2185B;
			colors[2] = Color.WHITE;
			
		}
		
		return colors;
	}

    /**
     * Returns a solid background color based on the selected theme.
     */
    public static int getBackgroundColor(Context context) {
        mApp = (Common) context.getApplicationContext();

        int color;
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            color = 0xFF111111;
        } else {
            color = 0xFFDDDDDD;
        }

        return color;
    }

    /**
     * Returns the correct empty color patch drawable based on the selected theme.
     */
    public static int getEmptyColorPatch(Context context) {
        mApp = (Common) context.getApplicationContext();

        int resourceID = 0;
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            resourceID = context.getResources().getIdentifier("empty_color_patch", "drawable", context.getPackageName());
        } else {
            resourceID = context.getResources().getIdentifier("empty_color_patch_light", "drawable", context.getPackageName());
        }

        return resourceID;
    }

    /**
     * Returns the correct circular empty color patch drawable based on the selected theme.
     */
    public static int getEmptyCircularColorPatch(Context context) {
        mApp = (Common) context.getApplicationContext();

        int resourceID = 0;
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            resourceID = context.getResources().getIdentifier("empty_color_patch_circular", "drawable", context.getPackageName());
        } else {
            resourceID = context.getResources().getIdentifier("empty_color_patch_circular_light", "drawable", context.getPackageName());
        }

        return resourceID;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.ImageTransformers;

import android.content.Context;
import android.graphics.Bitmap;
import android.support.v8.renderscript.Allocation;
import android.support.v8.renderscript.Element;
import android.support.v8.renderscript.RenderScript;
import android.support.v8.renderscript.ScriptIntrinsicBlur;

import com.squareup.picasso.Transformation;

public class PicassoBlurTransformer implements Transformation {

    RenderScript rs;
    public PicassoBlurTransformer(Context context) {
        super();
        rs = RenderScript.create(context);
    }

    @Override
    public Bitmap transform(Bitmap bitmap) {
        // Create another bitmap that will hold the results of the filter.
        Bitmap blurredBitmap = Bitmap.createBitmap(bitmap);

        // Allocate memory for Renderscript to work with
        Allocation input = Allocation.createFromBitmap(rs, bitmap, Allocation.MipmapControl.MIPMAP_FULL, Allocation.USAGE_SHARED);
        Allocation output = Allocation.createTyped(rs, input.getType());

        // Load up an instance of the specific script that we want to use.
        ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));
        script.setInput(input);

        // Set the blur radius
        script.setRadius(10);

        // Start the ScriptIntrinisicBlur
        script.forEach(output);

        // Copy the output to the blurred bitmap
        output.copyTo(blurredBitmap);
        return blurredBitmap;
    }

    @Override
    public String key() {
        return "blur";
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.ImageTransformers;

import android.graphics.Bitmap;
import android.graphics.BitmapShader;
import android.graphics.Canvas;
import android.graphics.Paint;

import com.squareup.picasso.Transformation;

public class PicassoCircularTransformer implements Transformation {

    @Override
    public Bitmap transform(Bitmap source) {
        int size = Math.min(source.getWidth(), source.getHeight());

        int x = (source.getWidth() - size) / 2;
        int y = (source.getHeight() - size) / 2;

        Bitmap squaredBitmap = Bitmap.createBitmap(source, x, y, size, size);
        if (squaredBitmap != source) {
            source.recycle();
        }

        Bitmap bitmap = Bitmap.createBitmap(size, size, source.getConfig());

        Canvas canvas = new Canvas(bitmap);
        Paint paint = new Paint();
        BitmapShader shader = new BitmapShader(squaredBitmap,
                BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP);
        paint.setShader(shader);
        paint.setAntiAlias(true);

        float r = size / 2f;
        canvas.drawCircle(r, r, r, paint);

        squaredBitmap.recycle();
        return bitmap;
    }

    @Override
    public String key() {
        return "circle";
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.ImageTransformers;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.LinearGradient;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.Shader;

import com.squareup.picasso.Transformation;

/**
 * Returns a bitmap image that is reflected over
 * the Y axis.
 *
 */
public class PicassoMirrorReflectionTransformer implements Transformation {

    @Override
    public Bitmap transform(Bitmap bitmap) {
        return mirrorBitmap(bitmap);
    }

    public Bitmap mirrorBitmap(Bitmap image) {
        // The gap we want between the reflection and the original image
        final int reflectionGap = 0;
        Bitmap originalImage = image;

        int width = originalImage.getWidth();
        int height = originalImage.getHeight();

        //Fip the image over the Y axis.
        Matrix matrix = new Matrix();
        matrix.preScale(1, -1);

        /*
         * Create a bitmap with the flip matix applied to it.
         * We only want the bottom half of the image
         */
        Bitmap reflectionImage = Bitmap.createBitmap(originalImage, 0,
                height / 2, width, height / 2, matrix, false);

        //Create a new bitmap with same width but taller to fit reflection
        Bitmap bitmapWithReflection = Bitmap.createBitmap(width,(height + height / 2), Bitmap.Config.ARGB_8888);

        /*
         * Create a new Canvas with the bitmap that's big enough for
         * the image, the gap, and the reflection.
         */
        Canvas canvas = new Canvas(bitmapWithReflection);

        //Draw in the original image.
        canvas.drawBitmap(originalImage, 0, 0, null);

        //Draw in the reflected image.
        canvas.drawBitmap(reflectionImage, 0, height + reflectionGap, null);

        if (originalImage!=null && !originalImage.isRecycled())
            originalImage.recycle();

        if (image!=null && !image.isRecycled())
            image.recycle();

        return bitmapWithReflection;
    }

    @Override
    public String key() {
        return "mirror";
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.ImageTransformers;

import android.graphics.Bitmap;
import android.graphics.drawable.ColorDrawable;
import android.os.Build;
//import android.support.v7.graphics.Palette;
import android.view.View;

import com.squareup.picasso.Transformation;

public class PicassoPaletteTransformer implements Transformation {

    View mView;
    ColorDrawable bgDrawable;
    String mId;

    public PicassoPaletteTransformer(View view, String id) {
        mView = view;
        mId = id;
    }

    @Override
    public Bitmap transform(Bitmap source) {
        //try {
            //Palette palette = Palette.generate(source);
            //if (mId.equals(mView.getTag()))
                //onGenerated(palette);
        //} catch (Exception e) {
            //e.printStackTrace();
            //mView.setBackgroundColor(0x99555555);
        //}

        return source;
    }

    @Override
    public String key() {
        return "trans#";
    }

    public void onGenerated(/* Palette palette */) {
        //try {
            //bgDrawable = new ColorDrawable(palette.getVibrantColor().getRgb());
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN)
                mView.setBackground(bgDrawable);
            else
                mView.setBackgroundDrawable(bgDrawable);
        //} catch (Exception e) {
            //e.printStackTrace();
            //mView.setBackgroundColor(0x99555555);
        //}

    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.ImageTransformers;

import android.graphics.Bitmap;
import android.graphics.BitmapShader;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.RectF;
import android.graphics.Shader;

import com.squareup.picasso.Transformation;

public class PicassoRoundedRectTransformer implements com.squareup.picasso.Transformation {
    private final int radius;
    private final int margin;  // dp
    private String key;

    // radius is corner radii in dp
    // margin is the board in dp
    public PicassoRoundedRectTransformer(final int radius, final int margin) {
        this.radius = radius;
        this.margin = margin;
        this.key = "rounded(radius=" + radius + ", margin=" + margin + ")";
    }

    @Override
    public Bitmap transform(final Bitmap source) {
        final Paint paint = new Paint();
        paint.setAntiAlias(true);
        paint.setShader(new BitmapShader(source, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP));

        Bitmap output = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(output);
        canvas.drawRoundRect(new RectF(margin, margin, source.getWidth() - margin, source.getHeight() - margin), radius, radius, paint);

        if (source != output) {
            source.recycle();
        }

        return output;
    }

    @Override
    public String key() {
        return this.key;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Portions copyright 2002, Google, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.jams.music.player.InAppBilling;

// This code was converted from code at http://iharder.sourceforge.net/base64/
// Lots of extraneous features were removed.
/* The original code said:
 * <p>
 * I am placing this code in the Public Domain. Do with it as you will.
 * This software comes with no guarantees or warranties but with
 * plenty of well-wishing instead!
 * Please visit
 * <a href="http://iharder.net/xmlizable">http://iharder.net/xmlizable</a>
 * periodically to check for updates or to contribute improvements.
 * </p>
 *
 * @author Robert Harder
 * @author rharder@usa.net
 * @version 1.3
 */

/**
 * Base64 converter class. This code is not a complete MIME encoder;
 * it simply converts binary data to base64 data and back.
 *
 * <p>Note {@link CharBase64} is a GWT-compatible implementation of this
 * class.
 */
public class Base64 {
    /** Specify encoding (value is {@code true}). */
    public final static boolean ENCODE = true;

    /** Specify decoding (value is {@code false}). */
    public final static boolean DECODE = false;

    /** The equals sign (=) as a byte. */
    private final static byte EQUALS_SIGN = (byte) '=';

    /** The new line character (\n) as a byte. */
    private final static byte NEW_LINE = (byte) '\n';

    /**
     * The 64 valid Base64 values.
     */
    private final static byte[] ALPHABET =
        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
        (byte) '9', (byte) '+', (byte) '/'};

    /**
     * The 64 valid web safe Base64 values.
     */
    private final static byte[] WEBSAFE_ALPHABET =
        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
        (byte) '9', (byte) '-', (byte) '_'};

    /**
     * Translates a Base64 value to either its 6-bit reconstruction value
     * or a negative number indicating some other meaning.
     **/
    private final static byte[] DECODABET = {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
        -5, -5, // Whitespace: Tab and Linefeed
        -9, -9, // Decimal 11 - 12
        -5, // Whitespace: Carriage Return
        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
        -9, -9, -9, -9, -9, // Decimal 27 - 31
        -5, // Whitespace: Space
        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
        62, // Plus sign at decimal 43
        -9, -9, -9, // Decimal 44 - 46
        63, // Slash at decimal 47
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
        -9, -9, -9, // Decimal 58 - 60
        -1, // Equals sign at decimal 61
        -9, -9, -9, // Decimal 62 - 64
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
        -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
        -9, -9, -9, -9, -9 // Decimal 123 - 127
        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
    };

    /** The web safe decodabet */
    private final static byte[] WEBSAFE_DECODABET =
        {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
        -5, -5, // Whitespace: Tab and Linefeed
        -9, -9, // Decimal 11 - 12
        -5, // Whitespace: Carriage Return
        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
        -9, -9, -9, -9, -9, // Decimal 27 - 31
        -5, // Whitespace: Space
        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 44
        62, // Dash '-' sign at decimal 45
        -9, -9, // Decimal 46-47
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
        -9, -9, -9, // Decimal 58 - 60
        -1, // Equals sign at decimal 61
        -9, -9, -9, // Decimal 62 - 64
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
        -9, -9, -9, -9, // Decimal 91-94
        63, // Underscore '_' at decimal 95
        -9, // Decimal 96
        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
        -9, -9, -9, -9, -9 // Decimal 123 - 127
        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
        };

    // Indicates white space in encoding
    private final static byte WHITE_SPACE_ENC = -5;
    // Indicates equals sign in encoding
    private final static byte EQUALS_SIGN_ENC = -1;

    /** Defeats instantiation. */
    private Base64() {
    }

    /* ********  E N C O D I N G   M E T H O D S  ******** */

    /**
     * Encodes up to three bytes of the array <var>source</var>
     * and writes the resulting four Base64 bytes to <var>destination</var>.
     * The source and destination arrays can be manipulated
     * anywhere along their length by specifying
     * <var>srcOffset</var> and <var>destOffset</var>.
     * This method does not check to make sure your arrays
     * are large enough to accommodate <var>srcOffset</var> + 3 for
     * the <var>source</var> array or <var>destOffset</var> + 4 for
     * the <var>destination</var> array.
     * The actual number of significant bytes in your array is
     * given by <var>numSigBytes</var>.
     *
     * @param source the array to convert
     * @param srcOffset the index where conversion begins
     * @param numSigBytes the number of significant bytes in your array
     * @param destination the array to hold the conversion
     * @param destOffset the index where output will be put
     * @param alphabet is the encoding alphabet
     * @return the <var>destination</var> array
     * @since 1.3
     */
    private static byte[] encode3to4(byte[] source, int srcOffset,
            int numSigBytes, byte[] destination, int destOffset, byte[] alphabet) {
        //           1         2         3
        // 01234567890123456789012345678901 Bit position
        // --------000000001111111122222222 Array position from threeBytes
        // --------|    ||    ||    ||    | Six bit groups to index alphabet
        //          >>18  >>12  >> 6  >> 0  Right shift necessary
        //                0x3f  0x3f  0x3f  Additional AND

        // Create buffer with zero-padding if there are only one or two
        // significant bytes passed in the array.
        // We have to shift left 24 in order to flush out the 1's that appear
        // when Java treats a value as negative that is cast from a byte to an int.
        int inBuff =
                (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0)
                | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0)
                | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);

        switch (numSigBytes) {
            case 3:
                destination[destOffset] = alphabet[(inBuff >>> 18)];
                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = alphabet[(inBuff) & 0x3f];
                return destination;
            case 2:
                destination[destOffset] = alphabet[(inBuff >>> 18)];
                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            case 1:
                destination[destOffset] = alphabet[(inBuff >>> 18)];
                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = EQUALS_SIGN;
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            default:
                return destination;
        } // end switch
    } // end encode3to4

    /**
     * Encodes a byte array into Base64 notation.
     * Equivalent to calling
     * {@code encodeBytes(source, 0, source.length)}
     *
     * @param source The data to convert
     * @since 1.4
     */
    public static String encode(byte[] source) {
        return encode(source, 0, source.length, ALPHABET, true);
    }

    /**
     * Encodes a byte array into web safe Base64 notation.
     *
     * @param source The data to convert
     * @param doPadding is {@code true} to pad result with '=' chars
     *        if it does not fall on 3 byte boundaries
     */
    public static String encodeWebSafe(byte[] source, boolean doPadding) {
        return encode(source, 0, source.length, WEBSAFE_ALPHABET, doPadding);
    }

    /**
     * Encodes a byte array into Base64 notation.
     *
     * @param source the data to convert
     * @param off offset in array where conversion should begin
     * @param len length of data to convert
     * @param alphabet the encoding alphabet
     * @param doPadding is {@code true} to pad result with '=' chars
     * if it does not fall on 3 byte boundaries
     * @since 1.4
     */
    public static String encode(byte[] source, int off, int len, byte[] alphabet,
            boolean doPadding) {
        byte[] outBuff = encode(source, off, len, alphabet, Integer.MAX_VALUE);
        int outLen = outBuff.length;

        // If doPadding is false, set length to truncate '='
        // padding characters
        while (doPadding == false && outLen > 0) {
            if (outBuff[outLen - 1] != '=') {
                break;
            }
            outLen -= 1;
        }

        return new String(outBuff, 0, outLen);
    }

    /**
     * Encodes a byte array into Base64 notation.
     *
     * @param source the data to convert
     * @param off offset in array where conversion should begin
     * @param len length of data to convert
     * @param alphabet is the encoding alphabet
     * @param maxLineLength maximum length of one line.
     * @return the BASE64-encoded byte array
     */
    public static byte[] encode(byte[] source, int off, int len, byte[] alphabet,
            int maxLineLength) {
        int lenDiv3 = (len + 2) / 3; // ceil(len / 3)
        int len43 = lenDiv3 * 4;
        byte[] outBuff = new byte[len43 // Main 4:3
                                  + (len43 / maxLineLength)]; // New lines

        int d = 0;
        int e = 0;
        int len2 = len - 2;
        int lineLength = 0;
        for (; d < len2; d += 3, e += 4) {

            // The following block of code is the same as
            // encode3to4( source, d + off, 3, outBuff, e, alphabet );
            // but inlined for faster encoding (~20% improvement)
            int inBuff =
                    ((source[d + off] << 24) >>> 8)
                    | ((source[d + 1 + off] << 24) >>> 16)
                    | ((source[d + 2 + off] << 24) >>> 24);
            outBuff[e] = alphabet[(inBuff >>> 18)];
            outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];
            outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];
            outBuff[e + 3] = alphabet[(inBuff) & 0x3f];

            lineLength += 4;
            if (lineLength == maxLineLength) {
                outBuff[e + 4] = NEW_LINE;
                e++;
                lineLength = 0;
            } // end if: end of line
        } // end for: each piece of array

        if (d < len) {
            encode3to4(source, d + off, len - d, outBuff, e, alphabet);

            lineLength += 4;
            if (lineLength == maxLineLength) {
                // Add a last newline
                outBuff[e + 4] = NEW_LINE;
                e++;
            }
            e += 4;
        }

        assert (e == outBuff.length);
        return outBuff;
    }


    /* ********  D E C O D I N G   M E T H O D S  ******** */


    /**
     * Decodes four bytes from array <var>source</var>
     * and writes the resulting bytes (up to three of them)
     * to <var>destination</var>.
     * The source and destination arrays can be manipulated
     * anywhere along their length by specifying
     * <var>srcOffset</var> and <var>destOffset</var>.
     * This method does not check to make sure your arrays
     * are large enough to accommodate <var>srcOffset</var> + 4 for
     * the <var>source</var> array or <var>destOffset</var> + 3 for
     * the <var>destination</var> array.
     * This method returns the actual number of bytes that
     * were converted from the Base64 encoding.
     *
     *
     * @param source the array to convert
     * @param srcOffset the index where conversion begins
     * @param destination the array to hold the conversion
     * @param destOffset the index where output will be put
     * @param decodabet the decodabet for decoding Base64 content
     * @return the number of decoded bytes converted
     * @since 1.3
     */
    private static int decode4to3(byte[] source, int srcOffset,
            byte[] destination, int destOffset, byte[] decodabet) {
        // Example: Dk==
        if (source[srcOffset + 2] == EQUALS_SIGN) {
            int outBuff =
                    ((decodabet[source[srcOffset]] << 24) >>> 6)
                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12);

            destination[destOffset] = (byte) (outBuff >>> 16);
            return 1;
        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
            // Example: DkL=
            int outBuff =
                    ((decodabet[source[srcOffset]] << 24) >>> 6)
                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18);

            destination[destOffset] = (byte) (outBuff >>> 16);
            destination[destOffset + 1] = (byte) (outBuff >>> 8);
            return 2;
        } else {
            // Example: DkLE
            int outBuff =
                    ((decodabet[source[srcOffset]] << 24) >>> 6)
                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18)
                    | ((decodabet[source[srcOffset + 3]] << 24) >>> 24);

            destination[destOffset] = (byte) (outBuff >> 16);
            destination[destOffset + 1] = (byte) (outBuff >> 8);
            destination[destOffset + 2] = (byte) (outBuff);
            return 3;
        }
    } // end decodeToBytes


    /**
     * Decodes data from Base64 notation.
     *
     * @param s the string to decode (decoded in default encoding)
     * @return the decoded data
     * @since 1.4
     */
    public static byte[] decode(String s) throws Base64DecoderException {
        byte[] bytes = s.getBytes();
        return decode(bytes, 0, bytes.length);
    }

    /**
     * Decodes data from web safe Base64 notation.
     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
     *
     * @param s the string to decode (decoded in default encoding)
     * @return the decoded data
     */
    public static byte[] decodeWebSafe(String s) throws Base64DecoderException {
        byte[] bytes = s.getBytes();
        return decodeWebSafe(bytes, 0, bytes.length);
    }

    /**
     * Decodes Base64 content in byte array format and returns
     * the decoded byte array.
     *
     * @param source The Base64 encoded data
     * @return decoded data
     * @since 1.3
     * @throws Base64DecoderException
     */
    public static byte[] decode(byte[] source) throws Base64DecoderException {
        return decode(source, 0, source.length);
    }

    /**
     * Decodes web safe Base64 content in byte array format and returns
     * the decoded data.
     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
     *
     * @param source the string to decode (decoded in default encoding)
     * @return the decoded data
     */
    public static byte[] decodeWebSafe(byte[] source)
            throws Base64DecoderException {
        return decodeWebSafe(source, 0, source.length);
    }

    /**
     * Decodes Base64 content in byte array format and returns
     * the decoded byte array.
     *
     * @param source the Base64 encoded data
     * @param off    the offset of where to begin decoding
     * @param len    the length of characters to decode
     * @return decoded data
     * @since 1.3
     * @throws Base64DecoderException
     */
    public static byte[] decode(byte[] source, int off, int len)
            throws Base64DecoderException {
        return decode(source, off, len, DECODABET);
    }

    /**
     * Decodes web safe Base64 content in byte array format and returns
     * the decoded byte array.
     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
     *
     * @param source the Base64 encoded data
     * @param off    the offset of where to begin decoding
     * @param len    the length of characters to decode
     * @return decoded data
     */
    public static byte[] decodeWebSafe(byte[] source, int off, int len)
            throws Base64DecoderException {
        return decode(source, off, len, WEBSAFE_DECODABET);
    }

    /**
     * Decodes Base64 content using the supplied decodabet and returns
     * the decoded byte array.
     *
     * @param source the Base64 encoded data
     * @param off the offset of where to begin decoding
     * @param len the length of characters to decode
     * @param decodabet the decodabet for decoding Base64 content
     * @return decoded data
     */
    public static byte[] decode(byte[] source, int off, int len, byte[] decodabet)
            throws Base64DecoderException {
        int len34 = len * 3 / 4;
        byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output
        int outBuffPosn = 0;

        byte[] b4 = new byte[4];
        int b4Posn = 0;
        int i = 0;
        byte sbiCrop = 0;
        byte sbiDecode = 0;
        for (i = 0; i < len; i++) {
            sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits
            sbiDecode = decodabet[sbiCrop];

            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better
                if (sbiDecode >= EQUALS_SIGN_ENC) {
                    // An equals sign (for padding) must not occur at position 0 or 1
                    // and must be the last byte[s] in the encoded value
                    if (sbiCrop == EQUALS_SIGN) {
                        int bytesLeft = len - i;
                        byte lastByte = (byte) (source[len - 1 + off] & 0x7f);
                        if (b4Posn == 0 || b4Posn == 1) {
                            throw new Base64DecoderException(
                                    "invalid padding byte '=' at byte offset " + i);
                        } else if ((b4Posn == 3 && bytesLeft > 2)
                                || (b4Posn == 4 && bytesLeft > 1)) {
                            throw new Base64DecoderException(
                                    "padding byte '=' falsely signals end of encoded value "
                                            + "at offset " + i);
                        } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {
                            throw new Base64DecoderException(
                                    "encoded value has invalid trailing byte");
                        }
                        break;
                    }

                    b4[b4Posn++] = sbiCrop;
                    if (b4Posn == 4) {
                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
                        b4Posn = 0;
                    }
                }
            } else {
                throw new Base64DecoderException("Bad Base64 input character at " + i
                        + ": " + source[i + off] + "(decimal)");
            }
        }

        // Because web safe encoding allows non padding base64 encodes, we
        // need to pad the rest of the b4 buffer with equal signs when
        // b4Posn != 0.  There can be at most 2 equal signs at the end of
        // four characters, so the b4 buffer must have two or three
        // characters.  This also catches the case where the input is
        // padded with EQUALS_SIGN
        if (b4Posn != 0) {
            if (b4Posn == 1) {
                throw new Base64DecoderException("single trailing character at offset "
                        + (len - 1));
            }
            b4[b4Posn++] = EQUALS_SIGN;
            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
        }

        byte[] out = new byte[outBuffPosn];
        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
        return out;
    }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Copyright 2002, Google, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.jams.music.player.InAppBilling;

/**
 * Exception thrown when encountering an invalid Base64 input character.
 *
 * @author nelson
 */
public class Base64DecoderException extends Exception {
    public Base64DecoderException() {
        super();
    }

    public Base64DecoderException(String s) {
        super(s);
    }

    private static final long serialVersionUID = 1L;
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Copyright (c) 2012 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jams.music.player.InAppBilling;

/**
 * Exception thrown when something went wrong with in-app billing.
 * An IabException has an associated IabResult (an error).
 * To get the IAB result that caused this exception to be thrown,
 * call {@link #getResult()}.
 */
public class IabException extends Exception {
    IabResult mResult;

    public IabException(IabResult r) {
        this(r, null);
    }
    public IabException(int response, String message) {
        this(new IabResult(response, message));
    }
    public IabException(IabResult r, Exception cause) {
        super(r.getMessage(), cause);
        mResult = r;
    }
    public IabException(int response, String message, Exception cause) {
        this(new IabResult(response, message), cause);
    }

    /** Returns the IAB result (error) that this exception signals. */
    public IabResult getResult() { return mResult; }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Copyright (c) 2012 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jams.music.player.InAppBilling;

import java.util.ArrayList;
import java.util.List;

import org.json.JSONException;

import android.app.Activity;
import android.app.PendingIntent;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentSender.SendIntentException;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.RemoteException;
import android.text.TextUtils;
import android.util.Log;

import com.android.vending.billing.IInAppBillingService;


/**
 * Provides convenience methods for in-app billing. You can create one instance of this
 * class for your application and use it to process in-app billing operations.
 * It provides synchronous (blocking) and asynchronous (non-blocking) methods for
 * many common in-app billing operations, as well as automatic signature
 * verification.
 *
 * After instantiating, you must perform setup in order to start using the object.
 * To perform setup, call the {@link #startSetup} method and provide a listener;
 * that listener will be notified when setup is complete, after which (and not before)
 * you may call other methods.
 *
 * After setup is complete, you will typically want to request an inventory of owned
 * items and subscriptions. See {@link #queryInventory}, {@link #queryInventoryAsync}
 * and related methods.
 *
 * When you are done with this object, don't forget to call {@link #dispose}
 * to ensure proper cleanup. This object holds a binding to the in-app billing
 * service, which will leak unless you dispose of it correctly. If you created
 * the object on an Activity's onCreate method, then the recommended
 * place to dispose of it is the Activity's onDestroy method.
 *
 * A note about threading: When using this object from a background thread, you may
 * call the blocking versions of methods; when using from a UI thread, call
 * only the asynchronous versions and handle the results via callbacks.
 * Also, notice that you can only call one asynchronous operation at a time;
 * attempting to start a second asynchronous operation while the first one
 * has not yet completed will result in an exception being thrown.
 *
 * @author Bruno Oliveira (Google)
 *
 */
public class IabHelper {
    // Is debug logging enabled?
    boolean mDebugLog = false;
    String mDebugTag = "IabHelper";

    // Is setup done?
    boolean mSetupDone = false;

    // Has this object been disposed of? (If so, we should ignore callbacks, etc)
    boolean mDisposed = false;

    // Are subscriptions supported?
    boolean mSubscriptionsSupported = false;

    // Is an asynchronous operation in progress?
    // (only one at a time can be in progress)
    boolean mAsyncInProgress = false;

    // (for logging/debugging)
    // if mAsyncInProgress == true, what asynchronous operation is in progress?
    String mAsyncOperation = "";

    // Context we were passed during initialization
    Context mContext;

    // Connection to the service
    IInAppBillingService mService;
    ServiceConnection mServiceConn;

    // The request code used to launch purchase flow
    int mRequestCode;

    // The item type of the current purchase flow
    String mPurchasingItemType;

    // Public key for verifying signature, in base64 encoding
    String mSignatureBase64 = null;

    // Billing response codes
    public static final int BILLING_RESPONSE_RESULT_OK = 0;
    public static final int BILLING_RESPONSE_RESULT_USER_CANCELED = 1;
    public static final int BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE = 3;
    public static final int BILLING_RESPONSE_RESULT_ITEM_UNAVAILABLE = 4;
    public static final int BILLING_RESPONSE_RESULT_DEVELOPER_ERROR = 5;
    public static final int BILLING_RESPONSE_RESULT_ERROR = 6;
    public static final int BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED = 7;
    public static final int BILLING_RESPONSE_RESULT_ITEM_NOT_OWNED = 8;

    // IAB Helper error codes
    public static final int IABHELPER_ERROR_BASE = -1000;
    public static final int IABHELPER_REMOTE_EXCEPTION = -1001;
    public static final int IABHELPER_BAD_RESPONSE = -1002;
    public static final int IABHELPER_VERIFICATION_FAILED = -1003;
    public static final int IABHELPER_SEND_INTENT_FAILED = -1004;
    public static final int IABHELPER_USER_CANCELLED = -1005;
    public static final int IABHELPER_UNKNOWN_PURCHASE_RESPONSE = -1006;
    public static final int IABHELPER_MISSING_TOKEN = -1007;
    public static final int IABHELPER_UNKNOWN_ERROR = -1008;
    public static final int IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE = -1009;
    public static final int IABHELPER_INVALID_CONSUMPTION = -1010;

    // Keys for the responses from InAppBillingService
    public static final String RESPONSE_CODE = "RESPONSE_CODE";
    public static final String RESPONSE_GET_SKU_DETAILS_LIST = "DETAILS_LIST";
    public static final String RESPONSE_BUY_INTENT = "BUY_INTENT";
    public static final String RESPONSE_INAPP_PURCHASE_DATA = "INAPP_PURCHASE_DATA";
    public static final String RESPONSE_INAPP_SIGNATURE = "INAPP_DATA_SIGNATURE";
    public static final String RESPONSE_INAPP_ITEM_LIST = "INAPP_PURCHASE_ITEM_LIST";
    public static final String RESPONSE_INAPP_PURCHASE_DATA_LIST = "INAPP_PURCHASE_DATA_LIST";
    public static final String RESPONSE_INAPP_SIGNATURE_LIST = "INAPP_DATA_SIGNATURE_LIST";
    public static final String INAPP_CONTINUATION_TOKEN = "INAPP_CONTINUATION_TOKEN";

    // Item types
    public static final String ITEM_TYPE_INAPP = "inapp";
    public static final String ITEM_TYPE_SUBS = "subs";

    // some fields on the getSkuDetails response bundle
    public static final String GET_SKU_DETAILS_ITEM_LIST = "ITEM_ID_LIST";
    public static final String GET_SKU_DETAILS_ITEM_TYPE_LIST = "ITEM_TYPE_LIST";

    /**
     * Creates an instance. After creation, it will not yet be ready to use. You must perform
     * setup by calling {@link #startSetup} and wait for setup to complete. This constructor does not
     * block and is safe to call from a UI thread.
     *
     * @param ctx Your application or Activity context. Needed to bind to the in-app billing service.
     * @param base64PublicKey Your application's public key, encoded in base64.
     *     This is used for verification of purchase signatures. You can find your app's base64-encoded
     *     public key in your application's page on Google Play Developer Console. Note that this
     *     is NOT your "developer public key".
     */
    public IabHelper(Context ctx, String base64PublicKey) {
        mContext = ctx.getApplicationContext();
        mSignatureBase64 = base64PublicKey;
        logDebug("IAB helper created.");
    }

    /**
     * Enables or disable debug logging through LogCat.
     */
    public void enableDebugLogging(boolean enable, String tag) {
        checkNotDisposed();
        mDebugLog = enable;
        mDebugTag = tag;
    }

    public void enableDebugLogging(boolean enable) {
        checkNotDisposed();
        mDebugLog = enable;
    }

    /**
     * Callback for setup process. This listener's {@link #onIabSetupFinished} method is called
     * when the setup process is complete.
     */
    public interface OnIabSetupFinishedListener {
        /**
         * Called to notify that setup is complete.
         *
         * @param result The result of the setup process.
         */
        public void onIabSetupFinished(IabResult result);
    }

    /**
     * Starts the setup process. This will start up the setup process asynchronously.
     * You will be notified through the listener when the setup process is complete.
     * This method is safe to call from a UI thread.
     *
     * @param listener The listener to notify when the setup process is complete.
     */
    public void startSetup(final OnIabSetupFinishedListener listener) {
        // If already set up, can't do it again.
        checkNotDisposed();
        if (mSetupDone) throw new IllegalStateException("IAB helper is already set up.");

        // Connection to IAB service
        logDebug("Starting in-app billing setup.");
        mServiceConn = new ServiceConnection() {
            @Override
            public void onServiceDisconnected(ComponentName name) {
                logDebug("Billing service disconnected.");
                mService = null;
            }

            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                if (mDisposed) return;
                logDebug("Billing service connected.");
                mService = IInAppBillingService.Stub.asInterface(service);
                String packageName = mContext.getPackageName();
                try {
                    logDebug("Checking for in-app billing 3 support.");

                    // check for in-app billing v3 support
                    int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);
                    if (response != BILLING_RESPONSE_RESULT_OK) {
                        if (listener != null) listener.onIabSetupFinished(new IabResult(response,
                                "Error checking for billing v3 support."));

                        // if in-app purchases aren't supported, neither are subscriptions.
                        mSubscriptionsSupported = false;
                        return;
                    }
                    logDebug("In-app billing version 3 supported for " + packageName);

                    // check for v3 subscriptions support
                    response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);
                    if (response == BILLING_RESPONSE_RESULT_OK) {
                        logDebug("Subscriptions AVAILABLE.");
                        mSubscriptionsSupported = true;
                    }
                    else {
                        logDebug("Subscriptions NOT AVAILABLE. Response: " + response);
                    }

                    mSetupDone = true;
                }
                catch (RemoteException e) {
                    if (listener != null) {
                        listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION,
                                                    "RemoteException while setting up in-app billing."));
                    }
                    e.printStackTrace();
                    return;
                }

                if (listener != null) {
                    listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Setup successful."));
                }
            }
        };

        Intent serviceIntent = new Intent("com.android.vending.billing.InAppBillingService.BIND");
        serviceIntent.setPackage("com.android.vending");
        if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {
            // service available to handle that Intent
            mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);
        }
        else {
            // no service available to handle that Intent
            if (listener != null) {
                listener.onIabSetupFinished(
                        new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
                        "Billing service unavailable on device."));
            }
        }
    }

    /**
     * Dispose of object, releasing resources. It's very important to call this
     * method when you are done with this object. It will release any resources
     * used by it such as service connections. Naturally, once the object is
     * disposed of, it can't be used again.
     */
    public void dispose() {
        logDebug("Disposing.");
        mSetupDone = false;
        if (mServiceConn != null) {
            logDebug("Unbinding from service.");
            if (mContext != null) mContext.unbindService(mServiceConn);
        }
        mDisposed = true;
        mContext = null;
        mServiceConn = null;
        mService = null;
        mPurchaseListener = null;
    }

    private void checkNotDisposed() {
        if (mDisposed) throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
    }

    /** Returns whether subscriptions are supported. */
    public boolean subscriptionsSupported() {
        checkNotDisposed();
        return mSubscriptionsSupported;
    }


    /**
     * Callback that notifies when a purchase is finished.
     */
    public interface OnIabPurchaseFinishedListener {
        /**
         * Called to notify that an in-app purchase finished. If the purchase was successful,
         * then the sku parameter specifies which item was purchased. If the purchase failed,
         * the sku and extraData parameters may or may not be null, depending on how far the purchase
         * process went.
         *
         * @param result The result of the purchase.
         * @param info The purchase information (null if purchase failed)
         */
        public void onIabPurchaseFinished(IabResult result, Purchase info);
    }

    // The listener registered on launchPurchaseFlow, which we have to call back when
    // the purchase finishes
    OnIabPurchaseFinishedListener mPurchaseListener;

    public void launchPurchaseFlow(Activity act, String sku, int requestCode, OnIabPurchaseFinishedListener listener) {
        launchPurchaseFlow(act, sku, requestCode, listener, "");
    }

    public void launchPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener, String extraData) {
        launchPurchaseFlow(act, sku, ITEM_TYPE_INAPP, requestCode, listener, extraData);
    }

    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener) {
        launchSubscriptionPurchaseFlow(act, sku, requestCode, listener, "");
    }

    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener, String extraData) {
        launchPurchaseFlow(act, sku, ITEM_TYPE_SUBS, requestCode, listener, extraData);
    }

    /**
     * Initiate the UI flow for an in-app purchase. Call this method to initiate an in-app purchase,
     * which will involve bringing up the Google Play screen. The calling activity will be paused while
     * the user interacts with Google Play, and the result will be delivered via the activity's
     * {@link android.app.Activity#onActivityResult} method, at which point you must call
     * this object's {@link #handleActivityResult} method to continue the purchase flow. This method
     * MUST be called from the UI thread of the Activity.
     *
     * @param act The calling activity.
     * @param sku The sku of the item to purchase.
     * @param itemType indicates if it's a product or a subscription (ITEM_TYPE_INAPP or ITEM_TYPE_SUBS)
     * @param requestCode A request code (to differentiate from other responses --
     *     as in {@link android.app.Activity#startActivityForResult}).
     * @param listener The listener to notify when the purchase process finishes
     * @param extraData Extra data (developer payload), which will be returned with the purchase data
     *     when the purchase completes. This extra data will be permanently bound to that purchase
     *     and will always be returned when the purchase is queried.
     */
    public void launchPurchaseFlow(Activity act, String sku, String itemType, int requestCode,
                        OnIabPurchaseFinishedListener listener, String extraData) {
        checkNotDisposed();
        checkSetupDone("launchPurchaseFlow");
        flagStartAsync("launchPurchaseFlow");
        IabResult result;

        if (itemType.equals(ITEM_TYPE_SUBS) && !mSubscriptionsSupported) {
            IabResult r = new IabResult(IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE,
                    "Subscriptions are not available.");
            flagEndAsync();
            if (listener != null) listener.onIabPurchaseFinished(r, null);
            return;
        }

        try {
            logDebug("Constructing buy intent for " + sku + ", item type: " + itemType);
            Bundle buyIntentBundle = mService.getBuyIntent(3, mContext.getPackageName(), sku, itemType, extraData);
            int response = getResponseCodeFromBundle(buyIntentBundle);
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logError("Unable to buy item, Error response: " + getResponseDesc(response));
                flagEndAsync();
                result = new IabResult(response, "Unable to buy item");
                if (listener != null) listener.onIabPurchaseFinished(result, null);
                return;
            }

            PendingIntent pendingIntent = buyIntentBundle.getParcelable(RESPONSE_BUY_INTENT);
            logDebug("Launching buy intent for " + sku + ". Request code: " + requestCode);
            mRequestCode = requestCode;
            mPurchaseListener = listener;
            mPurchasingItemType = itemType;
            act.startIntentSenderForResult(pendingIntent.getIntentSender(),
                                           requestCode, new Intent(),
                                           Integer.valueOf(0), Integer.valueOf(0),
                                           Integer.valueOf(0));
        }
        catch (SendIntentException e) {
            logError("SendIntentException while launching purchase flow for sku " + sku);
            e.printStackTrace();
            flagEndAsync();

            result = new IabResult(IABHELPER_SEND_INTENT_FAILED, "Failed to send intent.");
            if (listener != null) listener.onIabPurchaseFinished(result, null);
        }
        catch (RemoteException e) {
            logError("RemoteException while launching purchase flow for sku " + sku);
            e.printStackTrace();
            flagEndAsync();

            result = new IabResult(IABHELPER_REMOTE_EXCEPTION, "Remote exception while starting purchase flow");
            if (listener != null) listener.onIabPurchaseFinished(result, null);
        }
    }

    /**
     * Handles an activity result that's part of the purchase flow in in-app billing. If you
     * are calling {@link #launchPurchaseFlow}, then you must call this method from your
     * Activity's {@link android.app.Activity@onActivityResult} method. This method
     * MUST be called from the UI thread of the Activity.
     *
     * @param requestCode The requestCode as you received it.
     * @param resultCode The resultCode as you received it.
     * @param data The data (Intent) as you received it.
     * @return Returns true if the result was related to a purchase flow and was handled;
     *     false if the result was not related to a purchase, in which case you should
     *     handle it normally.
     */
    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
        IabResult result;
        if (requestCode != mRequestCode) return false;

        checkNotDisposed();
        checkSetupDone("handleActivityResult");

        // end of async purchase operation that started on launchPurchaseFlow
        flagEndAsync();

        if (data == null) {
            logError("Null data in IAB activity result.");
            result = new IabResult(IABHELPER_BAD_RESPONSE, "Null data in IAB result");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
            return true;
        }

        int responseCode = getResponseCodeFromIntent(data);
        String purchaseData = data.getStringExtra(RESPONSE_INAPP_PURCHASE_DATA);
        String dataSignature = data.getStringExtra(RESPONSE_INAPP_SIGNATURE);

        if (resultCode == Activity.RESULT_OK && responseCode == BILLING_RESPONSE_RESULT_OK) {
            logDebug("Successful resultcode from purchase activity.");
            logDebug("Purchase data: " + purchaseData);
            logDebug("Data signature: " + dataSignature);
            logDebug("Extras: " + data.getExtras());
            logDebug("Expected item type: " + mPurchasingItemType);

            if (purchaseData == null || dataSignature == null) {
                logError("BUG: either purchaseData or dataSignature is null.");
                logDebug("Extras: " + data.getExtras().toString());
                result = new IabResult(IABHELPER_UNKNOWN_ERROR, "IAB returned null purchaseData or dataSignature");
                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
                return true;
            }

            Purchase purchase = null;
            try {
                purchase = new Purchase(mPurchasingItemType, purchaseData, dataSignature);
                String sku = purchase.getSku();

                // Verify signature
                if (!Security.verifyPurchase(mSignatureBase64, purchaseData, dataSignature)) {
                    logError("Purchase signature verification FAILED for sku " + sku);
                    result = new IabResult(IABHELPER_VERIFICATION_FAILED, "Signature verification failed for sku " + sku);
                    if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, purchase);
                    return true;
                }
                logDebug("Purchase signature successfully verified.");
            }
            catch (JSONException e) {
                logError("Failed to parse purchase data.");
                e.printStackTrace();
                result = new IabResult(IABHELPER_BAD_RESPONSE, "Failed to parse purchase data.");
                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
                return true;
            }

            if (mPurchaseListener != null) {
                mPurchaseListener.onIabPurchaseFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Success"), purchase);
            }
        }
        else if (resultCode == Activity.RESULT_OK) {
            // result code was OK, but in-app billing response was not OK.
            logDebug("Result code was OK but in-app billing response was not OK: " + getResponseDesc(responseCode));
            if (mPurchaseListener != null) {
                result = new IabResult(responseCode, "Problem purchashing item.");
                mPurchaseListener.onIabPurchaseFinished(result, null);
            }
        }
        else if (resultCode == Activity.RESULT_CANCELED) {
            logDebug("Purchase canceled - Response: " + getResponseDesc(responseCode));
            result = new IabResult(IABHELPER_USER_CANCELLED, "User canceled.");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
        }
        else {
            logError("Purchase failed. Result code: " + Integer.toString(resultCode)
                    + ". Response: " + getResponseDesc(responseCode));
            result = new IabResult(IABHELPER_UNKNOWN_PURCHASE_RESPONSE, "Unknown purchase response.");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
        }
        return true;
    }

    public Inventory queryInventory(boolean querySkuDetails, List<String> moreSkus) throws IabException {
        return queryInventory(querySkuDetails, moreSkus, null);
    }

    /**
     * Queries the inventory. This will query all owned items from the server, as well as
     * information on additional skus, if specified. This method may block or take long to execute.
     * Do not call from a UI thread. For that, use the non-blocking version {@link #refreshInventoryAsync}.
     *
     * @param querySkuDetails if true, SKU details (price, description, etc) will be queried as well
     *     as purchase information.
     * @param moreItemSkus additional PRODUCT skus to query information on, regardless of ownership.
     *     Ignored if null or if querySkuDetails is false.
     * @param moreSubsSkus additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
     *     Ignored if null or if querySkuDetails is false.
     * @throws IabException if a problem occurs while refreshing the inventory.
     */
    public Inventory queryInventory(boolean querySkuDetails, List<String> moreItemSkus,
                                        List<String> moreSubsSkus) throws IabException {
        checkNotDisposed();
        checkSetupDone("queryInventory");
        try {
            Inventory inv = new Inventory();
            int r = queryPurchases(inv, ITEM_TYPE_INAPP);
            if (r != BILLING_RESPONSE_RESULT_OK) {
                throw new IabException(r, "Error refreshing inventory (querying owned items).");
            }

            if (querySkuDetails) {
                r = querySkuDetails(ITEM_TYPE_INAPP, inv, moreItemSkus);
                if (r != BILLING_RESPONSE_RESULT_OK) {
                    throw new IabException(r, "Error refreshing inventory (querying prices of items).");
                }
            }

            // if subscriptions are supported, then also query for subscriptions
            if (mSubscriptionsSupported) {
                r = queryPurchases(inv, ITEM_TYPE_SUBS);
                if (r != BILLING_RESPONSE_RESULT_OK) {
                    throw new IabException(r, "Error refreshing inventory (querying owned subscriptions).");
                }

                if (querySkuDetails) {
                    r = querySkuDetails(ITEM_TYPE_SUBS, inv, moreItemSkus);
                    if (r != BILLING_RESPONSE_RESULT_OK) {
                        throw new IabException(r, "Error refreshing inventory (querying prices of subscriptions).");
                    }
                }
            }

            return inv;
        }
        catch (RemoteException e) {
            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while refreshing inventory.", e);
        }
        catch (JSONException e) {
            throw new IabException(IABHELPER_BAD_RESPONSE, "Error parsing JSON response while refreshing inventory.", e);
        }
    }

    /**
     * Listener that notifies when an inventory query operation completes.
     */
    public interface QueryInventoryFinishedListener {
        /**
         * Called to notify that an inventory query operation completed.
         *
         * @param result The result of the operation.
         * @param inv The inventory.
         */
        public void onQueryInventoryFinished(IabResult result, Inventory inv);
    }


    /**
     * Asynchronous wrapper for inventory query. This will perform an inventory
     * query as described in {@link #queryInventory}, but will do so asynchronously
     * and call back the specified listener upon completion. This method is safe to
     * call from a UI thread.
     *
     * @param querySkuDetails as in {@link #queryInventory}
     * @param moreSkus as in {@link #queryInventory}
     * @param listener The listener to notify when the refresh operation completes.
     */
    public void queryInventoryAsync(final boolean querySkuDetails,
                               final List<String> moreSkus,
                               final QueryInventoryFinishedListener listener) {
        final Handler handler = new Handler();
        checkNotDisposed();
        checkSetupDone("queryInventory");
        flagStartAsync("refresh inventory");
        (new Thread(new Runnable() {
            public void run() {
                IabResult result = new IabResult(BILLING_RESPONSE_RESULT_OK, "Inventory refresh successful.");
                Inventory inv = null;
                try {
                    inv = queryInventory(querySkuDetails, moreSkus);
                }
                catch (IabException ex) {
                    result = ex.getResult();
                }

                flagEndAsync();

                final IabResult result_f = result;
                final Inventory inv_f = inv;
                if (!mDisposed && listener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            listener.onQueryInventoryFinished(result_f, inv_f);
                        }
                    });
                }
            }
        })).start();
    }

    public void queryInventoryAsync(QueryInventoryFinishedListener listener) {
        queryInventoryAsync(true, null, listener);
    }

    public void queryInventoryAsync(boolean querySkuDetails, QueryInventoryFinishedListener listener) {
        queryInventoryAsync(querySkuDetails, null, listener);
    }


    /**
     * Consumes a given in-app product. Consuming can only be done on an item
     * that's owned, and as a result of consumption, the user will no longer own it.
     * This method may block or take long to return. Do not call from the UI thread.
     * For that, see {@link #consumeAsync}.
     *
     * @param itemInfo The PurchaseInfo that represents the item to consume.
     * @throws IabException if there is a problem during consumption.
     */
    void consume(Purchase itemInfo) throws IabException {
        checkNotDisposed();
        checkSetupDone("consume");

        if (!itemInfo.mItemType.equals(ITEM_TYPE_INAPP)) {
            throw new IabException(IABHELPER_INVALID_CONSUMPTION,
                    "Items of type '" + itemInfo.mItemType + "' can't be consumed.");
        }

        try {
            String token = itemInfo.getToken();
            String sku = itemInfo.getSku();
            if (token == null || token.equals("")) {
               logError("Can't consume "+ sku + ". No token.");
               throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
                   + sku + " " + itemInfo);
            }

            logDebug("Consuming sku: " + sku + ", token: " + token);
            int response = mService.consumePurchase(3, mContext.getPackageName(), token);
            if (response == BILLING_RESPONSE_RESULT_OK) {
               logDebug("Successfully consumed sku: " + sku);
            }
            else {
               logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
               throw new IabException(response, "Error consuming sku " + sku);
            }
        }
        catch (RemoteException e) {
            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + itemInfo, e);
        }
    }

    /**
     * Callback that notifies when a consumption operation finishes.
     */
    public interface OnConsumeFinishedListener {
        /**
         * Called to notify that a consumption has finished.
         *
         * @param purchase The purchase that was (or was to be) consumed.
         * @param result The result of the consumption operation.
         */
        public void onConsumeFinished(Purchase purchase, IabResult result);
    }

    /**
     * Callback that notifies when a multi-item consumption operation finishes.
     */
    public interface OnConsumeMultiFinishedListener {
        /**
         * Called to notify that a consumption of multiple items has finished.
         *
         * @param purchases The purchases that were (or were to be) consumed.
         * @param results The results of each consumption operation, corresponding to each
         *     sku.
         */
        public void onConsumeMultiFinished(List<Purchase> purchases, List<IabResult> results);
    }

    /**
     * Asynchronous wrapper to item consumption. Works like {@link #consume}, but
     * performs the consumption in the background and notifies completion through
     * the provided listener. This method is safe to call from a UI thread.
     *
     * @param purchase The purchase to be consumed.
     * @param listener The listener to notify when the consumption operation finishes.
     */
    public void consumeAsync(Purchase purchase, OnConsumeFinishedListener listener) {
        checkNotDisposed();
        checkSetupDone("consume");
        List<Purchase> purchases = new ArrayList<Purchase>();
        purchases.add(purchase);
        consumeAsyncInternal(purchases, listener, null);
    }

    /**
     * Same as {@link consumeAsync}, but for multiple items at once.
     * @param purchases The list of PurchaseInfo objects representing the purchases to consume.
     * @param listener The listener to notify when the consumption operation finishes.
     */
    public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener) {
        checkNotDisposed();
        checkSetupDone("consume");
        consumeAsyncInternal(purchases, null, listener);
    }

    /**
     * Returns a human-readable description for the given response code.
     *
     * @param code The response code
     * @return A human-readable string explaining the result code.
     *     It also includes the result code numerically.
     */
    public static String getResponseDesc(int code) {
        String[] iab_msgs = ("0:OK/1:User Canceled/2:Unknown/" +
                "3:Billing Unavailable/4:Item unavailable/" +
                "5:Developer Error/6:Error/7:Item Already Owned/" +
                "8:Item not owned").split("/");
        String[] iabhelper_msgs = ("0:OK/-1001:Remote exception during initialization/" +
                                   "-1002:Bad response received/" +
                                   "-1003:Purchase signature verification failed/" +
                                   "-1004:Send intent failed/" +
                                   "-1005:User cancelled/" +
                                   "-1006:Unknown purchase response/" +
                                   "-1007:Missing token/" +
                                   "-1008:Unknown error/" +
                                   "-1009:Subscriptions not available/" +
                                   "-1010:Invalid consumption attempt").split("/");

        if (code <= IABHELPER_ERROR_BASE) {
            int index = IABHELPER_ERROR_BASE - code;
            if (index >= 0 && index < iabhelper_msgs.length) return iabhelper_msgs[index];
            else return String.valueOf(code) + ":Unknown IAB Helper Error";
        }
        else if (code < 0 || code >= iab_msgs.length)
            return String.valueOf(code) + ":Unknown";
        else
            return iab_msgs[code];
    }


    // Checks that setup was done; if not, throws an exception.
    void checkSetupDone(String operation) {
        if (!mSetupDone) {
            logError("Illegal state for operation (" + operation + "): IAB helper is not set up.");
            throw new IllegalStateException("IAB helper is not set up. Can't perform operation: " + operation);
        }
    }

    // Workaround to bug where sometimes response codes come as Long instead of Integer
    int getResponseCodeFromBundle(Bundle b) {
        Object o = b.get(RESPONSE_CODE);
        if (o == null) {
            logDebug("Bundle with null response code, assuming OK (known issue)");
            return BILLING_RESPONSE_RESULT_OK;
        }
        else if (o instanceof Integer) return ((Integer)o).intValue();
        else if (o instanceof Long) return (int)((Long)o).longValue();
        else {
            logError("Unexpected type for bundle response code.");
            logError(o.getClass().getName());
            throw new RuntimeException("Unexpected type for bundle response code: " + o.getClass().getName());
        }
    }

    // Workaround to bug where sometimes response codes come as Long instead of Integer
    int getResponseCodeFromIntent(Intent i) {
        Object o = i.getExtras().get(RESPONSE_CODE);
        if (o == null) {
            logError("Intent with no response code, assuming OK (known issue)");
            return BILLING_RESPONSE_RESULT_OK;
        }
        else if (o instanceof Integer) return ((Integer)o).intValue();
        else if (o instanceof Long) return (int)((Long)o).longValue();
        else {
            logError("Unexpected type for intent response code.");
            logError(o.getClass().getName());
            throw new RuntimeException("Unexpected type for intent response code: " + o.getClass().getName());
        }
    }

    void flagStartAsync(String operation) {
        if (mAsyncInProgress) throw new IllegalStateException("Can't start async operation (" +
                operation + ") because another async operation(" + mAsyncOperation + ") is in progress.");
        mAsyncOperation = operation;
        mAsyncInProgress = true;
        logDebug("Starting async operation: " + operation);
    }

    void flagEndAsync() {
        logDebug("Ending async operation: " + mAsyncOperation);
        mAsyncOperation = "";
        mAsyncInProgress = false;
    }


    int queryPurchases(Inventory inv, String itemType) throws JSONException, RemoteException {
        // Query purchases
        logDebug("Querying owned items, item type: " + itemType);
        logDebug("Package name: " + mContext.getPackageName());
        boolean verificationFailed = false;
        String continueToken = null;

        do {
            logDebug("Calling getPurchases with continuation token: " + continueToken);
            Bundle ownedItems = mService.getPurchases(3, mContext.getPackageName(),
                    itemType, continueToken);

            int response = getResponseCodeFromBundle(ownedItems);
            logDebug("Owned items response: " + String.valueOf(response));
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logDebug("getPurchases() failed: " + getResponseDesc(response));
                return response;
            }
            if (!ownedItems.containsKey(RESPONSE_INAPP_ITEM_LIST)
                    || !ownedItems.containsKey(RESPONSE_INAPP_PURCHASE_DATA_LIST)
                    || !ownedItems.containsKey(RESPONSE_INAPP_SIGNATURE_LIST)) {
                logError("Bundle returned from getPurchases() doesn't contain required fields.");
                return IABHELPER_BAD_RESPONSE;
            }

            ArrayList<String> ownedSkus = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_ITEM_LIST);
            ArrayList<String> purchaseDataList = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_PURCHASE_DATA_LIST);
            ArrayList<String> signatureList = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_SIGNATURE_LIST);

            for (int i = 0; i < purchaseDataList.size(); ++i) {
                String purchaseData = purchaseDataList.get(i);
                String signature = signatureList.get(i);
                String sku = ownedSkus.get(i);
                if (Security.verifyPurchase(mSignatureBase64, purchaseData, signature)) {
                    logDebug("Sku is owned: " + sku);
                    Purchase purchase = new Purchase(itemType, purchaseData, signature);

                    if (TextUtils.isEmpty(purchase.getToken())) {
                        logWarn("BUG: empty/null token!");
                        logDebug("Purchase data: " + purchaseData);
                    }

                    // Record ownership and token
                    inv.addPurchase(purchase);
                }
                else {
                    logWarn("Purchase signature verification **FAILED**. Not adding item.");
                    logDebug("   Purchase data: " + purchaseData);
                    logDebug("   Signature: " + signature);
                    verificationFailed = true;
                }
            }

            continueToken = ownedItems.getString(INAPP_CONTINUATION_TOKEN);
            logDebug("Continuation token: " + continueToken);
        } while (!TextUtils.isEmpty(continueToken));

        return verificationFailed ? IABHELPER_VERIFICATION_FAILED : BILLING_RESPONSE_RESULT_OK;
    }

    int querySkuDetails(String itemType, Inventory inv, List<String> moreSkus)
                                throws RemoteException, JSONException {
        logDebug("Querying SKU details.");
        ArrayList<String> skuList = new ArrayList<String>();
        skuList.addAll(inv.getAllOwnedSkus(itemType));
        if (moreSkus != null) {
            for (String sku : moreSkus) {
                if (!skuList.contains(sku)) {
                    skuList.add(sku);
                }
            }
        }

        if (skuList.size() == 0) {
            logDebug("queryPrices: nothing to do because there are no SKUs.");
            return BILLING_RESPONSE_RESULT_OK;
        }

        Bundle querySkus = new Bundle();
        querySkus.putStringArrayList(GET_SKU_DETAILS_ITEM_LIST, skuList);
        Bundle skuDetails = mService.getSkuDetails(3, mContext.getPackageName(),
                itemType, querySkus);

        if (!skuDetails.containsKey(RESPONSE_GET_SKU_DETAILS_LIST)) {
            int response = getResponseCodeFromBundle(skuDetails);
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logDebug("getSkuDetails() failed: " + getResponseDesc(response));
                return response;
            }
            else {
                logError("getSkuDetails() returned a bundle with neither an error nor a detail list.");
                return IABHELPER_BAD_RESPONSE;
            }
        }

        ArrayList<String> responseList = skuDetails.getStringArrayList(
                RESPONSE_GET_SKU_DETAILS_LIST);

        for (String thisResponse : responseList) {
            SkuDetails d = new SkuDetails(itemType, thisResponse);
            logDebug("Got sku details: " + d);
            inv.addSkuDetails(d);
        }
        return BILLING_RESPONSE_RESULT_OK;
    }


    void consumeAsyncInternal(final List<Purchase> purchases,
                              final OnConsumeFinishedListener singleListener,
                              final OnConsumeMultiFinishedListener multiListener) {
        final Handler handler = new Handler();
        flagStartAsync("consume");
        (new Thread(new Runnable() {
            public void run() {
                final List<IabResult> results = new ArrayList<IabResult>();
                for (Purchase purchase : purchases) {
                    try {
                        consume(purchase);
                        results.add(new IabResult(BILLING_RESPONSE_RESULT_OK, "Successful consume of sku " + purchase.getSku()));
                    }
                    catch (IabException ex) {
                        results.add(ex.getResult());
                    }
                }

                flagEndAsync();
                if (!mDisposed && singleListener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            singleListener.onConsumeFinished(purchases.get(0), results.get(0));
                        }
                    });
                }
                if (!mDisposed && multiListener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            multiListener.onConsumeMultiFinished(purchases, results);
                        }
                    });
                }
            }
        })).start();
    }

    void logDebug(String msg) {
        if (mDebugLog) Log.d(mDebugTag, msg);
    }

    void logError(String msg) {
        Log.e(mDebugTag, "In-app billing error: " + msg);
    }

    void logWarn(String msg) {
        Log.w(mDebugTag, "In-app billing warning: " + msg);
    }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Copyright (c) 2012 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jams.music.player.InAppBilling;

/**
 * Represents the result of an in-app billing operation.
 * A result is composed of a response code (an integer) and possibly a
 * message (String). You can get those by calling
 * {@link #getResponse} and {@link #getMessage()}, respectively. You
 * can also inquire whether a result is a success or a failure by
 * calling {@link #isSuccess()} and {@link #isFailure()}.
 */
public class IabResult {
    int mResponse;
    String mMessage;

    public IabResult(int response, String message) {
        mResponse = response;
        if (message == null || message.trim().length() == 0) {
            mMessage = IabHelper.getResponseDesc(response);
        }
        else {
            mMessage = message + " (response: " + IabHelper.getResponseDesc(response) + ")";
        }
    }
    public int getResponse() { return mResponse; }
    public String getMessage() { return mMessage; }
    public boolean isSuccess() { return mResponse == IabHelper.BILLING_RESPONSE_RESULT_OK; }
    public boolean isFailure() { return !isSuccess(); }
    public String toString() { return "IabResult: " + getMessage(); }
}


@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Copyright (c) 2012 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jams.music.player.InAppBilling;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Represents a block of information about in-app items.
 * An Inventory is returned by such methods as {@link IabHelper#queryInventory}.
 */
public class Inventory {
    Map<String,SkuDetails> mSkuMap = new HashMap<String,SkuDetails>();
    Map<String,Purchase> mPurchaseMap = new HashMap<String,Purchase>();

    Inventory() { }

    /** Returns the listing details for an in-app product. */
    public SkuDetails getSkuDetails(String sku) {
        return mSkuMap.get(sku);
    }

    /** Returns purchase information for a given product, or null if there is no purchase. */
    public Purchase getPurchase(String sku) {
        return mPurchaseMap.get(sku);
    }

    /** Returns whether or not there exists a purchase of the given product. */
    public boolean hasPurchase(String sku) {
        return mPurchaseMap.containsKey(sku);
    }

    /** Return whether or not details about the given product are available. */
    public boolean hasDetails(String sku) {
        return mSkuMap.containsKey(sku);
    }

    /**
     * Erase a purchase (locally) from the inventory, given its product ID. This just
     * modifies the Inventory object locally and has no effect on the server! This is
     * useful when you have an existing Inventory object which you know to be up to date,
     * and you have just consumed an item successfully, which means that erasing its
     * purchase data from the Inventory you already have is quicker than querying for
     * a new Inventory.
     */
    public void erasePurchase(String sku) {
        if (mPurchaseMap.containsKey(sku)) mPurchaseMap.remove(sku);
    }

    /** Returns a list of all owned product IDs. */
    List<String> getAllOwnedSkus() {
        return new ArrayList<String>(mPurchaseMap.keySet());
    }

    /** Returns a list of all owned product IDs of a given type */
    List<String> getAllOwnedSkus(String itemType) {
        List<String> result = new ArrayList<String>();
        for (Purchase p : mPurchaseMap.values()) {
            if (p.getItemType().equals(itemType)) result.add(p.getSku());
        }
        return result;
    }

    /** Returns a list of all purchases. */
    List<Purchase> getAllPurchases() {
        return new ArrayList<Purchase>(mPurchaseMap.values());
    }

    void addSkuDetails(SkuDetails d) {
        mSkuMap.put(d.getSku(), d);
    }

    void addPurchase(Purchase p) {
        mPurchaseMap.put(p.getSku(), p);
    }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Copyright (c) 2012 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jams.music.player.InAppBilling;

import org.json.JSONException;
import org.json.JSONObject;

/**
 * Represents an in-app billing purchase.
 */
public class Purchase {
    String mItemType;  // ITEM_TYPE_INAPP or ITEM_TYPE_SUBS
    String mOrderId;
    String mPackageName;
    String mSku;
    long mPurchaseTime;
    int mPurchaseState;
    String mDeveloperPayload;
    String mToken;
    String mOriginalJson;
    String mSignature;

    public Purchase(String itemType, String jsonPurchaseInfo, String signature) throws JSONException {
        mItemType = itemType;
        mOriginalJson = jsonPurchaseInfo;
        JSONObject o = new JSONObject(mOriginalJson);
        mOrderId = o.optString("orderId");
        mPackageName = o.optString("packageName");
        mSku = o.optString("productId");
        mPurchaseTime = o.optLong("purchaseTime");
        mPurchaseState = o.optInt("purchaseState");
        mDeveloperPayload = o.optString("developerPayload");
        mToken = o.optString("token", o.optString("purchaseToken"));
        mSignature = signature;
    }

    public String getItemType() { return mItemType; }
    public String getOrderId() { return mOrderId; }
    public String getPackageName() { return mPackageName; }
    public String getSku() { return mSku; }
    public long getPurchaseTime() { return mPurchaseTime; }
    public int getPurchaseState() { return mPurchaseState; }
    public String getDeveloperPayload() { return mDeveloperPayload; }
    public String getToken() { return mToken; }
    public String getOriginalJson() { return mOriginalJson; }
    public String getSignature() { return mSignature; }

    @Override
    public String toString() { return "PurchaseInfo(type:" + mItemType + "):" + mOriginalJson; }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Copyright (c) 2012 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jams.music.player.InAppBilling;

import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;

import android.text.TextUtils;
import android.util.Log;

/**
 * Security-related methods. For a secure implementation, all of this code
 * should be implemented on a server that communicates with the
 * application on the device. For the sake of simplicity and clarity of this
 * example, this code is included here and is executed on the device. If you
 * must verify the purchases on the phone, you should obfuscate this code to
 * make it harder for an attacker to replace the code with stubs that treat all
 * purchases as verified.
 */
public class Security {
    private static final String TAG = "IABUtil/Security";

    private static final String KEY_FACTORY_ALGORITHM = "RSA";
    private static final String SIGNATURE_ALGORITHM = "SHA1withRSA";

    /**
     * Verifies that the data was signed with the given signature, and returns
     * the verified purchase. The data is in JSON format and signed
     * with a private key. The data also contains the {@link PurchaseState}
     * and product ID of the purchase.
     * @param base64PublicKey the base64-encoded public key to use for verifying.
     * @param signedData the signed JSON string (signed, not encrypted)
     * @param signature the signature for the data, signed with the private key
     */
    public static boolean verifyPurchase(String base64PublicKey, String signedData, String signature) {
        if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(base64PublicKey) ||
                TextUtils.isEmpty(signature)) {
            Log.e(TAG, "Purchase verification failed: missing data.");
            return false;
        }

        PublicKey key = Security.generatePublicKey(base64PublicKey);
        return Security.verify(key, signedData, signature);
    }

    /**
     * Generates a PublicKey instance from a string containing the
     * Base64-encoded public key.
     *
     * @param encodedPublicKey Base64-encoded public key
     * @throws IllegalArgumentException if encodedPublicKey is invalid
     */
    public static PublicKey generatePublicKey(String encodedPublicKey) {
        try {
            byte[] decodedKey = Base64.decode(encodedPublicKey);
            KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);
            return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        } catch (InvalidKeySpecException e) {
            Log.e(TAG, "Invalid key specification.");
            throw new IllegalArgumentException(e);
        } catch (Base64DecoderException e) {
            Log.e(TAG, "Base64 decoding failed.");
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Verifies that the signature from the server matches the computed
     * signature on the data.  Returns true if the data is correctly signed.
     *
     * @param publicKey public key associated with the developer account
     * @param signedData signed data from server
     * @param signature server signature
     * @return true if the data and signature match
     */
    public static boolean verify(PublicKey publicKey, String signedData, String signature) {
        Signature sig;
        try {
            sig = Signature.getInstance(SIGNATURE_ALGORITHM);
            sig.initVerify(publicKey);
            sig.update(signedData.getBytes());
            if (!sig.verify(Base64.decode(signature))) {
                Log.e(TAG, "Signature verification failed.");
                return false;
            }
            return true;
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, "NoSuchAlgorithmException.");
        } catch (InvalidKeyException e) {
            Log.e(TAG, "Invalid key specification.");
        } catch (SignatureException e) {
            Log.e(TAG, "Signature exception.");
        } catch (Base64DecoderException e) {
            Log.e(TAG, "Base64 decoding failed.");
        }
        return false;
    }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Copyright (c) 2012 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jams.music.player.InAppBilling;

import org.json.JSONException;
import org.json.JSONObject;

/**
 * Represents an in-app product's listing details.
 */
public class SkuDetails {
    String mItemType;
    String mSku;
    String mType;
    String mPrice;
    String mTitle;
    String mDescription;
    String mJson;

    public SkuDetails(String jsonSkuDetails) throws JSONException {
        this(IabHelper.ITEM_TYPE_INAPP, jsonSkuDetails);
    }

    public SkuDetails(String itemType, String jsonSkuDetails) throws JSONException {
        mItemType = itemType;
        mJson = jsonSkuDetails;
        JSONObject o = new JSONObject(mJson);
        mSku = o.optString("productId");
        mType = o.optString("type");
        mPrice = o.optString("price");
        mTitle = o.optString("title");
        mDescription = o.optString("description");
    }

    public String getSku() { return mSku; }
    public String getType() { return mType; }
    public String getPrice() { return mPrice; }
    public String getTitle() { return mTitle; }
    public String getDescription() { return mDescription; }

    @Override
    public String toString() {
        return "SkuDetails:" + mJson;
    }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.LauncherActivity;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.Map;

import org.apache.commons.io.FileUtils;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.graphics.Paint;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentTransaction;
import android.util.DisplayMetrics;
import android.view.Display;
import android.view.View;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.google.analytics.tracking.android.EasyTracker;
import com.google.analytics.tracking.android.Fields;
import com.google.analytics.tracking.android.MapBuilder;
import com.google.android.gms.common.GooglePlayServicesUtil;
import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.InAppBilling.IabHelper;
import com.jams.music.player.InAppBilling.IabResult;
import com.jams.music.player.InAppBilling.Inventory;
import com.jams.music.player.InAppBilling.Purchase;
import com.jams.music.player.MainActivity.MainActivity;
import com.jams.music.player.MiscFragments.TrialFragment;
import com.jams.music.player.Services.BuildMusicLibraryService;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.WelcomeActivity.WelcomeActivity;

public class LauncherActivity extends FragmentActivity {

	public Context mContext;
	private Common mApp;
	public Activity mActivity;
	
	public static String mAccountName;
    static final int REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR = 1002;
    public static IabHelper mHelper;
    protected static final String ITEM_SKU = "com.jams.music.player.unlock";
    protected static final String ITEM_SKU_PROMO = "com.jams.music.player.unlock.promo";
    private static final String CAMPAIGN_SOURCE_PARAM = "utm_source";
    protected boolean mPurchased;
    protected boolean mPurchasedPromo;
    private boolean mExplicitShowTrialFragment;
    
    public static TextView buildingLibraryMainText;
    public static TextView buildingLibraryInfoText;
    private RelativeLayout buildingLibraryLayout;
    private Handler mHandler;

	@SuppressLint("NewApi")
	@Override
	public void onCreate(Bundle savedInstanceState) {
		
		setTheme(R.style.AppThemeNoActionBar);
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_launcher);
		
		mContext = this;
		mActivity = this;
		mApp = (Common) mContext.getApplicationContext();
		mHandler = new Handler();
		
		//Increment the start count. This value will be used to determine when the library should be rescanned.
    	int startCount = mApp.getSharedPreferences().getInt("START_COUNT", 1);
    	mApp.getSharedPreferences().edit().putInt("START_COUNT", startCount+1).commit();
		
		//Save the dimensions of the layout for later use on KitKat devices.
		final RelativeLayout launcherRootView = (RelativeLayout) findViewById(R.id.launcher_root_view);
		launcherRootView.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
			
			@Override
			public void onGlobalLayout() {
				
				try {
					
					int screenDimens[] = new int[2];
					int screenHeight = 0;
					int screenWidth = 0;
		            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
		            	//API levels 14, 15 and 16.
		            	screenDimens = getTrueDeviceResolution();
		            	screenWidth = screenDimens[0];
		            	screenHeight = screenDimens[1];
		            	
		            } else {
		            	//API levels 17+.
		            	Display display = getWindowManager().getDefaultDisplay();
		            	DisplayMetrics metrics = new DisplayMetrics();
		            	display.getRealMetrics(metrics);
		            	screenHeight = metrics.heightPixels;
		            	screenWidth = metrics.widthPixels;
		            	
		            }
					
					int layoutHeight = launcherRootView.getHeight();
					int layoutWidth = launcherRootView.getWidth();
					
					int extraHeight = screenHeight - layoutHeight;
					int extraWidth = screenWidth = layoutWidth;
					
					mApp.getSharedPreferences().edit().putInt("KITKAT_HEIGHT", layoutHeight).commit();
					mApp.getSharedPreferences().edit().putInt("KITKAT_WIDTH", layoutWidth).commit();
					mApp.getSharedPreferences().edit().putInt("KITKAT_HEIGHT_LAND", layoutWidth - extraHeight).commit();
					mApp.getSharedPreferences().edit().putInt("KITKAT_WIDTH_LAND", screenHeight).commit();

				} catch (Exception e) {
					e.printStackTrace();
				}
				
		    }
			
		});
		
		//Build the music library based on the user's scan frequency preferences.
        int scanFrequency = mApp.getSharedPreferences().getInt("SCAN_FREQUENCY", 5);
        int updatedStartCount = mApp.getSharedPreferences().getInt("START_COUNT", 1);
		
		//Launch the appropriate activity based on the "FIRST RUN" flag.
		if (mApp.getSharedPreferences().getBoolean(Common.FIRST_RUN, true)==true) {
			
        	//Create the default Playlists directory if it doesn't exist.
        	File playlistsDirectory = new File(Environment.getExternalStorageDirectory() + "/Playlists/");
        	if (!playlistsDirectory.exists() || !playlistsDirectory.isDirectory()) {
        		playlistsDirectory.mkdir();
        	}
			
			//Disable equalizer for HTC devices by default.
			if (mApp.getSharedPreferences().getBoolean(Common.FIRST_RUN, true)==true &&
				Build.PRODUCT.contains("HTC")) {
				mApp.getSharedPreferences().edit().putBoolean("EQUALIZER_ENABLED", false).commit();
			}
			
        	//Send out a test broadcast to initialize the homescreen/lockscreen widgets.
        	sendBroadcast(new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME));
			
			Intent intent = new Intent(this, WelcomeActivity.class);
			startActivity(intent);
			overridePendingTransition(R.anim.fade_in, R.anim.fade_out);
			
		} else if (mApp.isBuildingLibrary()) {
			buildingLibraryMainText = (TextView) findViewById(R.id.building_music_library_text);
	        buildingLibraryInfoText = (TextView) findViewById(R.id.building_music_library_info);
	        buildingLibraryLayout = (RelativeLayout) findViewById(R.id.building_music_library_layout);
	        
	        buildingLibraryInfoText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
	        buildingLibraryInfoText.setPaintFlags(buildingLibraryInfoText.getPaintFlags() |
	        								  	  Paint.ANTI_ALIAS_FLAG |
	        								  	  Paint.SUBPIXEL_TEXT_FLAG);
	        
	        buildingLibraryMainText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
	        buildingLibraryMainText.setPaintFlags(buildingLibraryMainText.getPaintFlags() |
	        								  	  Paint.ANTI_ALIAS_FLAG |
	        								  	  Paint.SUBPIXEL_TEXT_FLAG);
	        
	        buildingLibraryMainText.setText(R.string.jams_is_building_library);
	        buildingLibraryLayout.setVisibility(View.VISIBLE);
	        
	        //Initialize the runnable that will fire once the scan process is complete.
			mHandler.post(scanFinishedCheckerRunnable);
		
		} else if (mApp.getSharedPreferences().getBoolean("RESCAN_ALBUM_ART", false)==true) {

			buildingLibraryMainText = (TextView) findViewById(R.id.building_music_library_text);
	        buildingLibraryInfoText = (TextView) findViewById(R.id.building_music_library_info);
	        buildingLibraryLayout = (RelativeLayout) findViewById(R.id.building_music_library_layout);
	        
	        buildingLibraryInfoText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
	        buildingLibraryInfoText.setPaintFlags(buildingLibraryInfoText.getPaintFlags() |
	        								  	  Paint.ANTI_ALIAS_FLAG |
	        								  	  Paint.SUBPIXEL_TEXT_FLAG);
	        
	        buildingLibraryMainText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
	        buildingLibraryMainText.setPaintFlags(buildingLibraryMainText.getPaintFlags() |
	        								  	  Paint.ANTI_ALIAS_FLAG |
	        								  	  Paint.SUBPIXEL_TEXT_FLAG);
	        
	        buildingLibraryMainText.setText(R.string.jams_is_caching_artwork);
	        initScanProcess(0);
	        
		} else if ((mApp.getSharedPreferences().getBoolean("REBUILD_LIBRARY", false)==true) || 
				   (scanFrequency==0 && mApp.isScanFinished()==false) || 
				   (scanFrequency==1 && mApp.isScanFinished()==false && updatedStartCount%3==0) || 
				   (scanFrequency==2 && mApp.isScanFinished()==false && updatedStartCount%5==0) || 
				   (scanFrequency==3 && mApp.isScanFinished()==false && updatedStartCount%10==0) || 
				   (scanFrequency==4 && mApp.isScanFinished()==false && updatedStartCount%20==0)) {
			
			buildingLibraryMainText = (TextView) findViewById(R.id.building_music_library_text);
	        buildingLibraryInfoText = (TextView) findViewById(R.id.building_music_library_info);
	        buildingLibraryLayout = (RelativeLayout) findViewById(R.id.building_music_library_layout);
	        
	        buildingLibraryInfoText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
	        buildingLibraryInfoText.setPaintFlags(buildingLibraryInfoText.getPaintFlags() |
	        								  	  Paint.ANTI_ALIAS_FLAG |
	        								  	  Paint.SUBPIXEL_TEXT_FLAG);
	        
	        buildingLibraryMainText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
	        buildingLibraryMainText.setPaintFlags(buildingLibraryMainText.getPaintFlags() |
	        								  	  Paint.ANTI_ALIAS_FLAG |
	        								  	  Paint.SUBPIXEL_TEXT_FLAG);
	        
	        initScanProcess(1);
	        
		} else {
			
			//Check if this activity was called from Settings.
			if (getIntent().hasExtra("UPGRADE")) {
				if (getIntent().getExtras().getBoolean("UPGRADE")==true) {
					mExplicitShowTrialFragment = true;
				} else {
					mExplicitShowTrialFragment = false;
				}
				
			}

			//initInAppBilling();
            launchMainActivity();
		}

		//Fire away a report to Google Analytics.
		try {
			if (mApp.isGoogleAnalyticsEnabled()==true) {
				EasyTracker easyTracker = EasyTracker.getInstance(this);
		    	easyTracker.send(MapBuilder.createEvent("Jams startup.",     // Event category (required)
			                   						  	"User started Jams.",  // Event action (required)
			                   						  	"User started Jams.",   // Event label
			                   						  	null)            // Event value
						   .build());
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	
	private int[] getTrueDeviceResolution() {
    	
    	int[] resolution = new int[2];
    	try {
    		Display display = getWindowManager().getDefaultDisplay();   
    		
        	Method mGetRawH = Display.class.getMethod("getRawHeight");
        	Method mGetRawW = Display.class.getMethod("getRawWidth");
        	
        	int rawWidth = (Integer) mGetRawW.invoke(display);
        	int rawHeight = (Integer) mGetRawH.invoke(display);
        	
        	resolution[0] = rawWidth;
        	resolution[1] = rawHeight;
        	
    	} catch (Exception e) {
    		e.printStackTrace();
    	}
    	
    	return resolution;
    }
	
	private void initScanProcess(int scanCode) {
		
		//Start the service that will start scanning the user's library/caching album art.
		mApp.setIsBuildingLibrary(true);
		buildingLibraryLayout.setVisibility(View.VISIBLE);
		if (scanCode==0) {
        	Intent intent = new Intent(this, BuildMusicLibraryService.class);
        	intent.putExtra("SCAN_TYPE", "RESCAN_ALBUM_ART");
			startService(intent);
			
	        mApp.getSharedPreferences().edit().putBoolean("RESCAN_ALBUM_ART", false).commit();
			
		} else if (scanCode==1) {
	    	Intent intent = new Intent(this, BuildMusicLibraryService.class);
	    	intent.putExtra("SCAN_TYPE", "FULL_SCAN");
			startService(intent);
			
			mApp.getSharedPreferences().edit().putBoolean("REBUILD_LIBRARY", false).commit();
		}
		
		//Initialize the runnable that will fire once the scan process is complete.
		mHandler.post(scanFinishedCheckerRunnable);
		
	}
	
	private Runnable scanFinishedCheckerRunnable = new Runnable() {

		@Override
		public void run() {
			
			if (mApp.isBuildingLibrary()==false) {
				launchMainActivity();
			} else {
				mHandler.postDelayed(this, 100);
			}

		}
		
	};
	
	/*private void initInAppBilling() {
		String base64EncodedPublicKey = "";
		
		base64EncodedPublicKey = Common.uid4 + 
								 Common.uid2 +
								 Common.uid6 +
								 Common.uid1 +
								 Common.uid3 +
								 Common.uid5;

    	mHelper = new IabHelper(this, base64EncodedPublicKey);
    	
    	try {
    		mHelper.startSetup(new IabHelper.OnIabSetupFinishedListener() {
        		
        		@Override
        		public void onIabSetupFinished(IabResult result) {
        			if (!result.isSuccess()) {
        				//In-app billing could not be initialized.
        				mApp.getSharedPreferences().edit().putBoolean("TRIAL", true).commit();
        				checkTrialStatus();
        			} else {             
        				//In-app billing was initialized successfully.
        				mHelper.queryInventoryAsync(mGotInventoryListener);
        			}
        			
        		}
        		
        	});
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    		checkTrialStatus();
    	}
    	
	}*/
	
	/*IabHelper.QueryInventoryFinishedListener mGotInventoryListener = new IabHelper.QueryInventoryFinishedListener() {
		
		public void onQueryInventoryFinished(IabResult result, Inventory inventory) {
			if (result.isFailure()) {
				//Couldn't query in-app purchases.
				checkTrialStatus();
				mApp.getSharedPreferences().edit().putBoolean("TRIAL", true).commit();
				
			} else {
				//Check if the user bought the unlocker.
				mPurchased = inventory.hasPurchase(ITEM_SKU);
				mPurchasedPromo = inventory.hasPurchase(ITEM_SKU_PROMO);
			}
			
			//If the developer (yours truly) is using the app, skip the trial process.
			final AccountManager accountManager = AccountManager.get(mContext);
	        final Account[] accounts = accountManager.getAccountsByType("com.google");
	        boolean developerEdition = false;
	        
	        for (int i=0; i < accounts.length; i++) {
	        	if (accounts[i].name.equals("jamsmusicplayer@gmail.com")) {
	        		developerEdition = true;
	        	}
	        }
			
			if (mPurchased==true || mPurchasedPromo==true || developerEdition==true) {
				//The user bought the app.
				mApp.getSharedPreferences().edit().putBoolean("TRIAL", false).commit();
				launchMainActivity();
				
			} else {
				//The user is still running the trial version.
				checkTrialStatus();
				mApp.getSharedPreferences().edit().putBoolean("TRIAL", true).commit();
			}
			
		}
		
	};
	
	IabHelper.OnIabPurchaseFinishedListener mPurchaseFinishedListener = new IabHelper.OnIabPurchaseFinishedListener() {
		
		public void onIabPurchaseFinished(IabResult result, Purchase purchase) {
			
			if (result.isFailure()) {	
				Toast.makeText(mContext, R.string.unable_to_purchase, Toast.LENGTH_LONG).show();
				mApp.getSharedPreferences().edit().putBoolean("TRIAL", true).commit();
				return;
			} else if (purchase.getSku().equals(ITEM_SKU)) {
				Toast.makeText(mContext, R.string.jams_trial_time_removed, Toast.LENGTH_LONG).show();
				mApp.getSharedPreferences().edit().putBoolean("TRIAL", false).commit();
				launchMainActivity();
				
			}
	      
		}
	   
	};*/
	
	/* Checks the trial version status of the app. The first install time of the app is 
	 * retrieved and then compared against the current time. If the current time is more 
	 * than 7 days away from the first install time, the trial version has expired and the 
	 * user will be prompted to buy the full version unlocker. If the current time is less 
	 * than 7 days away from the first install time of the app, the trial version is still 
	 * valid and the app will continue running normally.
	 * 
	 * This approach has a major drawback: The user can simply uninstall the app at the end 
	 * of the trial period, reinstall it, and he/she will get a full 7 day trial again. To 
	 * avoid this issue, we'll create a hidden file called ".jams_info" in the user's external 
	 * storage directory (Environment.getExternalStorageDir()). The file will contain one 
	 * line: The time in millis that is 10 days in the future from the first install time. 
	 * The trial expires in 7 days, so the extra 3 days will be a "buffer" time period that 
	 * will discourage free-loaders from simply reinstalling the app and reusing it. If a 
	 * user wants to try the app again, they can do so 3 days after their trial expires.
	 * 
	 * Every time the app starts up, it will first check for the ".jams_info" file. If it exists, 
	 * Jams will check to make sure that the current time is earlier/before the time that has 
	 * just been read in. If it is, the app will open up. If it isn't, the user will get the 
	 * trial expiry dialog.
	 */
	/*public void checkTrialStatus() {
		
		PackageManager pm = mContext.getPackageManager();
		PackageInfo packageInfo = null;
		try {
			packageInfo = pm.getPackageInfo("com.jams.music.player", PackageManager.GET_ACTIVITIES);
		} catch (NameNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		long firstInstallTime = packageInfo.firstInstallTime;
		long currentTime = System.currentTimeMillis();
		long expiryTime = firstInstallTime + 604800000l;
		long numDaysRemainingMillis = expiryTime - currentTime;

		if (currentTime >= expiryTime) {
			//The trial version has expired. 
			
			//Write a file to the sdcard that stores the trial's reactivation time (3 days in the future).
			long trialReactivationTime = System.currentTimeMillis() + 259200000l;
			File file = new File(Environment.getExternalStorageDirectory() + "/.jams_info");
			try {
				if (file.exists()) {
					file.delete();
				}
				
				FileUtils.write(file, 
								"" + trialReactivationTime, 
								false);
				
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (Exception e) {
				e.printStackTrace();
			}
			
			//Prompt the user to buy the full version of the app.
			showTrialFragment(true, 0);
			//showTrialDialog(true, 0);
		} else {
			
			//The trial version is still valid.
			boolean trialValid = checkTrialReactivationTime();
			if (trialValid) {
				//The trial is still valid. Show the trial dialog every 5 startups.
				long numDaysRemaining = (long) (numDaysRemainingMillis / (1000*60*60*24));
				float updatedStartCount = mApp.getSharedPreferences().getInt("START_COUNT", 1);
				if ((updatedStartCount/5)==(Math.round(updatedStartCount/5)) || mExplicitShowTrialFragment) {
					showTrialFragment(false, (int) numDaysRemaining);
					//showTrialDialog(false, (int) numDaysRemaining);
				} else {
					launchMainActivity();
				}
				
			} else {
				//The trial has expired.
				showTrialFragment(true, 0);
				//showTrialDialog(true, 0);
			}
			
		}
		
	}*/
	
	/* This method checks for the /sdcard/.jams_info file. If it exists, 
	 * it tries to read the reactivation time from the file.
	 * Checks if the current time is 3 days (or more) in the future 
	 * than the time that was just read. If so, returns true. If not, 
	 * returns false.
	 */
	private boolean checkTrialReactivationTime() {
		
		File file = new File(Environment.getExternalStorageDirectory() + "/.jams_info");
		if (file.exists()) {
			//The file exists. Try reading the reactivation time from it.
			String time = null;
			long reactivationTime = -1;
			try {
				time = FileUtils.readFileToString(file);
				reactivationTime = Long.parseLong(time);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				reactivationTime = -1;
			} catch (Exception e) {
				e.printStackTrace();
				reactivationTime = -1;
			}
			
			if (reactivationTime!=-1) {
				//Check if the current time is later than the reactivation time.
				long currentTime = System.currentTimeMillis();
				if (currentTime >= reactivationTime) {
					//Yeap, the trial's been reactivated.
					return true;
				} else {
					//Nope, the trial's still in the expired state.
					return false;
				}
				
			} else {
				//We were unable to read the activation time. Continue the trial.
				return true;
			}
			
		} else {
			//The file doesn't exist, so the trial is active.
			return true;
		}
		
	}
	
	private void showTrialFragment(final boolean expired, int numDaysRemaining) {
		
		//Load the trial fragment into the activity.
		TrialFragment fragment = new TrialFragment();
		Bundle bundle = new Bundle();
		bundle.putInt("NUM_DAYS_REMAINING", numDaysRemaining);
		bundle.putBoolean("EXPIRED", expired);
		fragment.setArguments(bundle);
		
		FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
	    transaction.replace(R.id.launcher_root_view, fragment, "trialFragment");
	    transaction.commit();

	}

	private void showUpgradeFragmentWithPromo() {
		/*SpecialUpgradeOfferFragment fragment = new SpecialUpgradeOfferFragment();
		FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
	    transaction.replace(R.id.launcher_root_view, fragment, "specialUpgradeOfferFragment");
	    transaction.commit();*/
	    
	}
	
	public void showTrialDialog(final boolean expired, int numDaysRemaining) {
		
		AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
		builder.setTitle(R.string.app_name);
		builder.setCancelable(false);

		View view = this.getLayoutInflater().inflate(R.layout.trial_expiry_dialog, null);
		TextView trialExpiredText = (TextView) view.findViewById(R.id.trial_message);
		TextView trialDaysRemaining = (TextView) view.findViewById(R.id.trial_days_remaining);
		TextView trialDaysCaps = (TextView) view.findViewById(R.id.days_caps);
		
		trialExpiredText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		trialExpiredText.setPaintFlags(trialExpiredText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		trialDaysRemaining.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		
		trialDaysCaps.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		trialDaysCaps.setPaintFlags(trialDaysCaps.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		if (expired) {
			trialDaysRemaining.setText(R.string.expired);
			trialExpiredText.setText(R.string.trial_expired);
			trialDaysRemaining.setTextColor(0xFFFF8800);
			trialDaysCaps.setVisibility(View.GONE);
			trialDaysRemaining.setTextSize(36);
			trialDaysRemaining.setPaintFlags(trialDaysRemaining.getPaintFlags() 
											 | Paint.ANTI_ALIAS_FLAG 
											 | Paint.SUBPIXEL_TEXT_FLAG);
		} else {
			trialExpiredText.setText(R.string.trial_running);
			trialDaysRemaining.setText("" + numDaysRemaining);
			trialDaysCaps.setVisibility(View.VISIBLE);
			trialDaysRemaining.setTextColor(0xFF0099CC);
			trialDaysRemaining.setPaintFlags(trialDaysRemaining.getPaintFlags() 
											 | Paint.ANTI_ALIAS_FLAG 
											 | Paint.SUBPIXEL_TEXT_FLAG 
											 | Paint.FAKE_BOLD_TEXT_FLAG);
		}
		
		builder.setView(view);
		builder.setPositiveButton(R.string.upgrade, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				showUpgradeFragmentWithPromo();

			}
			
		});
		
		builder.setNegativeButton(R.string.later, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				if (expired) {
					finish();
				} else {
					launchMainActivity();
				}
				
				
			}
			
		});
		
		builder.create().show();
	}
	
	private void launchMainActivity() {
		Intent intent = new Intent(mContext, MainActivity.class);
		int startupScreen = mApp.getSharedPreferences().getInt("STARTUP_SCREEN", 0);
		
		switch (startupScreen) {
		case 0:
			intent.putExtra("TARGET_FRAGMENT", "ARTISTS");
			break;
		case 1:
			intent.putExtra("TARGET_FRAGMENT", "ALBUM_ARTISTS");
			break;
		case 2:
			intent.putExtra("TARGET_FRAGMENT", "ALBUMS");
			break;
		case 3:
			intent.putExtra("TARGET_FRAGMENT", "SONGS");
			break;
		case 4:
			intent.putExtra("TARGET_FRAGMENT", "PLAYLISTS");
			break;
		case 5:
			intent.putExtra("TARGET_FRAGMENT", "GENRES");
			break;
		case 6:
			intent.putExtra("TARGET_FRAGMENT", "FOLDERS");
			break;
		}
		
		startActivity(intent);
		overridePendingTransition(R.anim.fade_in, R.anim.fade_out);
		finish();
		
	}
	
	public void showErrorDialog(final int code) {
        runOnUiThread(new Runnable() {
        	
            @Override
            public void run() {
              Dialog d = GooglePlayServicesUtil.getErrorDialog(
		                 code,
		                 LauncherActivity.this,
		                 REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR);
              d.show();
            }
            
        });
        
    }
	
	/** Given a URI, returns a map of campaign data that can be sent with
	 * any GA hit.
	 *
	 * @param uri A hierarchical URI that may or may not have campaign data
	 *     stored in query parameters.
	 *
	 * @return A map that may contain campaign or referrer
	 *     that may be sent with any Google Analytics hit.
   	 */
	private Map<String,String> getReferrerMapFromUri(Uri uri) {
		 MapBuilder paramMap = new MapBuilder();

		 //If no URI, return an empty Map.
		 if (uri==null) { 
			 return paramMap.build(); 
		 }

		 /* Source is the only required campaign field. No need to continue if not
		  * present. */
		 if (uri.getQueryParameter(CAMPAIGN_SOURCE_PARAM)!=null) {

			 /* MapBuilder.setCampaignParamsFromUrl parses Google Analytics campaign
			  * ("UTM") parameters from a string URL into a Map that can be set on
			  * the Tracker. */
			 paramMap.setCampaignParamsFromUrl(uri.toString());

			 /* If no source parameter, set authority to source and medium to
			  * "referral". */
		 } else if (uri.getAuthority()!=null) {
			 paramMap.set(Fields.CAMPAIGN_MEDIUM, "referral");
			 paramMap.set(Fields.CAMPAIGN_SOURCE, uri.getAuthority());
		 }

		 return paramMap.build();
	}

	@Override
	public void onPause() {
		super.onPause();

		try {
			if (isFinishing() && mHelper!=null) {
				mHelper.dispose();
				mHelper = null;	
			}
			
			finish();			
		} catch (Exception e) {
			e.printStackTrace();
		}

	}
	 
	@Override
	public void onDestroy() {
		super.onDestroy();

		try {
			if (mHelper!=null) {
		 		mHelper.dispose();
		 		mHelper = null;
		 	}	
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	 	
	}

	@Override
	public void onStart() {
		super.onStart();
		//GAnalytics.
		try {
			if (mApp.isGoogleAnalyticsEnabled()==true) {
				EasyTracker.getInstance(this).activityStart(this);
				
				//Get the intent that started this Activity.
			    Intent intent = this.getIntent();
			    Uri uri = intent.getData();

			    //Send a screenview using any available campaign or referrer data.
			    MapBuilder.createAppView().setAll(getReferrerMapFromUri(uri));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
	    
	}

	@Override
	public void onStop() {
		super.onStop();
		//GAnalytics.
		try {
			if (mApp.isGoogleAnalyticsEnabled()==true) {
				EasyTracker.getInstance(this).activityStop(this);
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.ListViewFragment;

import android.content.Context;
import android.database.Cursor;
import android.os.Bundle;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.PopupMenu;
import android.widget.PopupMenu.OnMenuItemClickListener;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.andraskindler.quickscroll.Scrollable;
import com.jams.music.player.AsyncTasks.AsyncAddToQueueTask;
import com.jams.music.player.Dialogs.AddToPlaylistDialog;
import com.jams.music.player.Dialogs.CautionEditArtistsDialog;
import com.jams.music.player.Dialogs.ID3sArtistEditorDialog;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.ImageTransformers.PicassoCircularTransformer;

import java.util.HashMap;

/**
 * Generic ListView adapter for ListViewFragment.
 * 
 * @author Saravan Pantham
 */
public class ListViewCardsAdapter extends SimpleCursorAdapter implements Scrollable {
	
	private Context mContext;
	private Common mApp;
	private ListViewFragment mListViewFragment;
    public static ListViewHolder mHolder = null;
    private String mName = "";
    
    //HashMap for DB column names.
    private HashMap<Integer, String> mDBColumnsMap;
    public static final int TITLE_TEXT = 0;
    public static final int SOURCE = 1;
    public static final int FILE_PATH = 2;
    public static final int ARTWORK_PATH = 3;
    public static final int FIELD_1 = 4; //Empty fields for other 
    public static final int FIELD_2 = 5;
    public static final int FIELD_3 = 6;
    public static final int FIELD_4 = 7;
    public static final int FIELD_5 = 8;
    
    public ListViewCardsAdapter(Context context, ListViewFragment listViewFragment, 
    					   		HashMap<Integer, String> dbColumnsMap) {
    	
        super(context, -1, listViewFragment.getCursor(), new String[] {}, new int[] {}, 0);
        mContext = context;
        mListViewFragment = listViewFragment;
        mApp = (Common) mContext.getApplicationContext();
        mDBColumnsMap = dbColumnsMap;
        
    }
    
    /**
     * Quick scroll indicator implementation.
     */
    @Override
    public String getIndicatorForPosition(int childPosition, int groupPosition) {
    	Cursor c = (Cursor) getItem(childPosition);
    	String title = c.getString(c.getColumnIndex(mDBColumnsMap.get(TITLE_TEXT)));
    	if (title!=null && title.length() > 1)
    		return "  " + title.substring(0, 1) + "  ";
        else
            return "  N/A  ";
    }
    
    /**
     * Returns the current position of the top view in the list/grid.
     */
	@Override
	public int getScrollPosition(int childPosition, int groupPosition) {
		// TODO Auto-generated method stub
		return childPosition;
	}

	/**
	 * Returns the individual row/child in the list/grid.
	 */
    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        Cursor c = (Cursor) getItem(position);

		if (convertView == null) {
			convertView = LayoutInflater.from(mContext).inflate(R.layout.list_view_item, parent, false);

			mHolder = new ListViewHolder();
			mHolder.leftImage = (ImageView) convertView.findViewById(R.id.listViewLeftIcon);
			mHolder.titleText = (TextView) convertView.findViewById(R.id.listViewTitleText);
			mHolder.subText = (TextView) convertView.findViewById(R.id.listViewSubText);
			mHolder.rightSubText = (TextView) convertView.findViewById(R.id.listViewRightSubText);
            mHolder.overflowIcon = (ImageButton) convertView.findViewById(R.id.listViewOverflow);
            mHolder.subTextParent = (RelativeLayout) convertView.findViewById(R.id.listViewSubTextParent);

            //Remove the sub text's parent layout for playlists list view.
            if (mListViewFragment.getFragmentId()==Common.PLAYLISTS_FRAGMENT) {
                mHolder.subTextParent.setVisibility(View.GONE);
                RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mHolder.titleText.getLayoutParams();
                params.addRule(RelativeLayout.CENTER_VERTICAL);
                mHolder.titleText.setLayoutParams(params);

            }

			mHolder.titleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
            mHolder.subText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
            mHolder.rightSubText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
            mHolder.leftImage.setImageResource(UIElementsHelper.getEmptyCircularColorPatch(mContext));
			
			mHolder.titleText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			mHolder.subText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			mHolder.rightSubText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));

            mHolder.overflowIcon.setImageResource(UIElementsHelper.getIcon(mContext, "ic_action_overflow"));
			mHolder.overflowIcon.setOnClickListener(overflowClickListener);
			mHolder.overflowIcon.setFocusable(false);
			mHolder.overflowIcon.setFocusableInTouchMode(false);
			
			convertView.setTag(mHolder);
		} else {
		    mHolder = (ListViewHolder) convertView.getTag();
		}

		//Retrieve data from the cursor.
		String titleText = "";
		String source = "";
		String filePath = "";
		String artworkPath = "";
		String field1 = "";
		String field2 = "";
		String field3 = "";
		String field4 = "";
		String field5 = "";
		try {
			titleText = c.getString(c.getColumnIndex(mDBColumnsMap.get(TITLE_TEXT)));
			source = c.getString(c.getColumnIndex(mDBColumnsMap.get(SOURCE)));
			filePath = c.getString(c.getColumnIndex(mDBColumnsMap.get(FILE_PATH)));
			artworkPath = c.getString(c.getColumnIndex(mDBColumnsMap.get(ARTWORK_PATH)));
			field1 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_1)));
			field2 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_2)));
			field3 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_3)));
			field4 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_4)));
			field5 = c.getString(c.getColumnIndex(mDBColumnsMap.get(FIELD_5)));
			
		} catch (NullPointerException e) {
			//e.printStackTrace();
		}
		
		//Set the tags for this grid item.
		convertView.setTag(R.string.title_text, titleText);
		convertView.setTag(R.string.song_source, source);
		convertView.setTag(R.string.song_file_path, filePath);
		convertView.setTag(R.string.album_art, artworkPath);
		convertView.setTag(R.string.field_1, field1);
		convertView.setTag(R.string.field_2, field2);
		convertView.setTag(R.string.field_3, field3);
		convertView.setTag(R.string.field_4, field4);
		convertView.setTag(R.string.field_5, field5);
		
		//Set the tags for this list item's overflow button.
		mHolder.overflowIcon.setTag(R.string.title_text, titleText);
		mHolder.overflowIcon.setTag(R.string.source, source);
		mHolder.overflowIcon.setTag(R.string.file_path, filePath);
		mHolder.overflowIcon.setTag(R.string.field_1, field1);
		mHolder.overflowIcon.setTag(R.string.field_2, field2);
		mHolder.overflowIcon.setTag(R.string.field_3, field3);
		mHolder.overflowIcon.setTag(R.string.field_4, field4);
		mHolder.overflowIcon.setTag(R.string.field_5, field5);
		
		//Set the title text in the ListView.
		mHolder.titleText.setText(titleText);
		mHolder.subText.setText(field2);
		mHolder.rightSubText.setText(field1);

		//Load the album art.
        mApp.getPicasso().load(artworkPath)
                         .transform(new PicassoCircularTransformer())
                         .placeholder(UIElementsHelper.getEmptyCircularColorPatch(mContext))
                         .resizeDimen(R.dimen.list_view_left_icon_size, R.dimen.list_view_left_icon_size)
                         .into(mHolder.leftImage);
		
		return convertView;
	}

    /**
     * Click listener for overflow button.
     */
    private OnClickListener overflowClickListener = new OnClickListener() {

		@Override
		public void onClick(View v) {
			PopupMenu menu = new PopupMenu(mContext, v);
			menu.inflate(R.menu.artist_overflow_menu);
			menu.setOnMenuItemClickListener(popupMenuItemClickListener);
			mName = (String) v.getTag(R.string.artist);
		    menu.show();
			
		}
    	
    };
    
    /**
     * Menu item click listener for the pop up menu.
     */
    private OnMenuItemClickListener popupMenuItemClickListener = new OnMenuItemClickListener() {

		@Override
		public boolean onMenuItemClick(MenuItem item) {
			
			switch(item.getItemId()) {
        	case R.id.edit_artist_tags:
        		//Edit Artist Tags.
        		if (mApp.getSharedPreferences().getBoolean("SHOW_ARTIST_EDIT_CAUTION", true)==true) {
            		FragmentTransaction transaction = mListViewFragment.getFragmentManager().beginTransaction();
            		Bundle bundle = new Bundle();
            		bundle.putString("EDIT_TYPE", "ARTIST");
            		bundle.putString("ARTIST", mName);
            		CautionEditArtistsDialog dialog = new CautionEditArtistsDialog();
            		dialog.setArguments(bundle);
            		dialog.show(transaction, "cautionArtistsDialog");
        		} else {
    				FragmentTransaction ft = mListViewFragment.getFragmentManager().beginTransaction();
    				Bundle bundle = new Bundle();
    				bundle.putString("EDIT_TYPE", "ARTIST");
    				bundle.putString("ARTIST", mName);
    				ID3sArtistEditorDialog dialog = new ID3sArtistEditorDialog();
    				dialog.setArguments(bundle);
    				dialog.show(ft, "id3ArtistEditorDialog");
        		}
        		break;
        	case R.id.add_to_queue: 
        		//Add to Queue.
        		AsyncAddToQueueTask task = new AsyncAddToQueueTask(mContext,
        														   mListViewFragment,
        														   "ARTIST",
        														   mName, 
        														   null,
        														   null, 
        														   null, 
        														   null,
        														   null,
        														   null);
        		task.execute();
        		break;
        	case R.id.play_next:
        		AsyncAddToQueueTask playNextTask = new AsyncAddToQueueTask(mContext,
																		   mListViewFragment,
																		   "ARTIST",
																		   mName, 
																		   null,
																		   null, 
																		   null, 
																		   null,
																		   null,
																		   null);
        		playNextTask.execute(new Boolean[] { true });
        		break;
        	case R.id.add_to_playlist:
        		//Add to Playlist
        		FragmentTransaction ft = mListViewFragment.getFragmentManager().beginTransaction();
				AddToPlaylistDialog dialog = new AddToPlaylistDialog();
				Bundle bundle = new Bundle();
				bundle.putString("ADD_TYPE", "ARTIST");
				bundle.putString("ARTIST", mName);
				dialog.setArguments(bundle);
				dialog.show(ft, "AddToPlaylistDialog");
				break;
        	case R.id.blacklist_artist:
        		//Blacklist Artist
        		mApp.getDBAccessHelper().setBlacklistForArtist(mName, true);
        		Toast.makeText(mContext, R.string.artist_blacklisted, Toast.LENGTH_SHORT).show();
        		
        		//Update the ListView.
        		mListViewFragment.mHandler.post(mListViewFragment.queryRunnable);
        		mListViewFragment.getListViewAdapter().notifyDataSetChanged();

        		break;
        	
			}
			
			return false;
		}
    	
    };

    /**
     * Holder subclass for ListViewCardsAdapter.
     * 
     * @author Saravan Pantham
     */
	static class ListViewHolder {
	    public ImageView leftImage;
	    public TextView titleText;
	    public TextView subText;
	    public TextView rightSubText;
	    public ImageButton overflowIcon;
        public RelativeLayout subTextParent;

	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.ListViewFragment;

import android.content.Context;
import android.database.Cursor;
import android.graphics.BitmapFactory;
import android.graphics.Paint;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.provider.MediaStore;
import android.support.v4.app.Fragment;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.LinearInterpolator;
import android.view.animation.TranslateAnimation;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.andraskindler.quickscroll.QuickScroll;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.DBHelpers.MediaStoreAccessHelper;
import com.jams.music.player.Helpers.PauseOnScrollHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.MainActivity.MainActivity;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

import java.util.HashMap;

/**
 * Generic, multipurpose ListView fragment.
 * 
 * @author Saravan Pantham
 */
public class ListViewFragment extends Fragment {
	
	private Context mContext;
	private ListViewFragment mFragment;
	private Common mApp;
	private View mRootView;
	private int mFragmentId;
    private String mFragmentTitle;
	
	private QuickScroll mQuickScroll;
	private ListViewCardsAdapter mListViewAdapter;
    private HashMap<Integer, String> mDBColumnsMap;
	private ListView mListView;
	private TextView mEmptyTextView;
	
	private RelativeLayout mSearchLayout;
	private EditText mSearchEditText;
	
	public Handler mHandler = new Handler();
	private Cursor mCursor;
	private String mQuerySelection = "";
	
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mRootView = (ViewGroup) inflater.inflate(R.layout.fragment_list_view, container, false);
        mContext = getActivity().getApplicationContext();
	    mApp = (Common) mContext;
        mFragment = this;
        
        //Set the background. We're using getGridViewBackground() since the list doesn't have card items.
        mRootView.setBackgroundColor(UIElementsHelper.getGridViewBackground(mContext));
        
        //Grab the fragment. This will determine which data to load into the cursor.
        mFragmentId = getArguments().getInt(Common.FRAGMENT_ID);
        mFragmentTitle = getArguments().getString(MainActivity.FRAGMENT_HEADER);
        mDBColumnsMap = new HashMap<Integer, String>();
        
	    //Init the search fields.
	    mSearchLayout = (RelativeLayout) mRootView.findViewById(R.id.search_layout);
	    mSearchEditText = (EditText) mRootView.findViewById(R.id.search_field);
	    
	    mSearchEditText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
	    mSearchEditText.setPaintFlags(mSearchEditText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
	    mSearchEditText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
	    mSearchEditText.setFocusable(true);
	    mSearchEditText.setCursorVisible(true);
	    
        mQuickScroll = (QuickScroll) mRootView.findViewById(R.id.quickscroll);

	    mListView = (ListView) mRootView.findViewById(R.id.generalListView);
        mListView.setVerticalScrollBarEnabled(false);

        //Apply the ListViews' dividers.
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            mListView.setDivider(mContext.getResources().getDrawable(R.drawable.icon_list_divider));
        } else {
            mListView.setDivider(mContext.getResources().getDrawable(R.drawable.icon_list_divider_light));
        }

		mListView.setDividerHeight(1);
        
        //KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
        	int topPadding = Common.getStatusBarHeight(mContext);
            
            //Calculate navigation bar height.
            int navigationBarHeight = 0;
            int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
            if (resourceId > 0) {
                navigationBarHeight = getResources().getDimensionPixelSize(resourceId);
            }
            
            mListView.setClipToPadding(false);
            mListView.setPadding(0, topPadding, 0, navigationBarHeight);
            mQuickScroll.setPadding(0, topPadding, 0, navigationBarHeight);

            RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams) mListView.getLayoutParams();
            layoutParams = (RelativeLayout.LayoutParams) mSearchLayout.getLayoutParams();
            layoutParams.setMargins(15, topPadding + 15, 15, 0);
            mSearchLayout.setLayoutParams(layoutParams);
            
        }

        //Set the empty views.
        mEmptyTextView = (TextView) mRootView.findViewById(R.id.empty_view_text);
	    mEmptyTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Light"));
	    mEmptyTextView.setPaintFlags(mEmptyTextView.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        //Create a set of options to optimize the bitmap memory usage.
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        options.inJustDecodeBounds = false;
        options.inPurgeable = true;
	    
        mHandler.postDelayed(queryRunnable, 400);
        return mRootView;
    }
    
    /**
     * Query runnable.
     */
    public Runnable queryRunnable = new Runnable() {

		@Override
		public void run() {
			new AsyncRunQuery().execute();
			
		}
    	
    };
    
    /**
     * Displays the search field.
     */
    private void showSearch() {
    	mSearchLayout.setVisibility(View.VISIBLE);
    	final TranslateAnimation searchAnim = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0f, 
    														   		 Animation.RELATIVE_TO_SELF, 0f, 
    														   		 Animation.RELATIVE_TO_SELF, -2f, 
    														   		 Animation.RELATIVE_TO_SELF, 0f);
    	searchAnim.setDuration(500l);
    	searchAnim.setInterpolator(new AccelerateDecelerateInterpolator());
    	
    	final TranslateAnimation gridListAnim = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0f, 
		   		 													   Animation.RELATIVE_TO_SELF, 0f, 
		   		 													   Animation.RELATIVE_TO_SELF, 0f, 
		   		 													   Animation.RELATIVE_TO_SELF, 2f);

    	gridListAnim.setDuration(500l);
    	gridListAnim.setInterpolator(new LinearInterpolator());
    	
    	gridListAnim.setAnimationListener(new AnimationListener() {

			@Override
			public void onAnimationEnd(Animation animation) {
				mListView.setAdapter(null);
				
			}

			@Override
			public void onAnimationRepeat(Animation animation) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void onAnimationStart(Animation animation) {
				mSearchLayout.startAnimation(searchAnim);
				mSearchLayout.setVisibility(View.VISIBLE);
				
			}
    		
    	});
    	
    	searchAnim.setAnimationListener(new AnimationListener() {

			@Override
			public void onAnimationEnd(Animation animation) {
				if (mSearchEditText.requestFocus()) {
				    mFragment.getActivity()
				    		.getWindow()
				    		.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
				}
				
			}

			@Override
			public void onAnimationRepeat(Animation animation) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void onAnimationStart(Animation animation) {
				// TODO Auto-generated method stub
				
			}
    		
    	});
    	
    	mListView.startAnimation(gridListAnim);
    	
    }
    
    /**
     * Item click listener for the ListView.
     */
    private OnItemClickListener onItemClickListener = new OnItemClickListener() {

		@Override
		public void onItemClick(AdapterView<?> arg0, View view, int index, long id) {
            switch (mFragmentId) {
                case Common.SONGS_FRAGMENT:
                    mApp.getPlaybackKickstarter()
                        .initPlayback(mContext,
                                      mQuerySelection,
                                      Common.PLAY_ALL_SONGS,
                                      index,
                                      true,
                                      false);
                    break;
                case Common.PLAYLISTS_FRAGMENT:
                    
                    break;
            }
			
		}
    	
    };
    
    @Override
    public void onDestroyView() {
    	super.onDestroyView();
    	mRootView = null;
    	
    	if (mCursor!=null) {
        	mCursor.close();
        	mCursor = null;
    	}
    	
    	onItemClickListener = null;
    	mListView = null;
    	mListView = null;
    	mListViewAdapter = null;
    	mContext = null;
    	mHandler = null;
    	
    }
    
    /**
     * Runs the correct DB query based on the passed in fragment id and 
     * displays the ListView.
     * 
     * @author Saravan Pantham
     */
    public class AsyncRunQuery extends AsyncTask<Void, Void, Void> {

		@Override
		protected Void doInBackground(Void... params) {
            if (mFragmentId==Common.PLAYLISTS_FRAGMENT)
                mCursor = MediaStoreAccessHelper.getAllUniquePlaylists(mContext);
            else
                mCursor = mApp.getDBAccessHelper().getFragmentCursor(mContext, mQuerySelection, mFragmentId);

            loadDBColumnNames();
	        return null;
		}
		
		/**
		 * Populates the DB column names based on the specifed fragment id.
		 */
		private void loadDBColumnNames() {
			
			switch (mFragmentId) {
			case Common.ARTISTS_FRAGMENT:
				mDBColumnsMap.put(ListViewCardsAdapter.TITLE_TEXT, DBAccessHelper.SONG_ARTIST);
				mDBColumnsMap.put(ListViewCardsAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
				mDBColumnsMap.put(ListViewCardsAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
				mDBColumnsMap.put(ListViewCardsAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
				break;
			case Common.ALBUM_ARTISTS_FRAGMENT:
				mDBColumnsMap.put(ListViewCardsAdapter.TITLE_TEXT, DBAccessHelper.SONG_ALBUM_ARTIST);
				mDBColumnsMap.put(ListViewCardsAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
				mDBColumnsMap.put(ListViewCardsAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
				mDBColumnsMap.put(ListViewCardsAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
				break;
			case Common.ALBUMS_FRAGMENT:
				mDBColumnsMap.put(ListViewCardsAdapter.TITLE_TEXT, DBAccessHelper.SONG_ALBUM);
				mDBColumnsMap.put(ListViewCardsAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
				mDBColumnsMap.put(ListViewCardsAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
				mDBColumnsMap.put(ListViewCardsAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
				break;
			case Common.SONGS_FRAGMENT:
				mDBColumnsMap.put(ListViewCardsAdapter.TITLE_TEXT, DBAccessHelper.SONG_TITLE);
				mDBColumnsMap.put(ListViewCardsAdapter.SOURCE, DBAccessHelper.SONG_SOURCE);
				mDBColumnsMap.put(ListViewCardsAdapter.FILE_PATH, DBAccessHelper.SONG_FILE_PATH);
				mDBColumnsMap.put(ListViewCardsAdapter.ARTWORK_PATH, DBAccessHelper.SONG_ALBUM_ART_PATH);
				mDBColumnsMap.put(ListViewCardsAdapter.FIELD_1, DBAccessHelper.SONG_DURATION);
				mDBColumnsMap.put(ListViewCardsAdapter.FIELD_2, DBAccessHelper.SONG_ARTIST);
				break;
			case Common.PLAYLISTS_FRAGMENT:
                mDBColumnsMap.put(ListViewCardsAdapter.TITLE_TEXT, MediaStore.Audio.Playlists.NAME);
                mDBColumnsMap.put(ListViewCardsAdapter.FIELD_1, MediaStore.Audio.Playlists._COUNT);
				break;
			case Common.GENRES_FRAGMENT:
				break;
			case Common.FOLDERS_FRAGMENT:
				break;
			}
			
		}
    	
		@Override
		public void onPostExecute(Void result) {
			super.onPostExecute(result);
			
			TranslateAnimation animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f, 
					  											  Animation.RELATIVE_TO_SELF, 0.0f, 
					  											  Animation.RELATIVE_TO_SELF, 2.0f, 
					  											  Animation.RELATIVE_TO_SELF, 0.0f);

			animation.setDuration(600);
			animation.setInterpolator(new AccelerateDecelerateInterpolator());
			
        	mListViewAdapter = new ListViewCardsAdapter(mContext, mFragment, mDBColumnsMap);
	        mListView.setAdapter(mListViewAdapter);
            mListView.setOnItemClickListener(onItemClickListener);
	        
	     /* SwingBottomInAnimationAdapter animationAdapter = new SwingBottomInAnimationAdapter(mListViewAdapter);
	        animationAdapter.setShouldAnimate(true);
	        animationAdapter.setShouldAnimateFromPosition(0);
	        animationAdapter.setAbsListView(mListView);
	        mListView.setAdapter(animationAdapter); */
	        
	        //Init the quick scroll widget.
	        mQuickScroll.init(QuickScroll.TYPE_INDICATOR_WITH_HANDLE, 
	        				  mListView,
	        				  (ListViewCardsAdapter) mListViewAdapter,
	        				  QuickScroll.STYLE_HOLO);
	        
	        int[] quickScrollColors = UIElementsHelper.getQuickScrollColors(mContext);
            PauseOnScrollHelper scrollListener = new PauseOnScrollHelper(mApp.getPicasso(), null, true, true);

            mQuickScroll.setOnScrollListener(scrollListener);
            mQuickScroll.setPicassoInstance(mApp.getPicasso());
	        mQuickScroll.setHandlebarColor(quickScrollColors[0], quickScrollColors[0], quickScrollColors[1]);
	        mQuickScroll.setIndicatorColor(quickScrollColors[1], quickScrollColors[0], quickScrollColors[2]);
	        mQuickScroll.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 48);
	        
	        animation.setAnimationListener(new AnimationListener() {

				@Override
				public void onAnimationEnd(Animation arg0) {
					mQuickScroll.setVisibility(View.VISIBLE);
					
				}

				@Override
				public void onAnimationRepeat(Animation arg0) {
					// TODO Auto-generated method stub
					
				}

				@Override
				public void onAnimationStart(Animation arg0) {
					mListView.setVisibility(View.VISIBLE);
					
				}
	        	
	        });
	        
	        mListView.startAnimation(animation);
			
		}
		
    }

    @Override
    public void onResume() {
        super.onResume();

        //Set the ActionBar title.
        getActivity().getActionBar().setTitle(mFragmentTitle);

    }

    /*
     * Getter methods.
     */

	public ListViewCardsAdapter getListViewAdapter() {
		return (ListViewCardsAdapter) mListViewAdapter;
	}

	public ListView getListView() {
		return mListView;
	}

	public Cursor getCursor() {
		return mCursor;
	}

    public int getFragmentId() {
        return mFragmentId;
    }

	/*
	 * Setter methods.
	 */
	
	public void setCursor(Cursor cursor) {
		this.mCursor = cursor;
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MainActivity;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.graphics.drawable.ColorDrawable;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.ActionBarDrawerToggle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.widget.DrawerLayout;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.FrameLayout;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.Drawers.NavigationDrawerFragment;
import com.jams.music.player.Drawers.QueueDrawerFragment;
import com.jams.music.player.FoldersFragment.FilesFoldersFragment;
import com.jams.music.player.GridViewFragment.GridViewFragment;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.ListViewFragment.ListViewFragment;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

public class MainActivity extends FragmentActivity {

	//Context and Common object(s).
	private Context mContext;
	private Common mApp;

	//UI elements.
	private FrameLayout mDrawerParentLayout;
	private DrawerLayout mDrawerLayout;
	private RelativeLayout mNavDrawerLayout;
	private RelativeLayout mCurrentQueueDrawerLayout;
	private ActionBarDrawerToggle mDrawerToggle;
    private QueueDrawerFragment mQueueDrawerFragment;
    private Menu mMenu;
	
	//Current fragment params.
	private Fragment mCurrentFragment;
	public static int mCurrentFragmentId;
	public static int mCurrentFragmentLayout;
	
	//Layout flags.
	public static final String CURRENT_FRAGMENT = "CurrentFragment";
	public static final String ARTISTS_FRAGMENT_LAYOUT = "ArtistsFragmentLayout";
	public static final String ALBUM_ARTISTS_FRAGMENT_LAYOUT = "AlbumArtistsFragmentLayout";
	public static final String ALBUMS_FRAGMENT_LAYOUT = "AlbumsFragmentLayout";
	public static final String PLAYLISTS_FRAGMENT_LAYOUT = "PlaylistsFragmentLayout";
	public static final String GENRES_FRAGMENT_LAYOUT = "GenresFragmentLayout";
	public static final String FOLDERS_FRAGMENT_LAYOUT = "FoldersFragmentLayout";
    public static final String FRAGMENT_HEADER = "FragmentHeader";
	public static final int LIST_LAYOUT = 0;
	public static final int GRID_LAYOUT = 1;
	
	@Override
	public void onCreate(Bundle savedInstanceState) {
		
		//Context and Common object(s).
        mContext = getApplicationContext();
        mApp = (Common) getApplicationContext();
        
        //Set the theme and inflate the layout.
        setTheme();
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        //Init the UI elements.
        mDrawerParentLayout = (FrameLayout) findViewById(R.id.main_activity_root);
        mDrawerLayout = (DrawerLayout) findViewById(R.id.main_activity_drawer_root);
        mNavDrawerLayout = (RelativeLayout) findViewById(R.id.nav_drawer_container);
        mCurrentQueueDrawerLayout = (RelativeLayout) findViewById(R.id.current_queue_drawer_container);

        //Load the drawer fragments.
        loadDrawerFragments();
		
        //KitKat specific translucency.
        applyKitKatTranslucency();
        
        //Load the fragment.
        loadFragment(savedInstanceState);
        
    	/**
    	 * Navigation drawer toggle.
    	 */
    	mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, 
    			  								  R.drawable.ic_navigation_drawer, 
    			  								  0, 0) {

    		@Override
    		public void onDrawerClosed(View view) {
    			if (mQueueDrawerFragment!=null &&
                    view==mCurrentQueueDrawerLayout)
                    mQueueDrawerFragment.setIsDrawerOpen(false);
    		
    		}

    		@Override
    		public void onDrawerOpened(View view) {
                if (mQueueDrawerFragment!=null &&
                    view==mCurrentQueueDrawerLayout)
                    mQueueDrawerFragment.setIsDrawerOpen(true);

    		}

    	};

    	//Apply the drawer toggle to the DrawerLayout.
    	mDrawerLayout.setDrawerListener(mDrawerToggle);
    	getActionBar().setDisplayHomeAsUpEnabled(true);
    	getActionBar().setDisplayShowHomeEnabled(true);

        //Check if this is the first time the app is being started.
        if (mApp.getSharedPreferences().getBoolean(Common.FIRST_RUN, true)==true) {
            showAlbumArtScanningDialog();
            mApp.getSharedPreferences().edit().putBoolean(Common.FIRST_RUN, false).commit();
        }
    	
	}
	
	/**
	 * Sets the entire activity-wide theme.
	 */
	private void setTheme() {
    	//Set the UI theme.
    	if (mApp.getCurrentTheme()==Common.DARK_THEME) {
    		setTheme(R.style.AppTheme);
    	} else {
    		setTheme(R.style.AppThemeLight);
    	}
    	
	}
	
	/**
	 * Apply KitKat specific translucency.
	 */
	private void applyKitKatTranslucency() {
		
		//KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {

        	//Set the window background.
        	getWindow().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));
        	
    		int topPadding = Common.getStatusBarHeight(mContext);
    		if (mDrawerLayout!=null) {
    			mDrawerLayout.setPadding(0, topPadding, 0, 0);
    			mNavDrawerLayout.setPadding(0, topPadding, 0, 0);
    			mCurrentQueueDrawerLayout.setPadding(0, topPadding, 0, 0);
    		}

            //Calculate ActionBar and navigation bar height.
            TypedValue tv = new TypedValue();
            int actionBarHeight = 0;
            if (getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) {
                actionBarHeight = TypedValue.complexToDimensionPixelSize(tv.data, getResources().getDisplayMetrics());
            }

            if (mDrawerParentLayout!=null) {
            	mDrawerParentLayout.setPadding(0, actionBarHeight, 0, 0);
            	mDrawerParentLayout.setClipToPadding(false);
            }
            
        }
        
	}
	
	/**
	 * Loads the correct fragment based on the selected browser.
	 */
	public void loadFragment(Bundle savedInstanceState) {
		//Get the target fragment from savedInstanceState if it's not null (orientation changes?).
		if (savedInstanceState!=null) {
			mCurrentFragmentId = savedInstanceState.getInt(CURRENT_FRAGMENT);
            invalidateOptionsMenu();
			
		} else {
			//Set the current fragment based on the intent's extras.
    		if (getIntent().hasExtra(CURRENT_FRAGMENT)) {
    			mCurrentFragmentId = getIntent().getExtras().getInt(CURRENT_FRAGMENT);
    		}
    		
    		switch (mCurrentFragmentId) {
    		case Common.ARTISTS_FRAGMENT:
    			mCurrentFragment = getLayoutFragment(Common.ARTISTS_FRAGMENT);
    			break;
    		case Common.ALBUM_ARTISTS_FRAGMENT:
    			mCurrentFragment = getLayoutFragment(Common.ALBUM_ARTISTS_FRAGMENT);
    			break;
    		case Common.ALBUMS_FRAGMENT:
    			mCurrentFragment = getLayoutFragment(Common.ALBUMS_FRAGMENT);
    			break;
    		case Common.SONGS_FRAGMENT:
    			mCurrentFragment = getLayoutFragment(Common.SONGS_FRAGMENT);
    			break;
    		case Common.PLAYLISTS_FRAGMENT:
    			mCurrentFragment = getLayoutFragment(Common.PLAYLISTS_FRAGMENT);
    			break;
    		case Common.GENRES_FRAGMENT:
    			mCurrentFragment = getLayoutFragment(Common.GENRES_FRAGMENT);
    			break;
    		case Common.FOLDERS_FRAGMENT:
    			mCurrentFragment = new FilesFoldersFragment();
    			break;
    		}
    		
    		switchContent(mCurrentFragment);
		}
		
	}
	
	/**
	 * Retrieves the correct fragment based on the saved layout preference.
	 */
	private Fragment getLayoutFragment(int fragmentId) {
		
		//Instantiate a new bundle.
		Fragment fragment = null;
		Bundle bundle = new Bundle();
		
		//Retrieve layout preferences for the current fragment.
		switch (fragmentId) {
		case Common.ARTISTS_FRAGMENT:
			mCurrentFragmentLayout = mApp.getSharedPreferences().getInt(ARTISTS_FRAGMENT_LAYOUT, GRID_LAYOUT);
			bundle.putInt(Common.FRAGMENT_ID, Common.ARTISTS_FRAGMENT);
            bundle.putString(FRAGMENT_HEADER, mContext.getResources().getString(R.string.artists));
			break;
		case Common.ALBUM_ARTISTS_FRAGMENT:
			mCurrentFragmentLayout = mApp.getSharedPreferences().getInt(ALBUM_ARTISTS_FRAGMENT_LAYOUT, GRID_LAYOUT);
			bundle.putInt(Common.FRAGMENT_ID, Common.ALBUM_ARTISTS_FRAGMENT);
            bundle.putString(FRAGMENT_HEADER, mContext.getResources().getString(R.string.album_artists));
			break;
		case Common.ALBUMS_FRAGMENT:
			mCurrentFragmentLayout = mApp.getSharedPreferences().getInt(ALBUMS_FRAGMENT_LAYOUT, GRID_LAYOUT);
			bundle.putInt(Common.FRAGMENT_ID, Common.ALBUMS_FRAGMENT);
            bundle.putString(FRAGMENT_HEADER, mContext.getResources().getString(R.string.albums));
			break;
		case Common.SONGS_FRAGMENT:
			mCurrentFragmentLayout = LIST_LAYOUT;
			bundle.putInt(Common.FRAGMENT_ID, Common.SONGS_FRAGMENT);
            bundle.putString(FRAGMENT_HEADER, mContext.getResources().getString(R.string.songs));
			break;
		case Common.PLAYLISTS_FRAGMENT:
			mCurrentFragmentLayout = mApp.getSharedPreferences().getInt(PLAYLISTS_FRAGMENT_LAYOUT, LIST_LAYOUT);
			bundle.putInt(Common.FRAGMENT_ID, Common.PLAYLISTS_FRAGMENT);
            bundle.putString(FRAGMENT_HEADER, mContext.getResources().getString(R.string.playlists));
			break;
		case Common.GENRES_FRAGMENT:
			mCurrentFragmentLayout = mApp.getSharedPreferences().getInt(GENRES_FRAGMENT_LAYOUT, GRID_LAYOUT);
			bundle.putInt(Common.FRAGMENT_ID, Common.GENRES_FRAGMENT);
            bundle.putString(FRAGMENT_HEADER, mContext.getResources().getString(R.string.genres));
			break;
		case Common.FOLDERS_FRAGMENT:
			mCurrentFragmentLayout = mApp.getSharedPreferences().getInt(FOLDERS_FRAGMENT_LAYOUT, LIST_LAYOUT);
			bundle.putInt(Common.FRAGMENT_ID, Common.FOLDERS_FRAGMENT);
            bundle.putString(FRAGMENT_HEADER, mContext.getResources().getString(R.string.folders));
			break;
		}		
				
		//Return the correct layout fragment.
		if (mCurrentFragmentLayout==GRID_LAYOUT) {
			fragment = new GridViewFragment();
			fragment.setArguments(bundle);
		} else {
			fragment = new ListViewFragment();
			fragment.setArguments(bundle);
		}
		
		return fragment;
	}
	
	/**
	 * Loads the specified fragment into the target layout.
	 */
	public void switchContent(Fragment fragment) {
        // Reset action bar
        getActionBar().setDisplayHomeAsUpEnabled(true);
        getActionBar().setDisplayShowHomeEnabled(true);
        getActionBar().setDisplayShowCustomEnabled(false);

		getSupportFragmentManager().beginTransaction()
								   .replace(R.id.mainActivityContainer, fragment)
								   .commit();
		
		//Close the drawer(s).
		mDrawerLayout.closeDrawer(Gravity.START);
        invalidateOptionsMenu();

	}
	
	/**
	 * Loads the drawer fragments.
	 */
	private void loadDrawerFragments() {
		//Load the navigation drawer.
		getSupportFragmentManager().beginTransaction()
		   						   .replace(R.id.nav_drawer_container, new NavigationDrawerFragment())
		   						   .commit();
		
		//Load the current queue drawer.
        mQueueDrawerFragment = new QueueDrawerFragment();
		getSupportFragmentManager().beginTransaction()
		   						   .replace(R.id.current_queue_drawer_container, mQueueDrawerFragment)
		   						   .commit();
		
	}

	/**
	 * Called when the user taps on the "Play all" or "Shuffle all" action button.
	 */
	public void playAll(boolean shuffle) {
		//Start the playback sequence.
		mApp.getPlaybackKickstarter().initPlayback(mContext, "", Common.PLAY_ALL_SONGS, 0, true, true);

	}

    /**
     * Displays the message dialog for album art processing.
     */
    private void showAlbumArtScanningDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle(R.string.album_art);
        builder.setMessage(R.string.scanning_for_album_art_details);
        builder.setPositiveButton(R.string.got_it, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                dialog.dismiss();
            }

        });

        builder.create().show();
    }

    /**
     * Inflates the generic MainActivity ActionBar layout.
     *
     * @param inflater The ActionBar's menu inflater.
     * @param menu The ActionBar menu to work with.
     */
    private void showMainActivityActionItems(MenuInflater inflater, Menu menu) {
        //Inflate the menu.
        getMenu().clear();
        inflater = getMenuInflater();
        inflater.inflate(R.menu.main_activity, menu);

        //Set the ActionBar background
        getActionBar().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));
        getActionBar().setDisplayShowTitleEnabled(true);
        getActionBar().setDisplayUseLogoEnabled(false);
        getActionBar().setHomeButtonEnabled(true);

        //Set the ActionBar text color.
        int actionBarTitleId = Resources.getSystem().getIdentifier("action_bar_title", "id", "android");
        if (actionBarTitleId > 0) {
            TextView title = (TextView) findViewById(actionBarTitleId);
            if (title != null) {
                title.setTextColor(0xFFFFFFFF);
            }

        }

    }

    /**
     * Displays the folder fragment's action items.
     *
     * @param filePath The file path to set as the ActionBar's title text.
     * @param inflater The ActionBar's menu inflater.
     * @param menu The ActionBar menu to work with.
     * @param showPaste Pass true if the ActionBar is being updated for a copy/move operation.
     */
    public void showFolderFragmentActionItems(String filePath,
                                              MenuInflater inflater,
                                              Menu menu,
                                              boolean showPaste) {
        getMenu().clear();
        inflater.inflate(R.menu.files_folders_fragment, menu);


        getActionBar().setDisplayShowTitleEnabled(false);
        getActionBar().setDisplayUseLogoEnabled(false);
        getActionBar().setDisplayShowCustomEnabled(true);
        getActionBar().setHomeButtonEnabled(true);
        getActionBar().setLogo(0);
        getActionBar().setIcon(0);

        if (showPaste) {
            //Change the ActionBar's background and show the Paste Here option.
            menu.findItem(R.id.action_paste).setVisible(true);
            menu.findItem(R.id.action_cancel).setVisible(true);
            getActionBar().setBackgroundDrawable(mContext.getResources()
                                                         .getDrawable(R.drawable.cab_background_top_apptheme));

            //Change the KitKat system bar color.
            if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT)
                getWindow().setBackgroundDrawable(new ColorDrawable(0xFF002E3E));

        } else {
            //Hide the Paste Here option and set the default ActionBar background.
            menu.findItem(R.id.action_paste).setVisible(false);
            menu.findItem(R.id.action_cancel).setVisible(false);
            getActionBar().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));

            //Change the KitKat system bar color.
            if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT)
                getWindow().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));

        }

        LayoutInflater inflator = LayoutInflater.from(this);
        View view = inflator.inflate(R.layout.custom_actionbar_layout, null);

        TextView titleText = (TextView) view.findViewById(R.id.custom_actionbar_title);
        titleText.setText(filePath);
        titleText.setSelected(true);
        titleText.setTextColor(0xFFFFFFFF);

        //Inject the custom view into the ActionBar.
        getActionBar().setCustomView(view);

    }
	
	/**
	 * Initializes the ActionBar.
	 */
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
        mMenu = menu;
        if (mCurrentFragmentId==Common.FOLDERS_FRAGMENT)
            showFolderFragmentActionItems(FilesFoldersFragment.currentDir,
                                          getMenuInflater(), menu, false);
        else
            showMainActivityActionItems(getMenuInflater(), menu);

		return super.onCreateOptionsMenu(menu);
	}

	/**
	 * ActionBar item selection listener.
	 */
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		
		if (mDrawerToggle.onOptionsItemSelected(item)) {
			return true;
	    }
		
		switch (item.getItemId()) {
		case R.id.action_search:
			//ArtistsFragment.showSearch();
			return true;
	    case R.id.action_queue_drawer:
	    	if (mDrawerLayout!=null && mCurrentQueueDrawerLayout!=null) {
		    	if (mDrawerLayout.isDrawerOpen(mCurrentQueueDrawerLayout)) {
		    		mDrawerLayout.closeDrawer(mCurrentQueueDrawerLayout);
		    	} else {
		    		mDrawerLayout.openDrawer(mCurrentQueueDrawerLayout);
		    	}
		    	
	    	}
	    	return true;
        case R.id.action_up:
            ((FilesFoldersFragment) mCurrentFragment).getParentDir();
            return true;
        case R.id.action_paste:
            ((FilesFoldersFragment) mCurrentFragment).pasteIntoCurrentDir(((FilesFoldersFragment) mCurrentFragment).copyMoveSourceFile);
            showMainActivityActionItems(getMenuInflater(), getMenu());
            return true;
        case R.id.action_cancel:
            ((FilesFoldersFragment) mCurrentFragment).copyMoveSourceFile = null;
            if (((FilesFoldersFragment) mCurrentFragment).shouldMoveCopiedFile)
                Toast.makeText(mContext, R.string.move_canceled, Toast.LENGTH_LONG).show();
            else
                Toast.makeText(mContext, R.string.copy_canceled, Toast.LENGTH_LONG).show();
            return true;
	    default:
	        return super.onOptionsItemSelected(item);
	    }
		
	}
	
	@Override
    protected void onPostCreate(Bundle savedInstanceState) {
        super.onPostCreate(savedInstanceState);
        mDrawerToggle.syncState();
    }

    @Override
    public void onBackPressed() {

        if(mDrawerLayout.isDrawerOpen(Gravity.START)) { // Close left drawer if opened
            mDrawerLayout.closeDrawer(Gravity.START);

        } else if (getCurrentFragmentId()==Common.FOLDERS_FRAGMENT) {
            if (((FilesFoldersFragment) mCurrentFragment).getCurrentDir().equals("/"))
                super.onBackPressed();
            else
                ((FilesFoldersFragment) mCurrentFragment).getParentDir();

        } else {
            super.onBackPressed();
        }

    }

    @Override
    public void onResume() {
        super.onResume();
        if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT) {
            getActionBar().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));
            getWindow().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));
        }

    }
	
	/**
	 * Getters/Setters.
	 */
	
	public int getCurrentFragmentId() {
		return mCurrentFragmentId;
	}
	
	public void setCurrentFragmentId(int id) {
		mCurrentFragmentId = id;
	}

    public Menu getMenu() {
        return mMenu;
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MiscFragments;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.AnimationUtils;
import android.widget.ProgressBar;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.jams.music.player.AsyncTasks.AsyncBuildLibraryTask;
import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncBuildLibraryTask.OnBuildLibraryProgressUpdate;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.MainActivity.MainActivity;
import com.jams.music.player.Services.BuildMusicLibraryService;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.WelcomeActivity.WelcomeActivity;

public class BuildingLibraryProgressFragment extends Fragment implements OnBuildLibraryProgressUpdate {
	
	private Context mContext;
	private Common mApp;
	private View mRootView;
	private RelativeLayout mProgressElementsContainer;
	private TextView mCurrentTaskText;
	private ProgressBar mProgressBar;
	private Animation mFadeInAnimation;
	
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		
		mContext = getActivity().getApplicationContext();
		mApp = (Common) mContext;
		mRootView = (View) getActivity().getLayoutInflater().inflate(R.layout.fragment_building_library_progress, null);
		
		mProgressElementsContainer = (RelativeLayout) mRootView.findViewById(R.id.progress_elements_container);
		mProgressElementsContainer.setVisibility(View.INVISIBLE);
		
		mCurrentTaskText = (TextView) mRootView.findViewById(R.id.building_library_task);
		mCurrentTaskText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Light"));
        mCurrentTaskText.setPaintFlags(mCurrentTaskText.getPaintFlags() 
        						       | Paint.ANTI_ALIAS_FLAG
        						       | Paint.SUBPIXEL_TEXT_FLAG);
        
        mProgressBar = (ProgressBar) mRootView.findViewById(R.id.building_library_progress);
        mProgressBar.setMax(1000000); 
        
        mFadeInAnimation = AnimationUtils.loadAnimation(mContext, R.anim.fade_in);
        mFadeInAnimation.setAnimationListener(fadeInListener);
        mFadeInAnimation.setDuration(700);
        
        return mRootView;
    }
	
	/**
	 * Fade in animation listener.
	 */
	private AnimationListener fadeInListener = new AnimationListener() {

		@Override
		public void onAnimationEnd(Animation arg0) {
			mProgressElementsContainer.setVisibility(View.VISIBLE);
			
		}

		@Override
		public void onAnimationRepeat(Animation arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onAnimationStart(Animation arg0) {
			// TODO Auto-generated method stub
			
		}
		
	};
	
	@Override
	public void onStartBuildingLibrary() {
		mProgressElementsContainer.startAnimation(mFadeInAnimation);
		
	}

	@Override
	public void onProgressUpdate(AsyncBuildLibraryTask task, String mCurrentTask,
                                 int overallProgress, int maxProgress,
                                 boolean mediaStoreTransferDone) {
        /**
         * overallProgress refers to the progress that the service's notification
         * progress bar will display. Since this fragment will only show the progress
         * of building the library (and not scanning the album art), we need to
         * multiply the overallProgress by 4 (the building library task only takes
         * up a quarter of the overall progress bar).
         */
		mProgressBar.setProgress(overallProgress*4);

        //This fragment only shows the MediaStore transfer progress.
        if (mediaStoreTransferDone)
            onFinishBuildingLibrary(task);
		
	}

	@Override
	public void onFinishBuildingLibrary(AsyncBuildLibraryTask task) {
        task.mBuildLibraryProgressUpdate.remove(0);
		Intent intent = new Intent(mContext, MainActivity.class);
		intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		mContext.startActivity(intent);

	}
	
}


@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MiscFragments;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Paint;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentTransaction;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.InAppBilling.IabHelper;
import com.jams.music.player.InAppBilling.IabResult;
import com.jams.music.player.InAppBilling.Purchase;
import com.jams.music.player.MainActivity.MainActivity;
import com.jams.music.player.Utils.Common;

public class TrialFragment extends Fragment {
	
	private Context mContext;
	private SharedPreferences sharedPreferences;
	
	protected static final String ITEM_SKU = "com.jams.music.player.unlock";
    protected static final String ITEM_SKU_PROMO = "com.jams.music.player.unlock.promo";
	
	private int numDaysRemaining;
	private boolean expired;
	
	private TextView daysRemaining;
	private TextView infoText;
	private Button laterButton;
	private Button upgradeNowButton;
	
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_trial_version, container, false);
		mContext = getActivity().getApplicationContext();
		sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		
		numDaysRemaining = getArguments().getInt("NUM_DAYS_REMAINING");
		expired = getArguments().getBoolean("EXPIRED");

        //Circumvent the trial check since the app is no longer paid.
        getActivity().finish();
        Intent intent = new Intent(mContext, MainActivity.class);
        startActivity(intent);
        return rootView;

		/*daysRemaining = (TextView) rootView.findViewById(R.id.trial_days_remaining);
		infoText = (TextView) rootView.findViewById(R.id.trial_message);
		laterButton = (Button) rootView.findViewById(R.id.upgrade_later);
		upgradeNowButton = (Button) rootView.findViewById(R.id.upgrade_now);
		
		daysRemaining.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		daysRemaining.setPaintFlags(daysRemaining.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		infoText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		infoText.setPaintFlags(infoText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		laterButton.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		laterButton.setPaintFlags(laterButton.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		upgradeNowButton.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		upgradeNowButton.setPaintFlags(upgradeNowButton.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		if (expired) {
			daysRemaining.setText(R.string.expired);
			infoText.setText(R.string.trial_expired);
			daysRemaining.setTextColor(0xFFCC0000);
		} else {
			infoText.setText(R.string.trial_running);
			if (numDaysRemaining==1) {
				daysRemaining.setText(numDaysRemaining + " " + mContext.getResources().getString(R.string.day_remaining));
			} else {
				daysRemaining.setText(numDaysRemaining + " " + mContext.getResources().getString(R.string.days_remaining));
			}
			
			daysRemaining.setTextColor(0xFF0099CC);
		}
		
		laterButton.setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View v) {
				if (expired) {
					getActivity().finish();
				} else {
					launchMainActivity();
				}
				
			}
			
		});
		
		upgradeNowButton.setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View v) {
				initUpgradeProcessWithPromo();
				
			}
			
		});
		
		//KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
        	int topPadding = Common.getStatusBarHeight(mContext);

        	//Calculate ActionBar height
            TypedValue tv = new TypedValue();
            int actionBarHeight = 0;
            if (getActivity().getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) {
                actionBarHeight = TypedValue.complexToDimensionPixelSize(tv.data,getResources().getDisplayMetrics());
            }
        	
            //Calculate navigation bar height.
            int navigationBarHeight = 0;
            int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
            if (resourceId > 0) {
                navigationBarHeight = getResources().getDimensionPixelSize(resourceId);
            }
            
            rootView.setClipToPadding(false);
            rootView.setPadding(0, topPadding + actionBarHeight, 0, navigationBarHeight);
        }
		
		return rootView;*/
	}
	
	private void initUpgradeProcessWithPromo() {
/*		//Load the special offer fragment into the activity.
		SpecialUpgradeOfferFragment fragment = new SpecialUpgradeOfferFragment();
		
		FragmentTransaction transaction = getActivity().getSupportFragmentManager().beginTransaction();
	    transaction.replace(R.id.launcher_root_view, fragment, "specialUpgradeOfferFragment");
	    transaction.commit();*/
	    
	}
	
	private void launchMainActivity() {
		Intent intent = new Intent(mContext, MainActivity.class);
		int startupScreen = sharedPreferences.getInt("STARTUP_SCREEN", 0);
		
		switch (startupScreen) {
		case 0:
			intent.putExtra("TARGET_FRAGMENT", "ARTISTS");
			break;
		case 1:
			intent.putExtra("TARGET_FRAGMENT", "ALBUM_ARTISTS");
			break;
		case 2:
			intent.putExtra("TARGET_FRAGMENT", "ALBUMS");
			break;
		case 3:
			intent.putExtra("TARGET_FRAGMENT", "SONGS");
			break;
		case 4:
			intent.putExtra("TARGET_FRAGMENT", "PLAYLISTS");
			break;
		case 5:
			intent.putExtra("TARGET_FRAGMENT", "GENRES");
			break;
		case 6:
			intent.putExtra("TARGET_FRAGMENT", "FOLDERS");
			break;
		}
		
		startActivity(intent);
		getActivity().overridePendingTransition(R.anim.fade_in, R.anim.fade_out);
		getActivity().finish();
		
	}
	
	IabHelper.OnIabPurchaseFinishedListener mPurchaseFinishedListener = new IabHelper.OnIabPurchaseFinishedListener() {
		
		public void onIabPurchaseFinished(IabResult result, Purchase purchase) {
			
			if (result.isFailure()) {	
				Toast.makeText(mContext, R.string.unable_to_purchase, Toast.LENGTH_LONG).show();
				sharedPreferences.edit().putBoolean("TRIAL", true).commit();
				return;
			} else if (purchase.getSku().equals(ITEM_SKU) || purchase.getSku().equals(ITEM_SKU_PROMO)) {
				Toast.makeText(mContext, R.string.jams_trial_time_removed, Toast.LENGTH_LONG).show();
				sharedPreferences.edit().putBoolean("TRIAL", false).commit();
				launchMainActivity();
				
			}
	      
		}
	   
	};
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MusicFoldersSelectionFragment;

import android.content.Context;
import android.graphics.Color;
import android.graphics.Paint;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Utils.Common;

import java.util.ArrayList;
import java.util.Set;

public class MultiselectListViewAdapter extends ArrayAdapter<String> {

	private Context mContext;
	private Common mApp;
	private MusicFoldersSelectionFragment mFragment;
	private boolean mDirChecked;
	private boolean mWelcomeSetup;
   
    public MultiselectListViewAdapter(Context context, 
    								  MusicFoldersSelectionFragment fragment, 
    								  boolean welcomeSetup,
    								  boolean dirChecked) {
    	
    	super(context, -1, fragment.getFileFolderNamesList());
    	
    	mContext = context;
    	mApp = (Common) mContext.getApplicationContext();
    	mFragment = fragment;
    	mDirChecked = dirChecked; //Indicates if this entire dir is a music folder.
    	mWelcomeSetup = welcomeSetup;
    	
    }
    
    @Override
    public View getView(int position, View convertView, ViewGroup parent){
		FoldersMultiselectHolder holder = null;

		if (convertView==null) {
			convertView = LayoutInflater.from(mContext).inflate(R.layout.folder_view_layout_multiselect, parent, false);

			holder = new FoldersMultiselectHolder();
			holder.fileFolderNameText = (TextView) convertView.findViewById(R.id.file_folder_title_multiselect);
			holder.fileFoldersCheckbox = (CheckBox) convertView.findViewById(R.id.music_folder_select_checkbox);
			holder.fileFoldersImage = (ImageView) convertView.findViewById(R.id.file_folder_icon);
			holder.fileFolderSizeText = (TextView) convertView.findViewById(R.id.file_folder_size_multiselect);

			//Apply the card layout's background based on the color theme.
			if (mWelcomeSetup==true || mApp.getCurrentTheme()==Common.LIGHT_THEME) {
				holder.fileFolderNameText.setTextColor(Color.parseColor("#2F2F2F"));
                holder.fileFolderSizeText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));

			} else if (mApp.getCurrentTheme()==Common.DARK_THEME) {
				holder.fileFolderNameText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
                holder.fileFolderSizeText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));

			}
			
			holder.fileFolderNameText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			holder.fileFolderSizeText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			
			holder.fileFoldersImage.setImageResource(R.drawable.icon_folderblue);
			convertView.setTag(holder);
			
		} else {
		    holder = (FoldersMultiselectHolder) convertView.getTag();
		}
		
		try {
			holder.fileFolderNameText.setText(mFragment.getFileFolderNamesList().get(position));
			holder.fileFolderSizeText.setText(mFragment.getFileFolderSizesList().get(position));
			
			//Set the corresponding path of the checkbox as it's tag.
			holder.fileFoldersCheckbox.setTag(mFragment.getFileFolderPathsList().get(position));
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		//Set the checkbox status.
		String folderPath = mFragment.getFileFolderPathsList().get(position);
		if (mDirChecked) {
			holder.fileFoldersCheckbox.setChecked(true);
			if (mFragment.getMusicFoldersHashMap().get(folderPath)!=null && 
				mFragment.getMusicFoldersHashMap().get(folderPath)==false) {
				holder.fileFoldersCheckbox.setChecked(false);
			}
			
		} else {
			holder.fileFoldersCheckbox.setChecked(false);
			if (mFragment.getMusicFoldersHashMap().get(folderPath)!=null && 
				mFragment.getMusicFoldersHashMap().get(folderPath)==true) {
				holder.fileFoldersCheckbox.setChecked(true);
			}
			
		}
		
		holder.fileFoldersCheckbox.setOnCheckedChangeListener(checkChangeListener);
		return convertView;
	}
    
    /**
	 * Checkbox status listener.
     */
    private OnCheckedChangeListener checkChangeListener = new OnCheckedChangeListener() {

		@Override
		public void onCheckedChanged(CompoundButton checkBox, boolean isChecked) {
			
			//Only respond to user presses.
			if (checkBox.isPressed()) {
				String filePath = (String) checkBox.getTag();
                if (isChecked)
				    mFragment.getMusicFoldersHashMap().put(filePath, true);
                else
                    if (mFragment.getMusicFoldersHashMap().containsKey(filePath))
                        removeKeyAndSubFolders(filePath);
                    else
                        mFragment.getMusicFoldersHashMap().put(filePath, false);
				
			}
			
		}
    	
    };

    /**
     * Loops through the HashMap and removes the specified key and
     * all other keys that start with the specified key.
     */
    private void removeKeyAndSubFolders(String key) {
        //Get a list of all file paths (keys).
        Set<String> keySet = mFragment.getMusicFoldersHashMap().keySet();
        String[] keyArray = new String[keySet.size()];
        keySet.toArray(keyArray);

        if (keyArray==null || keyArray.length==0)
            return;

        for (int i=0; i < keyArray.length; i++)
            if (keyArray[i].startsWith(key))
                mFragment.getMusicFoldersHashMap().remove(keyArray[i]);

    }

    static class FoldersMultiselectHolder {
		public TextView fileFolderNameText;
		public TextView fileFolderSizeText;
		public CheckBox fileFoldersCheckbox;
		public ImageView fileFoldersImage;

    }
   
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MusicFoldersSelectionFragment;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

import android.annotation.SuppressLint;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Utils.Common;

public class MusicFoldersSelectionFragment extends Fragment {
	
	private Context mContext;
	private Common mApp;
	private boolean mWelcomeSetup = false;

    private RelativeLayout mUpLayout;
    private ImageView mUpIcon;
    private TextView mUpText;
    private TextView mCurrentFolderText;

	private ListView mFoldersListView;
	private Cursor mCursor;
	
	private String mRootDir;
	private String mCurrentDir;
	
	private List<String> mFileFolderNamesList; 
	private List<String> mFileFolderPathsList;
	private List<String> mFileFolderSizesList;
	private HashMap<String, Boolean> mMusicFolders;
	
	private static boolean CALLED_FROM_WELCOME = false;
	
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		
		mContext = getActivity().getApplicationContext();
		mApp = (Common) mContext;
		View rootView = getActivity().getLayoutInflater().inflate(R.layout.fragment_folders_selection, null);
		mMusicFolders = new HashMap<String, Boolean>();

        mFoldersListView = (ListView) rootView.findViewById(R.id.folders_list_view);
        mFoldersListView.setFastScrollEnabled(true);
        mWelcomeSetup = getArguments().getBoolean("com.jams.music.player.WELCOME");

        mUpLayout = (RelativeLayout) rootView.findViewById(R.id.folders_up_layout);
        mUpIcon = (ImageView) rootView.findViewById(R.id.folders_up_icon);
        mUpText = (TextView) rootView.findViewById(R.id.folders_up_text);
        mCurrentFolderText = (TextView) rootView.findViewById(R.id.folders_current_directory_text);

        mUpText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        mCurrentFolderText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));

        mUpLayout.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                try {
                    getDir(new File(mCurrentDir).getParentFile().getCanonicalPath());
                } catch (Exception e) {
                    e.printStackTrace();
                }

            }

        });

        if (mWelcomeSetup) {
            mFoldersListView.setDivider(getResources().getDrawable(R.drawable.icon_list_divider_light));
            mUpIcon.setImageResource(R.drawable.up);
        } else {
            mUpIcon.setImageResource(UIElementsHelper.getIcon(mContext, "up"));

            if (mApp.getCurrentTheme()==Common.DARK_THEME) {
                mUpIcon.setImageResource(R.drawable.icon_list_divider_light);
            } else {
                mUpIcon.setImageResource(R.drawable.icon_list_divider);
            }

        }

		mFoldersListView.setDividerHeight(1);
		mRootDir = Environment.getExternalStorageDirectory().getAbsolutePath().toString();
		mCurrentDir = mRootDir;

        //Get a mCursor with a list of all the current folder paths (will be empty if this is the first run).
		mCursor = mApp.getDBAccessHelper().getAllMusicFolderPaths();
        
		//Get a list of all the paths that are currently stored in the DB.
		for (int i=0; i < mCursor.getCount(); i++) {
			mCursor.moveToPosition(i);
			
			//Filter out any double slashes.
			String path = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.FOLDER_PATH));
			if (path.contains("//")) {
				path.replace("//", "/");
			}

			mMusicFolders.put(path, true);
		}
		
		//Close the cursor.
        if (mCursor!=null)
		    mCursor.close();
		
		//Get the folder hierarchy of the selected folder.
        getDir(mRootDir);
        
        mFoldersListView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> arg0, View arg1, int index, long arg3) {
				String newPath = mFileFolderPathsList.get(index);
				getDir(newPath);
				
			}
        	
        });
        
        return rootView;
    }

    /**
     * Sets the current directory's text.
     */
    private void setCurrentDirText() {
        mCurrentFolderText.setText(mCurrentDir);
    }
	
	/**
	 * Retrieves the folder hierarchy for the specified folder 
	 * (this method is NOT recursive and doesn't go into the parent 
	 * folder's subfolders. 
	 */
    private void getDir(String dirPath) {

		mFileFolderNamesList = new ArrayList<String>();
		mFileFolderPathsList = new ArrayList<String>();
		mFileFolderSizesList = new ArrayList<String>();
		
		File f = new File(dirPath);
		File[] files = f.listFiles();
		Arrays.sort(files);
		 
		if (files!=null) {
			
			for(int i=0; i < files.length; i++) {
				
				File file = files[i];
			 
				if(!file.isHidden() && file.canRead()) {
					
					if (file.isDirectory()) {
						
						/*
						 * Starting with Android 4.2, /storage/emulated/legacy/... 
						 * is a symlink that points to the actual directory where 
						 * the user's files are stored. We need to detect the 
						 * actual directory's file path here.
						 */
						String filePath;
						if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) 
							filePath = getRealFilePath(file.getAbsolutePath());
						else
							filePath = file.getAbsolutePath();
							
						mFileFolderPathsList.add(filePath);
						mFileFolderNamesList.add(file.getName());
						
						File[] listOfFiles = file.listFiles();
						
						if (listOfFiles!=null) {
							if (listOfFiles.length==1) {
								mFileFolderSizesList.add("" + listOfFiles.length + " item");
							} else {
								mFileFolderSizesList.add("" + listOfFiles.length + " items");
							}
							
						}
						
					}
					
				} 
			
			}
			
		}
		
		boolean dirChecked = false;
		if (getMusicFoldersHashMap().get(dirPath)!=null)
			dirChecked = getMusicFoldersHashMap().get(dirPath);
		
		MultiselectListViewAdapter mFoldersListViewAdapter = new MultiselectListViewAdapter(getActivity(), 
																							this, 
																							mWelcomeSetup,
																							dirChecked);
		
		mFoldersListView.setAdapter(mFoldersListViewAdapter);
		mFoldersListViewAdapter.notifyDataSetChanged();

        mCurrentDir = dirPath;
        setCurrentDirText();
		
    }
    
    /**
     * Resolves the /storage/emulated/legacy paths to 
     * their true folder path representations. Required 
     * for Nexuses and other devices with no SD card.
     */
    @SuppressLint("SdCardPath") 
    private String getRealFilePath(String filePath) {
    	
    	if (filePath.equals("/storage/emulated/0") || 
    		filePath.equals("/storage/emulated/0/") ||
    		filePath.equals("/storage/emulated/legacy") ||
    		filePath.equals("/storage/emulated/legacy/") ||
    		filePath.equals("/storage/sdcard0") || 
    		filePath.equals("/storage/sdcard0/") ||
    		filePath.equals("/sdcard") || 
    		filePath.equals("/sdcard/") || 
    		filePath.equals("/mnt/sdcard") || 
    		filePath.equals("/mnt/sdcard/")) {
    		
    		return Environment.getExternalStorageDirectory().toString();
    	}

    	return filePath;
    }
    
	@Override
	public void onDestroy() {
		super.onDestroy();
		
		if (CALLED_FROM_WELCOME==false) {
			getActivity().finish();
		}
		
	}
	
	@Override
	public void onPause() {
		super.onPause();
		
		if (CALLED_FROM_WELCOME==false) {
			getActivity().finish();
		}
		
	}
	
	@Override
	public void onDestroyView() {
		super.onDestroyView();

		if (isRemoving()) {
			mCursor.close();
			mCursor = null;
		}
		
	}
	
	/*
	 * Getter methods.
	 */
	public HashMap<String, Boolean> getMusicFoldersHashMap() {
		return mMusicFolders;
	}
	
	public ArrayList<String> getMusicFolderPaths() {
		return new ArrayList<String>(mMusicFolders.keySet());
	}
	
	public List<String> getFileFolderNamesList() {
		return mFileFolderNamesList;
	}
	
	public List<String> getFileFolderSizesList() {
		return mFileFolderSizesList;
	}
	
	public List<String> getFileFolderPathsList() {
		return mFileFolderPathsList;
	}
	
}


@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MusicLibraryEditorActivity;

import android.annotation.SuppressLint;
import android.app.Fragment;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Build;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.ListView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.MusicLibraryEditorActivity.MusicLibraryEditorAlbumsMultiselectAdapter.AsyncGetAlbumSongIds;

public class AlbumsPickerFragment extends Fragment {
	
	public static Cursor cursor;
	public static ListView listView;
	
	@SuppressLint("NewApi")
	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		View rootView = inflater.inflate(R.layout.fragment_albums_music_library_editor, null);

		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
			rootView.setBackground(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		} else {
			rootView.setBackgroundDrawable(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		}

		cursor = MusicLibraryEditorActivity.dbHelper.getAllUniqueAlbums("");
		listView = (ListView) rootView.findViewById(R.id.musicLibraryEditorAlbumsListView);
		listView.setFastScrollEnabled(true);
		listView.setAdapter(new MusicLibraryEditorAlbumsMultiselectAdapter(getActivity(), cursor));
		
		listView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> arg0, View view, int which, long dbID) {
				CheckBox checkbox = (CheckBox) view.findViewById(R.id.albumCheckboxMusicLibraryEditor);
				checkbox.performClick();
				
				/* Since we've performed a software-click (checkbox.performClick()), all we have 
				 * to do now is determine the *new* state of the checkbox. If the checkbox is checked, 
				 * that means that the user tapped on it when it was unchecked, and we should add 
				 * the album's songs to the HashSet. If the checkbox is unchecked, that means the user 
				 * tapped on it when it was checked, so we should remove the album's songs from the 
				 * HashSet.
				 */
				if (checkbox.isChecked()) {
					view.setBackgroundColor(0xCC0099CC);
					AsyncGetAlbumSongIds task = new AsyncGetAlbumSongIds((String) view.getTag(R.string.album),
																		 (String) view.getTag(R.string.artist));
					task.execute(new String[] {"ADD"});
				} else {
					view.setBackgroundColor(0x00000000);
					AsyncGetAlbumSongIds task = new AsyncGetAlbumSongIds((String) view.getTag(R.string.album),
																		 (String) view.getTag(R.string.artist));
					task.execute(new String[] {"REMOVE"});
				}
				
			}
			
		});
		
		TextView instructions = (TextView) rootView.findViewById(R.id.albums_music_library_editor_instructions);
		instructions.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		instructions.setPaintFlags(instructions.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		//KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
        	
            //Calculate navigation bar height.
            int navigationBarHeight = 0;
            int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
            if (resourceId > 0) {
                navigationBarHeight = getResources().getDimensionPixelSize(resourceId);
            }
            
            listView.setClipToPadding(false);
            listView.setPadding(0, 0, 0, navigationBarHeight);
        }
		
		return rootView;
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MusicLibraryEditorActivity;

import android.annotation.SuppressLint;
import android.app.Fragment;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Build;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.ListView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.MusicLibraryEditorActivity.MusicLibraryEditorArtistsMultiselectAdapter.AsyncGetArtistSongIds;

public class ArtistsPickerFragment extends Fragment {
	
	public static Cursor cursor;
	public static ListView listView;
	private TextView instructions;
	
	@SuppressLint("NewApi")
	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		View rootView = inflater.inflate(R.layout.fragment_artists_music_library_editor, null);

		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
			rootView.setBackground(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		} else {
			rootView.setBackgroundDrawable(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		}
		
		cursor = MusicLibraryEditorActivity.dbHelper.getAllUniqueArtists("");
		listView = (ListView) rootView.findViewById(R.id.musicLibraryEditorArtistsListView);
		listView.setFastScrollEnabled(true);
		listView.setAdapter(new MusicLibraryEditorArtistsMultiselectAdapter(getActivity(), cursor));
		
		listView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> arg0, View view, int which, long dbID) {
				CheckBox checkbox = (CheckBox) view.findViewById(R.id.artistCheckboxMusicLibraryEditor);
				checkbox.performClick();
				
				/* Since we've performed a software-click (checkbox.performClick()), all we have 
				 * to do now is determine the *new* state of the checkbox. If the checkbox is checked, 
				 * that means that the user tapped on it when it was unchecked, and we should add 
				 * the artist's songs to the HashSet. If the checkbox is unchecked, that means the user 
				 * tapped on it when it was checked, so we should remove the artist's songs from the 
				 * HashSet.
				 */
				if (checkbox.isChecked()) {
					view.setBackgroundColor(0xCC0099CC);
					AsyncGetArtistSongIds task = new AsyncGetArtistSongIds((String) view.getTag(R.string.artist));
					task.execute(new String[] {"ADD"});
				} else {
					view.setBackgroundColor(0x00000000);
					AsyncGetArtistSongIds task = new AsyncGetArtistSongIds((String) view.getTag(R.string.artist));
					task.execute(new String[] {"REMOVE"});
				}
				
			}
			
		});
		
		instructions = (TextView) rootView.findViewById(R.id.artists_music_library_editor_instructions);
		instructions.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		instructions.setPaintFlags(instructions.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		//KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
        	
            //Calculate navigation bar height.
            int navigationBarHeight = 0;
            int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
            if (resourceId > 0) {
                navigationBarHeight = getResources().getDimensionPixelSize(resourceId);
            }
            
            listView.setClipToPadding(false);
            listView.setPadding(0, 0, 0, navigationBarHeight);
        }
		
		return rootView;
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MusicLibraryEditorActivity;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Paint;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;

public class EditDeleteMusicLibraryAdapter extends SimpleCursorAdapter {
	
	private Context mContext;
	private SharedPreferences sharedPreferences;
    private LibrariesListViewHolder holder = null;
	
    public EditDeleteMusicLibraryAdapter(Context context, Cursor cursor) {
        super(context, -1, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    }

    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        Cursor c = (Cursor) getItem(position);

		if (convertView == null) {
			convertView = LayoutInflater.from(mContext).inflate(R.layout.sliding_menu_list_layout, parent, false);
			holder = new LibrariesListViewHolder();
			holder.tagColor = (ImageView) convertView.findViewById(R.id.sliding_menu_libraries_icon);
			holder.title = (TextView) convertView.findViewById(R.id.sliding_menu_list_item);
            holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));

			convertView.setTag(holder);
		} else {
		    holder = (LibrariesListViewHolder) convertView.getTag();
		}
		
		//Retrieve the library's parameters.
		String libraryName = c.getString(c.getColumnIndex(DBAccessHelper.LIBRARY_NAME));
		String libraryColorCode = c.getString(c.getColumnIndex(DBAccessHelper.LIBRARY_TAG));
		
		//Construct the library color tag drawable from the given color code string.
		int colorCodeDrawableID = mContext.getResources().getIdentifier(libraryColorCode, "drawable", mContext.getPackageName());
		
		//Set the tag for this child view. The key is required to be an application-defined key.
		convertView.setTag(R.string.library_name, libraryName);
		convertView.setTag(R.string.library_color_code, libraryColorCode);
		
		//Set the library name.
		holder.title.setText(libraryName);

		holder.tagColor.setImageResource(colorCodeDrawableID);
        
		return convertView;
	}

	static class LibrariesListViewHolder {
	    public ImageView tagColor;
	    public TextView title;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MusicLibraryEditorActivity;

import java.util.ArrayList;

import android.content.Context;
import android.graphics.Paint;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;

public class LibraryLabelsAdapter extends ArrayAdapter<String> {

	private Context mContext;
	private ArrayList<String> mColorsList;
   
    public LibraryLabelsAdapter(Context context, ArrayList<String> colorsList) {
    	super(context, R.id.playlists_flipped_song, colorsList);
    	mContext = context;
    	mColorsList = colorsList;

    }
    
    public View getView(final int position, View convertView, ViewGroup parent){
    	
    	SongsListViewHolder holder = null;
		if (convertView == null) {	
			convertView = LayoutInflater.from(mContext).inflate(R.layout.sliding_menu_list_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.title = (TextView) convertView.findViewById(R.id.sliding_menu_list_item);
			holder.image = (ImageView) convertView.findViewById(R.id.sliding_menu_libraries_icon);
			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}

		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.title.setPaintFlags(holder.title.getPaintFlags()
										 | Paint.ANTI_ALIAS_FLAG
										 | Paint.SUBPIXEL_TEXT_FLAG);		
		
		holder.title.setText(mColorsList.get(position));

		//Set the icon.
		switch(position) {
		case 0:
			holder.image.setImageResource(R.drawable.circle_blue_dark);
			break;
		case 1:
			holder.image.setImageResource(R.drawable.circle_blue_light);
			break;
		case 2:
			holder.image.setImageResource(R.drawable.circle_green_dark);
			break;
		case 3:
			holder.image.setImageResource(R.drawable.circle_green_light);
			break;
		case 4:
			holder.image.setImageResource(R.drawable.circle_purple_dark);
			break;
		case 5:
			holder.image.setImageResource(R.drawable.circle_purple_light);
			break;
		case 6:
			holder.image.setImageResource(R.drawable.circle_red_dark);
			break;
		case 7:
			holder.image.setImageResource(R.drawable.circle_red_light);
			break;
		case 8:
			holder.image.setImageResource(R.drawable.circle_yellow_dark);
			break;
		case 9:
			holder.image.setImageResource(R.drawable.circle_yellow_light);
			break;
		}
		
		return convertView;

	}
    
	static class SongsListViewHolder {
	    public TextView title;
	    public ImageView image;
	}
   
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MusicLibraryEditorActivity;

import java.util.HashSet;

import android.app.ActionBar;
import android.app.ActionBar.Tab;
import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.text.Spannable;
import android.text.SpannableString;
import android.util.TypedValue;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncCreateMusicLibraryTask;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.Utils.TypefaceSpan;
import com.nostra13.universalimageloader.core.DisplayImageOptions;
import com.nostra13.universalimageloader.core.assist.ImageScaleType;
import com.nostra13.universalimageloader.core.display.FadeInBitmapDisplayer;

public class MusicLibraryEditorActivity extends FragmentActivity {
	
	private Context mContext;
	private Common mApp;
	private String libraryName;
	private String libraryIconName;
	public static DBAccessHelper dbHelper;
	public static String currentTab = "Artists";
	public static DisplayImageOptions displayImageOptions;
	public static HashSet<String> songDBIdsList = new HashSet<String>();
	
	@SuppressWarnings("unchecked")
	@Override
	public void onCreate(Bundle savedInstanceState) {
		
		//Initialize Context and SharedPreferences.
		mContext = this;
        mApp = (Common) mContext.getApplicationContext();
		
		//Retrieve the name/icon of the library from the arguments.
		libraryName = getIntent().getExtras().getString("LIBRARY_NAME");
		libraryIconName = getIntent().getExtras().getString("LIBRARY_ICON");
		
		if (getIntent().getExtras().getSerializable("SONG_IDS_HASH_SET")!=null) {
			songDBIdsList = (HashSet<String>) getIntent().getExtras().getSerializable("SONG_IDS_HASH_SET");
		}

    	//Set the UI theme.
    	if (mApp.getCurrentTheme()==Common.DARK_THEME) {
    		setTheme(R.style.AppTheme);
    	} else {
    		setTheme(R.style.AppThemeLight);
    	}
		super.onCreate(savedInstanceState);
		
		//Initialize the database helper.
		dbHelper = new DBAccessHelper(mContext.getApplicationContext());

		//Create a set of options to optimize the bitmap memory usage.
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        options.inJustDecodeBounds = false;
        options.inPurgeable = true;
        
        //Display Image Options.
        int defaultArt = UIElementsHelper.getIcon(mContext, "default_album_art_padded");
        displayImageOptions = new DisplayImageOptions.Builder()
        						  .showImageForEmptyUri(R.drawable.default_album_art)
        						  .showImageOnFail(R.drawable.default_album_art)
        						  .showStubImage(R.drawable.transparent_drawable)
        						  .cacheInMemory(false)
        						  .cacheOnDisc(true)
        						  .decodingOptions(options)
        						  .imageScaleType(ImageScaleType.EXACTLY)
        						  .bitmapConfig(Bitmap.Config.RGB_565)
        						  .displayer(new FadeInBitmapDisplayer(400))
        						  .delayBeforeLoading(100)
        						  .build();
		
		//Attach tabs to the ActionBar.
		ActionBar actionBar = getActionBar();
		actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);

		//Add the artists tab.
		String artistsLabel = getResources().getString(R.string.artists);
		Tab tab = actionBar.newTab();
		tab.setText(artistsLabel);
		TabListener<ArtistsPickerFragment> artistsTabListener = new TabListener<ArtistsPickerFragment>(this, 
																					   				   artistsLabel, 
																					   				   ArtistsPickerFragment.class);
		
		tab.setTabListener(artistsTabListener);
		actionBar.addTab(tab);

		//Add the albums tab.
		String albumsLabel = getResources().getString(R.string.albums);
		tab = actionBar.newTab();
		tab.setText(albumsLabel);
		TabListener<AlbumsPickerFragment> albumsTabListener = new TabListener<AlbumsPickerFragment>(this,
																					  				albumsLabel, 
																					  				AlbumsPickerFragment.class);
		
		tab.setTabListener(albumsTabListener);
		actionBar.addTab(tab);
		
		//Add the songs tab.
		String songsLabel = getResources().getString(R.string.songs);
		tab = actionBar.newTab();
		tab.setText(songsLabel);
		TabListener<SongsPickerFragment> songsTabListener = new TabListener<SongsPickerFragment>(this,
																								 songsLabel, 
																								 SongsPickerFragment.class);
		
		tab.setTabListener(songsTabListener);
		actionBar.addTab(tab);
		
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
	    	getWindow().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));
	    	int topPadding = Common.getStatusBarHeight(mContext);
	    	View activityView = (View) findViewById(android.R.id.content);
	    	
	    	//Calculate ActionBar height
            TypedValue tv = new TypedValue();
            int actionBarHeight = 0;
            if (getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) {
                actionBarHeight = TypedValue.complexToDimensionPixelSize(tv.data,getResources().getDisplayMetrics());
            }
            
            if (activityView!=null) {
            	activityView.setPadding(0, topPadding + actionBarHeight, 0, 0);
            }
            
	    }
		
	}
	
	private class TabListener<T extends android.app.Fragment> implements ActionBar.TabListener {
		private android.app.Fragment mFragment;
		private final Activity mActivity;
		private final String mTag;
		private final Class<T> mClass;

		public TabListener(Activity activity, String tag, Class<T> clz) {
			mActivity = activity;
			mTag = tag;
			mClass = clz;
		}

		@Override
		public void onTabReselected(Tab arg0, android.app.FragmentTransaction arg1) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onTabSelected(Tab tab, android.app.FragmentTransaction ft) {
			
			currentTab = (String) tab.getText();
			//Check if the fragment is already initialized
			if (mFragment==null) {
				//If not, instantiate and add it to the activity
				mFragment = android.app.Fragment.instantiate(mActivity, mClass.getName());
				ft.add(android.R.id.content, mFragment, mTag);
			} else {
				//If it exists, simply attach it in order to show it
				ft.attach(mFragment);
			}
			
		}

		@Override
		public void onTabUnselected(Tab arg0, android.app.FragmentTransaction ft) {
			if (mFragment!=null) {
				ft.detach(mFragment);
			}
			
		}
	
	}
	
	public void createMusicLibrary() {
		//We're done with the database helper, so go ahead and close it.
		dbHelper.close();
		dbHelper = null;
		
		//Launch the AsyncTask that will create the new music library.
		AsyncCreateMusicLibraryTask task = new AsyncCreateMusicLibraryTask(this, this, songDBIdsList, libraryName, libraryIconName);
		task.execute();
		
	}
	
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		MenuInflater inflater = getMenuInflater();
	    inflater.inflate(R.menu.add_to_music_library, menu);
	    
	    ActionBar actionBar = getActionBar();
	    actionBar.setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));
		actionBar.setIcon(mContext.getResources().getIdentifier(libraryIconName, "drawable", mContext.getPackageName()));
		SpannableString s = new SpannableString(libraryName);
	    s.setSpan(new TypefaceSpan(this, "RobotoCondensed-Light"), 0, s.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
	    actionBar.setTitle(s);
	    
		return super.onCreateOptionsMenu(menu);
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
	    case R.id.select_all_music_library_editor:
	        /* DB IDs are sequential, so to save CPU cycles, 
	         * we'll just get the size of the DB (the number of 
	         * rows) and add that many entries to the HashSet.
	         */
	    	Cursor cursor = null;
	    	if (dbHelper!=null) {
	    		cursor = dbHelper.getAllSongs();
	    	}
	    	
	    	int songCount = 0;
	    	if (cursor!=null) {
	    		songCount = cursor.getCount();
	    	} else {
	    		Toast.makeText(mContext, R.string.no_songs_to_select, Toast.LENGTH_SHORT).show();
	    		return true;
	    	}
	    	
	    	for (int i=0; i < songCount+1; i++) {
	    		songDBIdsList.add("" + i);
	    	}
	    	
	    	//Refresh the current fragment's listview.
	    	if (ArtistsPickerFragment.listView!=null) {
	    		ArtistsPickerFragment.listView.setAdapter(null);
	    		ArtistsPickerFragment.listView.setAdapter(new MusicLibraryEditorArtistsMultiselectAdapter(this, 
	    																								  ArtistsPickerFragment.cursor));
	    		ArtistsPickerFragment.listView.invalidate();
	    	}
	    	
	    	if (AlbumsPickerFragment.listView!=null) {
	    		AlbumsPickerFragment.listView.setAdapter(null);
	    		AlbumsPickerFragment.listView.setAdapter(new MusicLibraryEditorAlbumsMultiselectAdapter(this, 
	    																								  AlbumsPickerFragment.cursor));
	    		AlbumsPickerFragment.listView.invalidate();
	    	}
	    	
	    	if (SongsPickerFragment.listView!=null) {
	    		SongsPickerFragment.listView.setAdapter(null);
	    		SongsPickerFragment.listView.setAdapter(new MusicLibraryEditorSongsMultiselectAdapter(this, 
	    																								  SongsPickerFragment.cursor));
	    		SongsPickerFragment.listView.invalidate();
	    	}
	    	
	        return true;
	    case R.id.done_music_library_editor:
	    	createMusicLibrary();
	    	return true;
	    default:
	        return super.onOptionsItemSelected(item);
	    }

	}
	
	@Override
	public void onPause() {
		super.onPause();
		songDBIdsList.clear();
		
		if (dbHelper!=null) {
			dbHelper.close();
			dbHelper = null;
		}
		
		if (isFinishing()) {
			if (SongsPickerFragment.cursor!=null) {
				SongsPickerFragment.cursor.close();
				SongsPickerFragment.cursor = null;
			}
			
			if (AlbumsPickerFragment.cursor!=null) {
				AlbumsPickerFragment.cursor.close();
				AlbumsPickerFragment.cursor = null;
			}
			
			if (ArtistsPickerFragment.cursor!=null) {
				ArtistsPickerFragment.cursor.close();
				ArtistsPickerFragment.cursor = null;
			}
			
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MusicLibraryEditorActivity;

import android.content.Context;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.AsyncTask;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class MusicLibraryEditorAlbumsMultiselectAdapter extends SimpleCursorAdapter {
	
	private Context mContext;
	private Common mApp;
	
    public MusicLibraryEditorAlbumsMultiselectAdapter(Context context, Cursor cursor) {
        super(context, -1, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        mApp = (Common) mContext.getApplicationContext();
    }

    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        final Cursor c = (Cursor) getItem(position);
	    SongsListViewHolder holder = null;

		if (convertView == null) {
			
			convertView = LayoutInflater.from(mContext).inflate(R.layout.music_library_editor_albums_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.image = (ImageView) convertView.findViewById(R.id.albumThumbnailMusicLibraryEditor);
			holder.title = (TextView) convertView.findViewById(R.id.albumNameMusicLibraryEditor);
			holder.checkBox = (CheckBox) convertView.findViewById(R.id.albumCheckboxMusicLibraryEditor);
			holder.subText = (TextView) convertView.findViewById(R.id.albumArtistNameMusicLibraryEditor);

			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}
		
		final View finalConvertView = convertView;
		final String songId = c.getString(c.getColumnIndex(DBAccessHelper._ID));
		final String songArtist = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ARTIST));
		final String songAlbum = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM));
		final String songAlbumArtPath = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH));
		
		//Set the album's name and artist as the row's tag.
		convertView.setTag(R.string.album, songAlbum);
		convertView.setTag(R.string.artist, songArtist);
		
		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.title.setPaintFlags(holder.title.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		holder.subText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.subText.setPaintFlags(holder.subText.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		//Set the song title.
		holder.title.setText(songAlbum);
		holder.subText.setText(songArtist);
        mApp.getImageLoader().displayImage(songAlbumArtPath, holder.image, MusicLibraryEditorActivity.displayImageOptions);

        //Check if the song's DB ID exists in the HashSet and set the appropriate checkbox status.
        if (MusicLibraryEditorActivity.songDBIdsList.contains(songId)) {
        	holder.checkBox.setChecked(true);
        	convertView.setBackgroundColor(0xCC0099CC);
        } else {
        	convertView.setBackgroundColor(0x00000000);
        	holder.checkBox.setChecked(false);
        }
        
        holder.checkBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean isChecked) {
				
				if (isChecked==true) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0xCC0099CC);
						AsyncGetAlbumSongIds task = new AsyncGetAlbumSongIds(songAlbum, songArtist);
						task.execute(new String[] {"ADD"});
					}
					
				} else if (isChecked==false) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0x00000000);
						AsyncGetAlbumSongIds task = new AsyncGetAlbumSongIds(songAlbum, songArtist);
						task.execute(new String[] {"REMOVE"});
						
					}

				}
				
			}
			
        });
 
		return convertView;
	}
    
	static class SongsListViewHolder {
	    public ImageView image;
	    public TextView title;
	    public TextView subText;
	    public CheckBox checkBox;
	}
	
	/***************************************************************
	 * This AsyncTask goes through a specified album and retrieves 
	 * every song in the album and its ID. It then inserts the ID(s) 
	 * into a HashSet.
	 ***************************************************************/
	static class AsyncGetAlbumSongIds extends AsyncTask<String, String, String> {

		private String mAlbumName;
		private String mArtistName;
		
		public AsyncGetAlbumSongIds(String albumName, String artistName) {
			mAlbumName = albumName;
			mArtistName = artistName;
		}
		
		@Override
		protected String doInBackground(String... params) {
			//Check if the user is adding or removing an album from the list.
			String operation = params[0];
			if (operation.equals("ADD")) {
				addAlbumToLibrary();
			} else {
				removeAlbumFromLibrary();
			}
			
			return null;
		}
		
		public void addAlbumToLibrary() {
			
			Cursor cursor = MusicLibraryEditorActivity.dbHelper.getAllSongsInAlbum(mAlbumName, mArtistName);
			if (cursor!=null && cursor.getCount() > 0) {

				for (int i=0; i < cursor.getCount(); i++) {
					cursor.moveToPosition(i);
					MusicLibraryEditorActivity.songDBIdsList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID)));
				}
				cursor.close();
				cursor = null;
				
			}
			
		}
		
		public void removeAlbumFromLibrary() {
			
			Cursor cursor = MusicLibraryEditorActivity.dbHelper.getAllSongsInAlbum(mAlbumName, mArtistName);
			if (cursor!=null && cursor.getCount() > 0) {

				for (int i=0; i < cursor.getCount(); i++) {
					cursor.moveToPosition(i);
					MusicLibraryEditorActivity.songDBIdsList.remove(cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID)));
				}
				cursor.close();
				cursor = null;
				
			}
			
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MusicLibraryEditorActivity;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.AsyncTask;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class MusicLibraryEditorArtistsMultiselectAdapter extends SimpleCursorAdapter {
	
	private Context mContext;
	private SharedPreferences sharedPreferences;
	private Common mApp;
	
    public MusicLibraryEditorArtistsMultiselectAdapter(Context context, Cursor cursor) {
        super(context, -1, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
        mApp = (Common) mContext.getApplicationContext();
    }

    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        final Cursor c = (Cursor) getItem(position);
	    SongsListViewHolder holder = null;

		if (convertView == null) {
			
			convertView = LayoutInflater.from(mContext).inflate(R.layout.music_library_editor_artists_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.image = (ImageView) convertView.findViewById(R.id.artistThumbnailMusicLibraryEditor);
			holder.title = (TextView) convertView.findViewById(R.id.artistNameMusicLibraryEditor);
			holder.checkBox = (CheckBox) convertView.findViewById(R.id.artistCheckboxMusicLibraryEditor);

			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}
		
		final View finalConvertView = convertView;
		final String songId = c.getString(c.getColumnIndex(DBAccessHelper._ID));
		final String songArtist = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ARTIST));
		String songAlbumArtPath = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH));
		
		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.title.setPaintFlags(holder.title.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		//Set the song title.
		holder.title.setText(songArtist);
        mApp.getImageLoader().displayImage(songAlbumArtPath, holder.image, MusicLibraryEditorActivity.displayImageOptions);

        //Check if the song's DB ID exists in the HashSet and set the appropriate checkbox status.
        if (MusicLibraryEditorActivity.songDBIdsList.contains(songId)) {
        	holder.checkBox.setChecked(true);
        	convertView.setBackgroundColor(0xCC0099CC);
        } else {
        	holder.checkBox.setChecked(false);
        	convertView.setBackgroundColor(0x00000000);
        }
        
        //Set a tag to the row that will attach the artist's name to it.
        convertView.setTag(R.string.artist, songArtist);
        
        holder.checkBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean isChecked) {
				
				if (isChecked==true) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0xCC0099CC);
						AsyncGetArtistSongIds task = new AsyncGetArtistSongIds(songArtist);
						task.execute(new String[] {"ADD"});
					}
					
				} else if (isChecked==false) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0x00000000);
						AsyncGetArtistSongIds task = new AsyncGetArtistSongIds(songArtist);
						task.execute(new String[] {"REMOVE"});
						
					}

				}
				
			}
			
        });
 
		return convertView;
	}
    
	static class SongsListViewHolder {
	    public ImageView image;
	    public TextView title;
	    public CheckBox checkBox;
	}
	
	/***************************************************************
	 * This AsyncTask goes through a specified artist and retrieves 
	 * every song by the artist and its ID. It then inserts the ID(s) 
	 * into a HashSet.
	 ***************************************************************/
	static class AsyncGetArtistSongIds extends AsyncTask<String, String, String> {

		private String mArtistName;
		
		public AsyncGetArtistSongIds(String artistName) {
			mArtistName = artistName;
		}
		
		@Override
		protected String doInBackground(String... params) {
			//Check if the user is adding or removing an artist from the list.
			String operation = params[0];
			if (operation.equals("ADD")) {
				addArtistToLibrary();
			} else {
				removeArtistFromLibrary();
			}
			
			return null;
		}
		
		public void addArtistToLibrary() {
			
			Cursor cursor = MusicLibraryEditorActivity.dbHelper.getAllSongsByArtist(mArtistName);
			if (cursor!=null && cursor.getCount() > 0) {

				for (int i=0; i < cursor.getCount(); i++) {
					cursor.moveToPosition(i);
					MusicLibraryEditorActivity.songDBIdsList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID)));
				}
				cursor.close();
				cursor = null;
				
			}
			
		}
		
		public void removeArtistFromLibrary() {

			Cursor cursor = MusicLibraryEditorActivity.dbHelper.getAllSongsByArtist(mArtistName);
			if (cursor!=null && cursor.getCount() > 0) {

				for (int i=0; i < cursor.getCount(); i++) {
					cursor.moveToPosition(i);
					MusicLibraryEditorActivity.songDBIdsList.remove(cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID)));
				}
				cursor.close();
				cursor = null;
				
			}
			
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MusicLibraryEditorActivity;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Paint;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class MusicLibraryEditorSongsMultiselectAdapter extends SimpleCursorAdapter {
	
	private Context mContext;
	private SharedPreferences sharedPreferences;
	private Common mApp;
	
    public MusicLibraryEditorSongsMultiselectAdapter(Context context, Cursor cursor) {
        super(context, -1, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
        mApp = (Common) mContext.getApplicationContext();
    }

    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        final Cursor c = (Cursor) getItem(position);
	    SongsListViewHolder holder = null;

		if (convertView == null) {
			
			convertView = LayoutInflater.from(mContext).inflate(R.layout.music_library_editor_songs_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.image = (ImageView) convertView.findViewById(R.id.songThumbnailMusicLibraryEditor);
			holder.title = (TextView) convertView.findViewById(R.id.songNameMusicLibraryEditor);
			holder.checkBox = (CheckBox) convertView.findViewById(R.id.songCheckboxMusicLibraryEditor);
			holder.subText = (TextView) convertView.findViewById(R.id.artistNameSongListView);

			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}
		
		final View finalConvertView = convertView;
		final String songId = c.getString(c.getColumnIndex(DBAccessHelper._ID));
		final String songTitle = c.getString(c.getColumnIndex(DBAccessHelper.SONG_TITLE));
		String songAlbumArtPath = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH));
		String songArtist = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ARTIST));
		
		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.title.setPaintFlags(holder.title.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		holder.subText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.subText.setPaintFlags(holder.subText.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		//Set the songID as the view's tag.
		convertView.setTag(R.string.song_id, songId);
		
		//Set the song title.
		holder.title.setText(songTitle);
		holder.subText.setText(songArtist);
        mApp.getImageLoader().displayImage(songAlbumArtPath, holder.image, MusicLibraryEditorActivity.displayImageOptions);

        //Check if the song's DB ID exists in the HashSet and set the appropriate checkbox status.
        if (MusicLibraryEditorActivity.songDBIdsList.contains(songId)) {
        	convertView.setBackgroundColor(0xCC0099CC);
        	holder.checkBox.setChecked(true);
        } else {
        	convertView.setBackgroundColor(0x00000000);
        	holder.checkBox.setChecked(false);
        }
        
        holder.checkBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean isChecked) {
				
				if (isChecked==true) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0xCC0099CC);
						MusicLibraryEditorActivity.songDBIdsList.add(songId);
					}
					
				} else if (isChecked==false) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0xCC0099CC);
						MusicLibraryEditorActivity.songDBIdsList.remove(songId);
					}

				}
				
			}
			
        });
 
		return convertView;
	}
    
	static class SongsListViewHolder {
	    public ImageView image;
	    public TextView title;
	    public TextView subText;
	    public CheckBox checkBox;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.MusicLibraryEditorActivity;

import android.annotation.SuppressLint;
import android.app.Fragment;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Build;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.ListView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;

public class SongsPickerFragment extends Fragment {
	
	public static Cursor cursor;
	public static ListView listView;
	
	@SuppressLint("NewApi")
	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		View rootView = inflater.inflate(R.layout.fragment_songs_music_library_editor, null);
		cursor = MusicLibraryEditorActivity.dbHelper.getAllSongs();
		
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
			rootView.setBackground(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		} else {
			rootView.setBackgroundDrawable(UIElementsHelper.getBackgroundGradientDrawable(getActivity()));
		}
		
		listView = (ListView) rootView.findViewById(R.id.musicLibraryEditorSongsListView);
		listView.setFastScrollEnabled(true);
		listView.setAdapter(new MusicLibraryEditorSongsMultiselectAdapter(getActivity(), cursor));

		listView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> arg0, View view, int which, long dbID) {
				CheckBox checkbox = (CheckBox) view.findViewById(R.id.songCheckboxMusicLibraryEditor);
				checkbox.performClick();
				
				/* Since we've performed a software-click (checkbox.performClick()), all we have 
				 * to do now is determine the *new* state of the checkbox. If the checkbox is checked, 
				 * that means that the user tapped on it when it was unchecked, and we should add 
				 * the song to the HashSet. If the checkbox is unchecked, that means the user 
				 * tapped on it when it was checked, so we should remove the song from the 
				 * HashSet.
				 */
				if (checkbox.isChecked()) {
					view.setBackgroundColor(0xCC0099CC);
					MusicLibraryEditorActivity.songDBIdsList.add((String) view.getTag(R.string.song_id));
				} else {
					view.setBackgroundColor(0x00000000);
					MusicLibraryEditorActivity.songDBIdsList.remove((String) view.getTag(R.string.song_id));
				}
				
			}
			
		});
		
		TextView instructions = (TextView) rootView.findViewById(R.id.songs_music_library_editor_instructions);
		instructions.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		instructions.setPaintFlags(instructions.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		//KitKat translucent navigation/status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
        	
            //Calculate navigation bar height.
            int navigationBarHeight = 0;
            int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
            if (resourceId > 0) {
                navigationBarHeight = getResources().getDimensionPixelSize(resourceId);
            }
            
            listView.setClipToPadding(false);
            listView.setPadding(0, 0, 0, navigationBarHeight);
        }
		
		return rootView;
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.NowPlayingActivity;

import android.animation.ObjectAnimator;
import android.annotation.SuppressLint;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.media.AudioManager;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentStatePagerAdapter;
import android.support.v4.content.LocalBroadcastManager;
import android.support.v4.widget.DrawerLayout;
import android.support.v4.widget.DrawerLayout.DrawerListener;
import android.util.Log;
import android.view.Gravity;
import android.view.HapticFeedbackConstants;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.view.animation.AnimationSet;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.RotateAnimation;
import android.view.animation.ScaleAnimation;
import android.widget.FrameLayout;
import android.widget.ImageButton;
import android.widget.ProgressBar;
import android.widget.RelativeLayout;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.Animations.FadeAnimation;
import com.jams.music.player.Animations.TranslateAnimation;
import com.jams.music.player.AsyncTasks.AsyncRemovePinnedSongsTask;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Drawers.QueueDrawerFragment;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.Services.AudioPlaybackService;
import com.jams.music.player.Utils.Common;
import com.velocity.view.pager.library.VelocityViewPager;

import java.util.HashMap;

public class NowPlayingActivity extends FragmentActivity {

    //Common objects.
	private Context mContext;
    private Common mApp;

    //Layouts.
	private DrawerLayout mDrawerLayout;
	private FrameLayout mDrawerParentLayout;
    private QueueDrawerFragment mQueueDrawerFragment;
    private RelativeLayout mCurrentQueueLayout;
	
	//Song info/seekbar elements.
	private SeekBar mSeekbar;
	private ProgressBar mStreamingProgressBar;
	
	//Playback Controls.
    private RelativeLayout mControlsLayoutHeaderParent;
	private RelativeLayout mControlsLayoutHeader;
	private ImageButton mPlayPauseButton;
    private RelativeLayout mPlayPauseButtonBackground;
	private ImageButton mNextButton;
	private ImageButton mPreviousButton;
	private ImageButton mShuffleButton;
	private ImageButton mRepeatButton;

    //Seekbar indicator.
    private RelativeLayout mSeekbarIndicatorLayoutParent;
    private RelativeLayout mSeekbarIndicatorLayout;
    private TextView mSeekbarIndicatorText;

    //Seekbar strobe effect.
    private AlphaAnimation mSeekbarStrobeAnim;
    private static final int SEEKBAR_STROBE_ANIM_REPEAT = Animation.INFINITE;

	//Playlist pager.
    private VelocityViewPager mViewPager;
    private PlaylistPagerAdapter mViewPagerAdapter;

    //Handler object.
    private Handler mHandler = new Handler();
    
    //Differentiates between a user's scroll input and a programmatic scroll.
    private boolean USER_SCROLL = true;

    //HashMap that passes on song information to the "Download from Cloud" dialog.
    private HashMap<String, String> metadata;
    
    //Interface instance and flags.
    private NowPlayingActivityListener mNowPlayingActivityListener;
    public static final String START_SERVICE = "StartService";
    private boolean mIsCreating = true;
    
    @SuppressLint("NewApi")
	@Override
    protected void onCreate(Bundle savedInstanceState) {
    	mContext = getApplicationContext();
    	mApp = (Common) getApplicationContext();
    	mApp.setNowPlayingActivity(this);
    	setNowPlayingActivityListener(mApp.getPlaybackKickstarter());
    	
    	//Set the UI theme.
        setTheme();
        
        super.onCreate(savedInstanceState);	
    	setContentView(R.layout.activity_now_playing);
    	
    	//Set the volume stream for this activity.
        this.setVolumeControlStream(AudioManager.STREAM_MUSIC);
        
        //Drawer layout.
        if (!mApp.isTabletInLandscape()) {
            mDrawerLayout = (DrawerLayout) findViewById(R.id.main_activity_drawer_root);
            mDrawerParentLayout = (FrameLayout) findViewById(R.id.now_playing_drawer_frame_root);
            mCurrentQueueLayout = (RelativeLayout) findViewById(R.id.queue_drawer);
            mDrawerLayout.setDrawerListener(mDrawerListener);
            mDrawerLayout.setBackgroundColor(UIElementsHelper.getBackgroundColor(mContext));

        } else {
            mCurrentQueueLayout = (RelativeLayout) findViewById(R.id.queue_drawer);
        }
        
        //ViewPager.
        mViewPager = (VelocityViewPager) findViewById(R.id.nowPlayingPlaylistPager);

        //Seekbar indicator.
        mSeekbarIndicatorLayoutParent = (RelativeLayout) findViewById(R.id.seekbarIndicatorParent);
        mSeekbarIndicatorLayout = (RelativeLayout) findViewById(R.id.seekbarIndicator);
        mSeekbarIndicatorText = (TextView) findViewById(R.id.seekbarIndicatorText);

        mSeekbarIndicatorLayoutParent.setVisibility(View.GONE);
        mSeekbarIndicatorLayout.setBackgroundResource(UIElementsHelper.getGridViewCardBackground(mContext));
        mSeekbarIndicatorText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        mSeekbarIndicatorText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
    	
    	//Playback Controls.
        mControlsLayoutHeaderParent = (RelativeLayout) findViewById(R.id.now_playing_controls_header_parent);
        mControlsLayoutHeader = (RelativeLayout) findViewById(R.id.now_playing_controls_header);
        mPlayPauseButtonBackground = (RelativeLayout) findViewById(R.id.playPauseButtonBackground);
    	mPlayPauseButton = (ImageButton) findViewById(R.id.playPauseButton);
        mNextButton = (ImageButton) findViewById(R.id.nextButton);
    	mPreviousButton = (ImageButton) findViewById(R.id.previousButton);
    	mShuffleButton = (ImageButton) findViewById(R.id.shuffleButton);
    	mRepeatButton = (ImageButton) findViewById(R.id.repeatButton);

    	//Song info/seekbar elements.
    	mSeekbar = (SeekBar) findViewById(R.id.nowPlayingSeekBar);
    	mStreamingProgressBar = (ProgressBar) findViewById(R.id.startingStreamProgressBar);
    	mStreamingProgressBar.setVisibility(View.GONE);

    	try {
    		mSeekbar.setThumb(getResources().getDrawable(R.drawable.transparent_drawable));
    	} catch (Exception e) {
    		e.printStackTrace();
    	}

        mPlayPauseButtonBackground.setBackgroundResource(UIElementsHelper.getShadowedCircle(mContext));
        mPlayPauseButton.setImageResource(R.drawable.pause_light);
        mPlayPauseButton.setId(R.drawable.pause_light);
    	mNextButton.setImageResource(UIElementsHelper.getIcon(mContext, "btn_playback_next"));
    	mPreviousButton.setImageResource(UIElementsHelper.getIcon(mContext, "btn_playback_previous"));
    	
    	if (mApp.getCurrentTheme()==Common.DARK_THEME) {
    		mNextButton.setAlpha(1f);
    		mPreviousButton.setAlpha(1f);
        }

        //KitKat specific layout code.
        setKitKatTranslucentBars();

    	//Set the control buttons and background.
        setControlButtonsBackground();
    	setPlayPauseButton();
        setShuffleButtonIcon();
        setRepeatButtonIcon();
    	
        //Set the click listeners.
    	mSeekbar.setOnSeekBarChangeListener(seekBarChangeListener);
    	mNextButton.setOnClickListener(mOnClickNextListener);
    	mPreviousButton.setOnClickListener(mOnClickPreviousListener);
    	mPlayPauseButton.setOnClickListener(playPauseClickListener);
        mPlayPauseButtonBackground.setOnClickListener(playPauseClickListener);
    	mShuffleButton.setOnClickListener(shuffleButtonClickListener);
    	mRepeatButton.setOnClickListener(repeatButtonClickListener);

        //Apply haptic feedback to the play/pause button.
        mPlayPauseButtonBackground.setHapticFeedbackEnabled(true);
        mPlayPauseButton.setHapticFeedbackEnabled(true);

    }
    
    /**
     * Updates this activity's UI elements based on the passed intent's 
     * update flag(s).
     */
    BroadcastReceiver mReceiver = new BroadcastReceiver() {
    	
        @Override
        public void onReceive(Context context, Intent intent) {
        	
        	//Grab the bundle from the intent.
        	Bundle bundle = intent.getExtras();

        	//Initializes the ViewPager.
        	if (intent.hasExtra(Common.INIT_PAGER) || 
        		intent.hasExtra(Common.NEW_QUEUE_ORDER))
                initViewPager();

        	//Updates the ViewPager's current page/position.
        	if (intent.hasExtra(Common.UPDATE_PAGER_POSTIION)) {
                int currentPosition = mViewPager.getCurrentItem();
                int newPosition = Integer.parseInt(bundle.getString(Common.UPDATE_PAGER_POSTIION));
                if (currentPosition!=newPosition) {

                    if (newPosition > 0 && Math.abs(newPosition - currentPosition) <= 5) {
                        //Smooth scroll to the new index.
                        scrollViewPager(newPosition, true, 1, false);
                    } else {
                        //The new index is too far away, so avoid smooth scrolling to it.
                        mViewPager.setCurrentItem(newPosition, false);
                    }

                    //Reinit the seekbar update handler.
                    mHandler.post(seekbarUpdateRunnable);

                }

        	}
        		
        	//Updates the playback control buttons.
        	if (intent.hasExtra(Common.UPDATE_PLAYBACK_CONTROLS)) {
        		setPlayPauseButton();
        		setRepeatButtonIcon();
        		setShuffleButtonIcon();
        		
        	}
        	
            //Displays the audibook toast.
        	if (intent.hasExtra(Common.SHOW_AUDIOBOOK_TOAST))
        		displayAudiobookToast(Long.parseLong(
        							  bundle.getString(
        							  Common.SHOW_AUDIOBOOK_TOAST)));
        	
        	//Updates the duration of the SeekBar.
        	if (intent.hasExtra(Common.UPDATE_SEEKBAR_DURATION))
        		setSeekbarDuration(Integer.parseInt(
        						   bundle.getString(
        						   Common.UPDATE_SEEKBAR_DURATION)));
        	
        	//Hides the seekbar and displays the streaming progress bar.
        	if (intent.hasExtra(Common.SHOW_STREAMING_BAR)) {
        		mSeekbar.setVisibility(View.INVISIBLE);
        		mStreamingProgressBar.setVisibility(View.VISIBLE);
        		mHandler.removeCallbacks(seekbarUpdateRunnable);
        		
        	}
        	
        	//Shows the seekbar and hides the streaming progress bar.
        	if (intent.hasExtra(Common.HIDE_STREAMING_BAR)) {
        		mSeekbar.setVisibility(View.VISIBLE);
        		mStreamingProgressBar.setVisibility(View.INVISIBLE);
        		mHandler.postDelayed(seekbarUpdateRunnable, 100);
        	}
        	
        	//Updates the buffering progress on the seekbar.
        	if (intent.hasExtra(Common.UPDATE_BUFFERING_PROGRESS))
        		mSeekbar.setSecondaryProgress(Integer.parseInt(
        									  bundle.getString(
        									  Common.UPDATE_BUFFERING_PROGRESS)));

        	//Close this activity if the service is about to stop running.
        	if (intent.hasExtra(Common.SERVICE_STOPPING)) {
        		mHandler.removeCallbacks(seekbarUpdateRunnable);
        		finish();
        	}
        	
        }
        
    };
    
    /**
     * Sets the activity's theme based on user preferences.
     */
    private void setTheme() {
        if (mApp.getCurrentTheme()==Common.DARK_THEME) {
            this.setTheme(R.style.AppThemeNoActionBar);
        } else {
            this.setTheme(R.style.AppThemeLightNoActionBar);
        }
        
    }
    
    /**
     * Initializes the view pager.
     */
    private void initViewPager() {

        try {
            mViewPager.setVisibility(View.INVISIBLE);
            mViewPagerAdapter = new PlaylistPagerAdapter(getSupportFragmentManager());
            mViewPager.setAdapter(mViewPagerAdapter);
            mViewPager.setOffscreenPageLimit(0);
            mViewPager.setOnPageChangeListener(mPageChangeListener);
            mViewPager.setCurrentItem(mApp.getService().getCurrentSongIndex(), false);

            FadeAnimation fadeAnimation = new FadeAnimation(mViewPager, 600, 0.0f,
                                                            1.0f, new DecelerateInterpolator(2.0f));

            fadeAnimation.animate();

        } catch (IllegalStateException e) {
            /*
             * Catches any exceptions that may occur
             * as a result of the user rapidly changing
             * their device's orientation.
             */
        }

        //Delay loading extra fragments by 1000ms.
        new Handler().postDelayed(new Runnable() {

            @Override
            public void run() {
                mViewPager.setOffscreenPageLimit(10);
            }

        }, 1000);

    }

    /**
     * Initializes the current queue drawer/layout.
     */
    private void initDrawer() {
        //Load the current queue drawer.
        mQueueDrawerFragment = new QueueDrawerFragment();

        try {
            getSupportFragmentManager().beginTransaction()
                                       .replace(R.id.queue_drawer, mQueueDrawerFragment)
                                       .setCustomAnimations(R.anim.fade_in, R.anim.fade_out)
                                       .commit();

        } catch (IllegalStateException e) {
            /*
             * Catches any exceptions that may occur if the
             * user rapidly changes the device's orientation.
             */
            e.printStackTrace();
        }

    }

    /**
     * Slides in the controls bar from the bottom along with a
     * slight rotation.
     */
    private void animateInControlsBar() {
        android.view.animation.TranslateAnimation slideUp =
                new android.view.animation.TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f,
                                                              Animation.RELATIVE_TO_SELF, 0.0f,
                                                              Animation.RELATIVE_TO_SELF, 2.0f,
                                                              Animation.RELATIVE_TO_SELF, 0.0f);
        slideUp.setDuration(300);
        slideUp.setInterpolator(new DecelerateInterpolator(2.0f));

        slideUp.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {
                mControlsLayoutHeaderParent.setVisibility(View.VISIBLE);
            }

            @Override
            public void onAnimationEnd(Animation animation) {

            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

        });

        mControlsLayoutHeaderParent.startAnimation(slideUp);
    }
    
    /**
     * Scrolls the ViewPager programmatically. If dispatchToListener 
     * is true, USER_SCROLL will be set to true.
     */
    private void scrollViewPager(int newPosition, 
    							 boolean smoothScroll, 
    							 int velocity, 
    							 boolean dispatchToListener) {
    	
    	USER_SCROLL = dispatchToListener;
    	mViewPager.scrollToItem(newPosition, 
                                smoothScroll,
                                velocity,
                                dispatchToListener);
    	
    }

    /**
     * Sets the background for the control buttons based on the selected theme.
     */
    private void setControlButtonsBackground() {
        mControlsLayoutHeader.setBackgroundResource(UIElementsHelper.getGridViewCardBackground(mContext));
    }
    
    /**
     * Sets the play/pause button states.
     */
    private void setPlayPauseButton() {
        if (mApp.isServiceRunning()) {
            if (mApp.getService().isPlayingMusic()) {
                animatePlayToPause();
                stopSeekbarStrobeEffect();
            } else {
                animatePauseToPlay();
                initSeekbarStrobeEffect();
            }

        }

    }

    /**
     * Animates the play button to a pause button.
     */
    private void animatePlayToPause() {

        //Check to make sure the current icon is the play icon.
        if (mPlayPauseButton.getId()!=R.drawable.play_light)
            return;

        //Fade out the play button.
        final ScaleAnimation scaleOut = new ScaleAnimation(1.0f, 0.0f, 1.0f, 0.0f,
                                                           mPlayPauseButton.getWidth()/2,
                                                           mPlayPauseButton.getHeight()/2);
        scaleOut.setDuration(150);
        scaleOut.setInterpolator(new AccelerateInterpolator());


        //Scale in the pause button.
        final ScaleAnimation scaleIn = new ScaleAnimation(0.0f, 1.0f, 0.0f, 1.0f,
                                                          mPlayPauseButton.getWidth()/2,
                                                          mPlayPauseButton.getHeight()/2);
        scaleIn.setDuration(150);
        scaleIn.setInterpolator(new DecelerateInterpolator());

        scaleOut.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mPlayPauseButton.setImageResource(R.drawable.pause_light);
                mPlayPauseButton.setPadding(0, 0, 0, 0);
                mPlayPauseButton.startAnimation(scaleIn);
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

        });

        scaleIn.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mPlayPauseButton.setScaleX(1.0f);
                mPlayPauseButton.setScaleY(1.0f);
                mPlayPauseButton.setId(R.drawable.pause_light);
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

        });

        mPlayPauseButton.startAnimation(scaleOut);
    }

    /**
     * Animates the pause button to a play button.
     */
    private void animatePauseToPlay() {

        //Check to make sure the current icon is the pause icon.
        if (mPlayPauseButton.getId()!=R.drawable.pause_light)
            return;

        //Scale out the pause button.
        final ScaleAnimation scaleOut = new ScaleAnimation(1.0f, 0.0f, 1.0f, 0.0f,
                                                           mPlayPauseButton.getWidth()/2,
                                                           mPlayPauseButton.getHeight()/2);
        scaleOut.setDuration(150);
        scaleOut.setInterpolator(new AccelerateInterpolator());


        //Scale in the play button.
        final ScaleAnimation scaleIn = new ScaleAnimation(0.0f, 1.0f, 0.0f, 1.0f,
                                                          mPlayPauseButton.getWidth()/2,
                                                          mPlayPauseButton.getHeight()/2);
        scaleIn.setDuration(150);
        scaleIn.setInterpolator(new DecelerateInterpolator());

        scaleOut.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mPlayPauseButton.setImageResource(R.drawable.play_light);
                mPlayPauseButton.setPadding(0, 0, -5, 0);
                mPlayPauseButton.startAnimation(scaleIn);
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

        });

        scaleIn.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mPlayPauseButton.setScaleX(1.0f);
                mPlayPauseButton.setScaleY(1.0f);
                mPlayPauseButton.setId(R.drawable.play_light);
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

        });

        mPlayPauseButton.startAnimation(scaleOut);
    }

    /**
     * Sets the repeat button icon based on the current repeat mode.
     */
    private void setRepeatButtonIcon() {
    	if (mApp.isServiceRunning())
	    	if (mApp.getService().getRepeatMode()==Common.REPEAT_OFF) {
	    		mRepeatButton.setImageResource(UIElementsHelper.getIcon(mContext, "repeat"));
	    	} else if (mApp.getService().getRepeatMode()==Common.REPEAT_PLAYLIST) {
	    		mRepeatButton.setImageResource(R.drawable.repeat_highlighted);
	    	} else if (mApp.getService().getRepeatMode()==Common.REPEAT_SONG) {
	    		mRepeatButton.setImageResource(R.drawable.repeat_song);
	    	} else if (mApp.getService().getRepeatMode()==Common.A_B_REPEAT) {
	    		mRepeatButton.setImageResource(R.drawable.repeat_song_range);
	    	}
    	
	    else
	    	mRepeatButton.setImageResource(UIElementsHelper.getIcon(mContext, "repeat"));
    	
    }
    
    /**
     * Sets the shuffle button icon based on the current shuffle mode.
     */
    private void setShuffleButtonIcon() {
    	if (mApp.isServiceRunning())
	        if (mApp.getService().isShuffleOn()==true) {
	        	mShuffleButton.setImageResource(R.drawable.shuffle_highlighted);
	        } else {
	        	mShuffleButton.setImageResource(UIElementsHelper.getIcon(mContext, "shuffle"));
	        }
    	
    	else
    		mShuffleButton.setImageResource(UIElementsHelper.getIcon(mContext, "shuffle"));
        
    }
    
    /**
     * Sets the seekbar's duration. Also updates the 
     * elapsed/remaining duration text.
     */
    private void setSeekbarDuration(int duration) {
    	mSeekbar.setMax(duration);
        mSeekbar.setProgress(mApp.getService().getCurrentMediaPlayer().getCurrentPosition()/1000);
    	mHandler.postDelayed(seekbarUpdateRunnable, 100);
    }
    
    /**
     * Sets the KitKat translucent status/nav bar and adjusts 
     * the views' boundaries.
     */
    private void setKitKatTranslucentBars() {
    	//KitKat translucent status bar.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
    		int statusBarHeight = Common.getStatusBarHeight(mContext);
            int navigationBarHeight = Common.getNavigationBarHeight(mContext);
            
            if (mDrawerParentLayout!=null) {
                mDrawerParentLayout.setClipToPadding(false);
                mDrawerParentLayout.setPadding(0, 0, 0, 0);
            }

            if (mControlsLayoutHeaderParent!=null) {
                int bottomPadding = mControlsLayoutHeaderParent.getPaddingBottom();
                mControlsLayoutHeaderParent.setClipToPadding(false);
                RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mControlsLayoutHeaderParent.getLayoutParams();

                if (navigationBarHeight > 0) {
                    /* The nav bar already has padding, so remove the extra 15dp
                     * margin that was applied in the layout file.
                     */
                    params.bottomMargin = 0;
                }

                params.bottomMargin += navigationBarHeight;
                mControlsLayoutHeaderParent.setLayoutParams(params);

            }

        }
        
    }

    /**
     * Seekbar change listener.
     */
    private OnSeekBarChangeListener seekBarChangeListener = new OnSeekBarChangeListener() {

		@Override
		public void onProgressChanged(SeekBar seekBar, int seekBarPosition, boolean changedByUser) {

            try {
                long currentSongDuration = mApp.getService().getCurrentMediaPlayer().getDuration();
                seekBar.setMax((int) currentSongDuration / 1000);

                if (changedByUser)
                    mSeekbarIndicatorText.setText(mApp.convertMillisToMinsSecs(seekBar.getProgress()*1000));
            } catch (Exception e) {
                e.printStackTrace();
            }

		}

		@Override
		public void onStartTrackingTouch(SeekBar seekBar) {
			mHandler.removeCallbacks(seekbarUpdateRunnable);
            mHandler.removeCallbacks(fadeOutSeekbarIndicator);

            mSeekbarIndicatorLayoutParent.setVisibility(View.VISIBLE);
            mSeekbarIndicatorLayout.setAlpha(0.8f);

		}

		@Override
		public void onStopTrackingTouch(SeekBar seekBar) {
			int seekBarPosition = seekBar.getProgress();
			mApp.getService().getCurrentMediaPlayer().seekTo(seekBarPosition*1000);

            //Reinitiate the handler.
            mHandler.post(seekbarUpdateRunnable);

            //Fade out the indicator after 1000ms.
            mHandler.postDelayed(fadeOutSeekbarIndicator, 1000);
			
		}
		
	};

    /**
     * Seekbar change indicator.
     */
    private Runnable fadeOutSeekbarIndicator = new Runnable() {

        @Override
        public void run() {
            FadeAnimation fadeOut = new FadeAnimation(mSeekbarIndicatorLayoutParent,
                                                      300, 0.9f, 0.0f, null);
            fadeOut.animate();
        }

    };
	
	/**
	 * Repeat button click listener.
	 */
	private OnClickListener repeatButtonClickListener = new OnClickListener() {

		@Override
		public void onClick(View arg0) {
			
			mApp.getService().clearABRepeatRange();
			if (mApp.getService().getRepeatMode()==Common.REPEAT_OFF) {
				mRepeatButton.setImageResource(R.drawable.repeat_highlighted);
				mApp.getService().setRepeatMode(Common.REPEAT_PLAYLIST);
				
			} else if (mApp.getService().getRepeatMode()==Common.REPEAT_PLAYLIST) {
				mRepeatButton.setImageResource(R.drawable.repeat_song);
				mApp.getService().setRepeatMode(Common.REPEAT_SONG);
				
			} else {
				mRepeatButton.setImageResource(UIElementsHelper.getIcon(mContext, "repeat"));
				mApp.getService().setRepeatMode(Common.REPEAT_OFF);
				
			}
			
		}
		
	};

	/**
	 * Shuffle button click listener.
	 */
	private OnClickListener shuffleButtonClickListener = new OnClickListener() {

		@Override
		public void onClick(View arg0) {
			//Toggle shuffle on/off.
			boolean shuffleOn = mApp.getService().toggleShuffleMode();
			
			if (shuffleOn)
				mShuffleButton.setImageResource(R.drawable.shuffle_highlighted);
			else
				mShuffleButton.setImageResource(UIElementsHelper.getIcon(mContext, "shuffle"));
			
		}
		
	};
    
	/**
	 * Click listener for the play/pause button.
	 */
    private OnClickListener playPauseClickListener = new OnClickListener() {
		
		@Override
		public void onClick(View view) {

            //BZZZT! Give the user a brief haptic feedback touch response.
            view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);

            //Update the playback UI elements.
            if (mApp.getService().isPlayingMusic()) {
                animatePauseToPlay();
                mHandler.removeCallbacks(seekbarUpdateRunnable);
            } else {
                animatePlayToPause();
                mHandler.post(seekbarUpdateRunnable);
            }

            /*
             * Toggle the playback state in a separate thread. This
             * will allow the play/pause button animation to remain
             * buttery smooth.
             */
            new AsyncTask() {

                @Override
                protected Object doInBackground(Object[] params) {
                    mApp.getService().togglePlaybackState();
                    return null;
                }

            }.execute();

		}
		
	};
	
	/**
	 * Click listener for the previous button.
	 */
	private OnClickListener mOnClickPreviousListener = new OnClickListener() {
		
		@Override
		public void onClick(View arg0) {

            //Remove the seekbar update runnable.
            mHandler.removeCallbacks(seekbarUpdateRunnable);

			/*
			 * Scrolling the pager will automatically call the skipToTrack() method. 
			 * Since we're passing true for the dispatchToListener parameter, the 
			 * onPageSelected() listener will receive a callback once the scrolling 
			 * animation completes. This has the side-benefit of letting the animation 
			 * finish before starting playback (keeps the animation buttery smooth).
			 */
			int newPosition = mViewPager.getCurrentItem() - 1;
			if (newPosition > -1) {
				scrollViewPager(newPosition, true, 1, true);
			} else {
				mViewPager.setCurrentItem(0, false);
			}
			
		}
		
	};
    
	/**
	 * Click listener for the next button.
	 */
	private OnClickListener mOnClickNextListener = new OnClickListener() {
		
		@Override
		public void onClick(View arg0) {

            //Remove the seekbar update runnable.
            mHandler.removeCallbacks(seekbarUpdateRunnable);

			/*
			 * Scrolling the pager will automatically call the skipToTrack() method. 
			 * Since we're passing true for the dispatchToListener parameter, the 
			 * onPageSelected() listener will receive a callback once the scrolling 
			 * animation completes. This has the side-benefit of letting the animation 
			 * finish before starting playback (keeps the animation buttery smooth).
			 */
			int newPosition = mViewPager.getCurrentItem() + 1;
			if (newPosition < mViewPagerAdapter.getCount()) {
				scrollViewPager(newPosition, true, 1, true);
			} else {
				if (mApp.getService().getRepeatMode()==Common.REPEAT_PLAYLIST)
					mViewPager.setCurrentItem(0, false);
				else
					Toast.makeText(mContext, R.string.no_songs_to_skip_to, Toast.LENGTH_SHORT).show();
			}

			//mApp.getService().skipToNextTrack();
			
		}
		
	};

	/**
	 * Downloads a GMusic song for local playback.
	 */
    /*private void pinSong() {
    	
    	//Check if the app is getting pinned songs from the official GMusic app.
		if (mApp.isFetchingPinnedSongs()==false) {
			
			//Retrieve the name of the song.
			mApp.getService().getCursor().moveToPosition(mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()));
			
			//Get the song's ID/title.
			String songID = mApp.getService().getCursor().getString(mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ID));
			String songTitle = mApp.getService().getCursor().getString(mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_TITLE));

    		//Check if a local copy of the song exists.
    		String localCopyPath = mApp.getDBAccessHelper().getLocalCopyPath(songID);
    		
			if (localCopyPath!=null) {
    			if (localCopyPath.isEmpty() || localCopyPath.equals("")) {
    				if (mMenu!=null) {
    					mMenu.findItem(R.id.action_pin).setIcon(R.drawable.pin_highlighted);
    				}
    				
    				//Get a mCursor with the current song and initiate the download process.
    				String selection = " AND " + DBAccessHelper.SONG_ID + "=" + "'" + songID + "'";
    				mApp.queueSongsToPin(false, false, selection);
    				String toastMessage = getResources().getString(R.string.downloading_no_dot) + " " + songTitle + ".";
					Toast.makeText(mContext, toastMessage, Toast.LENGTH_SHORT).show();
    			} else {
    				if (mMenu!=null) {
    					mMenu.findItem(R.id.action_pin).setIcon(R.drawable.pin_light);
    				}
    				
    	    		String selection = " AND " + DBAccessHelper.SONG_ID + "=" + "'" + songID + "'";
    	    		AsyncRemovePinnedSongsTask task = new AsyncRemovePinnedSongsTask(mContext, selection, null);
    	    		task.execute();
    			}
    		} else {
				if (mMenu!=null) {
					mMenu.findItem(R.id.action_pin).setIcon(R.drawable.pin_highlighted);
				}
    			
				//Get a mCursor with the current song and initiate the download process.
    			String selection = " AND " + DBAccessHelper.SONG_ID + "=" + "'" + songID + "'";
				mApp.queueSongsToPin(false, false, selection);
    		}
			
		} else {
			Toast.makeText(mContext, R.string.wait_until_pinning_complete, Toast.LENGTH_SHORT).show();
		}
		
    }*/

    /**
     * Drawer open/close listener.
     */
    private DrawerListener mDrawerListener = new DrawerListener() {

		@Override
		public void onDrawerClosed(View drawer) {
			if (mQueueDrawerFragment!=null &&
                drawer==mCurrentQueueLayout) {
                mQueueDrawerFragment.setIsDrawerOpen(false);
            }
			
		}

		@Override
		public void onDrawerOpened(View drawer) {
            if (mQueueDrawerFragment!=null &&
                drawer==mCurrentQueueLayout) {
                mQueueDrawerFragment.setIsDrawerOpen(true);
            }
			
		}

		@Override
		public void onDrawerSlide(View drawer, float arg1) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onDrawerStateChanged(int newState) {
			// TODO Auto-generated method stub
			
		}
    	
    };

    /**
     * Provides callback methods when the ViewPager's position/current page has changed.
     */
    private VelocityViewPager.OnPageChangeListener mPageChangeListener = new VelocityViewPager.OnPageChangeListener() {

		@Override
		public void onPageScrollStateChanged(int scrollState) {
			if (scrollState==VelocityViewPager.SCROLL_STATE_DRAGGING)
				USER_SCROLL = true;
			
		}

		@Override
		public void onPageScrolled(final int pagerPosition, float swipeVelocity, int offsetFromCurrentPosition) {
			
			/* swipeVelocity determines whether the viewpager has finished scrolling or not.
			 * Throw in an if statement that only allows the track to change when
			 * swipeVelocity is 0 (which means the page is done scrolling). This ensures
			 * that the tracks don't jump around or get truncated while the user is 
			 * swiping between different pages.
			 */

			if (mApp.isServiceRunning() && mApp.getService().getCursor().getCount()!=1) {
				
				/* Change tracks ONLY when the user has finished the swiping gesture (swipeVelocity will be zero).
				 * Also, don't skip tracks if the new pager position is the same as the current mCursor position (indicates 
				 * that the starting and ending position of the pager is the same).
				 */
				if (swipeVelocity==0.0f && pagerPosition!=mApp.getService().getCurrentSongIndex()) {
					if (USER_SCROLL) {
                        mHandler.removeCallbacks(seekbarUpdateRunnable);
                        smoothScrollSeekbar(0);

                        mHandler.postDelayed(new Runnable() {

                            @Override
                            public void run() {
                                mApp.getService().skipToTrack(pagerPosition);
                            }

                        }, 200);

					}

				}
				
			}
			
		}

		@Override
		public void onPageSelected(int newPosition) {
            //TODO Auto-generated method stub.

		}
		
	};
    
    /**
     * @deprecated
     * Applies the correct transformer effect to the ViewPager.
     */
    @SuppressWarnings("unused")
	private void setPlaylistPagerAnimation() {
    	if (mApp.getSharedPreferences().getInt("TRACK_CHANGE_ANIMATION", 0)==0) {
    		//Don't set a transformer.
    	} else if (mApp.getSharedPreferences().getInt("TRACK_CHANGE_ANIMATION", 0)==1) {
    		//mViewPager.setPageTransformer(true, new ZoomOutPageTransformer(0.85f));
    	} else if (mApp.getSharedPreferences().getInt("TRACK_CHANGE_ANIMATION", 0)==2) {
    		//mViewPager.setPageTransformer(true, new DepthPageTransformer());
    	}
    	
    }
	
    /**
     * Create a new Runnable to update the seekbar and time every 100ms.
     */
    public Runnable seekbarUpdateRunnable = new Runnable() {
    	
    	public void run() {
    		
    		try {
                long currentPosition = mApp.getService().getCurrentMediaPlayer().getCurrentPosition();
                int currentPositionInSecs = (int) currentPosition/1000;
                smoothScrollSeekbar(currentPositionInSecs);

                //mSeekbar.setProgress(currentPositionInSecs);
                mHandler.postDelayed(seekbarUpdateRunnable, 100);

    		} catch (Exception e) {
    			e.printStackTrace();
    		}
    		
    	}
    	
    };

    /**
     * Smoothly scrolls the seekbar to the indicated position.
     */
    private void smoothScrollSeekbar(int progress) {
        ObjectAnimator animation = ObjectAnimator.ofInt(mSeekbar, "progress", progress);
        animation.setDuration(200);
        animation.setInterpolator(new DecelerateInterpolator());
        animation.start();

    }

    /**
     * Initiates the strobe effect on the seekbar.
     */
    private void initSeekbarStrobeEffect() {
        mSeekbarStrobeAnim = new AlphaAnimation(1.0f, 0.0f);
        mSeekbarStrobeAnim.setRepeatCount(SEEKBAR_STROBE_ANIM_REPEAT);
        mSeekbarStrobeAnim.setDuration(700);
        mSeekbarStrobeAnim.setRepeatMode(Animation.REVERSE);

        mSeekbar.startAnimation(mSeekbarStrobeAnim);

    }

    /**
     * Stops the seekbar strobe effect.
     */
    private void stopSeekbarStrobeEffect() {
        mSeekbarStrobeAnim = new AlphaAnimation(mSeekbar.getAlpha(), 1.0f);
        mSeekbarStrobeAnim.setDuration(700);
        mSeekbar.startAnimation(mSeekbarStrobeAnim);
        
    }
    
    public class PlaylistPagerAdapter extends FragmentStatePagerAdapter {

        public PlaylistPagerAdapter(FragmentManager fm) {
            super(fm);

        }

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            super.destroyItem(container, position, object);
          
        }

        //This method controls the layout that is shown on each screen.
        @Override
        public Fragment getItem(int position) {

        	/* PlaylistPagerFragment.java will be shown on every pager screen. However, 
        	 * the fragment will check which screen (position) is being shown, and will
        	 * update its TextViews and ImageViews to match the song that's being played. */
    		Fragment fragment = new PlaylistPagerFragment();
    		
    		Bundle bundle = new Bundle();
    		bundle.putInt("POSITION", position);
    		fragment.setArguments(bundle);
    		return fragment;

        }

        @Override
        public int getCount() {
        	
        	try {
            	if (mApp.getService().getPlaybackIndecesList()!=null) {
            		return mApp.getService().getPlaybackIndecesList().size();
            	} else {
            		mApp.getService().stopSelf();
            		return 0;
            	}
        	} catch (Exception e) {
        		e.printStackTrace();
        		return 0;
        	}

        }

    }
	
	/**
	 * Displays the "Resuming from xx:xx" toast.
	 */
	public void displayAudiobookToast(long resumePlaybackPosition) {
		try {
			String resumingFrom = mContext.getResources().getString(R.string.resuming_from) 
								+ " " + mApp.convertMillisToMinsSecs(resumePlaybackPosition) + ".";
			
			Toast.makeText(mContext, resumingFrom, Toast.LENGTH_LONG).show();
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}

    /**
     * Toggles the open/closed state of the current queue drawer.
     */
	public void toggleCurrentQueueDrawer() {
        if (mDrawerLayout==null)
            return;

        if (mDrawerLayout.isDrawerOpen(Gravity.END))
            mDrawerLayout.closeDrawer(Gravity.END);
        else
            mDrawerLayout.openDrawer(Gravity.END);

    }

	/*
	 * Getter and setter methods.
	 */
	
	public SeekBar getSeekbar() {
		return mSeekbar;
	}
	
	public ProgressBar getStreamingProgressBar() {
		return mStreamingProgressBar;
	}
	
	public VelocityViewPager getPlaylistViewPager() {
		return mViewPager;
	}

	public NowPlayingActivityListener getNowPlayingActivityListener() {
		return mNowPlayingActivityListener;
	}
	
	public void setNowPlayingActivityListener(NowPlayingActivityListener listener) {
		mNowPlayingActivityListener = listener;
	}
	
	/**
	 * Interface that provides callbacks once this activity is 
	 * up and running.
	 */
	public interface NowPlayingActivityListener {
		
		/**
		 * Called once this activity's onResume() method finishes 
		 * executing.
		 */
		public void onNowPlayingActivityReady();
		
	}

	@Override
	public void onResume() {
		super.onResume();

        if (mIsCreating==false) {
            setKitKatTranslucentBars();
            mHandler.postDelayed(seekbarUpdateRunnable, 100);
            mIsCreating = false;
        }

        //Animate the controls bar in.
        //animateInControlsBar();

        //Update the seekbar.
        try {
            setSeekbarDuration(mApp.getService().getCurrentMediaPlayer().getDuration()/1000);
        } catch (Exception e) {
            e.printStackTrace();
        }

        //Load the drawer 1000ms after the activity is loaded.
        mHandler.postDelayed(new Runnable() {

            @Override
            public void run() {
                initDrawer();
            }

        }, 1000);

		if (getIntent().hasExtra(START_SERVICE) &&
			getNowPlayingActivityListener()!=null) {
			getNowPlayingActivityListener().onNowPlayingActivityReady();

			/**
			 * To prevent the service from being restarted every time this
			 * activity is resume, we're gonna have to remove the "START_SERVICE"
			 * extra from the intent.
			 */
			getIntent().removeExtra(START_SERVICE);

		}

	}

    @Override
    public void onPause() {
        super.onPause();
        if (isFinishing())
            mApp.setNowPlayingActivity(null);

    }
	
    @Override
    public void onStart() {
    	super.onStart();
    	//Initialize the broadcast manager that will listen for track changes.
    	LocalBroadcastManager.getInstance(mContext)
		 					 .registerReceiver((mReceiver), new IntentFilter(Common.UPDATE_UI_BROADCAST));
    	
    	/* Check if the service is up and running. If so, send out a broadcast message 
    	 * that will initialize this activity fully. This code block is what will 
    	 * initialize this activity fully if it is opened after the service is already 
    	 * up and running (the onServiceRunning() callback isn't available at this point).
    	 */
    	if (mApp.isServiceRunning() && mApp.getService().getCursor()!=null) {
    		String[] updateFlags = new String[] { Common.UPDATE_PAGER_POSTIION, 
    											  Common.UPDATE_SEEKBAR_DURATION, 
    											  Common.HIDE_STREAMING_BAR, 
    											  Common.INIT_PAGER, 
    											  Common.UPDATE_PLAYBACK_CONTROLS, 
    											  Common.UPDATE_EQ_FRAGMENT };
    		
        	String[] flagValues = new String[] { "" + mApp.getService().getCurrentSongIndex(), 
        										 "" + mApp.getService().getCurrentMediaPlayer().getDuration(), 
        										 "", "", "", "" };
        	mApp.broadcastUpdateUICommand(updateFlags, flagValues);
    	}
    	
    }
    
    @Override
    public void onStop() {
    	//Unregister the broadcast receivers.
    	LocalBroadcastManager.getInstance(mContext).unregisterReceiver(mReceiver);
    	super.onStop();
    	
    }
    
    @Override
    public void onSaveInstanceState(Bundle savedInstanceState) {
    	super.onSaveInstanceState(savedInstanceState);
    	savedInstanceState.putBoolean("CALLED_FROM_FOOTER", true);
    	savedInstanceState.putBoolean("CALLED_FROM_NOTIF", true);
    }
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.NowPlayingActivity;

import java.util.ArrayList;

import android.content.Context;
import android.content.SharedPreferences;
import android.graphics.Paint;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Utils.Common;

public class NowPlayingQueueListAdapter extends ArrayAdapter<Integer> {

	private Context mContext;
	private Common mApp;
	private ArrayList<Integer> mPlaybackIndecesList;
   
    public NowPlayingQueueListAdapter(Context context, ArrayList<Integer> playbackIndecesList) {
    	
    	super(context, -1, playbackIndecesList);
    	
    	mContext = context;
    	mApp = (Common) mContext;
    	mPlaybackIndecesList = playbackIndecesList;
    	
    }
    
    public View getView(final int position, View convertView, ViewGroup parent){
    	
    	NowPlayingQueueListViewHolder holder = null;
		if (convertView == null) {
			convertView = LayoutInflater.from(mContext).inflate(R.layout.now_playing_queue_listview_layout, parent, false);
			holder = new NowPlayingQueueListViewHolder();
			holder.songTitleText = (TextView) convertView.findViewById(R.id.playlists_flipped_song);
			holder.artistText = (TextView) convertView.findViewById(R.id.playlists_flipped_artist);
			holder.removeSong = (ImageView) convertView.findViewById(R.id.remove_song_from_queue);
			
			holder.songTitleText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Light"));
			holder.songTitleText.setPaintFlags(holder.songTitleText.getPaintFlags()
											 | Paint.ANTI_ALIAS_FLAG
											 | Paint.SUBPIXEL_TEXT_FLAG);		
			
			holder.artistText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
			holder.artistText.setPaintFlags(holder.artistText.getPaintFlags()
											 | Paint.ANTI_ALIAS_FLAG
											 | Paint.SUBPIXEL_TEXT_FLAG);
			
			convertView.setTag(holder);
		} else {
		    holder = (NowPlayingQueueListViewHolder) convertView.getTag();
		}
		
		//Move the local cursor to the correct position.
		mApp.getService().getCursor().moveToPosition(mPlaybackIndecesList.get(position));
		
		//Get the song's parameters.
		String songTitle;
		String songFilePath;
		String songArtist;
		try {
			songTitle = mApp.getService().getCursor().getString(mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_TITLE));
			songFilePath = mApp.getService().getCursor().getString(mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_FILE_PATH));
			songArtist = mApp.getService().getCursor().getString(mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ARTIST));
		} catch (Exception e) {
			/* If an exception is raised, the user is probably playing from the folders and the cursor hasn't been completely built yet.
			 * Just use temporary placeholders for now and the ListView will automatically refresh itself once the cursor is fully built. */
			songTitle = "Loading...";
			songFilePath = "";
			songArtist = "";
		}
		
		//Set the view tags.
		convertView.setTag(R.string.title, songTitle);
		convertView.setTag(R.string.song_file_path, songFilePath);
		convertView.setTag(R.string.artist, songArtist);
		
		holder.songTitleText.setText(songTitle);
		holder.artistText.setText(songArtist);
		
		//Apply the card layout's background based on the color theme.
		if (position==mApp.getService().getCurrentSongIndex()) {
			int[] colors = UIElementsHelper.getQuickScrollColors(mContext);
			convertView.setBackgroundColor(colors[0]);
			holder.songTitleText.setTextColor(colors[2]);
			holder.artistText.setTextColor(colors[2]);
			holder.removeSong.setImageResource(R.drawable.cross_light);
			
		} else if (mApp.getCurrentTheme()==Common.LIGHT_THEME) {
			convertView.setBackgroundColor(0xFFFFFFFF);
			holder.songTitleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
			holder.artistText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
			holder.removeSong.setImageResource(R.drawable.cross);
			
		} else if (mApp.getCurrentTheme()==Common.DARK_THEME) {
			convertView.setBackgroundColor(0xFF191919);
			holder.songTitleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
			holder.artistText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
			holder.removeSong.setImageResource(R.drawable.cross_light);
			
		}
		
		return convertView;

	}
    
	class NowPlayingQueueListViewHolder {
	    public TextView songTitleText;
	    public TextView artistText;
	    public ImageView removeSong;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.NowPlayingActivity;

import java.io.File;
import java.io.IOException;

import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.audio.exceptions.CannotReadException;
import org.jaudiotagger.audio.exceptions.CannotWriteException;
import org.jaudiotagger.audio.exceptions.InvalidAudioFrameException;
import org.jaudiotagger.audio.exceptions.ReadOnlyFileException;
import org.jaudiotagger.tag.FieldDataInvalidException;
import org.jaudiotagger.tag.FieldKey;
import org.jaudiotagger.tag.KeyNotFoundException;
import org.jaudiotagger.tag.Tag;

import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Paint;
import android.media.MediaMetadataRetriever;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.content.LocalBroadcastManager;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnLongClickListener;
import android.view.ViewGroup;
import android.widget.RatingBar;
import android.widget.RatingBar.OnRatingBarChangeListener;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class PlaylistPagerFlippedFragment extends Fragment {

	private Context mContext;
	private Common mApp;
	private RatingBar ratingBar;
	public TextView lyricsTextView;
	public TextView headerTextView;
	public TextView noLyricsFoundText;
	public RelativeLayout lyricsRelativeLayout;
	private Cursor tempCursor;
	
	//Broadcast that notifies the PlaylistPager that it should flip the card back around to the album art.
	public static LocalBroadcastManager localBroadcastManager;
	public static final String broadcastMessage = "com.jams.music.player.FLIP_BACK_TO_ALBUM_ART";
	
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        final ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_playlist_pager_flipped, container, false);
        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;
        
        ratingBar = (RatingBar) rootView.findViewById(R.id.playlist_pager_flipped_rating_bar);
        lyricsRelativeLayout = (RelativeLayout) rootView.findViewById(R.id.lyricsRelativeLayout);
        lyricsTextView = (TextView) rootView.findViewById(R.id.playlist_pager_flipped_lyrics);
        headerTextView = (TextView) rootView.findViewById(R.id.playlist_pager_flipped_title);
        noLyricsFoundText = (TextView) rootView.findViewById(R.id.no_embedded_lyrics_found_text);
        
        lyricsTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
        lyricsTextView.setPaintFlags(lyricsTextView.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        headerTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
        headerTextView.setPaintFlags(headerTextView.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        noLyricsFoundText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
        noLyricsFoundText.setPaintFlags(noLyricsFoundText.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
        
        lyricsRelativeLayout.setOnLongClickListener(new OnLongClickListener() {

			@Override
			public boolean onLongClick(View arg0) {
				//Fire a broadcast that notifies the PlaylistPager to update flip back to the album art.
				Intent intent = new Intent(broadcastMessage);
				intent.putExtra("MESSAGE", broadcastMessage);
				
				//Initialize the local broadcast manager.
				localBroadcastManager = LocalBroadcastManager.getInstance(mContext);
				localBroadcastManager.sendBroadcast(intent);
				
				return true;
			}
        	
        });
        
        //Get the file path of the current song.
        String updatedSongTitle = "";
		String updatedSongArtist = "";
		String songFilePath = "";
		String songId = "";
		MediaMetadataRetriever mmdr = new MediaMetadataRetriever();
		tempCursor = mApp.getService().getCursor();
		tempCursor.moveToPosition(mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()));
		if (tempCursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH)==-1) {
			//Retrieve the info from the file's metadata.
			songFilePath = tempCursor.getString(tempCursor.getColumnIndex(null));
			mmdr.setDataSource(songFilePath);
			
			updatedSongTitle = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE);
			updatedSongArtist = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);
			
		} else {
			/* Check if the cursor has the SONG_FILE_PATH column. If it does, we're dealing 
			 * with the SONGS table. If not, we're dealing with the PLAYLISTS table. We'll 
			 * retrieve data from the appropriate columns using this info. */
			if (tempCursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH)==-1) {
				//We're dealing with the Playlists table.
				songFilePath = tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.PLAYLIST_FILE_PATH));
				mmdr.setDataSource(songFilePath);
				
				updatedSongTitle = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE);
				updatedSongArtist = mmdr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);
			} else {
				//We're dealing with the songs table.
				songFilePath = tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH));
				updatedSongTitle = tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_TITLE));
				updatedSongArtist = tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_ARTIST));
				songId = tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_ID));
			}
			
		}
		
		headerTextView.setText(updatedSongTitle + " - " + updatedSongArtist);
        ratingBar.setStepSize(1);
        int rating = mApp.getDBAccessHelper().getSongRating(songId);
        ratingBar.setRating(rating); 

        //Get the rating value for the song.
        AudioFile audioFile = null;
        File file = null;
        try {
          	audioFile = null;
            file = new File(songFilePath);
      		try {
      			audioFile = AudioFileIO.read(file);
      		} catch (CannotReadException e1) {
      			// TODO Auto-generated catch block
      			e1.printStackTrace();
      		} catch (IOException e1) {
      			// TODO Auto-generated catch block
      			e1.printStackTrace();
      		} catch (org.jaudiotagger.tag.TagException e1) {
      			// TODO Auto-generated catch block
      			e1.printStackTrace();
      		} catch (ReadOnlyFileException e1) {
      			// TODO Auto-generated catch block
      			e1.printStackTrace();
      		} catch (InvalidAudioFrameException e1) {
      			// TODO Auto-generated catch block
      			e1.printStackTrace();
      		}
        } catch (Exception e) {
        	e.printStackTrace();
        }
        
        try {
        	final AudioFile finalizedAudioFile = audioFile;
        	final String finalSongFilePath = songFilePath;
        	final String finalSongId = songId;
	        ratingBar.setOnRatingBarChangeListener(new OnRatingBarChangeListener() {
	
				@Override
				public void onRatingChanged(RatingBar ratingBar, float rating, boolean fromUser) {
					//Change the rating in the DB and the actual audio file itself.
					
					Log.e("DEBUG", ">>>>>RATING: " + rating);
					
					try {
						Tag tag = finalizedAudioFile.getTag();
						tag.addField(FieldKey.RATING, "" + ((int) rating));
					} catch (KeyNotFoundException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (FieldDataInvalidException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (Exception e) {
						e.printStackTrace();
						Log.e("DEBUG", ">>>>>>>RATING FIELD NOT FOUND");
					}
					
					try {
						finalizedAudioFile.commit();
					} catch (CannotWriteException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (Exception e) {
						e.printStackTrace();
					}
	
					mApp.getDBAccessHelper().setSongRating(finalSongId, (int) rating);
					
				}
				
			});
	        
			//Check if the audio file has any embedded lyrics.
	        String lyrics = null;
	        try {
	        	Tag tag = audioFile.getTag();
	    		lyrics = tag.getFirst(FieldKey.LYRICS);
	    		
	    		if (lyrics==null || lyrics.isEmpty()) {
	    			lyricsTextView.setVisibility(View.GONE);
	    			noLyricsFoundText.setVisibility(View.VISIBLE);
	    			return rootView;
	    		}
	    		
	    		//Since the song has embedded lyrics, display them in the layout.
	    		lyricsTextView.setVisibility(View.VISIBLE);
	    		noLyricsFoundText.setVisibility(View.GONE);
	    		lyricsTextView.setText(lyrics);
	    	
	        } catch (Exception e) {
	    		e.printStackTrace();
	    		lyricsTextView.setVisibility(View.GONE);
    			noLyricsFoundText.setVisibility(View.VISIBLE);
    			return rootView;
	        }
        } catch (Exception e) {
        	e.printStackTrace();
        	//Can't do much here.
        }
		
        return rootView;
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.NowPlayingActivity;

import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentTransaction;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.DecelerateInterpolator;
import android.widget.ImageView;
import android.widget.PopupMenu;
import android.widget.RelativeLayout;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.Animations.TranslateAnimation;
import com.jams.music.player.Dialogs.ABRepeatDialog;
import com.jams.music.player.EqualizerActivity.EqualizerActivity;
import com.jams.music.player.Helpers.SongHelper;
import com.jams.music.player.Helpers.SongHelper.AlbumArtLoadedListener;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.ImageTransformers.PicassoMirrorReflectionTransformer;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.tag.FieldKey;
import org.jaudiotagger.tag.Tag;

import java.io.File;

public class PlaylistPagerFragment extends Fragment implements AlbumArtLoadedListener {

	private Context mContext;
	private Common mApp;
	private ViewGroup mRootView;
	private int mPosition;
	private SongHelper mSongHelper;
	private PopupMenu popup;

    private RelativeLayout bottomDarkPatch;
    private RelativeLayout songInfoLayout;
	private TextView songNameTextView;
	private TextView artistAlbumNameTextView;
	private ImageView coverArt;
	private ImageView overflowIcon;
	
	private boolean mAreLyricsVisible = false;
	private ScrollView mLyricsScrollView;
	private TextView mLyricsTextView;
	private TextView mLyricsEmptyTextView;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        
        mContext = getActivity();
        mApp = (Common) mContext.getApplicationContext();

        mRootView = (ViewGroup) inflater.inflate(R.layout.fragment_playlist_pager_fill, container, false);
        mPosition = getArguments().getInt("POSITION");

        overflowIcon = (ImageView) mRootView.findViewById(R.id.now_playing_overflow_icon);
    	coverArt = (ImageView) mRootView.findViewById(R.id.coverArt);
        bottomDarkPatch = (RelativeLayout) mRootView.findViewById(R.id.bottomDarkPatch);
        songInfoLayout = (RelativeLayout) mRootView.findViewById(R.id.songInfoLayout);
        songNameTextView = (TextView) mRootView.findViewById(R.id.songName);
    	artistAlbumNameTextView = (TextView) mRootView.findViewById(R.id.artistAlbumName);
    	
    	mLyricsScrollView = (ScrollView) mRootView.findViewById(R.id.lyrics_scroll_view);
    	mLyricsTextView = (TextView) mRootView.findViewById(R.id.lyrics);
    	mLyricsEmptyTextView = (TextView) mRootView.findViewById(R.id.lyrics_empty);
        
    	mLyricsTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
    	mLyricsEmptyTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
    	songNameTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
    	artistAlbumNameTextView.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));

        //Allow the TextViews to scroll if they extend beyond the layout margins.
        songNameTextView.setSelected(true);
        artistAlbumNameTextView.setSelected(true);
    	
    	//Initialize the pop up menu.
    	popup = new PopupMenu(getActivity(), overflowIcon);
		popup.getMenuInflater().inflate(R.menu.now_playing_overflow_menu, popup.getMenu());
        popup.setOnMenuItemClickListener(menuItemClickListener);

        mSongHelper = new SongHelper();
        mSongHelper.setAlbumArtLoadedListener(this);

        if (mApp.getOrientation()==Common.ORIENTATION_LANDSCAPE)
            mSongHelper.populateSongData(mContext, mPosition);
		else
            mSongHelper.populateSongData(mContext, mPosition, new PicassoMirrorReflectionTransformer());

    	songNameTextView.setText(mSongHelper.getTitle());
    	artistAlbumNameTextView.setText(mSongHelper.getAlbum() + " - " + mSongHelper.getArtist());
        overflowIcon.setOnClickListener(overflowClickListener);

        //Kitkat padding.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            int navigationBarHeight = Common.getNavigationBarHeight(mContext);
            int bottomPadding = songInfoLayout.getPaddingBottom();
            RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) bottomDarkPatch.getLayoutParams();

            if (navigationBarHeight > 0) {
                /* The nav bar already has padding, so remove the extra 15dp
                 * padding that was applied in the layout file.
                 */
                int marginPixelsValue = (int) mApp.convertDpToPixels(15, mContext);
                bottomPadding -= marginPixelsValue;
                params.height -= marginPixelsValue;
            }

            bottomPadding += navigationBarHeight;
            songInfoLayout.setPadding(0, 0, 0, bottomPadding);

            params.height += navigationBarHeight;
            bottomDarkPatch.setLayoutParams(params);

        }
    	
        return mRootView;
    }

    /**
     * Overflow button click listener.
     */
    private OnClickListener overflowClickListener = new OnClickListener() {

        @Override
        public void onClick(View v) {

            //Hide the "Current queue" item if it's already visible.
            if (mApp.isTabletInLandscape())
                popup.getMenu().findItem(R.id.current_queue).setVisible(false);

            popup.show();
        }

    };

    /**
     * Menu item click listener for the overflow pop up menu.
     */
    private PopupMenu.OnMenuItemClickListener menuItemClickListener = new PopupMenu.OnMenuItemClickListener() {

        @Override
        public boolean onMenuItemClick(MenuItem item) {

            switch (item.getItemId()) {
                case R.id.equalizer:
                    Intent intent = new Intent(getActivity(), EqualizerActivity.class);
                    startActivity(intent);
                    break;
                case R.id.save_clear_current_position:
                    String songId = mApp.getService().getCurrentSong().getId();
                    if (item.getTitle().equals(mContext.getResources().getString(R.string.save_current_position))) {
                        item.setTitle(R.string.clear_saved_position);

                        long currentPositionMillis = mApp.getService().getCurrentMediaPlayer().getCurrentPosition();
                        String message = mContext.getResources().getString(R.string.track_will_resume_from);
                        message += " " + mApp.convertMillisToMinsSecs(currentPositionMillis);
                        message += " " + mContext.getResources().getString(R.string.next_time_you_play_it);

                        mApp.getDBAccessHelper().setLastPlaybackPosition(songId, currentPositionMillis);
                        Toast.makeText(mContext, message, Toast.LENGTH_LONG).show();

                    } else {
                        item.setTitle(R.string.save_current_position);
                        mApp.getDBAccessHelper().setLastPlaybackPosition(songId, -1);
                        Toast.makeText(mContext, R.string.track_start_from_beginning_next_time_play, Toast.LENGTH_LONG).show();

                    }

                    //Requery the database and update the service cursor.
                    mApp.getPlaybackKickstarter().updateServiceCursor();

                    break;
                case R.id.show_embedded_lyrics:
                    if (item.getTitle().equals(mContext.getResources().getString(R.string.show_embedded_lyrics))) {
                        AsyncLoadLyricsTask task = new AsyncLoadLyricsTask();
                        task.execute();
                        item.setTitle(R.string.hide_lyrics);
                    } else {
                        hideLyrics();
                        item.setTitle(R.string.show_embedded_lyrics);
                    }

                    break;
                case R.id.a_b_repeat:
                    FragmentTransaction ft = getActivity().getSupportFragmentManager().beginTransaction();
                    ABRepeatDialog dialog = new ABRepeatDialog();
                    dialog.show(ft, "repeatSongRangeDialog");
                    break;
                case R.id.current_queue:
                    ((NowPlayingActivity) getActivity()).toggleCurrentQueueDrawer();
                    break;
                case R.id.go_to:
                    PopupMenu goToPopupMenu = new PopupMenu(getActivity(), overflowIcon);
                    goToPopupMenu.inflate(R.menu.show_more_menu);
                    goToPopupMenu.setOnMenuItemClickListener(goToMenuClickListener);
                    goToPopupMenu.show();
                    break;
            }

            return false;
        }

    };

    /**
     * "Go to" popup menu item click listener.
     */
    private PopupMenu.OnMenuItemClickListener goToMenuClickListener = new PopupMenu.OnMenuItemClickListener() {

        @Override
        public boolean onMenuItemClick(MenuItem item) {
            switch (item.getItemId()) {
                case R.id.go_to_this_artist:
                    break;
                case R.id.go_to_this_album_artist:
                    break;
                case R.id.go_to_this_album:
                    break;
                case R.id.go_to_this_genre:
                    break;
            }

            return false;
        }

    };

    /**
     * Callback method for album art loading.
     */
	@Override
	public void albumArtLoaded() {
		coverArt.setImageBitmap(mSongHelper.getAlbumArt());
	}

    /**
     * Reads lyrics from the audio file's tag and displays them.
     */
	class AsyncLoadLyricsTask extends AsyncTask<Boolean, Boolean, Boolean> {

		String mLyrics = "";
		
		@Override
		protected Boolean doInBackground(Boolean... arg0) {
			String songFilePath = mApp.getService().getCurrentSong().getFilePath();
			AudioFile audioFile = null;
			Tag tag = null;
			try {
				audioFile = AudioFileIO.read(new File(songFilePath));
				
				if (audioFile!=null)
					tag = audioFile.getTag();
				else
					return false;
				
				if (tag!=null)
					mLyrics = tag.getFirst(FieldKey.LYRICS);
				else
					return false;
				
			} catch (Exception e) {
				e.printStackTrace();
			}
			
			return true;
		}
		
		@Override
		public void onPostExecute(Boolean result) {
			super.onPostExecute(result);
			
			if (mLyrics!=null && !mLyrics.isEmpty()) {
				mLyricsTextView.setText(mLyrics);
				mLyricsTextView.setVisibility(View.VISIBLE);
				mLyricsEmptyTextView.setVisibility(View.INVISIBLE);
			} else {
				mLyrics = mContext.getResources().getString(R.string.no_embedded_lyrics_found);
				mLyricsTextView.setText(mLyrics);
				mLyricsTextView.setVisibility(View.INVISIBLE);
				mLyricsEmptyTextView.setVisibility(View.VISIBLE);
			}
			
			//Slide up the album art to show the lyrics.
	    	TranslateAnimation slideUpAnimation = new TranslateAnimation(coverArt, 400, new AccelerateInterpolator(), 
					 													 View.INVISIBLE,
					 													 Animation.RELATIVE_TO_SELF, 0.0f, 
					 													 Animation.RELATIVE_TO_SELF, 0.0f, 
					 													 Animation.RELATIVE_TO_SELF, 0.0f, 
					 													 Animation.RELATIVE_TO_SELF, -2.0f);

	    	slideUpAnimation.animate();
	    	
		}
		
	}

    /**
     * Slides down the album art to hide lyrics.
     */
    private void hideLyrics() {
        TranslateAnimation slideDownAnimation = new TranslateAnimation(coverArt, 400, new DecelerateInterpolator(2.0f),
                                                                       View.VISIBLE,
                                                                       Animation.RELATIVE_TO_SELF, 0.0f,
                                                                       Animation.RELATIVE_TO_SELF, 0.0f,
                                                                       Animation.RELATIVE_TO_SELF, -2.0f,
                                                                       Animation.RELATIVE_TO_SELF, 0.0f);

        slideDownAnimation.animate();
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.NowPlayingQueueActivity;

import android.app.ActionBar;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentTransaction;
import android.text.Spannable;
import android.text.SpannableString;
import android.util.DisplayMetrics;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.Utils.TypefaceSpan;

public class NowPlayingQueueActivity extends FragmentActivity {

	public Context mContext;
	public SharedPreferences sharedPreferences;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		
		mContext = this;
		sharedPreferences = getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		
    	//Get the screen's parameters.
	    DisplayMetrics displayMetrics = new DisplayMetrics();
	    this.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
	    int screenWidth = displayMetrics.widthPixels;
		
    	//Set the UI theme.
    	if (sharedPreferences.getString(Common.CURRENT_THEME, "LIGHT_CARDS_THEME").equals("DARK_THEME") ||
    		sharedPreferences.getString(Common.CURRENT_THEME, "LIGHT_CARDS_THEME").equals("DARK_CARDS_THEME")) {
    		setTheme(R.style.AppTheme);
    	} else {
    		setTheme(R.style.AppThemeLight);
    	}

    	super.onCreate(savedInstanceState);
    	
    	if (getOrientation().equals("PORTRAIT")) {

    		//Finish this activity and relaunch the activity that called this one.
    		Intent intent = new Intent(this, (Class<?>) getIntent().getSerializableExtra("CALLING_CLASS"));
    		intent.putExtras(getIntent());
    		intent.putExtra("NEW_PLAYLIST", false);
    		intent.putExtra("CALLED_FROM_FOOTER", true);
    		intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
    		finish();
    		startActivity(intent);
    		
    		return;
    		
    	} else {
    		
    		setContentView(R.layout.activity_now_playing_queue);
    		
        	final Fragment nowPlayingQueueFragment = new NowPlayingQueueFragment();
    	    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
    	    transaction.add(R.id.now_playing_queue_container, nowPlayingQueueFragment, "nowPlayingQueueFragment");
    	    transaction.commit();
    		
    	    SpannableString s = new SpannableString(getResources().getString(R.string.current_queue));
    	    s.setSpan(new TypefaceSpan(this, "RobotoCondensed-Light"), 0, s.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

    	    // Update the action bar title with the TypefaceSpan instance.
    	    ActionBar actionBar = getActionBar();
    	    actionBar.setTitle(s);
    	    actionBar.setBackgroundDrawable(getResources().getDrawable(R.drawable.holo_gray_selector));
    	    
    	}
    	
	}

    @Override
    public void onDestroy() {
    	super.onDestroy();
    	
/*    	NowPlayingQueueFragment nowPlayingQueueFragment = 
    	
    	if (nowPlayingQueueFragment.bm!=null) {
    		
        	if (!nowPlayingQueueFragment.bm.isRecycled()) {
        		nowPlayingQueueFragment.bm.recycle();
        	}
        	
    	}

    	nowPlayingQueueFragment.bm = null;
    	nowPlayingQueueFragment.embeddedArt = null;
    	nowPlayingQueueFragment.is = null;*/

    	overridePendingTransition(R.anim.scale_and_fade_in, R.anim.fade_out);
    	
    }
    
    public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
        final int height = options.outHeight;
        final int width = options.outWidth;
        int inSampleSize = 1;

        if (height > reqHeight || width > reqWidth) {
        	
            if (width > height) {
                inSampleSize = Math.round((float) height / (float) reqHeight);
            } else {
                inSampleSize = Math.round((float) width / (float) reqWidth);
            }
            
        }

        return inSampleSize;
    }
    
    //Resamples a resource image to avoid OOM errors.
    public Bitmap decodeSampledBitmapFromResource(int resID, int reqWidth, int reqHeight) {

	    final BitmapFactory.Options options = new BitmapFactory.Options();
	    options.inJustDecodeBounds = true;
	    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
	    options.inJustDecodeBounds = false;
	    options.inPurgeable = true;
	
	    return BitmapFactory.decodeResource(getBaseContext().getResources(), resID, options);
    }
    
    @Override
    public void onPause() {
    	super.onPause();
    	
    	//Kill the activity to free up memory. We can restart the activity later.
    	finish();
    	
    }
    
    //Retrieves the orientation of the device.
    public String getOrientation() {

        if(getResources().getDisplayMetrics().widthPixels > 
           getResources().getDisplayMetrics().heightPixels) { 
            return "LANDSCAPE";
        } else {
            return "PORTRAIT";
        }     
        
    }
    
    @Override
    public void onBackPressed() {
    	//Ask the user to rotate the device to get back to the previous activity.
    	Toast.makeText(mContext, R.string.rotate_device_to_go_back, Toast.LENGTH_LONG).show();
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.NowPlayingQueueActivity;

import java.io.File;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.Paint;
import android.os.Bundle;
import android.os.Handler;
import android.support.v4.app.Fragment;
import android.support.v4.content.LocalBroadcastManager;
import android.util.DisplayMetrics;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.ProgressBar;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Services.AudioPlaybackService;
import com.jams.music.player.Utils.Common;
import com.mobeta.android.dslv.DragSortListView;
import com.mobeta.android.dslv.SimpleFloatViewManager;

public class NowPlayingQueueFragment extends Fragment {

	private Context mContext;
	public NowPlayingQueueFragment nowPlayingQueueFragment = null;
	private SharedPreferences sharedPreferences;
	
	public DragSortListView nowPlayingQueueListView;
	public NowPlayingQueueListViewAdapter nowPlayingQueueListViewAdapter;
	public int contextMenuItemIndex;

	public TextView noMusicPlaying;
	public ImageView nowPlayingAlbumArt;
	public TextView nowPlayingSongTitle;
	public TextView nowPlayingSongArtist;
	public RelativeLayout nowPlayingSongContainer;
	
	public ProgressBar progressBar;
	public ImageButton playPauseButton;
	public ImageButton previousButton;
	public ImageButton nextButton;
	
	public int index;
	public View childView;
	public float progressFraction;
	public int currentProgress;
	public int totalDuration;
	public int currentProgressCountDown;
	public Handler mHandler = new Handler();
	private BroadcastReceiver receiver;
	private Common mApp;
	
	public DisplayMetrics displayMetrics;
	public int screenWidth;
	public int screenHeight;
	public static Cursor mCursor;
	private boolean CALLED_FROM_REMOVE = false;
	
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    	
    	//Inflate the correct layout based on the selected theme.
        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;
        nowPlayingQueueFragment = this;
        sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
        
        mCursor = mApp.getService().getCursor();
        View rootView = (ViewGroup) inflater.inflate(R.layout.now_playing_queue_layout, container, false);

        receiver = new BroadcastReceiver() {
        	
            @Override
            public void onReceive(Context context, Intent intent) {
                updateSongInfo();
            }
            
        };
        
        //Notify the application that this fragment is now visible.
        sharedPreferences.edit().putBoolean("NOW_PLAYING_QUEUE_VISIBLE", true).commit();
        
    	//Get the screen's parameters.
	    displayMetrics = new DisplayMetrics();
	    getActivity().getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
	    screenWidth = displayMetrics.widthPixels;
	    screenHeight = displayMetrics.heightPixels;
        
        noMusicPlaying = (TextView) rootView.findViewById(R.id.now_playing_queue_no_music_playing);
        nowPlayingAlbumArt = (ImageView) rootView.findViewById(R.id.now_playing_queue_album_art);
        nowPlayingSongTitle = (TextView) rootView.findViewById(R.id.now_playing_queue_song_title);
        nowPlayingSongArtist = (TextView) rootView.findViewById(R.id.now_playing_queue_song_artist);
        nowPlayingSongContainer = (RelativeLayout) rootView.findViewById(R.id.now_playing_queue_current_song_container);
        
        noMusicPlaying.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
        nowPlayingSongTitle.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
        nowPlayingSongArtist.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
        
        nowPlayingQueueListView = (DragSortListView) rootView.findViewById(R.id.now_playing_queue_list_view);
        progressBar = (ProgressBar) rootView.findViewById(R.id.now_playing_queue_progressbar);
        playPauseButton = (ImageButton) rootView.findViewById(R.id.now_playing_queue_play);
        nextButton = (ImageButton) rootView.findViewById(R.id.now_playing_queue_next);
        previousButton = (ImageButton) rootView.findViewById(R.id.now_playing_queue_previous);
        
		//Apply the card layout's background based on the color theme.
		if (sharedPreferences.getString(Common.CURRENT_THEME, "LIGHT_CARDS_THEME").equals("LIGHT_CARDS_THEME")) {
			rootView.setBackgroundColor(0xFFEEEEEE);
			nowPlayingQueueListView.setDivider(getResources().getDrawable(R.drawable.transparent_drawable));
			nowPlayingQueueListView.setDividerHeight(3);
			RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
			layoutParams.setMargins(7, 3, 7, 3);
			nowPlayingQueueListView.setLayoutParams(layoutParams);
		} else if (sharedPreferences.getString(Common.CURRENT_THEME, "LIGHT_CARDS_THEME").equals("DARK_CARDS_THEME")) {
			rootView.setBackgroundColor(0xFF000000);
			nowPlayingQueueListView.setDivider(getResources().getDrawable(R.drawable.transparent_drawable));
			nowPlayingQueueListView.setDividerHeight(3);
			RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
			layoutParams.setMargins(7, 3, 7, 3);
			nowPlayingQueueListView.setLayoutParams(layoutParams);
		}
        
        //Set the Now Playing container layout's background.
        nowPlayingSongContainer.setBackgroundColor(UIElementsHelper.getNowPlayingQueueBackground(mContext));
        
        //Loop through the service's cursor and retrieve the current queue's information.
        if (sharedPreferences.getBoolean("SERVICE_RUNNING", false)==false || mApp.getService().getCurrentMediaPlayer()==null) {
        	
        	//No audio is currently playing.
        	noMusicPlaying.setVisibility(View.VISIBLE);
        	nowPlayingAlbumArt.setImageBitmap(mApp.decodeSampledBitmapFromResource(R.drawable.default_album_art, screenWidth/3, screenWidth/3));
        	nowPlayingQueueListView.setVisibility(View.GONE);
        	nowPlayingSongTitle.setVisibility(View.GONE);
        	nowPlayingSongArtist.setVisibility(View.GONE);
        	progressBar.setVisibility(View.GONE);
        	
        } else {
        	
        	//Set the current play/pause conditions.
        	try {
        		
        		//Hide the progressBar and display the controls.
        		progressBar.setVisibility(View.GONE);
        		playPauseButton.setVisibility(View.VISIBLE);
        		nextButton.setVisibility(View.VISIBLE);
        		previousButton.setVisibility(View.VISIBLE);
        		
        		if (mApp.getService().getCurrentMediaPlayer().isPlaying()) {
        			playPauseButton.setImageResource(R.drawable.pause_holo_light);
        		} else {
        			playPauseButton.setImageResource(R.drawable.play_holo_light);
        		}
        	} catch (Exception e) {
        		/* The mediaPlayer hasn't been initialized yet, so let's just keep the controls 
        		 * hidden for now. Once the mediaPlayer is initialized and it starts playing, 
        		 * updateSongInfo() will be called, and we can show the controls/hide the progressbar 
        		 * there. For now though, we'll display the progressBar.
        		 */
        		progressBar.setVisibility(View.VISIBLE);
        		playPauseButton.setVisibility(View.GONE);
        		nextButton.setVisibility(View.GONE);
        		previousButton.setVisibility(View.GONE);
        	}
        	
    		//Retrieve and set the current title/artist/artwork.
    		mCursor.moveToPosition(mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()));
    		String currentTitle = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_TITLE));
    		String currentArtist = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ARTIST));
    		
    		nowPlayingSongTitle.setText(currentTitle);
    		nowPlayingSongArtist.setText(currentArtist);
    		
    		File file = new File(mContext.getExternalCacheDir() + "/current_album_art.jpg");
    		Bitmap bm = null;
    		if (file.exists()) {
    			bm = mApp.decodeSampledBitmapFromFile(file, screenWidth, screenHeight);
    			nowPlayingAlbumArt.setScaleX(1.0f);
    			nowPlayingAlbumArt.setScaleY(1.0f);
    		} else {
    			int defaultResource = UIElementsHelper.getIcon(mContext, "default_album_art");
    			bm = mApp.decodeSampledBitmapFromResource(defaultResource, screenWidth, screenHeight);
    			nowPlayingAlbumArt.setScaleX(0.5f);
    			nowPlayingAlbumArt.setScaleY(0.5f);
    		}
    		
    		nowPlayingAlbumArt.setImageBitmap(bm);
            noMusicPlaying.setPaintFlags(noMusicPlaying.getPaintFlags() 
            							 | Paint.ANTI_ALIAS_FLAG
            							 | Paint.SUBPIXEL_TEXT_FLAG);
            
            nowPlayingSongTitle.setPaintFlags(nowPlayingSongTitle.getPaintFlags() 
    									 	  | Paint.ANTI_ALIAS_FLAG 
    									 	  | Paint.FAKE_BOLD_TEXT_FLAG
    									 	  | Paint.SUBPIXEL_TEXT_FLAG);
            
            nowPlayingSongArtist.setPaintFlags(nowPlayingSongArtist.getPaintFlags() 
    									 	   | Paint.ANTI_ALIAS_FLAG
    									 	   | Paint.SUBPIXEL_TEXT_FLAG);
            
            /* Set the adapter. We'll pass in playbackIndecesList as the adapter's data backend.
             * The array can then be manipulated (reordered, items removed, etc) with no restrictions. 
             * Each integer element in the array will be used as a pointer to a specific cursor row, 
             * so there's no need to fiddle around with the actual cursor itself. */
            nowPlayingQueueListViewAdapter = new NowPlayingQueueListViewAdapter(getActivity(), mApp.getService().getPlaybackIndecesList());
            
            nowPlayingQueueListView.setAdapter(nowPlayingQueueListViewAdapter);
    		nowPlayingQueueListView.setFastScrollEnabled(true);
    		nowPlayingQueueListView.setDropListener(onDrop);
    		nowPlayingQueueListView.setRemoveListener(onRemove);
    		SimpleFloatViewManager simpleFloatViewManager = new SimpleFloatViewManager(nowPlayingQueueListView);
    		simpleFloatViewManager.setBackgroundColor(Color.TRANSPARENT);
    		nowPlayingQueueListView.setFloatViewManager(simpleFloatViewManager);
            
    		//Scroll down to the current song.
    		nowPlayingQueueListView.setSelection(mApp.getService().getCurrentSongIndex());
    		
            nowPlayingQueueListView.setOnItemClickListener(new OnItemClickListener() {

    			@Override
    			public void onItemClick(AdapterView<?> arg0, View view, int index, long arg3) {
    				mApp.getService().skipToTrack(index);
    				
    			}
            	
            });
            
            playPauseButton.setOnClickListener(new OnClickListener() {

				@Override
				public void onClick(View arg0) {
					mApp.getService().togglePlaybackState();
				}
            	
            });
            
            nextButton.setOnClickListener(new OnClickListener() {

				@Override
				public void onClick(View v) {
					mApp.getService().skipToNextTrack();
				}
            	
            });
            
            previousButton.setOnClickListener(new OnClickListener() {

				@Override
				public void onClick(View v) {
					mApp.getService().skipToPreviousTrack();
				}
            	
            });
            
        }
        		
        return rootView;
    }
    
    private DragSortListView.DropListener onDrop = new DragSortListView.DropListener() {
    	
        @Override
        public void drop(int from, int to) {
            if (from!=to) {
                int fromItem = nowPlayingQueueListViewAdapter.getItem(from);
                int toItem = nowPlayingQueueListViewAdapter.getItem(to);
                nowPlayingQueueListViewAdapter.remove(fromItem);
                nowPlayingQueueListViewAdapter.insert(fromItem, to);
                
                //If the current song was reordered, change currentSongIndex and update the next song.
                if (from==mApp.getService().getCurrentSongIndex()) {
                	mApp.getService().setCurrentSongIndex(to);
                	
                	//Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                	mApp.getService().prepareAlternateMediaPlayer();
                	return;
                	
                } else if (from > mApp.getService().getCurrentSongIndex() && to <= mApp.getService().getCurrentSongIndex()) {
                	//One of the next songs was moved to a position before the current song. Move currentSongIndex forward by 1.
                	mApp.getService().incrementCurrentSongIndex();
                	mApp.getService().incrementEnqueueReorderScalar();
                	
                	//Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                	mApp.getService().prepareAlternateMediaPlayer();
                	return;
                	
                } else if (from < mApp.getService().getCurrentSongIndex() && to > mApp.getService().getCurrentSongIndex()) {
                	//One of the previous songs was moved to a position after the current song. Move currentSongIndex back by 1.
                	mApp.getService().decrementCurrentSongIndex();
                	mApp.getService().decrementEnqueueReorderScalar();
                	
                	//Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                	mApp.getService().prepareAlternateMediaPlayer();
                	return;
                	
                }
                
                //If the next song was reordered, reload it with the new index.
                if (mApp.getService().getPlaybackIndecesList().size() > (mApp.getService().getCurrentSongIndex()+1)) {
                    if (fromItem==mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()+1) || 
                    	toItem==mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()+1)) {
                    	
                    	//Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                    	mApp.getService().prepareAlternateMediaPlayer();
                    	
                    }
                    
                } else {
                	//Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                	mApp.getService().prepareAlternateMediaPlayer();
                	
                }

            }
            
        }
        
    };
    
    private DragSortListView.RemoveListener onRemove = new DragSortListView.RemoveListener() {
    	
        @Override
        public void remove(int which) {
        	CALLED_FROM_REMOVE = true;
        	//Stop the service if we just removed the last (and only) song.
        	if (mApp.getService().getPlaybackIndecesList().size()==1) {
        		getActivity().stopService(new Intent(getActivity(), AudioPlaybackService.class));
        		return;
        	}
        	
            //If the song that was removed is the next song, reload it.
            if (mApp.getService().getPlaybackIndecesList().size() > (mApp.getService().getCurrentSongIndex()+1)) {
                if (nowPlayingQueueListViewAdapter.getItem(which)==mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()+1)) {

                	//Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
                	mApp.getService().prepareAlternateMediaPlayer();
                	
                } else if (nowPlayingQueueListViewAdapter.getItem(which)==mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex())) {
                	mApp.getService().incrementCurrentSongIndex();
                	mApp.getService().prepareMediaPlayer(mApp.getService().getCurrentSongIndex());
                	mApp.getService().decrementCurrentSongIndex();
                } else if (nowPlayingQueueListViewAdapter.getItem(which) < mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex())) {
                	mApp.getService().decrementCurrentSongIndex();
                }
                
            } else {
            	//Check which mediaPlayer is currently playing, and prepare the other mediaPlayer.
            	mApp.getService().prepareAlternateMediaPlayer();
            	
            }
            
            //Remove the item from the adapter.
            nowPlayingQueueListViewAdapter.remove(nowPlayingQueueListViewAdapter.getItem(which));
            
        }
        
    };

    //Used by the service to update the album art when a song changes.
    public void updateSongInfo() {

    	if (mCursor!=null && (mApp.getService().getPlaybackIndecesList().size() > 0)) {
    		
    		if (CALLED_FROM_REMOVE) {
    			if ((mApp.getService().getCurrentSongIndex()-1) < mApp.getService().getPlaybackIndecesList().size() &&
    				 (mApp.getService().getCurrentSongIndex()-1) > -1) {
    				mCursor.moveToPosition(mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()-1));
    			}
    		} else {
    			if (mApp.getService().getCurrentSongIndex() < mApp.getService().getPlaybackIndecesList().size()) {
    				mCursor.moveToPosition(mApp.getService().getPlaybackIndecesList().get(mApp.getService().getCurrentSongIndex()));
    			}
    			
    		}
    		
    		//Retrieve and set the current title/artist/artwork.
    		
    		String currentTitle = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_TITLE));
    		String currentArtist = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.SONG_ARTIST));
    		
    		nowPlayingSongTitle.setText(currentTitle);
    		nowPlayingSongArtist.setText(currentArtist);    		
    		
    		File file = new File(mContext.getExternalCacheDir() + "/current_album_art.jpg");
    		Bitmap bm = null;
    		if (file.exists()) {
    			bm = mApp.decodeSampledBitmapFromFile(file, screenWidth, screenHeight);
    			nowPlayingAlbumArt.setScaleX(1.0f);
    			nowPlayingAlbumArt.setScaleY(1.0f);
    		} else {
    			int defaultResource = UIElementsHelper.getIcon(mContext, "default_album_art");
    			bm = mApp.decodeSampledBitmapFromResource(defaultResource, screenWidth, screenHeight);
    			nowPlayingAlbumArt.setScaleX(0.5f);
    			nowPlayingAlbumArt.setScaleY(0.5f);
    		}

    		nowPlayingAlbumArt.setImageBitmap(bm);
			progressBar.setVisibility(View.GONE);
			playPauseButton.setVisibility(View.VISIBLE);
			previousButton.setVisibility(View.VISIBLE);
			nextButton.setVisibility(View.VISIBLE);

    		//Set the controls.
    		if (mApp.getService().getCurrentMediaPlayer().isPlaying()) {
    			playPauseButton.setImageResource(R.drawable.pause_holo_light);
    		} else {
    			playPauseButton.setImageResource(R.drawable.play_holo_light);
    		}
    		
    	} else {
    		//The service is stopped, so reset the fragment back to its uninitialized state.
    		//nowPlayingAlbumArt.setImageBitmap(NowPlayingQueueActivity.defaultArtworkBitmap);
        	noMusicPlaying.setVisibility(View.VISIBLE);
        	nowPlayingQueueListView.setVisibility(View.GONE);
        	nowPlayingSongTitle.setVisibility(View.GONE);
        	nowPlayingSongArtist.setVisibility(View.GONE);
        	
			nowPlayingSongTitle.setText("");
			nowPlayingSongArtist.setText("");
			nowPlayingAlbumArt.setImageBitmap(mApp.decodeSampledBitmapFromResource(R.drawable.default_album_art, screenWidth, screenWidth));
			
			progressBar.setVisibility(View.GONE);
			playPauseButton.setVisibility(View.GONE);
			previousButton.setVisibility(View.GONE);
			nextButton.setVisibility(View.GONE);
			
    	}
    	
    	//Update the listview.
    	nowPlayingQueueListViewAdapter.notifyDataSetChanged();
    	
    	CALLED_FROM_REMOVE = false;
		
    }
    
    //Called every 100ms to update the progress bar/remaining time fields.
    public Runnable progressBarRunnable = new Runnable() {

		@Override
		public void run() {
			
			try {
				
				currentProgressCountDown =  (mApp.getService().getCurrentMediaPlayer().getDuration()) - (mApp.getService().getCurrentMediaPlayer().getCurrentPosition());
				currentProgress = mApp.getService().getCurrentMediaPlayer().getCurrentPosition();
				totalDuration = mApp.getService().getCurrentMediaPlayer().getDuration();
				progressFraction = (float) currentProgress/totalDuration;
				
				if (mApp.getService().getCurrentMediaPlayer()!=null) {
					mHandler.postDelayed(progressBarRunnable, 100);
				}
				
			} catch (Exception e) {
				e.printStackTrace();
			}
			
		}
    	
    };
    
    /*@Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
    	
    	if (v.getId()==R.id.playlist_flipped_list_view) {
    		
    		menu.setHeaderTitle(R.string.song_actions);
    		String[] menuItems = getResources().getStringArray(R.array.playlist_songs_context_menu_items);
    
    		for (int i=0; i < menuItems.length; i++) {
    			menu.add(9383, i, i, menuItems[i]);
    		}
    		
    	}
    	
    }
    
    @Override
    public boolean onContextItemSelected(MenuItem item) {
        
    	if (item.getGroupId()==9383) {
    		
    		AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo();
        	index = info.position;
        	childView = info.targetView;
        	
        	String filePath = songFilePathsList.get(index);
    		
    		//Convert the filePath to an absolute file path.
        	File file = new File(filePath);
        	try {
				filePath = file.getCanonicalPath().toString();
			} catch (IOException e) {
				Toast.makeText(mContext, R.string.file_could_not_be_opened, Toast.LENGTH_SHORT).show();
				return super.onContextItemSelected(item);
			}
    		
    		switch(item.getItemId()) {
        	case 0:
        		//View Song Information.
        		break;
        	case 1:
        		//Enqueue.
        		DBAccessHelper dbHelper = new DBAccessHelper(mContext);
        		
        		//Escape any rogue apostrophes.
        		if (filePath.contains("'")) {
        			filePath = filePath.replace("'", "''");
        		}
        		
        		String selection = DBAccessHelper.SONG_FILE_PATH + "=" + "'" + filePath + "'";
        		Cursor cursor = dbHelper.getReadableDatabase().query(DBAccessHelper.MUSIC_LIBRARY_TABLE, 
        															 null, 
        															 selection, 
        															 null, 
        															 null, 
        															 null, 
        															 null);	
       
        		//Check if the service is currently active.
        		if (sharedPreferences.getBoolean("SERVICE_RUNNING", false)==true && 
        			mApp.getService().getCursor()!=null && mApp.getService().getCurrentMediaPlayer()!=null) {
        			
        			//The service is running, so we can go ahead and append the new cursor to the old cursor.
        			AudioPlaybackService.enqueueCursor(cursor);
        			
        		} else {
        			//The service doesn't seem to be running. We'll explicitly stop it, just in case, and then launch NowPlayingActivity.class.
        			Intent serviceIntent = new Intent(mContext, AudioPlaybackService.class);
        			mContext.stopService(serviceIntent);
        			
        			Intent intent = new Intent(mContext, NowPlayingActivity.class);
        			
        			//Get the parameters for the first song.
        			if (cursor.getCount() > 0) {
        				cursor.moveToFirst();
        				
            			intent.putExtra("SELECTED_SONG_DURATION", cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_DURATION)));
        				intent.putExtra("SELECTED_SONG_TITLE", cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_DURATION)));
        				intent.putExtra("SELECTED_SONG_ARTIST", cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ARTIST)));
        				intent.putExtra("SELECTED_SONG_ALBUM", cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ALBUM)));
        				intent.putExtra("SONG_SELECTED_INDEX", 0);
        				intent.putExtra("SELECTED_SONG_DATA_URI", cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH)));
        				intent.putExtra("SELECTED_SONG_GENRE", cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_GENRE)));
        				intent.putExtra("NEW_PLAYLIST", true);
        				intent.putExtra("NUMBER_SONGS", cursor.getCount());
        				intent.putExtra("CALLED_FROM_FOOTER", false);
        				intent.putExtra("PLAY_ALL", "");
        				intent.putExtra("CALLING_FRAGMENT", "ARTISTS_FLIPPED_FRAGMENT");
            			
        			}
        			
        			startActivity(intent);
    				getActivity().overridePendingTransition(R.anim.slide_in_from_right, R.anim.slide_out_to_left);
    				
    				cursor.close();
    				dbHelper.close();
        			
        		}
        		
        		//Unescape any rogue apostrophes.
        		if (filePath.contains("''")) {
        			filePath = filePath.replace("''", "'");
        		}
        		
        		int numberOfSongs = cursor.getCount();
        		String toastMessage = "";
        		if (numberOfSongs==1) {
        			toastMessage = numberOfSongs + " " + getResources().getString(R.string.song_enqueued_toast);
        		} else {
        			toastMessage = numberOfSongs + " " + getResources().getString(R.string.songs_enqueued_toast);
        		}
        		
        		Toast.makeText(mContext, toastMessage, Toast.LENGTH_SHORT).show();
        		
        		break;
        	case 2:
        		//Remove from playlist.
        		break;
        	
    		}
    		
    	}

        return super.onContextItemSelected(item);
    }*/
    
    @Override
    public void onPause() {
    	super.onPause();
    	
    	if (mHandler!=null) {
        	mHandler.removeCallbacks(progressBarRunnable);
        	mHandler = null;
    	}
    	
    	if (this.isRemoving()) {
    		if (mCursor!=null) {
    			mCursor.close();
    			mCursor = null;
    		}
    		
    	}
    	
    	nowPlayingQueueFragment = null;
    	sharedPreferences.edit().putBoolean("NOW_PLAYING_QUEUE_VISIBLE", false).commit();
    	
    }
    
    @Override
    public void onDestroy() {
    	super.onDestroy();
    	
    	if (mHandler!=null) {
        	mHandler.removeCallbacks(progressBarRunnable);
        	mHandler = null;
    	}

    	nowPlayingQueueFragment = null;
    	sharedPreferences.edit().putBoolean("NOW_PLAYING_QUEUE_VISIBLE", false).commit();
    	
    }
    
	@Override
	public void onStart() {
	    super.onStart();
	    LocalBroadcastManager.getInstance(mContext)
	    					 .registerReceiver((receiver), new IntentFilter(Common.UPDATE_UI_BROADCAST));
	
	}

	@Override
	public void onStop() {
	    LocalBroadcastManager.getInstance(mContext).unregisterReceiver(receiver);
	    super.onStop();
	    
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.NowPlayingQueueActivity;

import java.util.ArrayList;

import android.content.Context;
import android.content.SharedPreferences;
import android.graphics.Paint;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Utils.Common;

public class NowPlayingQueueListViewAdapter extends ArrayAdapter<Integer> {

	private Context mContext;
	private Common mApp;
	private SharedPreferences sharedPreferences;
	private ArrayList<Integer> mPlaybackIndecesList;
	private String mCurrentTheme;
   
    public NowPlayingQueueListViewAdapter(Context context, ArrayList<Integer> playbackIndecesList) {
    	
    	super(context, R.id.playlists_flipped_song, playbackIndecesList);
    	
    	mContext = context;
    	mApp = (Common) mContext.getApplicationContext();
    	sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    	mPlaybackIndecesList = playbackIndecesList;
    	mCurrentTheme = sharedPreferences.getString(Common.CURRENT_THEME, "LIGHT_CARDS_THEME");
    	
    }
    
    public View getView(final int position, View convertView, ViewGroup parent){
    	
    	NowPlayingQueueListViewHolder holder = null;
		if (convertView == null) {
			convertView = LayoutInflater.from(mContext).inflate(R.layout.playlist_flipped_listview_layout, parent, false);
			holder = new NowPlayingQueueListViewHolder();
			holder.songTitleText = (TextView) convertView.findViewById(R.id.playlists_flipped_song);
			holder.artistText = (TextView) convertView.findViewById(R.id.playlists_flipped_artist);
			holder.removeSong = (ImageView) convertView.findViewById(R.id.remove_song_from_queue);
			
			holder.songTitleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
			holder.songTitleText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Light"));
			holder.songTitleText.setPaintFlags(holder.songTitleText.getPaintFlags()
											   | Paint.ANTI_ALIAS_FLAG
											   | Paint.SUBPIXEL_TEXT_FLAG);		
			
			holder.artistText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
			holder.artistText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Regular"));
			holder.artistText.setPaintFlags(holder.artistText.getPaintFlags()
											| Paint.ANTI_ALIAS_FLAG
											| Paint.SUBPIXEL_TEXT_FLAG);
			
			convertView.setTag(holder);
		} else {
		    holder = (NowPlayingQueueListViewHolder) convertView.getTag();
		}
		
		//Move the local cursor to the correct position.
		mApp.getService().getCursor().moveToPosition(mPlaybackIndecesList.get(position));
		
		//Get the song's parameters.
		String songTitle;
		String songFilePath;
		String songArtist;
		try {
			songTitle = mApp.getService().getCursor().getString(mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_TITLE));
			songFilePath = mApp.getService().getCursor().getString(mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_FILE_PATH));
			songArtist = mApp.getService().getCursor().getString(mApp.getService().getCursor().getColumnIndex(DBAccessHelper.SONG_ARTIST));
		} catch (Exception e) {
			/* If an exception is raised, the user is probably playing from the folders and the cursor hasn't been completely built yet.
			 * Just use temporary placeholders for now and the ListView will automatically refresh itself once the cursor is fully built. */
			songTitle = "Loading...";
			songFilePath = "";
			songArtist = "";
		}
		
		//Set the view tags.
		convertView.setTag(R.string.title, songTitle);
		convertView.setTag(R.string.song_file_path, songFilePath);
		convertView.setTag(R.string.artist, songArtist);
		
		holder.songTitleText.setText(songTitle);
		holder.artistText.setText(songArtist);
		
		//Apply the card layout's background based on the color theme.
		if (position==mApp.getService().getCurrentSongIndex()) {
			int[] colors = UIElementsHelper.getQuickScrollColors(mContext);
			convertView.setBackgroundColor(colors[0]);
			holder.songTitleText.setTextColor(colors[2]);
			holder.artistText.setTextColor(colors[2]);
			holder.removeSong.setImageResource(R.drawable.cross_light);
			
		} else if (mCurrentTheme.equals("LIGHT_CARDS_THEME") ||
				   mCurrentTheme.equals("LIGHT_THEME")) {
			convertView.setBackgroundColor(0xFFFFFFFF);
			holder.songTitleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
			holder.artistText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
			holder.removeSong.setImageResource(R.drawable.cross);
			
		} else if (mCurrentTheme.equals("DARK_CARDS_THEME") ||
				   mCurrentTheme.equals("DARK_THEME")) {
			convertView.setBackgroundColor(0xFF191919);
			holder.songTitleText.setTextColor(UIElementsHelper.getThemeBasedTextColor(mContext));
			holder.artistText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));
			holder.removeSong.setImageResource(R.drawable.cross_light);
			
		}
		
		return convertView;

	}
    
	class NowPlayingQueueListViewHolder {
	    public TextView songTitleText;
	    public TextView artistText;
	    public ImageView removeSong;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaybackKickstarter;

import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.os.AsyncTask;
import android.os.Bundle;
import android.provider.MediaStore;
import android.util.Log;
import android.widget.Toast;

import com.jams.music.player.DBHelpers.MediaStoreAccessHelper;
import com.jams.music.player.R;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity.NowPlayingActivityListener;
import com.jams.music.player.Services.AudioPlaybackService;
import com.jams.music.player.Services.AudioPlaybackService.PrepareServiceListener;
import com.jams.music.player.Utils.Common;

/**
 * Initiates the playback sequence and 
 * starts AudioPlaybackService.
 * 
 * @author Saravan Pantham
 */
public class PlaybackKickstarter implements NowPlayingActivityListener, PrepareServiceListener {

	private Context mContext;
	private Common mApp;
	
	private String mQuerySelection;
	private int mPlaybackRouteId;
	private int mCurrentSongIndex;
    private boolean mPlayAll;

    public PlaybackKickstarter(Context context) {
        mContext = context;
    }

	private BuildCursorListener mBuildCursorListener;
	
	/**
	 * Public interface that provides access to 
	 * major events during the cursor building 
	 * process.
	 * 
	 * @author Saravan Pantham
	 */
	public interface BuildCursorListener {
		
		/**
		 * Called when the service cursor has been prepared successfully.
		 */
		public void onServiceCursorReady(Cursor cursor, int currentSongIndex, boolean playAll);
		
		/**
		 * Called when the service cursor failed to be built. 
		 * Also returns the failure reason via the exception's
         * message parameter.
		 */
		public void onServiceCursorFailed(String exceptionMessage);

        /**
         * Called when/if the service is already running and
         * should update its cursor. The service's cursor may
         * need to be updated if the user tapped on "Save
         * current position", etc.
         */
        public void onServiceCursorUpdated(Cursor cursor);
	
	}
	
	/**
	 * Helper method that calls all the required method(s) 
	 * that initialize music playback. This method should 
	 * always be called when the cursor for the service 
	 * needs to be changed.
	 */
	public void initPlayback(Context context, 
						     String querySelection,
							 int playbackRouteId,
							 int currentSongIndex,
							 boolean showNowPlayingActivity,
                             boolean playAll) {

		mApp = (Common) mContext.getApplicationContext();
		mQuerySelection = querySelection;
		mPlaybackRouteId = playbackRouteId;
		mCurrentSongIndex = currentSongIndex;
        mPlayAll = playAll;
		
		if (showNowPlayingActivity) {
			//Launch NowPlayingActivity.
			Intent intent = new Intent(mContext, NowPlayingActivity.class);
			intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
			intent.putExtra(NowPlayingActivity.START_SERVICE, true);
			mContext.startActivity(intent);
			
		} else {
			//Start the playback service if it isn't running.
			if (!mApp.isServiceRunning()) {
				startService();
			} else {
				//Call the callback method that will start building the new cursor.
				mApp.getService()
					.getPrepareServiceListener()
					.onServiceRunning(mApp.getService());
			}
			
		}
		
	}
	
	/**
	 * Starts AudioPlaybackService. Once the service is running, we get a
	 * callback to onServiceRunning() (see below). That's where the method to 
	 * build the cursor is called.
	 */
	private void startService() {
		Intent intent = new Intent(mContext, AudioPlaybackService.class);
		mContext.startService(intent);
	}

    /**
     * Requeries the database to update the current
     * service cursor.
     */
    public void updateServiceCursor() {
        new AsyncBuildCursorTask(true).execute();

    }

	/**
	 * Builds the cursor that will be used for playback. Once the cursor 
	 * is built, AudioPlaybackService receives a callback via
	 * onServiceCursorReady() (see below). The service then takes over 
	 * the rest of the process.
	 */
	class AsyncBuildCursorTask extends AsyncTask<Boolean, String, Cursor> {

        private boolean mIsUpdating = false;

        public AsyncBuildCursorTask(boolean isUpdating) {
            mIsUpdating = isUpdating;
        }

		@Override
		protected Cursor doInBackground(Boolean... params) {

            if (mPlaybackRouteId==Common.PLAY_ALL_IN_FOLDER)
                //Return a cursor directly from MediaStore.
                return MediaStoreAccessHelper.getAllSongsWithSelection(mContext,
                                                                       mQuerySelection,
                                                                       null,
                                                                       MediaStore.Audio.Media.DATA + " ASC");

            else
                return mApp.getDBAccessHelper().getPlaybackCursor(mContext, mQuerySelection, mPlaybackRouteId);

			
		}

        @Override
        public void onProgressUpdate(String... params) {
            getBuildCursorListener().onServiceCursorFailed(params[0]);
        }
		
		@Override
		public void onPostExecute(Cursor cursor) {
			super.onPostExecute(cursor);
			if (cursor!=null) {
                if (!mIsUpdating)
                    getBuildCursorListener().onServiceCursorReady(cursor, mCurrentSongIndex, mPlayAll);
                else
                    getBuildCursorListener().onServiceCursorUpdated(cursor);

            } else {
                getBuildCursorListener().onServiceCursorFailed("Playback cursor null.");
            }

		}
		
	}

	@Override
	public void onServiceRunning(AudioPlaybackService service) {
		//Build the cursor and pass it on to the service.
		mApp = (Common) mContext.getApplicationContext();
		mApp.setIsServiceRunning(true);
		mApp.setService(service);
		mApp.getService().setPrepareServiceListener(this);
		mApp.getService().setCurrentSongIndex(mCurrentSongIndex);
		new AsyncBuildCursorTask(false).execute();
		
	}

	@Override
	public void onServiceFailed(Exception exception) {
		//Can't move forward from this point.
		exception.printStackTrace();
		Toast.makeText(mContext, R.string.unable_to_start_playback, Toast.LENGTH_SHORT).show();
		
	}

	@Override
	public void onNowPlayingActivityReady() {
		//Start the playback service if it isn't running.
		if (!mApp.isServiceRunning()) {
			startService();
		} else {
			//Call the callback method that will start building the new cursor.
			mApp.getService()
				.getPrepareServiceListener()
				.onServiceRunning(mApp.getService());
		}
		
	}

    public BuildCursorListener getBuildCursorListener() {
        return mBuildCursorListener;
    }

    public void setBuildCursorListener(BuildCursorListener listener) {
        mBuildCursorListener = listener;
    }

    public String getPreviousQuerySelection() {
        return mQuerySelection;
    }

    public int getPreviousPlaybackRouteId() {
        return mPlaybackRouteId;
    }

    public int getPreviousCurrentSongIndex() {
        return mCurrentSongIndex;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistEditorActivity;

import android.app.Fragment;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.ListView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.PlaylistEditorActivity.PlaylistEditorAlbumsMultiselectAdapter.AsyncGetAlbumSongIds;
import com.jams.music.player.Utils.Common;

public class AlbumsPickerFragment extends Fragment {
	
	private Context mContext;
	private Common mApp;
	public static Cursor cursor;
	public static ListView listView;
	
	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		mContext = getActivity().getApplicationContext();
		mApp = (Common) getActivity().getApplicationContext();
		View rootView = inflater.inflate(R.layout.fragment_albums_music_library_editor, null);

		cursor = mApp.getDBAccessHelper().getAllUniqueAlbums("");
		listView = (ListView) rootView.findViewById(R.id.musicLibraryEditorAlbumsListView);
		listView.setFastScrollEnabled(true);
		listView.setAdapter(new PlaylistEditorAlbumsMultiselectAdapter(getActivity(), cursor));
		
		listView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> arg0, View view, int which, long dbID) {
				CheckBox checkbox = (CheckBox) view.findViewById(R.id.albumCheckboxMusicLibraryEditor);
				checkbox.performClick();
				
				/* Since we've performed a software-click (checkbox.performClick()), all we have 
				 * to do now is determine the *new* state of the checkbox. If the checkbox is checked, 
				 * that means that the user tapped on it when it was unchecked, and we should add 
				 * the album's songs to the HashSet. If the checkbox is unchecked, that means the user 
				 * tapped on it when it was checked, so we should remove the album's songs from the 
				 * HashSet.
				 */
				if (checkbox.isChecked()) {
					view.setBackgroundColor(0xCC0099CC);
					AsyncGetAlbumSongIds task = new AsyncGetAlbumSongIds(mContext,
																		 (String) view.getTag(R.string.album),
																		 (String) view.getTag(R.string.artist));
					task.execute(new String[] {"ADD"});
				} else {
					view.setBackgroundColor(0x00000000);
					AsyncGetAlbumSongIds task = new AsyncGetAlbumSongIds(mContext, 
																		 (String) view.getTag(R.string.album),
																		 (String) view.getTag(R.string.artist));
					task.execute(new String[] {"REMOVE"});
				}
				
			}
			
		});
		
		TextView instructions = (TextView) rootView.findViewById(R.id.albums_music_library_editor_instructions);
		instructions.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		instructions.setPaintFlags(instructions.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		return rootView;
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistEditorActivity;

import android.app.Fragment;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.ListView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.PlaylistEditorActivity.PlaylistEditorArtistsMultiselectAdapter.AsyncGetArtistSongIds;
import com.jams.music.player.Utils.Common;

public class ArtistsPickerFragment extends Fragment {
	
	private Context mContext;
	private Common mApp;
	public static Cursor cursor;
	public static ListView listView;
	private TextView instructions;
	
	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		mContext = getActivity().getApplicationContext();
		mApp = (Common) getActivity().getApplicationContext();
		View rootView = inflater.inflate(R.layout.fragment_artists_music_library_editor, null);

		cursor = mApp.getDBAccessHelper().getAllUniqueArtists("");
		listView = (ListView) rootView.findViewById(R.id.musicLibraryEditorArtistsListView);
		listView.setFastScrollEnabled(true);
		listView.setAdapter(new PlaylistEditorArtistsMultiselectAdapter(getActivity(), cursor));
		
		listView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> arg0, View view, int which, long dbID) {
				CheckBox checkbox = (CheckBox) view.findViewById(R.id.artistCheckboxMusicLibraryEditor);
				checkbox.performClick();
				
				/* Since we've performed a software-click (checkbox.performClick()), all we have 
				 * to do now is determine the *new* state of the checkbox. If the checkbox is checked, 
				 * that means that the user tapped on it when it was unchecked, and we should add 
				 * the artist's songs to the HashSet. If the checkbox is unchecked, that means the user 
				 * tapped on it when it was checked, so we should remove the artist's songs from the 
				 * HashSet.
				 */
				if (checkbox.isChecked()) {
					view.setBackgroundColor(0xCC0099CC);
					AsyncGetArtistSongIds task = new AsyncGetArtistSongIds(mContext, (String) view.getTag(R.string.artist));
					task.execute(new String[] {"ADD"});
				} else {
					view.setBackgroundColor(0x00000000);
					AsyncGetArtistSongIds task = new AsyncGetArtistSongIds(mContext, (String) view.getTag(R.string.artist));
					task.execute(new String[] {"REMOVE"});
				}
				
			}
			
		});
		
		instructions = (TextView) rootView.findViewById(R.id.artists_music_library_editor_instructions);
		instructions.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		instructions.setPaintFlags(instructions.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		return rootView;
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistEditorActivity;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Paint;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;

public class EditDeleteMusicLibraryAdapter extends SimpleCursorAdapter {
	
	private Context mContext;
	private SharedPreferences sharedPreferences;
    private LibrariesListViewHolder holder = null;
	
    public EditDeleteMusicLibraryAdapter(Context context, Cursor cursor) {
        super(context, -1, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    }

    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        Cursor c = (Cursor) getItem(position);

		if (convertView == null) {
			convertView = LayoutInflater.from(mContext).inflate(R.layout.sliding_menu_list_layout, parent, false);
			holder = new LibrariesListViewHolder();
			holder.tagColor = (ImageView) convertView.findViewById(R.id.sliding_menu_libraries_icon);
			holder.title = (TextView) convertView.findViewById(R.id.sliding_menu_list_item);
            holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			convertView.setTag(holder);
		} else {
		    holder = (LibrariesListViewHolder) convertView.getTag();
		}
		
		//Retrieve the library's parameters.
		String libraryName = c.getString(c.getColumnIndex(DBAccessHelper.LIBRARY_NAME));
		String libraryColorCode = c.getString(c.getColumnIndex(DBAccessHelper.LIBRARY_TAG));
		
		//Construct the library color tag drawable from the given color code string.
		int colorCodeDrawableID = mContext.getResources().getIdentifier(libraryColorCode, "drawable", mContext.getPackageName());
		
		//Set the tag for this child view. The key is required to be an application-defined key.
		convertView.setTag(R.string.library_name, libraryName);
		convertView.setTag(R.string.library_color_code, libraryColorCode);
		
		//Set the library name.
		holder.title.setText(libraryName);
		holder.tagColor.setImageResource(colorCodeDrawableID);
        
		return convertView;
	}

	static class LibrariesListViewHolder {
	    public ImageView tagColor;
	    public TextView title;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistEditorActivity;

import java.util.ArrayList;

import android.content.Context;
import android.graphics.Paint;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;

public class LibraryLabelsAdapter extends ArrayAdapter<String> {

	private Context mContext;
	private ArrayList<String> mColorsList;
   
    public LibraryLabelsAdapter(Context context, ArrayList<String> colorsList) {
    	super(context, R.id.playlists_flipped_song, colorsList);
    	mContext = context;
    	mColorsList = colorsList;

    }
    
    public View getView(final int position, View convertView, ViewGroup parent){
    	
    	SongsListViewHolder holder = null;
		if (convertView == null) {	
			convertView = LayoutInflater.from(mContext).inflate(R.layout.sliding_menu_list_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.title = (TextView) convertView.findViewById(R.id.sliding_menu_list_item);
			holder.image = (ImageView) convertView.findViewById(R.id.sliding_menu_libraries_icon);
			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}

		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.title.setPaintFlags(holder.title.getPaintFlags()
										 | Paint.ANTI_ALIAS_FLAG
										 | Paint.SUBPIXEL_TEXT_FLAG);		
		
		holder.title.setText(mColorsList.get(position));

		//Set the icon.
		switch(position) {
		case 0:
			holder.image.setImageResource(R.drawable.circle_blue_dark);
			break;
		case 1:
			holder.image.setImageResource(R.drawable.circle_blue_light);
			break;
		case 2:
			holder.image.setImageResource(R.drawable.circle_green_dark);
			break;
		case 3:
			holder.image.setImageResource(R.drawable.circle_green_light);
			break;
		case 4:
			holder.image.setImageResource(R.drawable.circle_purple_dark);
			break;
		case 5:
			holder.image.setImageResource(R.drawable.circle_purple_light);
			break;
		case 6:
			holder.image.setImageResource(R.drawable.circle_red_dark);
			break;
		case 7:
			holder.image.setImageResource(R.drawable.circle_red_light);
			break;
		case 8:
			holder.image.setImageResource(R.drawable.circle_yellow_dark);
			break;
		case 9:
			holder.image.setImageResource(R.drawable.circle_yellow_light);
			break;
		}
		
		return convertView;

	}
    
	static class SongsListViewHolder {
	    public TextView title;
	    public ImageView image;
	}
   
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistEditorActivity;

import java.util.HashSet;

import android.app.ActionBar;
import android.app.ActionBar.Tab;
import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.text.Spannable;
import android.text.SpannableString;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;

import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.Utils.TypefaceSpan;
import com.nostra13.universalimageloader.core.DisplayImageOptions;
import com.nostra13.universalimageloader.core.assist.ImageScaleType;
import com.nostra13.universalimageloader.core.display.FadeInBitmapDisplayer;

public class PlaylistEditorActivity extends FragmentActivity {
	
	private Context mContext;
	private Common mApp;
	private SharedPreferences sharedPreferences;
	private String libraryName;
	private String libraryIconName;
	public static String currentTab = "Artists";
	public static DisplayImageOptions displayImageOptions;
	public static HashSet<String> songDBIdsList = new HashSet<String>();

	@Override
	public void onCreate(Bundle savedInstanceState) {
		
		//Initialize Context and SharedPreferences.
		mContext = this;
		mApp = (Common) this.getApplicationContext();
		sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		
    	//Set the UI theme.
    	if (mApp.getCurrentTheme()==Common.DARK_THEME) {
    		setTheme(R.style.AppTheme);
    	} else {
    		setTheme(R.style.AppThemeLight);
    	}
		super.onCreate(savedInstanceState);

		//Create a set of options to optimize the bitmap memory usage.
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        options.inJustDecodeBounds = false;
        options.inPurgeable = true;
        
        //Display Image Options.
        displayImageOptions = new DisplayImageOptions.Builder()
        						  .showImageForEmptyUri(R.drawable.default_album_art)
        						  .showImageOnFail(R.drawable.default_album_art)
        						  .showStubImage(R.drawable.transparent_drawable)
        						  .cacheInMemory(false)
        						  .cacheOnDisc(true)
        						  .decodingOptions(options)
        						  .imageScaleType(ImageScaleType.EXACTLY)
        						  .bitmapConfig(Bitmap.Config.RGB_565)
        						  .displayer(new FadeInBitmapDisplayer(400))
        						  .delayBeforeLoading(100)
        						  .build();
		
		//Attach tabs to the ActionBar.
		ActionBar actionBar = getActionBar();
		actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);

		//Add the artists tab.
		String artistsLabel = getResources().getString(R.string.artists);
		Tab tab = actionBar.newTab();
		tab.setText(artistsLabel);
		TabListener<ArtistsPickerFragment> artistsTabListener = new TabListener<ArtistsPickerFragment>(this, 
																					   				   artistsLabel, 
																					   				   ArtistsPickerFragment.class);
		
		tab.setTabListener(artistsTabListener);
		actionBar.addTab(tab);

		//Add the albums tab.
		String albumsLabel = getResources().getString(R.string.albums);
		tab = actionBar.newTab();
		tab.setText(albumsLabel);
		TabListener<AlbumsPickerFragment> albumsTabListener = new TabListener<AlbumsPickerFragment>(this,
																					  				albumsLabel, 
																					  				AlbumsPickerFragment.class);
		
		tab.setTabListener(albumsTabListener);
		actionBar.addTab(tab);
		
		//Add the songs tab.
		String songsLabel = getResources().getString(R.string.songs);
		tab = actionBar.newTab();
		tab.setText(songsLabel);
		TabListener<SongsPickerFragment> songsTabListener = new TabListener<SongsPickerFragment>(this,
																								 songsLabel, 
																								 SongsPickerFragment.class);
		
		tab.setTabListener(songsTabListener);
		actionBar.addTab(tab);
		
	}
	
	private class TabListener<T extends android.app.Fragment> implements ActionBar.TabListener {
		private android.app.Fragment mFragment;
		private final Activity mActivity;
		private final String mTag;
		private final Class<T> mClass;

		public TabListener(Activity activity, String tag, Class<T> clz) {
			mActivity = activity;
			mTag = tag;
			mClass = clz;
		}

		@Override
		public void onTabReselected(Tab arg0, android.app.FragmentTransaction arg1) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onTabSelected(Tab tab, android.app.FragmentTransaction ft) {
			
			currentTab = (String) tab.getText();
			//Check if the fragment is already initialized
			if (mFragment==null) {
				//If not, instantiate and add it to the activity
				mFragment = android.app.Fragment.instantiate(mActivity, mClass.getName());
				ft.replace(android.R.id.content, mFragment, mTag);
			} else {
				//If it exists, simply attach it in order to show it
				ft.attach(mFragment);
			}
			
		}

		@Override
		public void onTabUnselected(Tab arg0, android.app.FragmentTransaction ft) {
			if (mFragment!=null) {
				ft.detach(mFragment);
			}
			
		}
	
	}
	
	public void createPlaylist() {
		
	}
	
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		MenuInflater inflater = getMenuInflater();
	    inflater.inflate(R.menu.add_to_music_library, menu);
	    
	    ActionBar actionBar = getActionBar();
		SpannableString s = new SpannableString(getResources().getString(R.string.create_playlist));
	    s.setSpan(new TypefaceSpan(this, "RobotoCondensed-Light"), 0, s.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
	    actionBar.setTitle(s);
	    
		return super.onCreateOptionsMenu(menu);
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
	    case R.id.select_all_music_library_editor:
	        /* DB IDs are sequential, so to save CPU cycles, 
	         * we'll just get the size of the DB (the number of 
	         * rows) and add that many entries to the HashSet.
	         */
	    	int songCount = mApp.getDBAccessHelper().getAllSongs().getCount();
	    	for (int i=0; i < songCount+1; i++) {
	    		songDBIdsList.add("" + i);
	    	}
	    	
	    	//Refresh the current fragment's listview.
	    	if (ArtistsPickerFragment.listView!=null) {
	    		ArtistsPickerFragment.listView.setAdapter(null);
	    		ArtistsPickerFragment.listView.setAdapter(new PlaylistEditorArtistsMultiselectAdapter(this, 
	    																								  ArtistsPickerFragment.cursor));
	    		ArtistsPickerFragment.listView.invalidate();
	    	}
	    	
	    	if (AlbumsPickerFragment.listView!=null) {
	    		AlbumsPickerFragment.listView.setAdapter(null);
	    		AlbumsPickerFragment.listView.setAdapter(new PlaylistEditorAlbumsMultiselectAdapter(this, 
	    																								  AlbumsPickerFragment.cursor));
	    		AlbumsPickerFragment.listView.invalidate();
	    	}
	    	
	    	if (SongsPickerFragment.listView!=null) {
	    		SongsPickerFragment.listView.setAdapter(null);
	    		SongsPickerFragment.listView.setAdapter(new PlaylistEditorSongsMultiselectAdapter(this, 
	    																								  SongsPickerFragment.cursor));
	    		SongsPickerFragment.listView.invalidate();
	    	}
	    	
	        return true;
	    case R.id.done_music_library_editor:
	    	createPlaylist();
	    	return true;
	    default:
	        return super.onOptionsItemSelected(item);
	    }

	}
	
	@Override
	public void onPause() {
		super.onPause();
		songDBIdsList.clear();
		
		if (isFinishing()) {
			if (SongsPickerFragment.cursor!=null) {
				SongsPickerFragment.cursor.close();
				SongsPickerFragment.cursor = null;
			}
			
			if (AlbumsPickerFragment.cursor!=null) {
				AlbumsPickerFragment.cursor.close();
				AlbumsPickerFragment.cursor = null;
			}
			
			if (ArtistsPickerFragment.cursor!=null) {
				ArtistsPickerFragment.cursor.close();
				ArtistsPickerFragment.cursor = null;
			}
			
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistEditorActivity;

import android.content.Context;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.AsyncTask;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class PlaylistEditorAlbumsMultiselectAdapter extends SimpleCursorAdapter {
	
	private Context mContext;
	private Common mApp;
	
    public PlaylistEditorAlbumsMultiselectAdapter(Context context, Cursor cursor) {
        super(context, -1, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        mApp = (Common) mContext.getApplicationContext();
    }

    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        final Cursor c = (Cursor) getItem(position);
	    SongsListViewHolder holder = null;

		if (convertView == null) {
			
			convertView = LayoutInflater.from(mContext).inflate(R.layout.music_library_editor_albums_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.image = (ImageView) convertView.findViewById(R.id.albumThumbnailMusicLibraryEditor);
			holder.title = (TextView) convertView.findViewById(R.id.albumNameMusicLibraryEditor);
			holder.checkBox = (CheckBox) convertView.findViewById(R.id.albumCheckboxMusicLibraryEditor);
			holder.subText = (TextView) convertView.findViewById(R.id.albumArtistNameMusicLibraryEditor);

			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}
		
		final View finalConvertView = convertView;
		final String songId = c.getString(c.getColumnIndex(DBAccessHelper._ID));
		final String songArtist = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ARTIST));
		final String songAlbum = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM));
		final String songAlbumArtPath = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH));
		
		//Set the album's name and artist as the row's tag.
		convertView.setTag(R.string.album, songAlbum);
		convertView.setTag(R.string.artist, songArtist);
		
		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.title.setPaintFlags(holder.title.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		holder.subText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.subText.setPaintFlags(holder.subText.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		//Set the song title.
		holder.title.setText(songAlbum);
		holder.subText.setText(songArtist);
        mApp.getImageLoader().displayImage(songAlbumArtPath, holder.image, PlaylistEditorActivity.displayImageOptions);

        //Check if the song's DB ID exists in the HashSet and set the appropriate checkbox status.
        if (PlaylistEditorActivity.songDBIdsList.contains(songId)) {
        	holder.checkBox.setChecked(true);
        	convertView.setBackgroundColor(0xCC0099CC);
        } else {
        	convertView.setBackgroundColor(0x00000000);
        	holder.checkBox.setChecked(false);
        }
        
        holder.checkBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean isChecked) {
				
				if (isChecked==true) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0xCC0099CC);
						AsyncGetAlbumSongIds task = new AsyncGetAlbumSongIds(mContext, songAlbum, songArtist);
						task.execute(new String[] {"ADD"});
					}
					
				} else if (isChecked==false) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0x00000000);
						AsyncGetAlbumSongIds task = new AsyncGetAlbumSongIds(mContext, songAlbum, songArtist);
						task.execute(new String[] {"REMOVE"});
						
					}

				}
				
			}
			
        });
 
		return convertView;
	}
    
	static class SongsListViewHolder {
	    public ImageView image;
	    public TextView title;
	    public TextView subText;
	    public CheckBox checkBox;
	}
	
	/***************************************************************
	 * This AsyncTask goes through a specified album and retrieves 
	 * every song in the album and its ID. It then inserts the ID(s) 
	 * into a HashSet.
	 ***************************************************************/
	static class AsyncGetAlbumSongIds extends AsyncTask<String, String, String> {

		private Common mApp;
		private String mAlbumName;
		private String mArtistName;
		
		public AsyncGetAlbumSongIds(Context context, String albumName, String artistName) {
			mApp = (Common) context.getApplicationContext();
			mAlbumName = albumName;
			mArtistName = artistName;
		}
		
		@Override
		protected String doInBackground(String... params) {
			//Check if the user is adding or removing an album from the list.
			String operation = params[0];
			if (operation.equals("ADD")) {
				addAlbumToLibrary();
			} else {
				removeAlbumFromLibrary();
			}
			
			return null;
		}
		
		public void addAlbumToLibrary() {
			
			Cursor cursor = mApp.getDBAccessHelper().getAllSongsInAlbum(mAlbumName, mArtistName);
			if (cursor!=null && cursor.getCount() > 0) {

				for (int i=0; i < cursor.getCount(); i++) {
					cursor.moveToPosition(i);
					PlaylistEditorActivity.songDBIdsList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID)));
				}
				cursor.close();
				cursor = null;
				
			}
			
		}
		
		public void removeAlbumFromLibrary() {
			
			Cursor cursor = mApp.getDBAccessHelper().getAllSongsInAlbum(mAlbumName, mArtistName);
			if (cursor!=null && cursor.getCount() > 0) {

				for (int i=0; i < cursor.getCount(); i++) {
					cursor.moveToPosition(i);
					PlaylistEditorActivity.songDBIdsList.remove(cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID)));
				}
				cursor.close();
				cursor = null;
				
			}
			
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistEditorActivity;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.AsyncTask;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class PlaylistEditorArtistsMultiselectAdapter extends SimpleCursorAdapter {
	
	private Context mContext;
	private SharedPreferences sharedPreferences;
	private Common mApp;
	
    public PlaylistEditorArtistsMultiselectAdapter(Context context, Cursor cursor) {
        super(context, -1, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
        mApp = (Common) mContext.getApplicationContext();
    }

    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        final Cursor c = (Cursor) getItem(position);
	    SongsListViewHolder holder = null;

		if (convertView == null) {
			
			convertView = LayoutInflater.from(mContext).inflate(R.layout.music_library_editor_artists_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.image = (ImageView) convertView.findViewById(R.id.artistThumbnailMusicLibraryEditor);
			holder.title = (TextView) convertView.findViewById(R.id.artistNameMusicLibraryEditor);
			holder.checkBox = (CheckBox) convertView.findViewById(R.id.artistCheckboxMusicLibraryEditor);

			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}
		
		final View finalConvertView = convertView;
		final String songId = c.getString(c.getColumnIndex(DBAccessHelper._ID));
		final String songArtist = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ARTIST));
		String songAlbumArtPath = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH));
		
		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.title.setPaintFlags(holder.title.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		//Set the song title.
		holder.title.setText(songArtist);
        mApp.getImageLoader().displayImage(songAlbumArtPath, holder.image, PlaylistEditorActivity.displayImageOptions);

        //Check if the song's DB ID exists in the HashSet and set the appropriate checkbox status.
        if (PlaylistEditorActivity.songDBIdsList.contains(songId)) {
        	holder.checkBox.setChecked(true);
        	convertView.setBackgroundColor(0xCC0099CC);
        } else {
        	holder.checkBox.setChecked(false);
        	convertView.setBackgroundColor(0x00000000);
        }
        
        //Set a tag to the row that will attach the artist's name to it.
        convertView.setTag(R.string.artist, songArtist);
        
        holder.checkBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean isChecked) {
				
				if (isChecked==true) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0xCC0099CC);
						AsyncGetArtistSongIds task = new AsyncGetArtistSongIds(mContext, songArtist);
						task.execute(new String[] {"ADD"});
					}
					
				} else if (isChecked==false) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0x00000000);
						AsyncGetArtistSongIds task = new AsyncGetArtistSongIds(mContext, songArtist);
						task.execute(new String[] {"REMOVE"});
						
					}

				}
				
			}
			
        });
 
		return convertView;
	}
    
	static class SongsListViewHolder {
	    public ImageView image;
	    public TextView title;
	    public CheckBox checkBox;
	}
	
	/***************************************************************
	 * This AsyncTask goes through a specified artist and retrieves 
	 * every song by the artist and its ID. It then inserts the ID(s) 
	 * into a HashSet.
	 ***************************************************************/
	static class AsyncGetArtistSongIds extends AsyncTask<String, String, String> {

		private Common mApp;
		private String mArtistName;
		
		public AsyncGetArtistSongIds(Context context, String artistName) {
			mApp = (Common) context.getApplicationContext();
			mArtistName = artistName;
		}
		
		@Override
		protected String doInBackground(String... params) {
			//Check if the user is adding or removing an artist from the list.
			String operation = params[0];
			if (operation.equals("ADD")) {
				addArtistToLibrary();
			} else {
				removeArtistFromLibrary();
			}
			
			return null;
		}
		
		public void addArtistToLibrary() {
			
			Cursor cursor = mApp.getDBAccessHelper().getAllSongsByArtist(mArtistName);
			if (cursor!=null && cursor.getCount() > 0) {

				for (int i=0; i < cursor.getCount(); i++) {
					cursor.moveToPosition(i);
					PlaylistEditorActivity.songDBIdsList.add(cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID)));
				}
				cursor.close();
				cursor = null;
				
			}
			
		}
		
		public void removeArtistFromLibrary() {

			Cursor cursor = mApp.getDBAccessHelper().getAllSongsByArtist(mArtistName);
			if (cursor!=null && cursor.getCount() > 0) {

				for (int i=0; i < cursor.getCount(); i++) {
					cursor.moveToPosition(i);
					PlaylistEditorActivity.songDBIdsList.remove(cursor.getString(cursor.getColumnIndex(DBAccessHelper._ID)));
				}
				cursor.close();
				cursor = null;
				
			}
			
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistEditorActivity;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Paint;
import android.support.v4.widget.SimpleCursorAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class PlaylistEditorSongsMultiselectAdapter extends SimpleCursorAdapter {
	
	private Context mContext;
	private SharedPreferences sharedPreferences;
	private Common mApp;
	
    public PlaylistEditorSongsMultiselectAdapter(Context context, Cursor cursor) {
        super(context, -1, cursor, new String[] {}, new int[] {}, 0);
        mContext = context;
        sharedPreferences = mContext.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
        mApp = (Common) mContext.getApplicationContext();
    }

    @Override
	public View getView(int position, View convertView, ViewGroup parent) {
        final Cursor c = (Cursor) getItem(position);
	    SongsListViewHolder holder = null;

		if (convertView == null) {
			
			convertView = LayoutInflater.from(mContext).inflate(R.layout.music_library_editor_songs_layout, parent, false);
			holder = new SongsListViewHolder();
			holder.image = (ImageView) convertView.findViewById(R.id.songThumbnailMusicLibraryEditor);
			holder.title = (TextView) convertView.findViewById(R.id.songNameMusicLibraryEditor);
			holder.checkBox = (CheckBox) convertView.findViewById(R.id.songCheckboxMusicLibraryEditor);
			holder.subText = (TextView) convertView.findViewById(R.id.artistNameSongListView);

			convertView.setTag(holder);
		} else {
		    holder = (SongsListViewHolder) convertView.getTag();
		}
		
		final View finalConvertView = convertView;
		final String songId = c.getString(c.getColumnIndex(DBAccessHelper._ID));
		final String songTitle = c.getString(c.getColumnIndex(DBAccessHelper.SONG_TITLE));
		String songAlbumArtPath = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH));
		String songArtist = c.getString(c.getColumnIndex(DBAccessHelper.SONG_ARTIST));
		
		holder.title.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.title.setPaintFlags(holder.title.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		holder.subText.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
		holder.subText.setPaintFlags(holder.subText.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
		
		//Set the songID as the view's tag.
		convertView.setTag(R.string.song_id, songId);
		
		//Set the song title.
		holder.title.setText(songTitle);
		holder.subText.setText(songArtist);
        mApp.getImageLoader().displayImage(songAlbumArtPath, holder.image, PlaylistEditorActivity.displayImageOptions);

        //Check if the song's DB ID exists in the HashSet and set the appropriate checkbox status.
        if (PlaylistEditorActivity.songDBIdsList.contains(songId)) {
        	convertView.setBackgroundColor(0xCC0099CC);
        	holder.checkBox.setChecked(true);
        } else {
        	convertView.setBackgroundColor(0x00000000);
        	holder.checkBox.setChecked(false);
        }
        
        holder.checkBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton checkbox, boolean isChecked) {
				
				if (isChecked==true) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0xCC0099CC);
						PlaylistEditorActivity.songDBIdsList.add(songId);
					}
					
				} else if (isChecked==false) {
					
					//Only receive inputs by the user and ignore any system-made changes to the checkbox state.
					if (checkbox.isPressed()) {
						finalConvertView.setBackgroundColor(0xCC0099CC);
						PlaylistEditorActivity.songDBIdsList.remove(songId);
					}

				}
				
			}
			
        });
 
		return convertView;
	}
    
	static class SongsListViewHolder {
	    public ImageView image;
	    public TextView title;
	    public TextView subText;
	    public CheckBox checkBox;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistEditorActivity;

import android.app.Fragment;
import android.database.Cursor;
import android.graphics.Paint;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.ListView;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class SongsPickerFragment extends Fragment {
	
	private Common mApp;
	public static Cursor cursor;
	public static ListView listView;
	
	@Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		mApp = (Common) getActivity().getApplicationContext();
		View rootView = inflater.inflate(R.layout.fragment_songs_music_library_editor, null);
		cursor = mApp.getDBAccessHelper().getAllSongs();
		
		listView = (ListView) rootView.findViewById(R.id.musicLibraryEditorSongsListView);
		listView.setFastScrollEnabled(true);
		listView.setAdapter(new PlaylistEditorSongsMultiselectAdapter(getActivity(), cursor));

		listView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> arg0, View view, int which, long dbID) {
				CheckBox checkbox = (CheckBox) view.findViewById(R.id.songCheckboxMusicLibraryEditor);
				checkbox.performClick();
				
				/* Since we've performed a software-click (checkbox.performClick()), all we have 
				 * to do now is determine the *new* state of the checkbox. If the checkbox is checked, 
				 * that means that the user tapped on it when it was unchecked, and we should add 
				 * the song to the HashSet. If the checkbox is unchecked, that means the user 
				 * tapped on it when it was checked, so we should remove the song from the 
				 * HashSet.
				 */
				if (checkbox.isChecked()) {
					view.setBackgroundColor(0xCC0099CC);
					PlaylistEditorActivity.songDBIdsList.add((String) view.getTag(R.string.song_id));
				} else {
					view.setBackgroundColor(0x00000000);
					PlaylistEditorActivity.songDBIdsList.remove((String) view.getTag(R.string.song_id));
				}
				
			}
			
		});
		
		TextView instructions = (TextView) rootView.findViewById(R.id.songs_music_library_editor_instructions);
		instructions.setTypeface(TypefaceHelper.getTypeface(getActivity(), "RobotoCondensed-Light"));
		instructions.setPaintFlags(instructions.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
		
		return rootView;
	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistUtils;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.Uri;
import android.provider.MediaStore;

import com.jams.music.player.DBHelpers.DBAccessHelper;

public class AddPlaylistUtils {
	
	//Retrieves a cursor that contiains the songs that need to be added to the new playlist.
	public static Cursor getPlaylistElementsCursor(Context context, 
										 		   DBAccessHelper musicLibraryDBHelper, 
										 		   SharedPreferences sharedPreferences,
										 		   String ARTIST,
										 		   String ALBUM,
										 		   String SONG,
										 		   String GENRE,
										 		   String ALBUM_ARTIST, 
										 		   String ADD_TYPE) {

		/*//Initialize the DB access and cursor object.
		Cursor cursor = null;
		
		if (ADD_TYPE.equals("ARTIST")) {
			String selection = null;
			String currentLibrary = sharedPreferences.getString(Common.CURRENT_LIBRARY, context.getResources().getString(R.string.all_libraries));
		    currentLibrary = currentLibrary.replace("'", "''");
		    ARTIST = ARTIST.replace("'", "''");
	    	
		    if (currentLibrary.equals(context.getResources().getString(R.string.all_libraries))) {
		    	selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + ARTIST + "'";
		        cursor = musicLibraryDBHelper.getAllSongsSearchable(selection);
		        
		    } else if (currentLibrary.equals(context.getResources().getString(R.string.google_play_music_no_asterisk))) {
		    	selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + ARTIST + "'"
		    			  + " AND " + DBAccessHelper.SONG_SOURCE + " = " + "'GOOGLE_PLAY_MUSIC'";
		        cursor = musicLibraryDBHelper.getAllSongsByArtistSearchable(selection);
		        
		    } else {
		    	selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + ARTIST + "'" + " AND "
		    			  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + currentLibrary + "'";
		        cursor = musicLibraryDBHelper.getAllSongsByArtistInLibrary(selection);
		        
		    }
		    
		    ARTIST = ARTIST.replace("''", "'");
		    
		} else if (ADD_TYPE.equals("ALBUM")) {
			String selection = null;
			String currentLibrary = sharedPreferences.getString(Common.CURRENT_LIBRARY, context.getResources().getString(R.string.all_libraries));
		    currentLibrary = currentLibrary.replace("'", "''");
			ARTIST = ARTIST.replace("'", "''");
			ALBUM = ALBUM.replace("'", "''");
			
		    if (currentLibrary.equals(context.getResources().getString(R.string.all_libraries))) {
	    		selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + ALBUM  + "'" + " AND "
						  + DBAccessHelper.SONG_ARTIST + "=" + "'" + ARTIST + "'";
		        cursor = musicLibraryDBHelper.getAllSongsByArtistAlbum(selection);
		        
		    } else if (currentLibrary.equals(context.getResources().getString(R.string.google_play_music_no_asterisk))) {
		    	selection = " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + ARTIST + "'" + " AND "
		    			  + DBAccessHelper.SONG_ALBUM + "=" + "'" + ALBUM + "'"
		    			  + " AND " + DBAccessHelper.SONG_SOURCE + " = " + "'GOOGLE_PLAY_MUSIC'";
		        cursor = musicLibraryDBHelper.getAllSongsByArtistSearchable(selection);
		        
		    } else {
		    	selection = " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + ALBUM  + "'" + " AND "
						  + DBAccessHelper.SONG_ARTIST + "=" + "'" + ARTIST + "'" + " AND " 
						  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + currentLibrary + "'";
		        cursor = musicLibraryDBHelper.getAllSongsByArtistAlbumInLibrary(selection);
		        
		    }
		    
		    ARTIST = ARTIST.replace("''", "'");
		    ALBUM = ALBUM.replace("''", "'");
			
		} else if (ADD_TYPE.equals("SONG")) {
			String selection = null;
			SONG = SONG.replace("'", "''");
			ARTIST = ARTIST.replace("'", "''");
			ALBUM = ALBUM.replace("'", "''");
		    String currentLibrary = sharedPreferences.getString(Common.CURRENT_LIBRARY, context.getResources().getString(R.string.all_libraries));
		    
		    currentLibrary = currentLibrary.replace("'", "''");
		    if (currentLibrary.equals(context.getResources().getString(R.string.all_libraries))) {
		    	selection = " AND " + DBAccessHelper.SONG_TITLE + "=" + "'" + SONG + "'" 
		    			  + " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + ARTIST + "'" 
		    			  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + ALBUM + "'";
		        cursor = musicLibraryDBHelper.getAllSongsSearchable(selection);
		        
		    } else if (currentLibrary.equals(context.getResources().getString(R.string.google_play_music_no_asterisk))) {
		    	selection = " AND " + DBAccessHelper.SONG_TITLE + "=" + "'" + SONG + "'" 
		    			  + " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + ARTIST + "'" 
		    			  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + ALBUM + "'"
		    			  + " AND " + DBAccessHelper.SONG_SOURCE + " = " + "'GOOGLE_PLAY_MUSIC'";
		        cursor = musicLibraryDBHelper.getAllSongsByArtistSearchable(selection);
		        
		    } else {
	    		selection = " AND " + DBAccessHelper.LIBRARY_NAME + "=" + "'" + currentLibrary + "'"
	    				  + " AND " + DBAccessHelper.SONG_TITLE + "=" + "'" + SONG + "'" 
		    			  + " AND " + DBAccessHelper.SONG_ARTIST + "=" + "'" + ARTIST + "'" 
		    			  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + ALBUM + "'";
		        cursor = musicLibraryDBHelper.getAllSongsInLibrarySearchable(selection);
		        
		    }
		    
		    SONG = SONG.replace("''", "'");
			ARTIST = ARTIST.replace("''", "'");
			ALBUM = ALBUM.replace("''", "'");

		} else if (ADD_TYPE.equals("GENRE")) {
			String selection = null;
			GENRE = GENRE.replace("'", "''");
			String currentLibrary = sharedPreferences.getString(Common.CURRENT_LIBRARY, context.getResources().getString(R.string.all_libraries));
		    currentLibrary = currentLibrary.replace("'", "''");
			
		    if (currentLibrary.equals(context.getResources().getString(R.string.all_libraries))) {
	    		selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + GENRE + "'";
		        cursor = musicLibraryDBHelper.getAllSongsInGenre(selection);
		        
		    } else if (currentLibrary.equals(context.getResources().getString(R.string.google_play_music_no_asterisk))) {
		    	selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + GENRE + "'"
						  + " AND " + DBAccessHelper.SONG_SOURCE + " = " + "'GOOGLE_PLAY_MUSIC'";
		        cursor = musicLibraryDBHelper.getAllSongsByArtistSearchable(selection);
		        
		    } else {
	    		selection = " AND " + DBAccessHelper.SONG_GENRE + "=" + "'" + GENRE  + "'" + " AND " 
	    				  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + currentLibrary + "'";
		        cursor = musicLibraryDBHelper.getAllSongsInGenreInLibrary(selection);
		        
		    }
		    
		    GENRE = GENRE.replace("''", "'");
		    
		} else if (ADD_TYPE.equals("ALBUM_ARTIST")) {
			String selection = null;
			ALBUM_ARTIST = ALBUM_ARTIST.replace("'", "''");
			
			String currentLibrary = sharedPreferences.getString(Common.CURRENT_LIBRARY, context.getResources().getString(R.string.all_libraries));
		    currentLibrary = currentLibrary.replace("'", "''");
			
		    if (currentLibrary.equals(context.getResources().getString(R.string.all_libraries))) {
	    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + ALBUM_ARTIST + "'";
		        cursor = musicLibraryDBHelper.getAllSongsInAlbumArtist(selection);
		        
		    } else if (currentLibrary.equals(context.getResources().getString(R.string.google_play_music_no_asterisk))) {
		    	selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + ALBUM_ARTIST + "'"
						  + " AND " + DBAccessHelper.SONG_SOURCE + " = " + "'GOOGLE_PLAY_MUSIC'";
		        cursor = musicLibraryDBHelper.getAllSongsByAlbumArtistSearchable(selection);
		        
		    } else {
	    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + ALBUM_ARTIST  + "'" + " AND " 
	    				  + DBAccessHelper.LIBRARY_NAME + "=" + "'" + currentLibrary + "'";
		        cursor = musicLibraryDBHelper.getAllSongsInAlbumArtistInLibrary(selection);
		        
		    }
		    
		    ALBUM_ARTIST = ALBUM_ARTIST.replace("''", "'");
		} else if (ADD_TYPE.equals("ALBUM_BY_ALBUM_ARTIST")) {
			String selection = null;
			ALBUM_ARTIST = ALBUM_ARTIST.replace("'", "''");
			ALBUM = ALBUM.replace("'", "''");
			
			String currentLibrary = sharedPreferences.getString(Common.CURRENT_LIBRARY, context.getResources().getString(R.string.all_libraries));
		    currentLibrary = currentLibrary.replace("'", "''");
			
		    if (currentLibrary.equals(context.getResources().getString(R.string.all_libraries))) {
	    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + ALBUM_ARTIST + "'"
	    				  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + ALBUM + "'";
	    		cursor = musicLibraryDBHelper.getAllSongsByAlbumArtistAlbum(selection);
		        
		    } else if (currentLibrary.equals(context.getResources().getString(R.string.google_play_music_no_asterisk))) {
		    	selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + ALBUM_ARTIST + "'"
		    			  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + ALBUM + "'"
						  + " AND " + DBAccessHelper.SONG_SOURCE + " = " + "'GOOGLE_PLAY_MUSIC'";
		    	cursor = musicLibraryDBHelper.getAllSongsByAlbumArtistAlbum(selection);
		        
		    } else {
	    		selection = " AND " + DBAccessHelper.SONG_ALBUM_ARTIST + "=" + "'" + ALBUM_ARTIST  + "'"
	    				  + " AND " + DBAccessHelper.SONG_ALBUM + "=" + "'" + ALBUM + "'"
	    				  + " AND " + DBAccessHelper.LIBRARY_NAME + "=" + "'" + currentLibrary + "'";
		        cursor = musicLibraryDBHelper.getAllSongsByAlbumArtistAlbumInLibrary(selection);
		        
		    }
		    
		    ALBUM_ARTIST = ALBUM_ARTIST.replace("''", "'");
		    ALBUM = ALBUM.replace("''", "'");
		}*/
		
		return null;
	}
	
	//Adds the specified song to Android's MediaStore.
	public static void addToMediaStorePlaylist(ContentResolver resolver, int audioId, long playlistId) {
        String[] cols = new String[] {"count(*)"};
        Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId);
        Cursor cur = resolver.query(uri, cols, null, null, null);
        cur.moveToFirst();
        final int base = cur.getInt(0);
        cur.close();
        ContentValues values = new ContentValues();
        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, Integer.valueOf(base + audioId));
        values.put(MediaStore.Audio.Playlists.Members.AUDIO_ID, audioId);
        resolver.insert(uri, values);
        
    }
	
	public static void removeFromPlaylist(ContentResolver resolver, int audioId, long playlistId) {
	    String[] cols = new String[] {"count(*)"};
	    Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId);
	    Cursor cur = resolver.query(uri, cols, null, null, null);
	    cur.moveToFirst();
	    final int base = cur.getInt(0);
	    cur.close();
	    ContentValues values = new ContentValues();
	
	    resolver.delete(uri, MediaStore.Audio.Playlists.Members.AUDIO_ID + "=" + audioId, null);
	    
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistUtils;

import java.io.File;

/*******************************************************
 * This helper class utilizes the Lizzy library to 
 * convert an M3U playlist file to another file format. 
 * 
 * @author Saravan Pantham
 *******************************************************/
public class ConvertFromM3U {

	//Playlist parameters
	private File mPlaylistFile;
	private String mOutputFormat;
	private String mOutputFilePath;
	
	//Success/Error codes.
	public static String SUCCESS = "Playlist converted.";
	public static String INPUT_FILE_IO_EXCEPTION = "The playlist file could not be read.";
	public static String INPUT_FILE_INVALID = "The playlist file is invalid or corrupt.";
	public static String PLAYLIST_COULD_NOT_BE_CONVERTED = "The playlist could not be converted.";
	public static String PLAYLIST_COULD_NOT_BE_SAVED = "The converted playlist could not be saved.";
	
	//Playlist format codes.
	public static String ASX = "asx";
	public static String ATOM = "atom";
	public static String B4S = "b4s";
	public static String HYPETAPE = "hypetape";
	public static String KPL = "kpl";
	public static String M3U = "m3u";
	public static String MPCPL = "mpcpl";
	public static String PLA = "pla";
	public static String PLIST = "plist";
	public static String PLP = "plp";
	public static String PLS = "pls";
	public static String RMP = "rmp";
	public static String RSS = "rss";
	public static String SMIL = "smil";
	public static String WPL = "wpl";
	public static String XSPF = "xspf";
	
	public ConvertFromM3U(File playlistFile, String outputFormat, String outputFilePath) {
		mPlaylistFile = playlistFile;
		mOutputFormat = outputFormat;
		mOutputFilePath = outputFilePath;
	}
	
	/* Runs the actual conversion process. Returns "SUCCESS" if the 
	 * operation succeeded. Returns an error code otherwise. */
	public String convertPlaylistFile() {
		
		
		
		return SUCCESS;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistUtils;

import java.io.File;

/*******************************************************
 * This helper class utilizes the Lizzy library to 
 * convert an M3U playlist file to another file format. 
 * 
 * @author Saravan Pantham
 *******************************************************/
public class ConvertToM3U {

	//Playlist parameters
	private File mPlaylistFile;
	private String mOutputFilePath;
	
	//Success/Error codes.
	public static String SUCCESS = "Playlist converted.";
	public static String INPUT_FILE_IO_EXCEPTION = "The playlist file could not be read.";
	public static String INPUT_FILE_INVALID = "The playlist file is invalid or corrupt.";
	public static String PLAYLIST_COULD_NOT_BE_CONVERTED = "The playlist could not be converted.";
	public static String PLAYLIST_COULD_NOT_BE_SAVED = "The converted playlist could not be saved.";
	
	public ConvertToM3U(File playlistFile, String outputFilePath) {
		mPlaylistFile = playlistFile;
		mOutputFilePath = outputFilePath;
	}
	
	/* Runs the actual conversion process. Returns "SUCCESS" if the 
	 * operation succeeded. Returns an error code otherwise. */
	public String convertPlaylistFile() {
		
		return SUCCESS;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.NoSuchElementException;

public class ReadFromM3UPlaylist {

    public ReadFromM3UPlaylist() throws Exception {
    	//Constructor.
    }

    public String convertStreamToString(java.io.InputStream is) {
    	
	    try {
	    	return new java.util.Scanner(is).useDelimiter("\\A").next();
	    } catch (NoSuchElementException e) {
	    	return "";
	    }
	    
    }

    public M3UHolder parseFile(File f) throws FileNotFoundException {
        if (f.exists()) {
            String stream = convertStreamToString(new FileInputStream(f));
            stream = stream.replaceAll("#EXTM3U", "").trim();
            String[] arr = stream.split("#EXTINF.*,");
            String urls = "", data = "";
            	
            for (int n = 0; n < arr.length; n++) {
                if (arr[n].contains("http")) {
                        String nu = arr[n].substring(arr[n].indexOf("http://"),
                                        arr[n].indexOf(".mp3") + 4);

                        urls = urls.concat(nu);
                        data = data.concat(arr[n].replaceAll(nu, "").trim())
                                        .concat("&&&&");
                        urls = urls.concat("####");
                }
                
            }
            return new M3UHolder(data.split("&&&&"), urls.split("####"));
        }
        return null;
    }

    public class M3UHolder {
        private String[] data, url;

        public M3UHolder(String[] names, String[] urls) {
            this.data = names;
            this.url = urls;
        }

        public int getSize() {
            if (url != null)
                    return url.length;
            return 0;
        }

        public String getName(int n) {
            return data[n];
        }

        public String getUrl(int n) {
            return url[n];
        }
        
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistUtils;

public class RelativizePaths {

	public static String convertToRelativePath(String absolutePath, String relativeTo) {
		StringBuilder relativePath = null;

		absolutePath = absolutePath.replaceAll("\\\\", "/");
		relativeTo = relativeTo.replaceAll("\\\\", "/");

		if (absolutePath.equals(relativeTo) == true) {

		} else {
			String[] absoluteDirectories = absolutePath.split("/");
			String[] relativeDirectories = relativeTo.split("/");
	
			//Get the shortest of the two paths
			int length = absoluteDirectories.length < relativeDirectories.length ?
			absoluteDirectories.length : relativeDirectories.length;
	
			//Use to determine where in the loop we exited
			int lastCommonRoot = -1;
			int index;
	
			//Find common root
			for (index = 0; index < length; index++) {
				
				if (absoluteDirectories[index].equals(relativeDirectories[index])) {
					lastCommonRoot = index;
				} else {
					break;
				}
				
			}
			
			if (lastCommonRoot != -1) {
				//Build up the relative path
				relativePath = new StringBuilder();
				//Add on the ..
				for (index = lastCommonRoot + 1; index < absoluteDirectories.length; index++) {
					if (absoluteDirectories[index].length() > 0) {
						relativePath.append("../");
					}
				}
				
				for (index = lastCommonRoot + 1; index < relativeDirectories.length - 1; index++) {
					relativePath.append(relativeDirectories[index] + "/");
				}
				
				relativePath.append(relativeDirectories[relativeDirectories.length - 1]);
			}
			
		}
		
		return relativePath == null ? null : relativePath.toString();
	
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.PlaylistUtils;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.audio.exceptions.CannotReadException;
import org.jaudiotagger.audio.exceptions.InvalidAudioFrameException;
import org.jaudiotagger.audio.exceptions.ReadOnlyFileException;
import org.jaudiotagger.tag.FieldKey;
import org.jaudiotagger.tag.Tag;
import org.jaudiotagger.tag.TagException;

public class WriteToM3UPlaylist {

	private String mPlaylistFolderPath;
	private String mPlaylistName;
	private String mPlaylistElementPath;
	private String mDurationInMs;
	private String mFullFilePath;
	
	public WriteToM3UPlaylist(String playlistFolderPath, 
							  String playlistName, 
							  String playlistElementPath,
							  String durationInMs) {
		
		mPlaylistFolderPath = playlistFolderPath;
		mPlaylistName = playlistName;
		mPlaylistElementPath = playlistElementPath;
		mDurationInMs = durationInMs;
	}
	
	//Saves the specified playlist to the specified file on the filesystem.
	//Returns true if the write operation succeeded. Returns false otherwise.
	public boolean writeToM3UFile() {
		
		BufferedWriter writer = null;
        try {
        	
        	//Check if the playlist target folder exists.
        	File folderPath = new File(mPlaylistFolderPath);
        	if (folderPath.isDirectory()==false) {
        		folderPath.mkdirs();
        	}
        	
            //Create/open the M3U file for writing.
        	mFullFilePath = mPlaylistFolderPath + "/" + mPlaylistName + ".m3u";
        	File file = new File(mFullFilePath);
            
        	//Create the opening M3U header only if the playlist doesn't already exist.
            writer = null;
        	if (file.exists()==false) {
        		writer = new BufferedWriter(new FileWriter(file, false));
        		writer.write("#EXTM3U");
        	} else {
        		writer = new BufferedWriter(new FileWriter(file, true));
        	}
        	
        	//Convert the duration units from millisecs to seconds.
        	long duration = Long.parseLong(mDurationInMs);
        	duration = duration/1000;
        	String durationInSecs = duration + "";
        	
        	//If the playlist element path and the duration are both null, just create an empty playlist.
        	if (durationInSecs!=null && mPlaylistElementPath!=null) {
                writer.newLine();
                writer.write("#EXTINF:" + durationInSecs + ", " + getSongTitle(mPlaylistElementPath));
                writer.newLine();
                writer.write("\"" + getRelativePath(mPlaylistFolderPath, mPlaylistElementPath) + "\"");
        	}
        	
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        } finally {
        	
            try {
                writer.close();
            } catch (Exception e) {
            	//Get rid of the writer object on the next garbage collection run.
            	writer = null;
            }
         
        }
        
        return true;
	}
	
	public String getSongTitle(String songFilePath) {
		
		String songTitle = "Title";
		
		//Try to get the song title from the ID3 tag.
		File songFile = new File(songFilePath);
		AudioFile audioFile = null;
		Tag tag = null;
		try {
			audioFile = AudioFileIO.read(songFile);
		} catch (CannotReadException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TagException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ReadOnlyFileException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvalidAudioFrameException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		tag = audioFile.getTag();
		songTitle = tag.getFirst(FieldKey.TITLE);
		
		//If the ID3 tag doesn't give us the info we need, just use the file name.
		if (songTitle.equals("Title") || songTitle.isEmpty()) {
			int indexOfLastSlash = songTitle.lastIndexOf("/")+1;
			int indexOfLastDot = songTitle.lastIndexOf(".");
			songTitle = songTitle.substring(indexOfLastSlash, indexOfLastDot);
		}
		
		return songTitle;
		
	}
	
	//This method will produce a file path for the songs, relative to the playlist location.
	public String getRelativePath(String playlistFilePath, String songFilePath) {
		
		String relativePath = RelativizePaths.convertToRelativePath(playlistFilePath, songFilePath);
		return relativePath;
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jams.music.player.RemoteControlClient;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

import android.app.PendingIntent;
import android.graphics.Bitmap;
import android.os.Looper;
import android.util.Log;

/**
 * RemoteControlClient enables exposing information meant to be consumed by remote controls capable
 * of displaying metadata, artwork and media transport control buttons. A remote control client
 * object is associated with a media button event receiver. This event receiver must have been
 * previously registered with
 * {@link android.media.AudioManager#registerMediaButtonEventReceiver(android.content.ComponentName)}
 * before the RemoteControlClient can be registered through
 * {@link android.media.AudioManager#registerRemoteControlClient(android.media.RemoteControlClient)}.
 */
@SuppressWarnings({"rawtypes", "unchecked"})
public class RemoteControlClientCompat {

    private static final String TAG = "RemoteControlCompat";

    private static Class sRemoteControlClientClass;

    // RCC short for RemoteControlClient
    private static Method sRCCEditMetadataMethod;
    private static Method sRCCSetPlayStateMethod;
    private static Method sRCCSetTransportControlFlags;

    private static boolean sHasRemoteControlAPIs = false;

    static {
        try {
            ClassLoader classLoader = RemoteControlClientCompat.class.getClassLoader();
            sRemoteControlClientClass = getActualRemoteControlClientClass(classLoader);
            // dynamically populate the playstate and flag values in case they change
            // in future versions.
            for (Field field : RemoteControlClientCompat.class.getFields()) {
                try {
                    Field realField = sRemoteControlClientClass.getField(field.getName());
                    Object realValue = realField.get(null);
                    field.set(null, realValue);
                } catch (NoSuchFieldException e) {
                    Log.w(TAG, "Could not get real field: " + field.getName());
                } catch (IllegalArgumentException e) {
                    Log.w(TAG, "Error trying to pull field value for: " + field.getName()
                            + " " + e.getMessage());
                } catch (IllegalAccessException e) {
                    Log.w(TAG, "Error trying to pull field value for: " + field.getName()
                            + " " + e.getMessage());
                }
            }

            // get the required public methods on RemoteControlClient
            sRCCEditMetadataMethod = sRemoteControlClientClass.getMethod("editMetadata",
                    boolean.class);
            sRCCSetPlayStateMethod = sRemoteControlClientClass.getMethod("setPlaybackState",
                    int.class);
            sRCCSetTransportControlFlags = sRemoteControlClientClass.getMethod(
                    "setTransportControlFlags", int.class);

            sHasRemoteControlAPIs = true;
        } catch (ClassNotFoundException e) {
            // Silently fail when running on an OS before ICS.
        } catch (NoSuchMethodException e) {
            // Silently fail when running on an OS before ICS.
        } catch (IllegalArgumentException e) {
            // Silently fail when running on an OS before ICS.
        } catch (SecurityException e) {
            // Silently fail when running on an OS before ICS.
        }
    }

    public static Class getActualRemoteControlClientClass(ClassLoader classLoader)
            throws ClassNotFoundException {
        return classLoader.loadClass("android.media.RemoteControlClient");
    }

    private Object mActualRemoteControlClient;

    public RemoteControlClientCompat(PendingIntent pendingIntent) {
        if (!sHasRemoteControlAPIs) {
            return;
        }
        try {
            mActualRemoteControlClient =
                    sRemoteControlClientClass.getConstructor(PendingIntent.class)
                            .newInstance(pendingIntent);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public RemoteControlClientCompat(PendingIntent pendingIntent, Looper looper) {
        if (!sHasRemoteControlAPIs) {
            return;
        }

        try {
            mActualRemoteControlClient =
                    sRemoteControlClientClass.getConstructor(PendingIntent.class, Looper.class)
                            .newInstance(pendingIntent, looper);
        } catch (Exception e) {
            Log.e(TAG, "Error creating new instance of " + sRemoteControlClientClass.getName(), e);
        }
    }

    /**
     * Class used to modify metadata in a {@link android.media.RemoteControlClient} object. Use
     * {@link android.media.RemoteControlClient#editMetadata(boolean)} to create an instance of an
     * editor, on which you set the metadata for the RemoteControlClient instance. Once all the
     * information has been set, use {@link #apply()} to make it the new metadata that should be
     * displayed for the associated client. Once the metadata has been "applied", you cannot reuse
     * this instance of the MetadataEditor.
     */
    public class MetadataEditorCompat {

        private Method mPutStringMethod;
        private Method mPutBitmapMethod;
        private Method mPutLongMethod;
        private Method mClearMethod;
        private Method mApplyMethod;

        private Object mActualMetadataEditor;

        /**
         * The metadata key for the content artwork / album art.
         */
        public final static int METADATA_KEY_ARTWORK = 100;

        private MetadataEditorCompat(Object actualMetadataEditor) {
            if (sHasRemoteControlAPIs && actualMetadataEditor == null) {
                throw new IllegalArgumentException("Remote Control API's exist, " +
                        "should not be given a null MetadataEditor");
            }
            if (sHasRemoteControlAPIs) {
                Class metadataEditorClass = actualMetadataEditor.getClass();

                try {
                    mPutStringMethod = metadataEditorClass.getMethod("putString",
                            int.class, String.class);
                    mPutBitmapMethod = metadataEditorClass.getMethod("putBitmap",
                            int.class, Bitmap.class);
                    mPutLongMethod = metadataEditorClass.getMethod("putLong",
                            int.class, long.class);
                    mClearMethod = metadataEditorClass.getMethod("clear", new Class[]{});
                    mApplyMethod = metadataEditorClass.getMethod("apply", new Class[]{});
                } catch (Exception e) {
                    throw new RuntimeException(e.getMessage(), e);
                }
            }
            mActualMetadataEditor = actualMetadataEditor;
        }

        /**
         * Adds textual information to be displayed.
         * Note that none of the information added after {@link #apply()} has been called,
         * will be displayed.
         * @param key The identifier of a the metadata field to set. Valid values are
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_ALBUM},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_ALBUMARTIST},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_TITLE},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_ARTIST},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_AUTHOR},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_COMPILATION},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_COMPOSER},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_DATE},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_GENRE},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_TITLE},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_WRITER}.
         * @param value The text for the given key, or {@code null} to signify there is no valid
         *      information for the field.
         * @return Returns a reference to the same MetadataEditor object, so you can chain put
         *      calls together.
         */
        public MetadataEditorCompat putString(int key, String value) {
            if (sHasRemoteControlAPIs) {
                try {
                    mPutStringMethod.invoke(mActualMetadataEditor, key, value);
                } catch (Exception e) {
                    throw new RuntimeException(e.getMessage(), e);
                }
            }
            return this;
        }

        /**
         * Sets the album / artwork picture to be displayed on the remote control.
         * @param key the identifier of the bitmap to set. The only valid value is
         *      {@link #METADATA_KEY_ARTWORK}
         * @param bitmap The bitmap for the artwork, or null if there isn't any.
         * @return Returns a reference to the same MetadataEditor object, so you can chain put
         *      calls together.
         * @throws IllegalArgumentException
         * @see android.graphics.Bitmap
         */
        public MetadataEditorCompat putBitmap(int key, Bitmap bitmap) {
            if (sHasRemoteControlAPIs) {
                try {
                    mPutBitmapMethod.invoke(mActualMetadataEditor, key, bitmap);
                } catch (Exception e) {
                    throw new RuntimeException(e.getMessage(), e);
                }
            }
            return this;
        }

        /**
         * Adds numerical information to be displayed.
         * Note that none of the information added after {@link #apply()} has been called,
         * will be displayed.
         * @param key the identifier of a the metadata field to set. Valid values are
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_CD_TRACK_NUMBER},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_DISC_NUMBER},
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_DURATION} (with a value
         *      expressed in milliseconds),
         *      {@link android.media.MediaMetadataRetriever#METADATA_KEY_YEAR}.
         * @param value The long value for the given key
         * @return Returns a reference to the same MetadataEditor object, so you can chain put
         *      calls together.
         * @throws IllegalArgumentException
         */
        public MetadataEditorCompat putLong(int key, long value) {
            if (sHasRemoteControlAPIs) {
                try {
                    mPutLongMethod.invoke(mActualMetadataEditor, key, value);
                } catch (Exception e) {
                    throw new RuntimeException(e.getMessage(), e);
                }
            }
            return this;
        }

        /**
         * Clears all the metadata that has been set since the MetadataEditor instance was
         * created with {@link android.media.RemoteControlClient#editMetadata(boolean)}.
         */
        public void clear() {
            if (sHasRemoteControlAPIs) {
                try {
                    mClearMethod.invoke(mActualMetadataEditor, (Object[]) null);
                } catch (Exception e) {
                    throw new RuntimeException(e.getMessage(), e);
                }
            }
        }

        /**
         * Associates all the metadata that has been set since the MetadataEditor instance was
         * created with {@link android.media.RemoteControlClient#editMetadata(boolean)}, or since
         * {@link #clear()} was called, with the RemoteControlClient. Once "applied", this
         * MetadataEditor cannot be reused to edit the RemoteControlClient's metadata.
         */
        public void apply() {
            if (sHasRemoteControlAPIs) {
                try {
                    mApplyMethod.invoke(mActualMetadataEditor, (Object[]) null);
                } catch (Exception e) {
                    throw new RuntimeException(e.getMessage(), e);
                }
            }
        }
    }

    /**
     * Creates a {@link android.media.RemoteControlClient.MetadataEditor}.
     * @param startEmpty Set to false if you want the MetadataEditor to contain the metadata that
     *     was previously applied to the RemoteControlClient, or true if it is to be created empty.
     * @return a new MetadataEditor instance.
     */
    public MetadataEditorCompat editMetadata(boolean startEmpty) {
        Object metadataEditor;
        if (sHasRemoteControlAPIs) {
            try {
                metadataEditor = sRCCEditMetadataMethod.invoke(mActualRemoteControlClient,
                        startEmpty);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        } else {
            metadataEditor = null;
        }
        return new MetadataEditorCompat(metadataEditor);
    }

    /**
     * Sets the current playback state.
     * @param state The current playback state, one of the following values:
     *       {@link android.media.RemoteControlClient#PLAYSTATE_STOPPED},
     *       {@link android.media.RemoteControlClient#PLAYSTATE_PAUSED},
     *       {@link android.media.RemoteControlClient#PLAYSTATE_PLAYING},
     *       {@link android.media.RemoteControlClient#PLAYSTATE_FAST_FORWARDING},
     *       {@link android.media.RemoteControlClient#PLAYSTATE_REWINDING},
     *       {@link android.media.RemoteControlClient#PLAYSTATE_SKIPPING_FORWARDS},
     *       {@link android.media.RemoteControlClient#PLAYSTATE_SKIPPING_BACKWARDS},
     *       {@link android.media.RemoteControlClient#PLAYSTATE_BUFFERING},
     *       {@link android.media.RemoteControlClient#PLAYSTATE_ERROR}.
     */
    public void setPlaybackState(int state) {
        if (sHasRemoteControlAPIs) {
            try {
                sRCCSetPlayStateMethod.invoke(mActualRemoteControlClient, state);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * Sets the flags for the media transport control buttons that this client supports.
     * @param transportControlFlags A combination of the following flags:
     *      {@link android.media.RemoteControlClient#FLAG_KEY_MEDIA_PREVIOUS},
     *      {@link android.media.RemoteControlClient#FLAG_KEY_MEDIA_REWIND},
     *      {@link android.media.RemoteControlClient#FLAG_KEY_MEDIA_PLAY},
     *      {@link android.media.RemoteControlClient#FLAG_KEY_MEDIA_PLAY_PAUSE},
     *      {@link android.media.RemoteControlClient#FLAG_KEY_MEDIA_PAUSE},
     *      {@link android.media.RemoteControlClient#FLAG_KEY_MEDIA_STOP},
     *      {@link android.media.RemoteControlClient#FLAG_KEY_MEDIA_FAST_FORWARD},
     *      {@link android.media.RemoteControlClient#FLAG_KEY_MEDIA_NEXT}
     */
    public void setTransportControlFlags(int transportControlFlags) {
        if (sHasRemoteControlAPIs) {
            try {
                sRCCSetTransportControlFlags.invoke(mActualRemoteControlClient,
                        transportControlFlags);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    public final Object getActualRemoteControlClientObject() {
        return mActualRemoteControlClient;
    }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jams.music.player.RemoteControlClient;

import java.lang.reflect.Method;

import android.media.AudioManager;
import android.util.Log;

/**
 * Contains methods to handle registering/unregistering remote control clients.  These methods only
 * run on ICS devices.  On previous devices, all methods are no-ops.
 */
@SuppressWarnings({"unchecked", "rawtypes"})
public class RemoteControlHelper {
    private static final String TAG = "RemoteControlHelper";

    private static boolean sHasRemoteControlAPIs = false;

    private static Method sRegisterRemoteControlClientMethod;
    private static Method sUnregisterRemoteControlClientMethod;

    static {
        try {
            ClassLoader classLoader = RemoteControlHelper.class.getClassLoader();
            Class sRemoteControlClientClass =
                    RemoteControlClientCompat.getActualRemoteControlClientClass(classLoader);
            sRegisterRemoteControlClientMethod = AudioManager.class.getMethod(
                    "registerRemoteControlClient", new Class[]{sRemoteControlClientClass});
            sUnregisterRemoteControlClientMethod = AudioManager.class.getMethod(
                    "unregisterRemoteControlClient", new Class[]{sRemoteControlClientClass});
            sHasRemoteControlAPIs = true;
        } catch (ClassNotFoundException e) {
            // Silently fail when running on an OS before ICS.
        } catch (NoSuchMethodException e) {
            // Silently fail when running on an OS before ICS.
        } catch (IllegalArgumentException e) {
            // Silently fail when running on an OS before ICS.
        } catch (SecurityException e) {
            // Silently fail when running on an OS before ICS.
        }
    }

    public static void registerRemoteControlClient(AudioManager audioManager,
            RemoteControlClientCompat remoteControlClient) {
        if (!sHasRemoteControlAPIs) {
            return;
        }

        try {
            sRegisterRemoteControlClientMethod.invoke(audioManager,
                    remoteControlClient.getActualRemoteControlClientObject());
        } catch (Exception e) {
            Log.e(TAG, e.getMessage(), e);
        }
    }


    public static void unregisterRemoteControlClient(AudioManager audioManager,
            RemoteControlClientCompat remoteControlClient) {
        if (!sHasRemoteControlAPIs) {
            return;
        }

        try {
            sUnregisterRemoteControlClientMethod.invoke(audioManager,
                    remoteControlClient.getActualRemoteControlClientObject());
        } catch (Exception e) {
            Log.e(TAG, e.getMessage(), e);
        }
    }
}


@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Scrobbling;

import android.content.Context;
import android.content.Intent;

/*****************************************************
 * Contains public methods that connect with Scrobble 
 * Droid.
 * 
 * @author Saravan Pantham
 *****************************************************/
public class ScrobbleDroidHelper {

	//Action Intent.
	public static Intent mScrobbleDroidIntent;
	
	/**
	 * Initializes the action intent that will be sent to 
	 * Scrobble Droid. This method should always 
	 * be called when sending a new set of data to the 
	 * scrobbling app.
	 */
	public static void initializeActionIntent() {
		mScrobbleDroidIntent = null;
		mScrobbleDroidIntent = new Intent("net.jjc1138.android.scrobbler.action.MUSIC_STATUS");
	}
	
	/**
	 * Attaches the song's metadata to the intent that was initialized in 
	 * <i>initializeActionIntent()</i>.
	 */
	public static void attachMetadata(boolean playing,
									  String artist,
									  String album,
									  String track,
									  int durationInSecs) {
		
		mScrobbleDroidIntent.putExtra("playing", playing);
		mScrobbleDroidIntent.putExtra("artist", artist);
		mScrobbleDroidIntent.putExtra("album", album);
		mScrobbleDroidIntent.putExtra("track", track);
		mScrobbleDroidIntent.putExtra("secs", durationInSecs);
		
	}
	
	/**
	 * Fires the broadcast intent that connects to Scrobble Droid.
	 */
	public static void sendBroadcast(Context mContext) {
		mContext.sendBroadcast(mScrobbleDroidIntent);
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Scrobbling;

import android.content.Context;
import android.content.Intent;

/***************************************************
 * Contains public methods that connect with Simple 
 * lastFM Scrobbler.
 * 
 * @author Saravan Pantham
 ***************************************************/
public class SimpleLastFMHelper {

	//Action intent.
	public static Intent mSimpleLastFMIntent;
	
	//Play state constants
	public static int START = 0;
	public static int RESUME = 1;
	public static int PAUSE = 2;
	public static int COMPLETE = 3;
	
	/**
	 * Initializes the action intent that will be sent to 
	 * Simple lastFM Scrobbler. This method should always 
	 * be called when sending a new set of data to the 
	 * scrobbling app.
	 */
	public static void initializeActionIntent() {
		mSimpleLastFMIntent = null;
		mSimpleLastFMIntent = new Intent("com.adam.aslfms.notify.playstatechanged");
	}
	
	/**
	 * Attaches the song's metadata to the intent that was initialized in 
	 * <i>initializeActionIntent()</i>.
	 */
	public static void attachMetadata(int state,
													String artist,
													String album,
													String track,
													int durationInSecs) {
		mSimpleLastFMIntent.putExtra("state", state);
		mSimpleLastFMIntent.putExtra("app-name", "Jams Music Player");
		mSimpleLastFMIntent.putExtra("app-package", "com.jams.music.player");
		mSimpleLastFMIntent.putExtra("artist", artist);
		mSimpleLastFMIntent.putExtra("album", album);
		mSimpleLastFMIntent.putExtra("track", track);
		mSimpleLastFMIntent.putExtra("duration", durationInSecs);
		
	}
	
	/**
	 * Fires the broadcast intent that connects to Simple lastFM Scrobbler.
	 */
	public static void sendBroadcast(Context mContext) {
		mContext.sendBroadcast(mSimpleLastFMIntent);
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Services;

import android.annotation.SuppressLint;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.appwidget.AppWidgetManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.database.MergeCursor;
import android.graphics.Bitmap;
import android.media.AudioManager;
import android.media.AudioManager.OnAudioFocusChangeListener;
import android.media.MediaMetadataRetriever;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnBufferingUpdateListener;
import android.media.MediaPlayer.OnCompletionListener;
import android.media.MediaPlayer.OnErrorListener;
import android.media.MediaPlayer.OnPreparedListener;
import android.media.RemoteControlClient;
import android.media.audiofx.PresetReverb;
import android.net.Uri;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.PowerManager;
import android.support.v4.app.NotificationCompat;
import android.util.Log;
import android.view.View;
import android.widget.RemoteViews;
import android.widget.Toast;

import com.google.analytics.tracking.android.Fields;
import com.google.analytics.tracking.android.GoogleAnalytics;
import com.google.analytics.tracking.android.MapBuilder;
import com.google.analytics.tracking.android.Tracker;
import com.jams.music.player.AsyncTasks.AsyncGetSongStreamURLTask;
import com.jams.music.player.BroadcastReceivers.HeadsetButtonsReceiver;
import com.jams.music.player.BroadcastReceivers.HeadsetPlugBroadcastReceiver;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.AudioManagerHelper;
import com.jams.music.player.Helpers.EqualizerHelper;
import com.jams.music.player.Helpers.SongHelper;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.PlaybackKickstarter.PlaybackKickstarter.BuildCursorListener;
import com.jams.music.player.R;
import com.jams.music.player.RemoteControlClient.RemoteControlClientCompat;
import com.jams.music.player.RemoteControlClient.RemoteControlHelper;
import com.jams.music.player.Scrobbling.ScrobbleDroidHelper;
import com.jams.music.player.Scrobbling.SimpleLastFMHelper;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.WidgetProviders.AlbumArtWidgetProvider;
import com.jams.music.player.WidgetProviders.BlurredWidgetProvider;
import com.jams.music.player.WidgetProviders.LargeWidgetProvider;
import com.jams.music.player.WidgetProviders.SmallWidgetProvider;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

/**
 * The meat and potatoes of the entire app. Manages 
 * playback, equalizer effects, and all other audio 
 * related operations.
 * 
 * @author Saravan Pantham
 */
public class AudioPlaybackService extends Service {
	
	//Context and Intent.
	private Context mContext;
	private Service mService;
	
	//Global Objects Provider.
	private Common mApp;
	
	//PrepareServiceListener instance.
	private PrepareServiceListener mPrepareServiceListener;
	
	//MediaPlayer objects and flags.
	private MediaPlayer mMediaPlayer;
	private MediaPlayer mMediaPlayer2;
	private int mCurrentMediaPlayer = 1;
	private boolean mFirstRun = true;
	
	//AudioManager.
	private AudioManager mAudioManager;
	private AudioManagerHelper mAudioManagerHelper;
	
	//Flags that indicate whether the mediaPlayers have been initialized.
	private boolean mMediaPlayerPrepared = false;
	private boolean mMediaPlayer2Prepared = false;
	
	//Cursor object(s) that will guide the rest of this queue.
	private Cursor mCursor;
	private MergeCursor mMergeCursor;
	
	//Holds the indeces of the current cursor, in the order that they'll be played.
	private ArrayList<Integer> mPlaybackIndecesList = new ArrayList<Integer>();
	
	//Holds the indeces of songs that were unplayable.
	private ArrayList<Integer> mFailedIndecesList = new ArrayList<Integer>();
	
	//Song data helpers for each MediaPlayer object.
	private SongHelper mMediaPlayerSongHelper;
	private SongHelper mMediaPlayer2SongHelper;

	//Pointer variable.
	private int mCurrentSongIndex;

	//Equalizer/Audio FX helpers.
	private EqualizerHelper mEqualizerHelper;
	
	//Notification elements.
	private NotificationCompat.Builder mNotificationBuilder;
	public static final int mNotificationId = 1080; //NOTE: Using 0 as a notification ID causes Android to ignore the notification call.
	
	//Custom actions for media player controls via the notification bar.
    public static final String LAUNCH_NOW_PLAYING_ACTION = "com.jams.music.player.LAUNCH_NOW_PLAYING_ACTION";
	public static final String PREVIOUS_ACTION = "com.jams.music.player.PREVIOUS_ACTION";
	public static final String PLAY_PAUSE_ACTION = "com.jams.music.player.PLAY_PAUSE_ACTION";
	public static final String NEXT_ACTION = "com.jams.music.player.NEXT_ACTION";
	public static final String STOP_SERVICE = "com.jams.music.player.STOP_SERVICE";
	
	//Indicates if an enqueue/queue reordering operation was performed on the original queue.
	private boolean mEnqueuePerformed = false;
	
	//Handler object.
	private Handler mHandler;
	
	//Volume variables that handle the crossfade effect.
	private float mFadeOutVolume = 1.0f;
	private float mFadeInVolume = 0.0f;
	
	//Headset plug receiver.
	private HeadsetPlugBroadcastReceiver mHeadsetPlugReceiver;
	
	//Crossfade.
	private int mCrossfadeDuration;
	
	//A-B Repeat variables.
	private int mRepeatSongRangePointA = 0;
	private int mRepeatSongRangePointB = 0;
	
	//Indicates if the user changed the track manually.
	private boolean mTrackChangedByUser = false;
	
	//RemoteControlClient for use with remote controls and ICS+ lockscreen controls.
	private RemoteControlClientCompat mRemoteControlClientCompat;
	private ComponentName mMediaButtonReceiverComponent;
	
	//Enqueue reorder scalar.
	private int mEnqueueReorderScalar = 0;
	
	//Temp placeholder for GMusic Uri.
	public static final Uri URI_BEING_LOADED = Uri.parse("uri_being_loaded");
	
	//Google Analytics.
	private GoogleAnalytics mGAInstance;
	private Tracker mTracker;
	private long mServiceStartTime;
	
	/**
	 * Constructor that should be used whenever this 
	 * service is being explictly created.
	 * 
	 * @param context The context being passed in.
	 */
	public AudioPlaybackService(Context context) {
		mContext = context;
	}
	
	/**
	 * Empty constructor. Required if a custom constructor 
	 * was explicitly declared (see above).
	 */
	public AudioPlaybackService() {
		super();
	}

	/**
	 * Prepares the MediaPlayer objects for first use 
	 * and starts the service. The workflow of the entire 
	 * service starts here.
	 * 
	 * @param intent Calling intent.
	 * @param flags Service flags.
	 * @param startId Service start ID.
	 */
	@SuppressLint("NewApi")
	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
        super.onStartCommand(intent, flags, startId);
        
		//Context.
		mContext = getApplicationContext();
		mService = this;
		mHandler = new Handler();
		
        mApp = (Common) getApplicationContext();
        mApp.setService((AudioPlaybackService) this);
        mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
  
        //Initialize Google Analytics.
        //initGoogleAnalytics();
        
        //Initialize the MediaPlayer objects.
        initMediaPlayers();
		
		//Time to play nice with other music players (and audio apps) and request audio focus.
		mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
		mAudioManagerHelper = new AudioManagerHelper();
		
		// Request audio focus for playback
		mAudioManagerHelper.setHasAudioFocus(requestAudioFocus());

        //Grab the crossfade duration for this session.
        mCrossfadeDuration = mApp.getCrossfadeDuration();

		//Initialize audio effects (equalizer, virtualizer, bass boost) for this session.
		initAudioFX();
		
	    mMediaButtonReceiverComponent = new ComponentName(this.getPackageName(), HeadsetButtonsReceiver.class.getName());
	    mAudioManager.registerMediaButtonEventReceiver(mMediaButtonReceiverComponent);
	    
	    if (mApp.getSharedPreferences().getBoolean(Common.SHOW_LOCKSCREEN_CONTROLS, true)==true) {
	    	initRemoteControlClient();
	    }
	    
		mApp.getPlaybackKickstarter().setBuildCursorListener(buildCursorListener);
		
		//The service has been successfully started.
		setPrepareServiceListener(mApp.getPlaybackKickstarter());
	    getPrepareServiceListener().onServiceRunning(this);
	    
		return START_STICKY;
	}
	
	/**
	 * Public interface that provides access to 
	 * major events during the service startup 
	 * process.
	 * 
	 * @author Saravan Pantham
	 */
	public interface PrepareServiceListener {

		/**
		 * Called when the service is up and running.
		 */
		public void onServiceRunning(AudioPlaybackService service);
		
		/**
		 * Called when the service failed to start. 
		 * Also returns the failure reason via the exception 
		 * parameter.
		 */
		public void onServiceFailed(Exception exception);
	
	}
	
	/**
	 * Initializes Google Analytics.
	 */
	private void initGoogleAnalytics() {
        try {
        	if (mApp.isGoogleAnalyticsEnabled()) {
        		String gaTrackingId = getResources().getString(R.string.ga_trackingId);
            	mServiceStartTime = System.currentTimeMillis();
            	
            	mGAInstance = GoogleAnalytics.getInstance(getApplicationContext());
                mTracker = mGAInstance.getTracker(gaTrackingId);
                
                mTracker.set(Fields.SESSION_CONTROL, "start");
                mTracker.send(MapBuilder.createEvent("Jams Service", 
    					 							 "Service started!", 
    					 							 "User is playing music.", 
    					 							 null).build());
        	}

        } catch (Exception e) {
        	e.printStackTrace();
        }
        
	}
	
	/**
	 * Initializes remote control clients for this service session. 
	 * Currently used for lockscreen controls.
	 */
	public void initRemoteControlClient() {
		if (mRemoteControlClientCompat==null) {
            Intent remoteControlIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
            remoteControlIntent.setComponent(mMediaButtonReceiverComponent);
            
            mRemoteControlClientCompat = new RemoteControlClientCompat(PendingIntent.getBroadcast(mContext, 0, remoteControlIntent, 0));
            RemoteControlHelper.registerRemoteControlClient(mAudioManager, mRemoteControlClientCompat);
            
        }
	    
	    mRemoteControlClientCompat.setPlaybackState(RemoteControlClient.PLAYSTATE_PLAYING);
	    mRemoteControlClientCompat.setTransportControlFlags(RemoteControlClient.FLAG_KEY_MEDIA_PLAY |
	             											RemoteControlClient.FLAG_KEY_MEDIA_PAUSE |
	             											RemoteControlClient.FLAG_KEY_MEDIA_NEXT |
	             											RemoteControlClient.FLAG_KEY_MEDIA_STOP |
	             											RemoteControlClient.FLAG_KEY_MEDIA_PREVIOUS);
	    
	}
	
	/**
	 * Initializes the MediaPlayer objects for this service session.
	 */
	private void initMediaPlayers() {
		
		/*
		 * Release the MediaPlayer objects if they are still valid.
		 */
		if (mMediaPlayer!=null) {
			mMediaPlayer.release();
			mMediaPlayer = null;
		}
		
		if (mMediaPlayer2!=null) {
			getMediaPlayer2().release();
			mMediaPlayer2 = null;
		}
		
		mMediaPlayer = new MediaPlayer();
		mMediaPlayer2 = new MediaPlayer();
		setCurrentMediaPlayer(1);
		
		getMediaPlayer().reset();
		getMediaPlayer2().reset();
		
		//Loop the players if the repeat mode is set to repeat the current song.
		if (getRepeatMode()==Common.REPEAT_SONG) {
			getMediaPlayer().setLooping(true);
			getMediaPlayer2().setLooping(true);
		}
		
		try {
			mMediaPlayer.setWakeMode(mContext, PowerManager.PARTIAL_WAKE_LOCK);
			getMediaPlayer2().setWakeMode(mContext, PowerManager.PARTIAL_WAKE_LOCK);
		} catch (Exception e) {
			mMediaPlayer = new MediaPlayer();
			mMediaPlayer2 = new MediaPlayer();
			setCurrentMediaPlayer(1);
		}

		//Set the mediaPlayers' stream sources.
		mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
		getMediaPlayer2().setAudioStreamType(AudioManager.STREAM_MUSIC);
		
	}
	
	/**
	 * Initializes the list of pointers to each cursor row.
	 */
	private void initPlaybackIndecesList(boolean playAll) {
		if (getCursor()!=null && getPlaybackIndecesList()!=null) {
			getPlaybackIndecesList().clear();
			for (int i=0; i < getCursor().getCount(); i++) {
				getPlaybackIndecesList().add(i);
			}
			
			if (isShuffleOn() && !playAll) {
                //Build a new list that doesn't include the current song index.
                ArrayList<Integer> newList = new ArrayList<Integer>(getPlaybackIndecesList());
                newList.remove(getCurrentSongIndex());

                //Shuffle the new list.
                Collections.shuffle(newList, new Random(System.nanoTime()));

                //Plug in the current song index back into the new list.
                newList.add(getCurrentSongIndex(), getCurrentSongIndex());
                mPlaybackIndecesList = newList;

			} else if (isShuffleOn() && playAll) {
                //Shuffle all elements.
                Collections.shuffle(getPlaybackIndecesList(), new Random(System.nanoTime()));
            }
			
		} else {
			stopSelf();
		}
		
	}
	
	/**
	 * Requests AudioFocus from the OS.
	 * 
	 * @return True if AudioFocus was gained. False, otherwise.
	 */
	private boolean requestAudioFocus() {
		int result = mAudioManager.requestAudioFocus(audioFocusChangeListener,
     												AudioManager.STREAM_MUSIC,
     												AudioManager.AUDIOFOCUS_GAIN);

		if (result!=AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
			//Stop the service.
			mService.stopSelf();
			Toast.makeText(mContext, R.string.close_other_audio_apps, Toast.LENGTH_LONG).show();
			return false;
		} else {
			return true;
		}
		
	}
	
	/**
	 * Initializes the equalizer and audio effects for this service session.
	 */
	public void initAudioFX() {

		try {	
	    	//Instatiate the equalizer helper object.
			mEqualizerHelper = new EqualizerHelper(mContext, mMediaPlayer.getAudioSessionId(), 
												   getMediaPlayer2().getAudioSessionId(), 
												   mApp.isEqualizerEnabled());

		} catch (UnsupportedOperationException e) {
			e.printStackTrace();
			mEqualizerHelper.setIsEqualizerSupported(false);
		} catch (Exception e) {
			e.printStackTrace();
			mEqualizerHelper.setIsEqualizerSupported(false);
		}
		
	}
	
	@Override
	public IBinder onBind(Intent arg0) {
		return null;
	}
	
	/**
	 * Retrieves the EQ values for mMediaPlayer's current song and 
	 * applies them to the EQ engine.
	 * 
	 * @param songId The id of the song that mMediaPlayer is current handling.
	 */
	private void applyMediaPlayerEQ(String songId) {
		
		if (mEqualizerHelper==null)
			return;
		
		short fiftyHertzBand = mEqualizerHelper.getEqualizer().getBand(50000);
		short oneThirtyHertzBand = mEqualizerHelper.getEqualizer().getBand(130000);
		short threeTwentyHertzBand = mEqualizerHelper.getEqualizer().getBand(320000);
		short eightHundredHertzBand = mEqualizerHelper.getEqualizer().getBand(800000);
		short twoKilohertzBand = mEqualizerHelper.getEqualizer().getBand(2000000);
		short fiveKilohertzBand = mEqualizerHelper.getEqualizer().getBand(5000000);
		short twelvePointFiveKilohertzBand = mEqualizerHelper.getEqualizer().getBand(9000000);

		//Get the equalizer/audioFX settings for this specific song.
		int[] eqValues = mApp.getDBAccessHelper().getSongEQValues(songId);

		//50Hz Band.
		if (eqValues[0]==16) {
			mEqualizerHelper.getEqualizer().setBandLevel(fiftyHertzBand, (short) 0);
		} else if (eqValues[0] < 16) {
			
			if (eqValues[0]==0) {
				mEqualizerHelper.getEqualizer().setBandLevel(fiftyHertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer().setBandLevel(fiftyHertzBand, (short) (-(16-eqValues[0])*100));
			}
			
		} else if (eqValues[0] > 16) {
			mEqualizerHelper.getEqualizer().setBandLevel(fiftyHertzBand, (short) ((eqValues[0]-16)*100));
		}
		
		//130Hz Band.
		if (eqValues[1]==16) {
			mEqualizerHelper.getEqualizer().setBandLevel(oneThirtyHertzBand, (short) 0);
		} else if (eqValues[1] < 16) {
			
			if (eqValues[1]==0) {
				mEqualizerHelper.getEqualizer().setBandLevel(oneThirtyHertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer().setBandLevel(oneThirtyHertzBand, (short) (-(16-eqValues[1])*100));
			}
			
		} else if (eqValues[1] > 16) {
			mEqualizerHelper.getEqualizer().setBandLevel(oneThirtyHertzBand, (short) ((eqValues[1]-16)*100));
		}
		
		//320Hz Band.
		if (eqValues[2]==16) {
			mEqualizerHelper.getEqualizer().setBandLevel(threeTwentyHertzBand, (short) 0);
		} else if (eqValues[2] < 16) {
			
			if (eqValues[2]==0) {
				mEqualizerHelper.getEqualizer().setBandLevel(threeTwentyHertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer().setBandLevel(threeTwentyHertzBand, (short) (-(16-eqValues[2])*100));
			}
			
		} else if (eqValues[2] > 16) {
			mEqualizerHelper.getEqualizer().setBandLevel(threeTwentyHertzBand, (short) ((eqValues[2]-16)*100));
		}
		
		//800Hz Band.
		if (eqValues[3]==16) {
			mEqualizerHelper.getEqualizer().setBandLevel(eightHundredHertzBand, (short) 0);
		} else if (eqValues[3] < 16) {
			
			if (eqValues[3]==0) {
				mEqualizerHelper.getEqualizer().setBandLevel(eightHundredHertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer().setBandLevel(eightHundredHertzBand, (short) (-(16-eqValues[3])*100));
			}
			
		} else if (eqValues[3] > 16) {
			mEqualizerHelper.getEqualizer().setBandLevel(eightHundredHertzBand, (short) ((eqValues[3]-16)*100));
		}
		
		//2kHz Band.
		if (eqValues[4]==16) {
			mEqualizerHelper.getEqualizer().setBandLevel(twoKilohertzBand, (short) 0);
		} else if (eqValues[4] < 16) {
			
			if (eqValues[4]==0) {
				mEqualizerHelper.getEqualizer().setBandLevel(twoKilohertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer().setBandLevel(twoKilohertzBand, (short) (-(16-eqValues[4])*100));
			}
			
		} else if (eqValues[4] > 16) {
			mEqualizerHelper.getEqualizer().setBandLevel(twoKilohertzBand, (short) ((eqValues[4]-16)*100));
		}
		
		//5kHz Band.
		if (eqValues[5]==16) {
			mEqualizerHelper.getEqualizer().setBandLevel(fiveKilohertzBand, (short) 0);
		} else if (eqValues[5] < 16) {
			
			if (eqValues[5]==0) {
				mEqualizerHelper.getEqualizer().setBandLevel(fiveKilohertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer().setBandLevel(fiveKilohertzBand, (short) (-(16-eqValues[5])*100));
			}
			
		} else if (eqValues[5] > 16) {
			mEqualizerHelper.getEqualizer().setBandLevel(fiveKilohertzBand, (short) ((eqValues[5]-16)*100));
		}
		
		//12.5kHz Band.
		if (eqValues[6]==16) {
			mEqualizerHelper.getEqualizer().setBandLevel(twelvePointFiveKilohertzBand, (short) 0);
		} else if (eqValues[6] < 16) {
			
			if (eqValues[6]==0) {
				mEqualizerHelper.getEqualizer().setBandLevel(twelvePointFiveKilohertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer().setBandLevel(twelvePointFiveKilohertzBand, (short) (-(16-eqValues[6])*100));
			}
			
		} else if (eqValues[6] > 16) {
			mEqualizerHelper.getEqualizer().setBandLevel(twelvePointFiveKilohertzBand, (short) ((eqValues[6]-16)*100));
		}
		
		//Set the audioFX values.
		mEqualizerHelper.getVirtualizer().setStrength((short) eqValues[7]);
		mEqualizerHelper.getBassBoost().setStrength((short) eqValues[8]);
		
		if (eqValues[9]==0) {
			mEqualizerHelper.getReverb().setPreset(PresetReverb.PRESET_NONE);
		} else if (eqValues[9]==1) {
			mEqualizerHelper.getReverb().setPreset(PresetReverb.PRESET_LARGEHALL);
		} else if (eqValues[9]==2) {
			mEqualizerHelper.getReverb().setPreset(PresetReverb.PRESET_LARGEROOM);
		} else if (eqValues[9]==3) {
			mEqualizerHelper.getReverb().setPreset(PresetReverb.PRESET_MEDIUMHALL);
		} else if (eqValues[9]==4) {
			mEqualizerHelper.getReverb().setPreset(PresetReverb.PRESET_MEDIUMROOM);
		} else if (eqValues[9]==5) {
			mEqualizerHelper.getReverb().setPreset(PresetReverb.PRESET_SMALLROOM);
		} else if (eqValues[9]==6) {
			mEqualizerHelper.getReverb().setPreset(PresetReverb.PRESET_PLATE);
		}
		
	}
	
	/**
	 * Retrieves the EQ values for mMediaPlayer2's current song and 
	 * applies them to the EQ engine.
	 * 
	 * @param songId The id of the song that mMediaPlayer is current handling.
	 */
	private void applyMediaPlayer2EQ(String songId) {

		if (mEqualizerHelper==null)
			return;
		
		short fiftyHertzBand = mEqualizerHelper.getEqualizer2().getBand(50000);
		short oneThirtyHertzBand = mEqualizerHelper.getEqualizer2().getBand(130000);
		short threeTwentyHertzBand = mEqualizerHelper.getEqualizer2().getBand(320000);
		short eightHundredHertzBand = mEqualizerHelper.getEqualizer2().getBand(800000);
		short twoKilohertzBand = mEqualizerHelper.getEqualizer2().getBand(2000000);
		short fiveKilohertzBand = mEqualizerHelper.getEqualizer2().getBand(5000000);
		short twelvePointFiveKilohertzBand = mEqualizerHelper.getEqualizer2().getBand(9000000);

		//Get the mEqualizerHelper.getEqualizer()/audioFX settings for this specific song.
		int[] eqValues = mApp.getDBAccessHelper().getSongEQValues(songId);
		
		//50Hz Band.
		if (eqValues[0]==16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(fiftyHertzBand, (short) 0);
		} else if (eqValues[0] < 16) {
			
			if (eqValues[0]==0) {
				mEqualizerHelper.getEqualizer2().setBandLevel(fiftyHertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer2().setBandLevel(fiftyHertzBand, (short) (-(16-eqValues[0])*100));
			}
			
		} else if (eqValues[0] > 16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(fiftyHertzBand, (short) ((eqValues[0]-16)*100));
		}
		
		//130Hz Band.
		if (eqValues[1]==16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(oneThirtyHertzBand, (short) 0);
		} else if (eqValues[1] < 16) {
			
			if (eqValues[1]==0) {
				mEqualizerHelper.getEqualizer2().setBandLevel(oneThirtyHertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer2().setBandLevel(oneThirtyHertzBand, (short) (-(16-eqValues[1])*100));
			}
			
		} else if (eqValues[1] > 16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(oneThirtyHertzBand, (short) ((eqValues[1]-16)*100));
		}
		
		//320Hz Band.
		if (eqValues[2]==16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(threeTwentyHertzBand, (short) 0);
		} else if (eqValues[2] < 16) {
			
			if (eqValues[2]==0) {
				mEqualizerHelper.getEqualizer2().setBandLevel(threeTwentyHertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer2().setBandLevel(threeTwentyHertzBand, (short) (-(16-eqValues[2])*100));
			}
			
		} else if (eqValues[2] > 16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(threeTwentyHertzBand, (short) ((eqValues[2]-16)*100));
		}
		
		//800Hz Band.
		if (eqValues[3]==16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(eightHundredHertzBand, (short) 0);
		} else if (eqValues[3] < 16) {
			
			if (eqValues[3]==0) {
				mEqualizerHelper.getEqualizer2().setBandLevel(eightHundredHertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer2().setBandLevel(eightHundredHertzBand, (short) (-(16-eqValues[3])*100));
			}
			
		} else if (eqValues[3] > 16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(eightHundredHertzBand, (short) ((eqValues[3]-16)*100));
		}
		
		//2kHz Band.
		if (eqValues[4]==16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(twoKilohertzBand, (short) 0);
		} else if (eqValues[4] < 16) {
			
			if (eqValues[4]==0) {
				mEqualizerHelper.getEqualizer2().setBandLevel(twoKilohertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer2().setBandLevel(twoKilohertzBand, (short) (-(16-eqValues[4])*100));
			}
			
		} else if (eqValues[4] > 16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(twoKilohertzBand, (short) ((eqValues[4]-16)*100));
		}
		
		//5kHz Band.
		if (eqValues[5]==16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(fiveKilohertzBand, (short) 0);
		} else if (eqValues[5] < 16) {
			
			if (eqValues[5]==0) {
				mEqualizerHelper.getEqualizer2().setBandLevel(fiveKilohertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer2().setBandLevel(fiveKilohertzBand, (short) (-(16-eqValues[5])*100));
			}
			
		} else if (eqValues[5] > 16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(fiveKilohertzBand, (short) ((eqValues[5]-16)*100));
		}
		
		//12.5kHz Band.
		if (eqValues[6]==16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(twelvePointFiveKilohertzBand, (short) 0);
		} else if (eqValues[6] < 16) {
			
			if (eqValues[6]==0) {
				mEqualizerHelper.getEqualizer2().setBandLevel(twelvePointFiveKilohertzBand, (short) -1500);
			} else {
				mEqualizerHelper.getEqualizer2().setBandLevel(twelvePointFiveKilohertzBand, (short) (-(16-eqValues[6])*100));
			}
			
		} else if (eqValues[6] > 16) {
			mEqualizerHelper.getEqualizer2().setBandLevel(twelvePointFiveKilohertzBand, (short) ((eqValues[6]-16)*100));
		}
		
		//Set the audioFX values.
		mEqualizerHelper.getVirtualizer2().setStrength((short) eqValues[7]);
		mEqualizerHelper.getBassBoost2().setStrength((short) eqValues[8]);
		
		if (eqValues[9]==0) {
			mEqualizerHelper.getReverb2().setPreset(PresetReverb.PRESET_NONE);
		} else if (eqValues[9]==1) {
			mEqualizerHelper.getReverb2().setPreset(PresetReverb.PRESET_LARGEHALL);
		} else if (eqValues[9]==2) {
			mEqualizerHelper.getReverb2().setPreset(PresetReverb.PRESET_LARGEROOM);
		} else if (eqValues[9]==3) {
			mEqualizerHelper.getReverb2().setPreset(PresetReverb.PRESET_MEDIUMHALL);
		} else if (eqValues[9]==4) {
			mEqualizerHelper.getReverb2().setPreset(PresetReverb.PRESET_MEDIUMROOM);
		} else if (eqValues[9]==5) {
			mEqualizerHelper.getReverb2().setPreset(PresetReverb.PRESET_SMALLROOM);
		} else if (eqValues[9]==6) {
			mEqualizerHelper.getReverb2().setPreset(PresetReverb.PRESET_PLATE);
		}
		
	}
	
	/**
	 * Builds and returns a fully constructed Notification for devices 
	 * on Jelly Bean and above (API 16+).
	 */
	@SuppressLint("NewApi") 
	private Notification buildJBNotification(SongHelper songHelper) {
		mNotificationBuilder = new NotificationCompat.Builder(mContext);
		mNotificationBuilder.setOngoing(true);
		mNotificationBuilder.setAutoCancel(false);
		mNotificationBuilder.setSmallIcon(R.drawable.notif_icon);
		
		//Open up the player screen when the user taps on the notification.
        Intent launchNowPlayingIntent = new Intent();
        launchNowPlayingIntent.setAction(AudioPlaybackService.LAUNCH_NOW_PLAYING_ACTION);
        PendingIntent launchNowPlayingPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, launchNowPlayingIntent, 0);
        mNotificationBuilder.setContentIntent(launchNowPlayingPendingIntent);
		
        //Grab the notification layouts.
		RemoteViews notificationView = new RemoteViews(mContext.getPackageName(), R.layout.notification_custom_layout);
		RemoteViews expNotificationView = new RemoteViews(mContext.getPackageName(), R.layout.notification_custom_expanded_layout);
		
		//Initialize the notification layout buttons.
    	Intent previousTrackIntent = new Intent();
    	previousTrackIntent.setAction(AudioPlaybackService.PREVIOUS_ACTION);
    	PendingIntent previousTrackPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, previousTrackIntent, 0);
    	
    	Intent playPauseTrackIntent = new Intent();
    	playPauseTrackIntent.setAction(AudioPlaybackService.PLAY_PAUSE_ACTION);
    	PendingIntent playPauseTrackPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, playPauseTrackIntent, 0);
    	
    	Intent nextTrackIntent = new Intent();
    	nextTrackIntent.setAction(AudioPlaybackService.NEXT_ACTION);
    	PendingIntent nextTrackPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, nextTrackIntent, 0);
    	
    	Intent stopServiceIntent = new Intent();
    	stopServiceIntent.setAction(AudioPlaybackService.STOP_SERVICE);
    	PendingIntent stopServicePendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, stopServiceIntent, 0);
		
    	//Check if audio is playing and set the appropriate play/pause button.
    	if (mApp.getService().isPlayingMusic()) {
			notificationView.setImageViewResource(R.id.notification_base_play, R.drawable.btn_playback_pause_light);
        	expNotificationView.setImageViewResource(R.id.notification_expanded_base_play, R.drawable.btn_playback_pause_light);
		} else {
			notificationView.setImageViewResource(R.id.notification_base_play, R.drawable.btn_playback_play_light);
        	expNotificationView.setImageViewResource(R.id.notification_expanded_base_play, R.drawable.btn_playback_play_light);
		}
    	
    	//Set the notification content.
        expNotificationView.setTextViewText(R.id.notification_expanded_base_line_one, songHelper.getTitle());
        expNotificationView.setTextViewText(R.id.notification_expanded_base_line_two, songHelper.getArtist());
        expNotificationView.setTextViewText(R.id.notification_expanded_base_line_three, songHelper.getAlbum());
        
        notificationView.setTextViewText(R.id.notification_base_line_one, songHelper.getTitle());
        notificationView.setTextViewText(R.id.notification_base_line_two, songHelper.getArtist());
        
        //Set the states of the next/previous buttons and their pending intents.
        if (mApp.getService().isOnlySongInQueue()) {
        	//This is the only song in the queue, so disable the previous/next buttons.
        	expNotificationView.setViewVisibility(R.id.notification_expanded_base_next, View.INVISIBLE);
        	expNotificationView.setViewVisibility(R.id.notification_expanded_base_previous, View.INVISIBLE);
        	expNotificationView.setOnClickPendingIntent(R.id.notification_expanded_base_play, playPauseTrackPendingIntent);
        	
        	notificationView.setViewVisibility(R.id.notification_base_next, View.INVISIBLE);
        	notificationView.setViewVisibility(R.id.notification_base_previous, View.INVISIBLE);
        	notificationView.setOnClickPendingIntent(R.id.notification_base_play, playPauseTrackPendingIntent);
        	
        } else if (mApp.getService().isFirstSongInQueue()) {
        	//This is the the first song in the queue, so disable the previous button.
        	expNotificationView.setViewVisibility(R.id.notification_expanded_base_previous, View.INVISIBLE);
        	expNotificationView.setViewVisibility(R.id.notification_expanded_base_next, View.VISIBLE);
        	expNotificationView.setOnClickPendingIntent(R.id.notification_expanded_base_play, playPauseTrackPendingIntent);
            expNotificationView.setOnClickPendingIntent(R.id.notification_expanded_base_next, nextTrackPendingIntent);
            
            notificationView.setViewVisibility(R.id.notification_base_previous, View.INVISIBLE);
        	notificationView.setViewVisibility(R.id.notification_base_next, View.VISIBLE);
        	notificationView.setOnClickPendingIntent(R.id.notification_base_play, playPauseTrackPendingIntent);
            notificationView.setOnClickPendingIntent(R.id.notification_base_next, nextTrackPendingIntent);
        	
        } else if (mApp.getService().isLastSongInQueue()) {
        	//This is the last song in the cursor, so disable the next button.
        	expNotificationView.setViewVisibility(R.id.notification_expanded_base_previous, View.VISIBLE);
        	expNotificationView.setViewVisibility(R.id.notification_expanded_base_next, View.INVISIBLE);
        	expNotificationView.setOnClickPendingIntent(R.id.notification_expanded_base_play, playPauseTrackPendingIntent);
            expNotificationView.setOnClickPendingIntent(R.id.notification_expanded_base_next, nextTrackPendingIntent);
            
            notificationView.setViewVisibility(R.id.notification_base_previous, View.VISIBLE);
        	notificationView.setViewVisibility(R.id.notification_base_next, View.INVISIBLE);
        	notificationView.setOnClickPendingIntent(R.id.notification_base_play, playPauseTrackPendingIntent);
            notificationView.setOnClickPendingIntent(R.id.notification_base_next, nextTrackPendingIntent);
        	
        } else {
        	//We're smack dab in the middle of the queue, so keep the previous and next buttons enabled.
        	expNotificationView.setViewVisibility(R.id.notification_expanded_base_previous,View.VISIBLE);
        	expNotificationView.setViewVisibility(R.id.notification_expanded_base_next, View.VISIBLE);
        	expNotificationView.setOnClickPendingIntent(R.id.notification_expanded_base_play, playPauseTrackPendingIntent);
            expNotificationView.setOnClickPendingIntent(R.id.notification_expanded_base_next, nextTrackPendingIntent);
            expNotificationView.setOnClickPendingIntent(R.id.notification_expanded_base_previous, previousTrackPendingIntent);
            
            notificationView.setViewVisibility(R.id.notification_base_previous,View.VISIBLE);
        	notificationView.setViewVisibility(R.id.notification_base_next, View.VISIBLE);
        	notificationView.setOnClickPendingIntent(R.id.notification_base_play, playPauseTrackPendingIntent);
            notificationView.setOnClickPendingIntent(R.id.notification_base_next, nextTrackPendingIntent);
            notificationView.setOnClickPendingIntent(R.id.notification_base_previous, previousTrackPendingIntent);
        	
        }
        
        //Set the "Stop Service" pending intents.
        expNotificationView.setOnClickPendingIntent(R.id.notification_expanded_base_collapse, stopServicePendingIntent);
        notificationView.setOnClickPendingIntent(R.id.notification_base_collapse, stopServicePendingIntent);
        
        //Set the album art.
        expNotificationView.setImageViewBitmap(R.id.notification_expanded_base_image, songHelper.getAlbumArt());
        notificationView.setImageViewBitmap(R.id.notification_base_image, songHelper.getAlbumArt());
        
        //Attach the shrunken layout to the notification.
        mNotificationBuilder.setContent(notificationView);
        
        //Build the notification object.
        Notification notification = mNotificationBuilder.build();
        
        //Attach the expanded layout to the notification and set its flags.
        notification.bigContentView = expNotificationView;
        notification.flags = Notification.FLAG_FOREGROUND_SERVICE | 
				 			 Notification.FLAG_NO_CLEAR | 
				 			 Notification.FLAG_ONGOING_EVENT;
        
        return notification;
	}
	
	/**
	 * Builds and returns a fully constructed Notification for devices 
	 * on Ice Cream Sandwich (APIs 14 & 15).
	 */
	private Notification buildICSNotification(SongHelper songHelper) {
		mNotificationBuilder = new NotificationCompat.Builder(mContext);
		mNotificationBuilder.setOngoing(true);
		mNotificationBuilder.setAutoCancel(false);
		mNotificationBuilder.setSmallIcon(R.drawable.notif_icon);
		
		//Open up the player screen when the user taps on the notification.
        Intent launchNowPlayingIntent = new Intent();
        launchNowPlayingIntent.setAction(AudioPlaybackService.LAUNCH_NOW_PLAYING_ACTION);
        PendingIntent launchNowPlayingPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, launchNowPlayingIntent, 0);
        mNotificationBuilder.setContentIntent(launchNowPlayingPendingIntent);
		
        //Grab the notification layout.
		RemoteViews notificationView = new RemoteViews(mContext.getPackageName(), R.layout.notification_custom_layout);
		
		//Initialize the notification layout buttons.
    	Intent previousTrackIntent = new Intent();
    	previousTrackIntent.setAction(AudioPlaybackService.PREVIOUS_ACTION);
    	PendingIntent previousTrackPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, previousTrackIntent, 0);
    	
    	Intent playPauseTrackIntent = new Intent();
    	playPauseTrackIntent.setAction(AudioPlaybackService.PLAY_PAUSE_ACTION);
    	PendingIntent playPauseTrackPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, playPauseTrackIntent, 0);
    	
    	Intent nextTrackIntent = new Intent();
    	nextTrackIntent.setAction(AudioPlaybackService.NEXT_ACTION);
    	PendingIntent nextTrackPendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, nextTrackIntent, 0);
    	
    	Intent stopServiceIntent = new Intent();
    	stopServiceIntent.setAction(AudioPlaybackService.STOP_SERVICE);
    	PendingIntent stopServicePendingIntent = PendingIntent.getBroadcast(mContext.getApplicationContext(), 0, stopServiceIntent, 0);
		
    	//Check if audio is playing and set the appropriate play/pause button.
    	if (mApp.getService().isPlayingMusic()) {
			notificationView.setImageViewResource(R.id.notification_base_play, R.drawable.btn_playback_pause_light);
		} else {
			notificationView.setImageViewResource(R.id.notification_base_play, R.drawable.btn_playback_play_light);
		}
    	
    	//Set the notification content.    
        notificationView.setTextViewText(R.id.notification_base_line_one, songHelper.getTitle());
        notificationView.setTextViewText(R.id.notification_base_line_two, songHelper.getArtist());
        
        //Set the states of the next/previous buttons and their pending intents.
        if (mApp.getService().isOnlySongInQueue()) {
        	//This is the only song in the queue, so disable the previous/next buttons.
        	notificationView.setViewVisibility(R.id.notification_base_next, View.INVISIBLE);
        	notificationView.setViewVisibility(R.id.notification_base_previous, View.INVISIBLE);
        	notificationView.setOnClickPendingIntent(R.id.notification_base_play, playPauseTrackPendingIntent);
        	
        } else if (mApp.getService().isFirstSongInQueue()) {
        	//This is the the first song in the queue, so disable the previous button. 
            notificationView.setViewVisibility(R.id.notification_base_previous, View.INVISIBLE);
        	notificationView.setViewVisibility(R.id.notification_base_next, View.VISIBLE);
        	notificationView.setOnClickPendingIntent(R.id.notification_base_play, playPauseTrackPendingIntent);
            notificationView.setOnClickPendingIntent(R.id.notification_base_next, nextTrackPendingIntent);
        	
        } else if (mApp.getService().isLastSongInQueue()) {
        	//This is the last song in the cursor, so disable the next button.    
            notificationView.setViewVisibility(R.id.notification_base_previous, View.VISIBLE);
        	notificationView.setViewVisibility(R.id.notification_base_next, View.INVISIBLE);
        	notificationView.setOnClickPendingIntent(R.id.notification_base_play, playPauseTrackPendingIntent);
            notificationView.setOnClickPendingIntent(R.id.notification_base_next, nextTrackPendingIntent);
        	
        } else {
        	//We're smack dab in the middle of the queue, so keep the previous and next buttons enabled.       
            notificationView.setViewVisibility(R.id.notification_base_previous,View.VISIBLE);
        	notificationView.setViewVisibility(R.id.notification_base_next, View.VISIBLE);
        	notificationView.setOnClickPendingIntent(R.id.notification_base_play, playPauseTrackPendingIntent);
            notificationView.setOnClickPendingIntent(R.id.notification_base_next, nextTrackPendingIntent);
            notificationView.setOnClickPendingIntent(R.id.notification_base_previous, previousTrackPendingIntent);
        	
        }
        
        //Set the "Stop Service" pending intent.
        notificationView.setOnClickPendingIntent(R.id.notification_base_collapse, stopServicePendingIntent);
        
        //Set the album art.
        notificationView.setImageViewBitmap(R.id.notification_base_image, songHelper.getAlbumArt());
        
        //Attach the shrunken layout to the notification.
        mNotificationBuilder.setContent(notificationView);
        
        //Build the notification object and set its flags.
        Notification notification = mNotificationBuilder.build();
        notification.flags = Notification.FLAG_FOREGROUND_SERVICE | 
				 			 Notification.FLAG_NO_CLEAR | 
				 			 Notification.FLAG_ONGOING_EVENT;
        
        return notification;
	}
	
	/**
	 * Returns the appropriate notification based on the device's 
	 * API level.
	 */
	private Notification buildNotification(SongHelper songHelper) {
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN)
			return buildJBNotification(songHelper);
		else
			return buildICSNotification(songHelper);
	}
	
	/**
	 * Updates the current notification with info from the specified 
	 * SongHelper object.
	 */
	public void updateNotification(SongHelper songHelper) {
		Notification notification = null;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN)
			notification = buildJBNotification(songHelper);
		else
			notification = buildICSNotification(songHelper);
		
		//Update the current notification.
		NotificationManager notifManager = (NotificationManager) mApp.getSystemService(Context.NOTIFICATION_SERVICE);
		notifManager.notify(mNotificationId, notification);
		
	}
	
	/**
	 * Updates all remote control clients (including the lockscreen controls).
	 */
	public void updateRemoteControlClients(SongHelper songHelper) {
		try {
            //Update the remote controls
            mRemoteControlClientCompat.editMetadata(true)
                    .putString(MediaMetadataRetriever.METADATA_KEY_ARTIST, getCurrentSong().getArtist())
                    .putString(MediaMetadataRetriever.METADATA_KEY_TITLE, getCurrentSong().getTitle())
                    .putString(MediaMetadataRetriever.METADATA_KEY_ALBUM, getCurrentSong().getAlbum())
                    .putLong(MediaMetadataRetriever.METADATA_KEY_DURATION, getCurrentMediaPlayer().getDuration())
                    .putBitmap(RemoteControlClientCompat.MetadataEditorCompat.METADATA_KEY_ARTWORK, getCurrentSong().getAlbumArt())
                    .apply();

            if (mRemoteControlClientCompat!=null) {

                if (getCurrentMediaPlayer().isPlaying())
                    mRemoteControlClientCompat.setPlaybackState(RemoteControlClient.PLAYSTATE_PLAYING);
                else
                    mRemoteControlClientCompat.setPlaybackState(RemoteControlClient.PLAYSTATE_PAUSED);

            }

		} catch (Exception e) {
			e.printStackTrace();
		}

	}
	
	/**
	 * This method combines mCursor with the specified newCursor.
	 * 
	 * @param newCursor The new cursor to append to mCursor.
	 * @param playNext Pass true if newCursor should be appeneded after the current song.
	 */
	public void enqueueCursor(Cursor newCursor, boolean playNext) {
		
		Cursor[] cursorArray = { getCursor(), newCursor };
		mMergeCursor = new MergeCursor(cursorArray);
		setCursor(mMergeCursor);
		getCursor().moveToPosition(mPlaybackIndecesList.get(mCurrentSongIndex));
		mEnqueuePerformed = true;
		
		if (playNext) {
        	//Check which mMediaPlayer is currently playing, and prepare the other mediaPlayer.
        	prepareAlternateMediaPlayer();
        	
		}
			
	}
	
	/**
	 * This method combines the current cursor with the specified playlist cursor.
	 * @param newCursor
	 */
	public void enqueuePlaylistCursor(Cursor newCursor) {
		
		String[] matrixCursorColumns = { DBAccessHelper.SONG_ARTIST,  
										 DBAccessHelper.SONG_ALBUM, 
										 DBAccessHelper.SONG_TITLE, 
										 DBAccessHelper.SONG_FILE_PATH,
										 DBAccessHelper.SONG_DURATION, 
										 DBAccessHelper.SONG_GENRE, 
										 DBAccessHelper.SONG_ID, 
										 DBAccessHelper.SONG_ALBUM_ART_PATH, 
										 DBAccessHelper.SONG_SOURCE };
		
		//Create an empty matrix getCursor() with the specified columns.
		MatrixCursor mMatrixCursor = new MatrixCursor(matrixCursorColumns);
		
		//Make a copy of the old getCursor() and copy it's contents over to the matrix getCursor().
		Cursor tempCursor = getCursor();
		
		tempCursor.moveToFirst();
		MediaMetadataRetriever mMMDR = new MediaMetadataRetriever();
		for (int i=0; i < tempCursor.getCount(); i++) {
			tempCursor.moveToPosition(i);
			
			//Check which type of getCursor() the service currently has.
			if (getCursor().getColumnIndex(DBAccessHelper.SONG_FILE_PATH)==-1) {
				
				//We'll have to manually extract the info from the audio file.
/*				String songFilePath = tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.PLAYLIST_SONG_FILE_PATH));
				
				try {
					mMMDR.setDataSource(songFilePath);
				} catch (Exception e) {
					//Skip the song if there's a problem with reading it.
					continue;
				}*/
				
				String songArtist = mMMDR.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);
				String songAlbum = mMMDR.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);
				String songTitle = mMMDR.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE);
				String songDuration = mMMDR.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION);
				String songGenre = mMMDR.extractMetadata(MediaMetadataRetriever.METADATA_KEY_GENRE);
				
				mMatrixCursor.addRow(new Object[] { songArtist, 
												   songAlbum,
												   songTitle, 
												   "",
												   songDuration, 
												   songGenre });

			} else {
				
				mMatrixCursor.addRow(new Object[] { tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_ARTIST)), 
												   tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_ALBUM)),
												   tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_TITLE)), 
												   tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_FILE_PATH)),
												   tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_DURATION)),
												   tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_GENRE)), 
												   tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_ID)), 
												   tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH)), 
												   tempCursor.getString(tempCursor.getColumnIndex(DBAccessHelper.SONG_SOURCE)) });

			}
		
		}
		
		tempCursor.close();
		
		//Copy the contents of the new getCursor() over to the MatrixCursor.
		if (newCursor.getCount() > 0) {

			String songArtist = "";
			String songAlbum = "";
			String songTitle = "";
			String filePath = "";
			String songDuration = "";
			for (int j=0; j < newCursor.getCount(); j++) {
/*				newCursor.moveToPosition(j);
				filePath = newCursor.getString(newCursor.getColumnIndex(DBAccessHelper.PLAYLIST_SONG_FILE_PATH));
				
				try {
					mMMDR.setDataSource(filePath);
				} catch (Exception e) {
					continue;
				}*/
				
				//Get the metadata from the song file.
				songArtist = mMMDR.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);
				songAlbum = mMMDR.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);
				songTitle = mMMDR.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE);
				songDuration = mMMDR.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION);
				String songGenre = mMMDR.extractMetadata(MediaMetadataRetriever.METADATA_KEY_GENRE);
				
				mMatrixCursor.addRow(new Object[] { songArtist, 
						   						   songAlbum,
						   						   songTitle, 
						   						   filePath,
						   						   songDuration,
						   						   songGenre });
				
			}
			
		}
		
		mEnqueuePerformed = true;
		newCursor.close();
		mCursor = (Cursor) mMatrixCursor;
		mMatrixCursor.close();
		
	}

	/**
	 * Listens for audio focus changes and reacts accordingly.
	 */
	private OnAudioFocusChangeListener audioFocusChangeListener = new OnAudioFocusChangeListener() {
		
		@Override
	    public void onAudioFocusChange(int focusChange) {
	        if (focusChange==AudioManager.AUDIOFOCUS_LOSS_TRANSIENT) {
	            //We've temporarily lost focus, so pause the mMediaPlayer, wherever it's at.
	        	try {
	        		getCurrentMediaPlayer().pause();
	        		updateNotification(mApp.getService().getCurrentSong());
	        		updateWidgets();
	        		scrobbleTrack(SimpleLastFMHelper.PAUSE);
	        		mAudioManagerHelper.setHasAudioFocus(false);
	        	} catch (Exception e) {
	        		e.printStackTrace();
	        	}
	        	
	        } else if (focusChange==AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK) {
	        	//Lower the current mMediaPlayer volume.
	        	mAudioManagerHelper.setAudioDucked(true);
	        	mAudioManagerHelper.setTargetVolume(5);
    			mAudioManagerHelper.setStepDownIncrement(1);
    			mAudioManagerHelper.setCurrentVolume(mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC));
    			mAudioManagerHelper.setOriginalVolume(mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC));
    			mHandler.post(duckDownVolumeRunnable);
	        
			} else if (focusChange==AudioManager.AUDIOFOCUS_GAIN) {
				
				if (mAudioManagerHelper.isAudioDucked()) {
					//Crank the volume back up again.
					mAudioManagerHelper.setTargetVolume(mAudioManagerHelper.getOriginalVolume());
	    			mAudioManagerHelper.setStepUpIncrement(1);
	    			mAudioManagerHelper.setCurrentVolume(mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC));
	    					
	    			mHandler.post(duckUpVolumeRunnable);
					mAudioManagerHelper.setAudioDucked(false);
				} else {
		            //We've regained focus. Update the audioFocus tag, but don't start the mMediaPlayer.
					mAudioManagerHelper.setHasAudioFocus(true);
		        	
				}
	        	
	        } else if (focusChange==AudioManager.AUDIOFOCUS_LOSS) {
	        	//We've lost focus permanently so pause the service. We'll have to request focus again later.
	        	getCurrentMediaPlayer().pause();
        		updateNotification(mApp.getService().getCurrentSong());
        		updateWidgets();
        		scrobbleTrack(SimpleLastFMHelper.PAUSE);
        		mAudioManagerHelper.setHasAudioFocus(false);
	            
	        }
	        
	    }
	    
	};
	
	/**
	 * Fades out volume before a duck operation.
	 */
	private Runnable duckDownVolumeRunnable = new Runnable() {

		@Override
		public void run() {
			if (mAudioManagerHelper.getCurrentVolume() > mAudioManagerHelper.getTargetVolume()) {
				mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, 
											  (mAudioManagerHelper.getCurrentVolume() - mAudioManagerHelper.getStepDownIncrement()), 
											  0);
				
				mAudioManagerHelper.setCurrentVolume( mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC));
			    mHandler.postDelayed(this, 50);
			}
			
		}
		
	};
	
	/**
	 * Fades in volume after a duck operation.
	 */
	private Runnable duckUpVolumeRunnable = new Runnable() {

		@Override
		public void run() {
			if (mAudioManagerHelper.getCurrentVolume() < mAudioManagerHelper.getTargetVolume()) {
				mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, 
											  (mAudioManagerHelper.getCurrentVolume() + mAudioManagerHelper.getStepUpIncrement()), 
											  0);
				
			    mAudioManagerHelper.setCurrentVolume(mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC));
			    mHandler.postDelayed(this, 50);
			}
			
		}
		
	};
	
	/**
	 * Called once mMediaPlayer is prepared.
	 */
    public OnPreparedListener mediaPlayerPrepared = new OnPreparedListener() {

		@Override
		public void onPrepared(MediaPlayer mediaPlayer) {
			
			//Update the prepared flag.
			setIsMediaPlayerPrepared(true);
			
			//Set the completion listener for mMediaPlayer.
			getMediaPlayer().setOnCompletionListener(onMediaPlayerCompleted);

			//Check to make sure we have AudioFocus.
			if (checkAndRequestAudioFocus()==true) {
				
				//Check if the the user saved the track's last playback position.
				if (getMediaPlayerSongHelper().getSavedPosition()!=-1) {
					//Seek to the saved track position.
					mMediaPlayer.seekTo((int) getMediaPlayerSongHelper().getSavedPosition());
					mApp.broadcastUpdateUICommand(new String[] { Common.SHOW_AUDIOBOOK_TOAST }, 
												  new String[] { "" + getMediaPlayerSongHelper().getSavedPosition() });

				}
				
				//This is the first time mMediaPlayer has been prepared, so start it immediately.
				if (mFirstRun) {
					startMediaPlayer();
					mFirstRun = false;
				}
				
			} else {
				return;
			}

		}
    	
    };
	
	/**
	 * Called once mMediaPlayer2 is prepared.
	 */
    public OnPreparedListener mediaPlayer2Prepared = new OnPreparedListener() {

		@Override
		public void onPrepared(MediaPlayer mediaPlayer) {
			
			//Update the prepared flag.
			setIsMediaPlayer2Prepared(true);
			
			//Set the completion listener for mMediaPlayer2.
			getMediaPlayer2().setOnCompletionListener(onMediaPlayer2Completed);

			//Check to make sure we have AudioFocus.
			if (checkAndRequestAudioFocus()==true) {
				
				//Check if the the user saved the track's last playback position.
				if (getMediaPlayer2SongHelper().getSavedPosition()!=-1) {
					//Seek to the saved track position.
					mMediaPlayer2.seekTo((int) getMediaPlayer2SongHelper().getSavedPosition());
					mApp.broadcastUpdateUICommand(new String[] { Common.SHOW_AUDIOBOOK_TOAST }, 
												  new String[] { "" + getMediaPlayer2SongHelper().getSavedPosition() });

				}
				
			} else {
				return;
			}
			
		}
    	
    };
    
    /**
     * Completion listener for mMediaPlayer.
     */
	private OnCompletionListener onMediaPlayerCompleted = new OnCompletionListener() { 
		
		@Override
		public void onCompletion(MediaPlayer mp) {
			
			//Remove the crossfade playback.
            mHandler.removeCallbacks(startCrossFadeRunnable);
			mHandler.removeCallbacks(crossFadeRunnable);
			
			//Set the track position handler (notifies the handler when the track should start being faded).
			if (mHandler!=null && mApp.isCrossfadeEnabled()) {
				mHandler.post(startCrossFadeRunnable);
			}

			//Reset the fadeVolume variables.
			mFadeInVolume = 0.0f;
			mFadeOutVolume = 1.0f;
			
			//Reset the volumes for both mediaPlayers.
			getMediaPlayer().setVolume(1.0f, 1.0f);
			getMediaPlayer2().setVolume(1.0f, 1.0f);

			try {
				if (isAtEndOfQueue() && getRepeatMode()!=Common.REPEAT_PLAYLIST) {
					stopSelf();
				} else if (isMediaPlayer2Prepared()) {
					startMediaPlayer2();
				} else {
					//Check every 100ms if mMediaPlayer2 is prepared.
					mHandler.post(startMediaPlayer2IfPrepared);
				}
				
			} catch (IllegalStateException e) {
				//mMediaPlayer2 isn't prepared yet.
				mHandler.post(startMediaPlayer2IfPrepared);
			}

		}
		
	};
	
	/**
	 * Completion listener for mMediaPlayer2.
	 */
	private OnCompletionListener onMediaPlayer2Completed = new OnCompletionListener() { 
		
		@Override
		public void onCompletion(MediaPlayer mp) {
			
			//Remove the crossfade playback.
            mHandler.removeCallbacks(startCrossFadeRunnable);
			mHandler.removeCallbacks(crossFadeRunnable);
			
			//Set the track position handler (notifies the handler when the track should start being faded).
			if (mHandler!=null && mApp.isCrossfadeEnabled()) {
				mHandler.post(startCrossFadeRunnable);
			}

			//Reset the fadeVolume variables.
			mFadeInVolume = 0.0f;
			mFadeOutVolume = 1.0f;
			
			//Reset the volumes for both mediaPlayers.
			getMediaPlayer().setVolume(1.0f, 1.0f);
			getMediaPlayer2().setVolume(1.0f, 1.0f);

			try {
				if (isAtEndOfQueue() && getRepeatMode()!=Common.REPEAT_PLAYLIST) {
					stopSelf();
				} else if (isMediaPlayerPrepared()) {
					startMediaPlayer();
				} else {
					//Check every 100ms if mMediaPlayer is prepared.
					mHandler.post(startMediaPlayerIfPrepared);
				}
				
			} catch (IllegalStateException e) {
				//mMediaPlayer isn't prepared yet.
				mHandler.post(startMediaPlayerIfPrepared);
			}

		}
		
	};
	
    /**
     * Buffering listener.
     */
    public OnBufferingUpdateListener bufferingListener = new OnBufferingUpdateListener() {

		@Override
		public void onBufferingUpdate(MediaPlayer mp, int percent) {
			
			if (mApp.getSharedPreferences().getBoolean("NOW_PLAYING_ACTIVE", false)==true) {
				
				if (mp==getCurrentMediaPlayer()) {
					float max = mp.getDuration()/1000;
					float maxDividedByHundred = max/100;
					mApp.broadcastUpdateUICommand(new String[] { Common.UPDATE_BUFFERING_PROGRESS }, 
												  new String[] { "" + (int) (percent*maxDividedByHundred) });
				}

			}
			
		}
    	
    };
    
    /**
     * Error listener for mMediaPlayer.
     */
    public OnErrorListener onErrorListener = new OnErrorListener() {

		@Override
		public boolean onError(MediaPlayer mMediaPlayer, int what, int extra) {
			/* This error listener might seem like it's not doing anything. 
			 * However, removing this will cause the mMediaPlayer object to go crazy 
			 * and skip around. The key here is to make this method return true. This 
			 * notifies the mMediaPlayer object that we've handled all errors and that 
			 * it shouldn't do anything else to try and remedy the situation. 
			 * 
			 * TL;DR: Don't touch this interface. Ever.
			 */
			return true;
		}
    	
    };
    
	/**
	 * Starts mMediaPlayer if it is prepared and ready for playback. 
	 * Otherwise, continues checking every 100ms if mMediaPlayer is prepared.
	 */
	private Runnable startMediaPlayerIfPrepared = new Runnable() {

		@Override
		public void run() {
			if (isMediaPlayerPrepared())
				startMediaPlayer();
			else
				mHandler.postDelayed(this, 100);
			
			
		}
		
	};
	
	/**
	 * Starts mMediaPlayer if it is prepared and ready for playback.
	 * Otherwise, continues checking every 100ms if mMediaPlayer2 is prepared.
	 */
	private Runnable startMediaPlayer2IfPrepared = new Runnable() {

		@Override
		public void run() {
			if (isMediaPlayer2Prepared())
				startMediaPlayer2();
			else
				mHandler.postDelayed(this, 100);
			
			
		}
		
	};

	/**
	 * First runnable that handles the cross fade operation between two tracks.
	 */
	public Runnable startCrossFadeRunnable = new Runnable() {

		@Override
		public void run() {

			//Check if we're in the last part of the current song.
			try {
				if (getCurrentMediaPlayer().isPlaying()) {

					int currentTrackDuration = getCurrentMediaPlayer().getDuration();
					int currentTrackFadePosition = currentTrackDuration - (mCrossfadeDuration*1000);
					if (getCurrentMediaPlayer().getCurrentPosition() >= currentTrackFadePosition) {
						//Launch the next runnable that will handle the cross fade effect.
						mHandler.postDelayed(crossFadeRunnable, 100);

					} else {
						mHandler.postDelayed(startCrossFadeRunnable, 1000);
					}

				} else {
					mHandler.postDelayed(startCrossFadeRunnable, 1000);
				}

			} catch (Exception e) {
				e.printStackTrace();
			}

		}

	};

	/**
	 * Crossfade runnable.
	 */
	public Runnable crossFadeRunnable = new Runnable() {

		@Override
		public void run() {
			try {
				
				//Do not crossfade if the current song is set to repeat itself.
				if (getRepeatMode()!=Common.REPEAT_SONG) {
					
					//Do not crossfade if this is the last track in the queue.
					if (getCursor().getCount() > (mCurrentSongIndex+1)) {
						
						//Set the next mMediaPlayer's volume and raise it incrementally.
						if (getCurrentMediaPlayer()==getMediaPlayer()) {
							
							getMediaPlayer2().setVolume(mFadeInVolume, mFadeInVolume);
							getMediaPlayer().setVolume(mFadeOutVolume, mFadeOutVolume);
							
							//If the mMediaPlayer is already playing or it hasn't been prepared yet, we can't use crossfade.
							if (!getMediaPlayer2().isPlaying()) {
								
								if (mMediaPlayer2Prepared==true) {

									if (checkAndRequestAudioFocus()==true) {
										
										//Check if the the user requested to save the track's last playback position.
										if (getMediaPlayer2SongHelper().getSavedPosition()!=-1) {
											//Seek to the saved track position.
											getMediaPlayer2().seekTo((int) getMediaPlayer2SongHelper().getSavedPosition());
											mApp.broadcastUpdateUICommand(new String[] { Common.SHOW_AUDIOBOOK_TOAST }, 
																		  new String[] { "" + getMediaPlayer2SongHelper().getSavedPosition() });
											
										}
										
										getMediaPlayer2().start();
									} else {
										return;
									}
									
								}
								
							}
							
						} else {
							
							getMediaPlayer().setVolume(mFadeInVolume, mFadeInVolume);
							getMediaPlayer2().setVolume(mFadeOutVolume, mFadeOutVolume);
							
							//If the mMediaPlayer is already playing or it hasn't been prepared yet, we can't use crossfade.
							if (!getMediaPlayer().isPlaying()) {
								
								if (mMediaPlayerPrepared==true) {

									if (checkAndRequestAudioFocus()==true) {
										
										//Check if the the user requested to save the track's last playback position.
										if (getMediaPlayerSongHelper().getSavedPosition()!=-1) {
											//Seek to the saved track position.
											getMediaPlayer().seekTo((int) getMediaPlayerSongHelper().getSavedPosition());
											mApp.broadcastUpdateUICommand(new String[] { Common.SHOW_AUDIOBOOK_TOAST }, 
																		  new String[] { "" + getMediaPlayerSongHelper().getSavedPosition() });
											
										}
										
										getMediaPlayer().start();
									} else {
										return;
									}
									
								}
								
							}
							
						}

						mFadeInVolume = mFadeInVolume + (float) (1.0f/(((float) mCrossfadeDuration)*10.0f));
						mFadeOutVolume = mFadeOutVolume - (float) (1.0f/(((float) mCrossfadeDuration)*10.0f));

						mHandler.postDelayed(crossFadeRunnable, 100);
					}
					
				}

			} catch (Exception e) {
				e.printStackTrace();
			}
			
		}
		
	};
	
	/**
	 * Grabs the song parameters at the specified index, retrieves its 
	 * data source, and beings to asynchronously prepare mMediaPlayer. 
	 * Once mMediaPlayer is prepared, mediaPlayerPrepared is called.
	 * 
	 * @return True if the method completed with no exceptions. False, otherwise.
	 */
	public boolean prepareMediaPlayer(int songIndex) {
		
		try {

            //Stop here if we're at the end of the queue.
            if (songIndex==-1)
                return true;

			//Reset mMediaPlayer to it's uninitialized state.
	    	getMediaPlayer().reset();
	    	
    		//Loop the player if the repeat mode is set to repeat the current song.
    		if (getRepeatMode()==Common.REPEAT_SONG) {
    			getMediaPlayer().setLooping(true);
    		}

	    	//Set mMediaPlayer's song data.
	    	SongHelper songHelper = new SongHelper();
	    	if (mFirstRun) {
	    		/*
	    		 * We're not preloading the next song (mMediaPlayer2 is not 
	    		 * playing right now). mMediaPlayer's song is pointed at 
	    		 * by mCurrentSongIndex.
	    		 */
	    		songHelper.populateSongData(mContext, songIndex);
                setMediaPlayerSongHelper(songHelper);

	    		//Set this service as a foreground service.
	    		startForeground(mNotificationId, buildNotification(songHelper));

	    	} else {
	    		songHelper.populateSongData(mContext, songIndex);
                setMediaPlayerSongHelper(songHelper);
	    	}

    		/*
    		 * Set the data source for mMediaPlayer and start preparing it 
    		 * asynchronously.
    		 */
	    	getMediaPlayer().setDataSource(mContext, getSongDataSource(getMediaPlayerSongHelper()));
			getMediaPlayer().setOnPreparedListener(mediaPlayerPrepared);
            getMediaPlayer().setOnErrorListener(onErrorListener);
            getMediaPlayer().prepareAsync();

        } catch (Exception e) {
            Log.e("DEBUG", "MESSAGE", e);
            e.printStackTrace();

            //Display an error toast to the user.
            showErrorToast();

            //Add the current song index to the list of failed indeces.
            getFailedIndecesList().add(songIndex);

            //Start preparing the next song.
            if (!isAtEndOfQueue() || mFirstRun)
                prepareMediaPlayer(songIndex+1);
            else
                return false;

            return false;
        }

		return true;
	}
	
	/**
	 * Grabs the song parameters at the specified index, retrieves its 
	 * data source, and beings to asynchronously prepare mMediaPlayer2. 
	 * Once mMediaPlayer2 is prepared, mediaPlayer2Prepared is called.
	 * 
	 * @return True if the method completed with no exceptions. False, otherwise.
	 */
	public boolean prepareMediaPlayer2(int songIndex) {
		
		try {

            //Stop here if we're at the end of the queue.
            if (songIndex==-1)
                return true;
			
			//Reset mMediaPlayer2 to its uninitialized state.
	    	getMediaPlayer2().reset();
	    	
    		//Loop the player if the repeat mode is set to repeat the current song.
    		if (getRepeatMode()==Common.REPEAT_SONG) {
    			getMediaPlayer2().setLooping(true);
    		}
	    	
	    	//Set mMediaPlayer2's song data.
	    	SongHelper songHelper = new SongHelper();
	    	songHelper.populateSongData(mContext, songIndex);
	    	setMediaPlayer2SongHelper(songHelper);

    		/*
    		 * Set the data source for mMediaPlayer and start preparing it 
    		 * asynchronously.
    		 */
	    	getMediaPlayer2().setDataSource(mContext, getSongDataSource(getMediaPlayer2SongHelper()));
			getMediaPlayer2().setOnPreparedListener(mediaPlayer2Prepared);
			getMediaPlayer2().setOnErrorListener(onErrorListener);
			getMediaPlayer2().prepareAsync();

		} catch (Exception e) {
			e.printStackTrace();

            //Display an error toast to the user.
            showErrorToast();

			//Add the current song index to the list of failed indeces.
			getFailedIndecesList().add(songIndex);
			
			//Start preparing the next song.
			if (!isAtEndOfQueue())
				prepareMediaPlayer2(songIndex+1);
			else
				return false;
			
			return false;
		}
		
		return true;
	}
	
	/**
	 * Returns the Uri of a song's data source. 
	 * If the song is a local file, its file path is 
	 * returned. If the song is from GMusic, its local 
	 * copy path is returned (if it exists). If no local 
	 * copy exists, the song's remote URL is requested 
	 * from Google's servers and a temporary placeholder 
	 * (URI_BEING_LOADED) is returned.
	 */
	private Uri getSongDataSource(SongHelper songHelper) {

		if (songHelper.getSource().equals(DBAccessHelper.GMUSIC)) {
			
			//Check if a local copy of the song exists.
			if (songHelper.getLocalCopyPath()!=null && 
				songHelper.getLocalCopyPath().length() > 2) {
				
				//Double check to make sure that the local copy file exists.
				if (new File(songHelper.getLocalCopyPath()).exists()) {
					//The local copy exists. Return its path.
					return Uri.parse(songHelper.getLocalCopyPath());
				} else {
					//The local copy doesn't exist. Request the remote URL and return a placeholder Uri.
					AsyncGetSongStreamURLTask task = new AsyncGetSongStreamURLTask(mContext, songHelper.getId());
					task.execute();
					
					return URI_BEING_LOADED;
				}
				
			} else {
				//Request the remote URL and return a placeholder Uri.
				AsyncGetSongStreamURLTask task = new AsyncGetSongStreamURLTask(mContext, songHelper.getId());
				task.execute();
				
				return URI_BEING_LOADED;			
			}
			
		} else {
			//Return the song's file path.
			return Uri.parse(songHelper.getFilePath());
		}
		
	}
	
	/**
	 * Updates all open homescreen/lockscreen widgets.
	 */
	public void updateWidgets() {
		try {
			//Fire a broadcast message to the widget(s) to update them.
			Intent smallWidgetIntent = new Intent(mContext, SmallWidgetProvider.class);
			smallWidgetIntent.setAction("android.appwidget.action.APPWIDGET_UPDATE");
			int smallWidgetIds[] = AppWidgetManager.getInstance(mContext).getAppWidgetIds(new ComponentName(mContext, SmallWidgetProvider.class));
			smallWidgetIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, smallWidgetIds);
			mContext.sendBroadcast(smallWidgetIntent);
			
			Intent largeWidgetIntent = new Intent(mContext, LargeWidgetProvider.class);
			largeWidgetIntent.setAction("android.appwidget.action.APPWIDGET_UPDATE");
			int largeWidgetIds[] = AppWidgetManager.getInstance(mContext).getAppWidgetIds(new ComponentName(mContext, LargeWidgetProvider.class));
			largeWidgetIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, largeWidgetIds);
			mContext.sendBroadcast(largeWidgetIntent);
			
			Intent blurredWidgetIntent = new Intent(mContext, BlurredWidgetProvider.class);
			blurredWidgetIntent.setAction("android.appwidget.action.APPWIDGET_UPDATE");
			int blurredWidgetIds[] = AppWidgetManager.getInstance(mContext).getAppWidgetIds(new ComponentName(mContext, BlurredWidgetProvider.class));
			blurredWidgetIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, blurredWidgetIds);
			mContext.sendBroadcast(blurredWidgetIntent);
			
			Intent albumArtWidgetIntent = new Intent(mContext, AlbumArtWidgetProvider.class);
			albumArtWidgetIntent.setAction("android.appwidget.action.APPWIDGET_UPDATE");
			int albumArtWidgetIds[] = AppWidgetManager.getInstance(mContext).getAppWidgetIds(new ComponentName(mContext, AlbumArtWidgetProvider.class));
			albumArtWidgetIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, albumArtWidgetIds);
			mContext.sendBroadcast(albumArtWidgetIntent);
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	
	/**
	 * Sets the A-B Repeat song markers.
	 * 
	 * @param pointA The duration to repeat from (in millis).
	 * @param pointB The duration to repeat until (in millis).
	 */
	public void setRepeatSongRange(int pointA, int pointB) {
		mRepeatSongRangePointA = pointA;
		mRepeatSongRangePointB = pointB;
		getCurrentMediaPlayer().seekTo(pointA);
		mHandler.postDelayed(checkABRepeatRange, 100);
	}
	
	/**
	 * Clears the A-B Repeat song markers.
	 */
	public void clearABRepeatRange() {
		mHandler.removeCallbacks(checkABRepeatRange);
		mRepeatSongRangePointA = 0;
		mRepeatSongRangePointB = 0;
		mApp.getSharedPreferences().edit().putInt(Common.REPEAT_MODE, Common.REPEAT_OFF);
	}
	
	/**
	 * Called repetitively to check for A-B repeat markers.
	 */
	private Runnable checkABRepeatRange = new Runnable() {

		@Override
		public void run() {
			try {
				if (getCurrentMediaPlayer().isPlaying()) {
					
					if (getCurrentMediaPlayer().getCurrentPosition()>= (mRepeatSongRangePointB)) {
						getCurrentMediaPlayer().seekTo(mRepeatSongRangePointA);
					}
					
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
			
			if (mApp.getSharedPreferences().getInt(Common.REPEAT_MODE, Common.REPEAT_OFF)==Common.A_B_REPEAT) {
				mHandler.postDelayed(checkABRepeatRange, 100);
			}
			
		}
		
	};
	
	/**
	 * Fix for KitKat error where the service is killed as soon 
	 * as the app is swiped away from the Recents menu.
	 */
	@Override
	public void onTaskRemoved(Intent rootIntent) {
	   Intent intent = new Intent(this, KitKatFixActivity.class);
	   intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	   startActivity(intent);
	   
	}

    /**
     * Displays an error toast.
     */
    private void showErrorToast() {
        Toast.makeText(mContext, R.string.song_failed_to_load, Toast.LENGTH_SHORT).show();
    }
	
	/**
	 * Deploys the current track's data to the specified 
	 * scrobbler.
	 * 
	 * @param state The scrobble state.
	 */
	public void scrobbleTrack(int state) {
		
		//If scrobbling is enabled, send out the appropriate action events.
		if (mApp.getSharedPreferences().getInt("SCROBBLING", 0)==0) {
			//Scrobbling is disabled.
			return;
		} 
		
		//Get the metadata of the track.
		getCursor().moveToPosition(mPlaybackIndecesList.get(mCurrentSongIndex));
		String songTitle = getCursor().getString(getCursor().getColumnIndex(DBAccessHelper.SONG_TITLE));
		String songArtist = getCursor().getString(getCursor().getColumnIndex(DBAccessHelper.SONG_ARTIST));
		String songAlbum = getCursor().getString(getCursor().getColumnIndex(DBAccessHelper.SONG_ALBUM));
		
		int songDurationInSecs;
		try {
			songDurationInSecs = getCursor().getInt(getCursor().getColumnIndex(DBAccessHelper.SONG_DURATION)) / 1000;
		} catch (Exception e) {
			songDurationInSecs = 0;
		}
		
		
		if (mApp.getSharedPreferences().getInt("SCROBBLING", 0)==1) {
			//Simple LastFM Helper.
			SimpleLastFMHelper.initializeActionIntent();
			SimpleLastFMHelper.attachMetadata(state, songArtist, songAlbum, songTitle, songDurationInSecs);
			SimpleLastFMHelper.sendBroadcast(mContext);
			
		} else if (mApp.getSharedPreferences().getInt("SCROBBLING", 0)==2) {
			//Scrobble Droid.
			ScrobbleDroidHelper.initializeActionIntent();
			if (state==SimpleLastFMHelper.START || state==SimpleLastFMHelper.RESUME) {
				ScrobbleDroidHelper.attachMetadata(true, songArtist, songAlbum, songTitle, songDurationInSecs);
			} else if (state==SimpleLastFMHelper.PAUSE) {
				ScrobbleDroidHelper.attachMetadata(false, songArtist, songAlbum, songTitle, songDurationInSecs);
			}
			
			ScrobbleDroidHelper.sendBroadcast(mContext);
		}
		
	}
	
	/**
	 * Checks if we have AudioFocus. If not, it explicitly requests it.
	 * 
	 * @return True if we have AudioFocus. False, otherwise.
	 */
	private boolean checkAndRequestAudioFocus() {
		if (mAudioManagerHelper.hasAudioFocus()==false) {
			if (requestAudioFocus()==true) {
				return true;
			} else {
				//Unable to get focus. Notify the user.
				Toast.makeText(mContext, R.string.unable_to_get_audio_focus, Toast.LENGTH_LONG).show();
				return false;
			}
			
		} else {
			return true;
		}
		
	}
	
	/**
	 * Registers the headset plug receiver.
	 */
	public void registerHeadsetPlugReceiver() {
		//Register the headset plug receiver.
		if (mApp.getSharedPreferences().getString("UNPLUG_ACTION", "DO_NOTHING").equals("PAUSE_MUSIC_PLAYBACK")) {
			IntentFilter filter = new IntentFilter(Intent.ACTION_HEADSET_PLUG);
			mHeadsetPlugReceiver = new HeadsetPlugBroadcastReceiver();
		    mService.registerReceiver(mHeadsetPlugReceiver, filter);
		}
		
	}
	
    /**
     * Increments mCurrentSongIndex based on mErrorCount. 
     * Returns the new value of mCurrentSongIndex.
     */
    public int incrementCurrentSongIndex() {
    	if ((getCurrentSongIndex()+1) < getCursor().getCount())
    		mCurrentSongIndex++;

    	return mCurrentSongIndex;
    }
    
    /**
     * Decrements mCurrentSongIndex by one. Returns the new value 
     * of mCurrentSongIndex.
     */
    public int decrementCurrentSongIndex() {
    	if ((getCurrentSongIndex()-1) > -1)
    		mCurrentSongIndex--;
    	
    	return mCurrentSongIndex;
    }
    
    /**
     * Increments mEnqueueReorderScalar. Returns the new value 
     * of mEnqueueReorderScalar.
     */
    public int incrementEnqueueReorderScalar() {
    	mEnqueueReorderScalar++;
    	return mCurrentSongIndex;
    }
    
    /**
     * Decrements mEnqueueReorderScalar. Returns the new value 
     * of mEnqueueReorderScalar.
     */
    public int decrementEnqueueReorderScalar() {
    	mEnqueueReorderScalar--;
    	return mCurrentSongIndex;
    }
    
    /**
     * Starts playing mMediaPlayer and sends out the update UI broadcast, 
     * and updates the notification and any open widgets.
     *  
     * Do NOT call this method before mMediaPlayer has been prepared.
     */
    private void startMediaPlayer() throws IllegalStateException {
    	
    	//Set the media player's equalizer/audio fx.
    	applyMediaPlayerEQ(getMediaPlayerSongHelper().getId());
    	
    	//Aaaaand let the show begin!
    	setCurrentMediaPlayer(1);
    	getMediaPlayer().start();
    	
    	//Set the new value for mCurrentSongIndex.
    	if (mFirstRun==false) {
        	do {
        		setCurrentSongIndex(determineNextSongIndex());
        	} while (getFailedIndecesList().contains(getCurrentSongIndex()));
    		
    		getFailedIndecesList().clear();
    		
    	} else {
    		while (getFailedIndecesList().contains(getCurrentSongIndex())) {
    			setCurrentSongIndex(determineNextSongIndex());
    		}

            //Initialize the crossfade runnable.
            if (mHandler!=null && mApp.isCrossfadeEnabled()) {
                mHandler.post(startCrossFadeRunnable);
            }
    		
    	}

    	
    	//Update the UI.
		String[] updateFlags = new String[] { Common.UPDATE_PAGER_POSTIION, 
											  Common.UPDATE_PLAYBACK_CONTROLS, 
											  Common.HIDE_STREAMING_BAR, 
											  Common.UPDATE_SEEKBAR_DURATION, 
											  Common.UPDATE_EQ_FRAGMENT };
		
		String[] flagValues = new String[] { getCurrentSongIndex() + "", 
											 "",
											 "", 
											 getMediaPlayer().getDuration() + "", 
											 "" };
		
		mApp.broadcastUpdateUICommand(updateFlags, flagValues); 
		setCurrentSong(getCurrentSong());
		
		//Start preparing the next song.
		prepareMediaPlayer2(determineNextSongIndex());
    }
    
    /**
     * Starts playing mMediaPlayer2, sends out the update UI broadcast,
     * and updates the notification and any open widgets.
     *
     * Do NOT call this method before mMediaPlayer2 has been prepared.
     */
    private void startMediaPlayer2() throws IllegalStateException {
    	
    	//Set the media player's equalizer/audio fx.
    	applyMediaPlayer2EQ(getMediaPlayer2SongHelper().getId());
    	
    	//Aaaaaand let the show begin!
    	setCurrentMediaPlayer(2);
    	getMediaPlayer2().start();
    	
    	//Set the new value for mCurrentSongIndex.
    	do {
    		setCurrentSongIndex(determineNextSongIndex());
    	} while (getFailedIndecesList().contains(getCurrentSongIndex()));
    	
		getFailedIndecesList().clear();
    	
    	//Update the UI.
		String[] updateFlags = new String[] { Common.UPDATE_PAGER_POSTIION, 
											  Common.UPDATE_PLAYBACK_CONTROLS, 
											  Common.HIDE_STREAMING_BAR, 
											  Common.UPDATE_SEEKBAR_DURATION, 
											  Common.UPDATE_EQ_FRAGMENT };
		
		String[] flagValues = new String[] { getCurrentSongIndex() + "", 
											 "",
											 "", 
											 getMediaPlayer2().getDuration() + "", 
											 "" };
		
		mApp.broadcastUpdateUICommand(updateFlags, flagValues); 
		setCurrentSong(getCurrentSong());
    	
		//Start preparing the next song.
		prepareMediaPlayer(determineNextSongIndex());
    }
    
    /**
     * Starts/resumes the current media player. Returns true if 
     * the operation succeeded. False, otherwise.
     */
    public boolean startPlayback() {
    	
    	try {
    		//Check to make sure we have audio focus.
    		if (checkAndRequestAudioFocus()) {
        		getCurrentMediaPlayer().start();
        		
        		//Update the UI and scrobbler.
        		String[] updateFlags = new String[] { Common.UPDATE_PLAYBACK_CONTROLS };
        		String[] flagValues = new String[] { "" };
        		
        		mApp.broadcastUpdateUICommand(updateFlags, flagValues);
        		updateNotification(mApp.getService().getCurrentSong());
    			updateWidgets();
    			scrobbleTrack(SimpleLastFMHelper.START);
    			
    		} else {
    			return false;
    		}
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    		return false;
    	}
    	
    	return true;
    }
    
    /**
     * Pauses the current media player. Returns true if 
     * the operation succeeded. False, otherwise.
     */
    public boolean pausePlayback() {
    	
    	try {
    		getCurrentMediaPlayer().pause();
    		
    		//Update the UI and scrobbler.
    		String[] updateFlags = new String[] { Common.UPDATE_PLAYBACK_CONTROLS };
    		String[] flagValues = new String[] { "" };
    		
    		mApp.broadcastUpdateUICommand(updateFlags, flagValues);
    		updateNotification(mApp.getService().getCurrentSong());
			updateWidgets();
			scrobbleTrack(SimpleLastFMHelper.PAUSE);
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    		return false;
    	}
    	
    	return true;
    }
    
    /**
     * Stops the current media player. Returns true if 
     * the operation succeeded. False, otherwise.
     */
    public boolean stopPlayback() {
    	
    	try {
    		getCurrentMediaPlayer().stop();
    		
    		//Update the UI and scrobbler.
    		String[] updateFlags = new String[] { Common.UPDATE_PLAYBACK_CONTROLS };
    		String[] flagValues = new String[] { "" };
    		
    		mApp.broadcastUpdateUICommand(updateFlags, flagValues);
    		updateNotification(mApp.getService().getCurrentSong());
			updateWidgets();
			scrobbleTrack(SimpleLastFMHelper.PAUSE);
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    		return false;
    	}
    	
    	return true;
    }

    /**
     * Skips to the next track (if there is one) and starts 
     * playing it. Returns true if the operation succeeded. 
     * False, otherwise.
     */
    public boolean skipToNextTrack() {
    	try {
    		//Reset both MediaPlayer objects.
    		getMediaPlayer().reset();
    		getMediaPlayer2().reset();
            clearCrossfadeCallbacks();
    		
    		//Loop the players if the repeat mode is set to repeat the current song.
    		if (getRepeatMode()==Common.REPEAT_SONG) {
    			getMediaPlayer().setLooping(true);
    			getMediaPlayer2().setLooping(true);
    		}
    		
			//Remove crossfade runnables and reset all volume levels.
			getHandler().removeCallbacks(crossFadeRunnable);
			getMediaPlayer().setVolume(1.0f, 1.0f);
			getMediaPlayer2().setVolume(1.0f, 1.0f);
    		
    		//Increment the song index.
    		incrementCurrentSongIndex();
    		
    		//Update the UI.
    		String[] updateFlags = new String[] { Common.UPDATE_PAGER_POSTIION };
    		String[] flagValues = new String[] { getCurrentSongIndex() + "" };
    		mApp.broadcastUpdateUICommand(updateFlags, flagValues);
    		
    		//Start the playback process.
    		mFirstRun = true;
    		prepareMediaPlayer(getCurrentSongIndex());
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    		return false;
    	}
    	
    	return true;
    }
    
    /**
     * Skips to the previous track (if there is one) and starts 
     * playing it. Returns true if the operation succeeded. 
     * False, otherwise.
     */
    public boolean skipToPreviousTrack() {

        /*
         * If the current track is not within the first three seconds,
         * reset it. If it IS within the first three seconds, skip to the
         * previous track.
         */
        try {
            if (getCurrentMediaPlayer().getCurrentPosition() > 3000) {
                getCurrentMediaPlayer().seekTo(0);
                return true;
            }

        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }

    	try {
    		//Reset both MediaPlayer objects.
    		getMediaPlayer().reset();
    		getMediaPlayer2().reset();
            clearCrossfadeCallbacks();
    		
    		//Loop the players if the repeat mode is set to repeat the current song.
    		if (getRepeatMode()==Common.REPEAT_SONG) {
    			getMediaPlayer().setLooping(true);
    			getMediaPlayer2().setLooping(true);
    		}
    		
    		//Remove crossfade runnables and reset all volume levels.
			getHandler().removeCallbacks(crossFadeRunnable);
			getMediaPlayer().setVolume(1.0f, 1.0f);
			getMediaPlayer2().setVolume(1.0f, 1.0f);
    		
    		//Decrement the song index.
    		decrementCurrentSongIndex();
    		
    		//Update the UI.
    		String[] updateFlags = new String[] { Common.UPDATE_PAGER_POSTIION };
    		String[] flagValues = new String[] { getCurrentSongIndex() + "" };
    		mApp.broadcastUpdateUICommand(updateFlags, flagValues);
    		
    		//Start the playback process.
    		mFirstRun = true;
    		prepareMediaPlayer(getCurrentSongIndex());
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    		return false;
    	}
    	
    	return true;
    }
    
    /**
     * Skips to the specified track index (if there is one) and starts 
     * playing it. Returns true if the operation succeeded. 
     * False, otherwise.
     */
    public boolean skipToTrack(int trackIndex) {
    	try {
    		//Reset both MediaPlayer objects.
    		getMediaPlayer().reset();
    		getMediaPlayer2().reset();
            clearCrossfadeCallbacks();
    		
    		//Loop the players if the repeat mode is set to repeat the current song.
    		if (getRepeatMode()==Common.REPEAT_SONG) {
    			getMediaPlayer().setLooping(true);
    			getMediaPlayer2().setLooping(true);
    		}
    		
    		//Remove crossfade runnables and reset all volume levels.
			getHandler().removeCallbacks(crossFadeRunnable);
			getMediaPlayer().setVolume(1.0f, 1.0f);
			getMediaPlayer2().setVolume(1.0f, 1.0f);
    		
    		//Update the song index.
    		setCurrentSongIndex(trackIndex);
    		
    		//Update the UI.
    		String[] updateFlags = new String[] { Common.UPDATE_PAGER_POSTIION };
    		String[] flagValues = new String[] { getCurrentSongIndex() + "" };
    		mApp.broadcastUpdateUICommand(updateFlags, flagValues);
    		
    		//Start the playback process.
    		mFirstRun = true;
    		prepareMediaPlayer(trackIndex);
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    		return false;
    	}
    	
    	return true;
    }
    
    /**
     * Toggles the playback state between playing and paused and 
     * returns whether the current media player is now playing 
     * music or not.
     */
    public boolean togglePlaybackState() {
    	if (isPlayingMusic())
    		pausePlayback();
    	else
    		startPlayback();
    	
    	return isPlayingMusic();
    }
    
    /**
     * Determines the next song's index based on the repeat 
     * mode and current song index. Returns -1 if we're at 
     * the end of the queue.
     */
    private int determineNextSongIndex() {
		if (isAtEndOfQueue() && getRepeatMode()==Common.REPEAT_PLAYLIST)
			return 0;
		else if (!isAtEndOfQueue() && getRepeatMode()==Common.REPEAT_SONG)
			return getCurrentSongIndex();
		else if (isAtEndOfQueue())
			return -1;
		else
			return (getCurrentSongIndex() + 1);
		
    }
    
    /**
     * Checks which MediaPlayer object is currently in use, and 
     * starts preparing the other one.
     */
    public void prepareAlternateMediaPlayer() {
    	if (mCurrentMediaPlayer==1)
    		prepareMediaPlayer2(determineNextSongIndex());
    	else
    		prepareMediaPlayer(determineNextSongIndex());
    	
    }
    
    /**
     * Toggles shuffle mode and returns whether shuffle is now on or off.
	 */
    public boolean toggleShuffleMode() {
    	if (isShuffleOn()) {
    		//Set shuffle off.
    		mApp.getSharedPreferences().edit().putBoolean(Common.SHUFFLE_ON, false).commit();

    		//Save the element at the current index.
    		int currentElement = getPlaybackIndecesList().get(getCurrentSongIndex());
    		
    		//Reset the cursor pointers list.
    		Collections.sort(getPlaybackIndecesList());
    		
    		//Reset the current index to the index of the old element.
    		setCurrentSongIndex(getPlaybackIndecesList().indexOf(currentElement));
    		
    		
    	} else {
    		//Set shuffle on.
    		mApp.getSharedPreferences().edit().putBoolean(Common.SHUFFLE_ON, true).commit();
    		
            //Build a new list that doesn't include the current song index.
            ArrayList<Integer> newList = new ArrayList<Integer>(getPlaybackIndecesList());
            newList.remove(getCurrentSongIndex());

            //Shuffle the new list.
            Collections.shuffle(newList, new Random(System.nanoTime()));

            //Plug in the current song index back into the new list.
            newList.add(getCurrentSongIndex(), getCurrentSongIndex());
            mPlaybackIndecesList = newList;

    		//Collections.shuffle(getPlaybackIndecesList().subList(0, getCurrentSongIndex()));
    		//Collections.shuffle(getPlaybackIndecesList().subList(getCurrentSongIndex()+1, getPlaybackIndecesList().size()));
    		
    	}
    	
    	/* Since the queue changed, we're gonna have to update the 
    	 * next MediaPlayer object with the new song info.
    	 */
    	prepareAlternateMediaPlayer();
    	
    	//Update all UI elements with the new queue order.
    	mApp.broadcastUpdateUICommand(new String[] { Common.NEW_QUEUE_ORDER }, new String[] { "" });
    	return isShuffleOn();
    }
    
    /**
     * Applies the specified repeat mode.
     */
    public void setRepeatMode(int repeatMode) {
    	if (repeatMode==Common.REPEAT_OFF || repeatMode==Common.REPEAT_PLAYLIST ||
    		repeatMode==Common.REPEAT_SONG || repeatMode==Common.A_B_REPEAT) {
    		//Save the repeat mode.
    		mApp.getSharedPreferences().edit().putInt(Common.REPEAT_MODE, repeatMode).commit();
    	} else {
    		//Just in case a bogus value is passed in.
    		mApp.getSharedPreferences().edit().putInt(Common.REPEAT_MODE, Common.REPEAT_OFF).commit();
    	}
    	
    	/* 
    	 * Set the both MediaPlayer objects to loop if the repeat mode 
    	 * is Common.REPEAT_SONG.
    	 */
    	try {
    		if (repeatMode==Common.REPEAT_SONG) {
    			getMediaPlayer().setLooping(true);
    			getMediaPlayer2().setLooping(true);
    		} else {
    			getMediaPlayer().setLooping(false);
    			getMediaPlayer2().setLooping(false);
    		}
    		
    		//Prepare the appropriate next song.
    		prepareAlternateMediaPlayer();
    		
    	} catch (Exception e) {
    		e.printStackTrace();
    	}

        /*
         * Remove the crossfade callbacks and reinitalize them
         * only if the user didn't select A-B repeat.
         */
        clearCrossfadeCallbacks();

        if (repeatMode!=Common.A_B_REPEAT)
            if (mHandler!=null && mApp.isCrossfadeEnabled())
                mHandler.post(startCrossFadeRunnable);
    	
    }
    
    /**
     * Returns the current active MediaPlayer object.
     */
    public MediaPlayer getCurrentMediaPlayer() {
    	if (mCurrentMediaPlayer==1)
    		return mMediaPlayer;
    	else
    		return mMediaPlayer2;
    }
    
    /**
     * Returns the primary MediaPlayer object. Don't 
     * use this method directly unless you have a good 
     * reason to explicitly call mMediaPlayer. Use 
     * getCurrentMediaPlayer() whenever possible.
     */
    public MediaPlayer getMediaPlayer() {
    	return mMediaPlayer;
    }
    
    /**
     * Returns the secondary MediaPlayer object. Don't 
     * use this method directly unless you have a good 
     * reason to explicitly call mMediaPlayer2. Use 
     * getCurrentMediaPlayer() whenever possible.
     */
    public MediaPlayer getMediaPlayer2() {
    	return mMediaPlayer2;
    }
    
    /**
     * Indicates if mMediaPlayer is prepared and 
     * ready for playback.
     */
    public boolean isMediaPlayerPrepared() {
    	return mMediaPlayerPrepared;
    }
    
    /**
     * Indicates if mMediaPlayer2 is prepared and 
     * ready for playback.
     */
    public boolean isMediaPlayer2Prepared() {
    	return mMediaPlayer2Prepared;
    }
    
    /**
     * Indicates if music is currently playing.
     */
    public boolean isPlayingMusic() {
    	try {
        	if (getCurrentMediaPlayer().isPlaying())
        		return true;
        	else
        		return false;
        	
    	} catch (Exception e) {
    		e.printStackTrace();
    		return false;
    	}

    }
    
    /**
     * Returns an instance of SongHelper. This 
     * object can be used to pull details about 
     * the current song.
     */
    public SongHelper getCurrentSong() {
    	if (getCurrentMediaPlayer()==mMediaPlayer) {
    		return mMediaPlayerSongHelper;
    	} else {
    		return mMediaPlayer2SongHelper;
    	}
    	
    }

    /**
     * Removes all crossfade callbacks on the current
     * Handler object. Also resets the volumes of the
     * MediaPlayer objects to 1.0f.
     */
    private void clearCrossfadeCallbacks() {
        if (mHandler==null)
            return;

        mHandler.removeCallbacks(startCrossFadeRunnable);
        mHandler.removeCallbacks(crossFadeRunnable);

        try {
            getMediaPlayer().setVolume(1.0f, 1.0f);
            getMediaPlayer2().setVolume(1.0f, 1.0f);
        } catch (IllegalStateException e) {
            e.printStackTrace();
        }

    }
    
    /**
     * Returns mMediaPlayer's SongHelper instance.
     */
    public SongHelper getMediaPlayerSongHelper() {
    	return mMediaPlayerSongHelper;
    }
    
    /**
     * Returns mMediaPlayer2's SongHelper instance.
     */
    public SongHelper getMediaPlayer2SongHelper() {
    	return mMediaPlayer2SongHelper;
    }
    
    /**
     * Returns the service's cursor object.
     */
    public Cursor getCursor() {
    	return mCursor;
    }
    
    /**
     * Returns the list of playback indeces that are used 
     * to traverse the cursor object.
     */
    public ArrayList<Integer> getPlaybackIndecesList() {
    	return mPlaybackIndecesList;
    }
    
    /**
     * Returns the list of playback indeces that could 
     * not be played.
     */
    public ArrayList<Integer> getFailedIndecesList() {
    	return mFailedIndecesList;
    }
    
    /**
     * Returns the current value of mCurrentSongIndex.
     */
    public int getCurrentSongIndex() {
    	return mCurrentSongIndex;
    }
    
    /**
     * Indicates if the track was changed by the user.
     */
    public boolean getTrackChangedByUser() {
    	return mTrackChangedByUser;
    }
    
    /**
     * Indicates if an enqueue operation was performed.
     */
    public boolean getEnqueuePerformed() {
    	return mEnqueuePerformed;
    }
    
    /**
     * Returns the EqualizerHelper instance. This 
     * can be used to modify equalizer settings and 
     * toggle them on/off.
     */
    public EqualizerHelper getEqualizerHelper() {
    	return mEqualizerHelper;
    }
    
    /**
     * Returns the mAudioManagerHelper instance. This 
     * can be used to modify AudioFocus states.
     */
    public AudioManagerHelper getAudioManagerHelper() {
    	return mAudioManagerHelper;
    }
    
    /**
     * Returns the mHandler object.
     */
    public Handler getHandler() {
    	return mHandler;
    }
    
    /**
     * Returns the headset plug receiver object.
     */
    public HeadsetPlugBroadcastReceiver getHeadsetPlugReceiver() {
    	return mHeadsetPlugReceiver;
    }
    
    /**
     * Returns the current enqueue reorder scalar.
     */
    public int getEnqueueReorderScalar() {
    	return mEnqueueReorderScalar;
    }
    
    /**
     * Returns point A in milliseconds for A-B repeat.
     */
    public int getRepeatSongRangePointA() {
    	return mRepeatSongRangePointA;
    }
    
    /**
     * Returns point B in milliseconds for A-B repeat.
     */
    public int getRepeatSongRangePointB() {
    	return mRepeatSongRangePointB;
    }
    
    /**
     * Returns the current repeat mode. The repeat mode 
     * is determined based on the value that is saved in 
     * SharedPreferences.
     */
    public int getRepeatMode() {
    	return mApp.getSharedPreferences().getInt(Common.REPEAT_MODE, Common.REPEAT_OFF);
    }
    
    /**
     * Indicates if shuffle mode is turned on or off.
     */
    public boolean isShuffleOn() {
    	return mApp.getSharedPreferences().getBoolean(Common.SHUFFLE_ON, false);
    }
    
    /**
     * Indicates if mCurrentSongIndex points to the last 
     * song in the current queue.
     */
    public boolean isAtEndOfQueue() {
    	return (getCurrentSongIndex()==(getPlaybackIndecesList().size()-1));
    }
    
    /**
     * Indicates if mCurrentSongIndex points to the first 
     * song in the current queue.
     */
    public boolean isAtStartOfQueue() {
    	return getCurrentSongIndex()==0;
    }
    
	/**
	 * Sets the current active media player. Note that this 
	 * method does not modify the MediaPlayer objects in any 
	 * way. It simply changes the int variable that points to 
	 * the new current MediaPlayer object.
	 */
	public void setCurrentMediaPlayer(int currentMediaPlayer) {
		mCurrentMediaPlayer = currentMediaPlayer;
	}
	
	/**
	 * Sets the prepared flag for mMediaPlayer.
	 */
	public void setIsMediaPlayerPrepared(boolean prepared) {
		mMediaPlayerPrepared = prepared;
	}
	
	/**
	 * Sets the prepared flag for mMediaPlayer2.
	 */
	public void setIsMediaPlayer2Prepared(boolean prepared) {
		mMediaPlayer2Prepared = prepared;
	}

	/**
	 * Changes the value of mCurrentSongIndex.
	 */
	public void setCurrentSongIndex(int currentSongIndex) {
		mCurrentSongIndex = currentSongIndex;
	}
	
	/**
	 * Sets whether the track was changed by the user or not.
	 */
	public void setTrackChangedByUser(boolean trackChangedByUser) {
		mTrackChangedByUser = trackChangedByUser;
	}
	
	/**
	 * Sets whether an enqueue operation was performed or not.
	 */
	public void setEnqueuePerformed(boolean enqueuePerformed) {
		mEnqueuePerformed = enqueuePerformed;
	}
	
	/**
	 * Sets the new enqueue reorder scalar value.
	 */
	public void setEnqueueReorderScalar(int scalar) {
		mEnqueueReorderScalar = scalar;
	}
	
    /**
     * Sets point A in milliseconds for A-B repeat.
     */
    public void setRepeatSongRangePointA(int value) {
    	mRepeatSongRangePointA = value;
    }
    
    /**
     * Returns point B in milliseconds for A-B repeat.
     */
    public void getRepeatSongRangePointB(int value) {
    	mRepeatSongRangePointB = value;
    }
	
	/**
	 * Replaces the current cursor object with the new one.
	 */
	public void setCursor(Cursor cursor) {
		mCursor = cursor;
	}
	
	/**
	 * Moves the cursor back to the first song in the queue. 
	 * This does not necessarily move the cursor to index 0. 
	 * It moves it to the element at index 0 in 
	 * mPlaybackIndecesList.
	 */
	public void moveCursorToQueueStart() {
		getCursor().moveToPosition(getPlaybackIndecesList().get(0));
	}
	
	/**
	 * Moves the cursor forward to the last song in the queue. 
	 * This does not necessarily move the cursor to index 
	 * {cursorSize-1}. It moves it to the element at index 
	 * {cursorSize-1} in mPlaybackIndecesList.
	 */
	public void moveCursorToQueueEnd() {
		getCursor().moveToPosition(getPlaybackIndecesList().get(getPlaybackIndecesList().size()-1));
	}
	
	/**
	 * Moves the cursor to the specified index in the queue.
	 * Returns true if the index was valid and the cursor 
	 * position was moved successfully. False, otherwise.
	 */
	public boolean moveCursorToIndex(int index) {
		if (index < getCursor().getCount() && index > -1) {
			getCursor().moveToPosition(getPlaybackIndecesList().get(index));
			return true;
		} else {
			return false;
		}
		
	}
	
	/**
	 * Returns true if there's only one song in the current queue.
	 * False, otherwise.
	 */
	public boolean isOnlySongInQueue() {
		if (getCurrentSongIndex()==0 && getCursor().getCount()==1)
			return true;
		else
			return false;
		
	}
	
	/**
	 * Returns true if mCurrentSongIndex is pointing at the first 
	 * song in the queue and there is more than one song in the 
	 * queue. False, otherwise.
	 */
	public boolean isFirstSongInQueue() {
		if (getCurrentSongIndex()==0 && getCursor().getCount() > 1)
			return true;
		else
			return false;
		
	}
	
	/**
	 * Returns true if mCurrentSongIndex is pointing at the last 
	 * song in the queue. False, otherwise.
	 */
	public boolean isLastSongInQueue() {
		if (getCurrentSongIndex()==(getCursor().getCount()-1))
			return true;
		else
			return false;
		
	}
	
	/**
	 * Returns an instance of the PrepareServiceListener.
	 */
	public PrepareServiceListener getPrepareServiceListener() {
		return mPrepareServiceListener;
	}
	
	/**
	 * Sets the mPrepareServiceListener object.
	 */
	public void setPrepareServiceListener(PrepareServiceListener listener) {
		mPrepareServiceListener = listener;
	}
	
	/**
	 * Sets mMediaPlayerSongHelper.
	 */
	public void setMediaPlayerSongHelper(SongHelper songHelper) {
		mMediaPlayerSongHelper = songHelper;
	}
	
	/**
	 * Sets mMediaPlayer2SongHelper.
	 */
	public void setMediaPlayer2SongHelper(SongHelper songHelper) {
		mMediaPlayer2SongHelper = songHelper;
	}
	
	/**
	 * Sets the current MediaPlayer's SongHelper object. Also 
	 * indirectly calls the updateNotification() and updateWidgets() 
	 * methods via the [CURRENT SONG HELPER].setIsCurrentSong() method.
	 */
	private void setCurrentSong(SongHelper songHelper) {
		if (getCurrentMediaPlayer()==mMediaPlayer) {
			mMediaPlayerSongHelper = songHelper;
			mMediaPlayerSongHelper.setIsCurrentSong();
		} else {
			mMediaPlayer2SongHelper = songHelper;
			mMediaPlayer2SongHelper.setIsCurrentSong();
		}
		
	}
	
	/**
	 * (non-Javadoc)
	 * @see android.app.Service#onDestroy()
	 */
	@Override
	public void onDestroy() {

		//Notify the UI that the service is about to stop.
		mApp.broadcastUpdateUICommand(new String[] { Common.SERVICE_STOPPING }, 
									  new String[] { "" });
		
		//Fire a broadcast message to the widget(s) to update them.
		updateWidgets();
		
		//Send service stop event to GAnalytics.
		try {
			if (mApp.isGoogleAnalyticsEnabled()) {
				mTracker.set(Fields.SESSION_CONTROL, "end");
				mTracker.send(MapBuilder.createTiming("Jams Service", 
													  System.currentTimeMillis() - mServiceStartTime, 
													  "Service duration.", 
													  "User stopped music playback.")
						.build());
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		//Save the last track's info within the current queue.
		try {
			mApp.getSharedPreferences().edit().putLong("LAST_SONG_TRACK_POSITION", getCurrentMediaPlayer().getCurrentPosition());
		} catch (Exception e) {
			e.printStackTrace();
			mApp.getSharedPreferences().edit().putLong("LAST_SONG_TRACK_POSITION", 0);
		}
		
		//If the current song is repeating a specific range, reset the repeat option.
		if (getRepeatMode()==Common.REPEAT_SONG) {
			setRepeatMode(Common.REPEAT_OFF);
		}
		
		mFadeInVolume = 0.0f;
		mFadeOutVolume = 1.0f;
		
		//Unregister the headset plug receiver and RemoteControlClient.
		try {
			RemoteControlHelper.unregisterRemoteControlClient(mAudioManager, mRemoteControlClientCompat);
			unregisterReceiver(mHeadsetPlugReceiver);
		} catch (Exception e) {
			//Just null out the receiver if it hasn't been registered yet.
			mHeadsetPlugReceiver = null;
		}
		
		//Remove the notification.
		NotificationManager notificationManager = (NotificationManager) this.getSystemService(NOTIFICATION_SERVICE);
		notificationManager.cancel(mNotificationId);
		
		try {
			mEqualizerHelper.releaseEQObjects();
			mEqualizerHelper = null;
		} catch (Exception e1) {
			e1.printStackTrace();
			mEqualizerHelper = null;
		}

		if (mMediaPlayer!=null)
			mMediaPlayer.release();
		
		if (mMediaPlayer2!=null)
			getMediaPlayer2().release();
		
		mMediaPlayer = null;
		mMediaPlayer2 = null;
		
		//Close the cursor(s).
		try {
			getCursor().close();
			setCursor(null);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		//Final scrobbling.
		scrobbleTrack(SimpleLastFMHelper.PAUSE);

        /*
         * If A-B repeat is enabled, disable it to prevent the
         * next service instance from repeating the same section
         * over and over on the new track.
         */
        if (getRepeatMode()==Common.A_B_REPEAT)
            setRepeatMode(Common.REPEAT_OFF);

		//Remove audio focus and unregister the audio buttons receiver.
		mAudioManagerHelper.setHasAudioFocus(false);
		mAudioManager.abandonAudioFocus(audioFocusChangeListener);
		mAudioManager.unregisterMediaButtonEventReceiver(new ComponentName(getPackageName(), HeadsetButtonsReceiver.class.getName()));
		mAudioManager = null;
		mMediaButtonReceiverComponent = null;
		mRemoteControlClientCompat = null;
		
		//Nullify the service object.
		mApp.setService(null);
		mApp.setIsServiceRunning(false);
		mApp = null;
		
	}

    /**
     * Interface implementation to listen for service cursor events.
     */
    public BuildCursorListener buildCursorListener = new BuildCursorListener() {

        @Override
        public void onServiceCursorReady(Cursor cursor, int currentSongIndex, boolean playAll) {

            if (cursor.getCount()==0) {
                Toast.makeText(mContext, R.string.no_audio_files_found, Toast.LENGTH_SHORT).show();
                if (mApp.getNowPlayingActivity()!=null)
                    mApp.getNowPlayingActivity().finish();

                return;
            }

            setCursor(cursor);
            setCurrentSongIndex(currentSongIndex);
            getFailedIndecesList().clear();
            initPlaybackIndecesList(playAll);
            mFirstRun = true;
            prepareMediaPlayer(currentSongIndex);

            //Notify NowPlayingActivity to initialize its ViewPager.
            mApp.broadcastUpdateUICommand(new String[] { Common.INIT_PAGER },
                    new String[] { "" });

        }

        @Override
        public void onServiceCursorFailed(String exceptionMessage) {
            //We don't have a valid cursor, so stop the service.
            Log.e("SERVICE CURSOR EXCEPTION", "onServiceCursorFailed(): " + exceptionMessage);
            Toast.makeText(mContext, R.string.unable_to_start_playback, Toast.LENGTH_SHORT).show();
            stopSelf();

        }

        @Override
        public void onServiceCursorUpdated(Cursor cursor) {
            //Make sure the new cursor and the old cursor are the same size.
            if (getCursor().getCount()==cursor.getCount()) {
                setCursor(cursor);
            }

        }

    };

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Services;

import android.app.Notification;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.IBinder;
import android.support.v4.app.NotificationCompat;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncAutoGetAlbumArtTask;
import com.jams.music.player.SettingsActivity.SettingsActivity____;

public class AutoFetchAlbumArtService extends Service {
	
	private Context mContext;
	private SharedPreferences sharedPreferences;
	public static NotificationCompat.Builder builder;
	public static Notification notification;
	public static final int NOTIFICATION_ID = 2; //NOTE: Using 0 as a notification ID causes the Android to ignore the notification call.
	
	//Prepare the media player for first use.
	@Override
	public void onCreate() {
		
		//Initialize SharedPreferences.
        sharedPreferences = this.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
        mContext = this;
		super.onCreate();
		
	}
	
	//This method is called when the service is created.
	@Override
    public int onStartCommand(Intent intent, int flags, int startId) {

		//Launch a notification to set the service as a foreground service.
		builder = new NotificationCompat.Builder(this);
        builder.setSmallIcon(R.drawable.ic_launcher);
        builder.setContentTitle(getResources().getString(R.string.downloading_missing_cover_art));
        builder.setTicker(getResources().getString(R.string.downloading_missing_cover_art));
        builder.setContentText(null);
        
        notification = builder.build();
        notification.flags |= Notification.FLAG_FOREGROUND_SERVICE;
        notification.flags |= Notification.FLAG_NO_CLEAR;
        notification.flags |= Notification.FLAG_ONGOING_EVENT;

        startForeground(NOTIFICATION_ID, notification);
		
        //Call the AsyncTask that checks for missing art and downloads them.
        AsyncAutoGetAlbumArtTask task = new AsyncAutoGetAlbumArtTask(mContext, SettingsActivity____.mSettingsActivity);
        task.execute();
        
        return START_STICKY;
    }
	
	@Override
	public IBinder onBind(Intent arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void onDestroy() {
		super.onDestroy();

	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Services;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.IBinder;
import android.support.v4.app.NotificationCompat;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncBuildLibraryTask;
import com.jams.music.player.WelcomeActivity.WelcomeActivity;

public class BuildMusicLibraryService extends Service implements AsyncBuildLibraryTask.OnBuildLibraryProgressUpdate {
	
	private Context mContext;
	private NotificationCompat.Builder mBuilder;
	private Notification mNotification;
	private NotificationManager mNotifyManager;
	public static int mNotificationId = 92713;
	
	@Override
	public void onCreate() {
		mContext = this.getApplicationContext();
	}
	
	@Override
	public int onStartCommand(Intent intent, int startId, int flags) {
		
		//Create a persistent notification that keeps this service running and displays the scan progress.
		mBuilder = new NotificationCompat.Builder(mContext);
		mBuilder.setSmallIcon(R.drawable.notif_icon);
		mBuilder.setContentTitle(getResources().getString(R.string.building_music_library));
		mBuilder.setTicker(getResources().getString(R.string.building_music_library));
		mBuilder.setContentText("");
		mBuilder.setProgress(0, 0, true);
		
		mNotifyManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
		mNotification = mBuilder.build();
		mNotification.flags |= Notification.FLAG_INSISTENT | Notification.FLAG_NO_CLEAR;
		
		startForeground(mNotificationId, mNotification);	

        //Go crazy with a full-on scan.
        AsyncBuildLibraryTask task = new AsyncBuildLibraryTask(mContext, this);
        task.setOnBuildLibraryProgressUpdate(WelcomeActivity.mBuildingLibraryProgressFragment);
        task.setOnBuildLibraryProgressUpdate(this);
        task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);

		return START_STICKY;
	}
	
	@Override
	public IBinder onBind(Intent arg0) {
		// TODO Auto-generated method stub
		return null;
	}

    @Override
    public void onStartBuildingLibrary() {

    }

    @Override
    public void onProgressUpdate(AsyncBuildLibraryTask task, String mCurrentTask, int overallProgress,
                                 int maxProgress, boolean mediaStoreTransferDone) {
        mBuilder = new NotificationCompat.Builder(mContext);
        mBuilder.setSmallIcon(R.drawable.notif_icon);
        mBuilder.setContentTitle(mCurrentTask);
        mBuilder.setTicker(mCurrentTask);
        mBuilder.setContentText("");
        mBuilder.setProgress(maxProgress, overallProgress, false);

        mNotifyManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
        mNotification = mBuilder.build();
        mNotification.flags |= Notification.FLAG_INSISTENT | Notification.FLAG_NO_CLEAR;
        mNotifyManager.notify(mNotificationId, mNotification);

    }

    @Override
    public void onFinishBuildingLibrary(AsyncBuildLibraryTask task) {
        mNotifyManager.cancel(mNotificationId);
        stopSelf();

        Toast.makeText(mContext, R.string.finished_scanning_album_art, Toast.LENGTH_LONG).show();

    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Services;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v4.content.LocalBroadcastManager;

import com.google.android.apps.dashclock.api.DashClockExtension;
import com.google.android.apps.dashclock.api.ExtensionData;
import com.jams.music.player.R;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.Utils.Common;

public class DashClockExtensionService extends DashClockExtension {
	
	private Common mApp;
	private BroadcastReceiver receiver;
	
	private String status;
	private String expandedTitle;
	private String expandedBody;

	@Override
	public void onCreate() {
		super.onCreate();
		
    	mApp = (Common) this.getApplicationContext();
		
		//Register a broadcast listener to listen for track updates.
        receiver = new BroadcastReceiver() {
        	
            @Override
            public void onReceive(Context context, Intent intent) {
                updateExtensionData();
                
            }
            
        };
        
    	LocalBroadcastManager.getInstance(this)
		 					 .registerReceiver((receiver), 
		 							 			new IntentFilter("com.jams.music.player.NEW_SONG_UPDATE_UI"));
		
	}
	
    @Override
    protected void onUpdateData(int reason) {
        //Nope.
    }
    
    private void updateExtensionData() {
    	ExtensionData data = new ExtensionData();
    	
        //Publish the extension data update.
    	if (mApp.isServiceRunning()) {
    		//Show the extension with updated data.
    		try {
    			
    			status = "Playing";
    			expandedTitle = mApp.getService().getCurrentSong().getTitle();
    			expandedBody = mApp.getService().getCurrentSong().getAlbum() 
    						 + " - " 
    						 + mApp.getService().getCurrentSong().getArtist(); 
    			
    			Intent notificationIntent = new Intent(this, NowPlayingActivity.class);
    	        notificationIntent.putExtra("CALLED_FROM_FOOTER", true);
    	        notificationIntent.putExtra("CALLED_FROM_NOTIF", true);
    			
    			//Publish the extension data update.
    	        publishUpdate(data.visible(true)
        						  .icon(R.drawable.dashclock_icon)
        						  .status(status)
        						  .expandedTitle(expandedTitle)
        						  .expandedBody(expandedBody)
        						  .clickIntent(notificationIntent));
    			
    		} catch (Exception e) {
    			e.printStackTrace();
    			//Hide the extension.
        		publishUpdate(data.visible(false));
    		}
    	} else {
    		//Hide the extension.
    		publishUpdate(data.visible(false));
    	}
    	 
    }
    
    @Override
    public void onDestroy() {
    	super.onDestroy();
    	LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver);
    	
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Services;

import android.app.Activity;
import android.os.Bundle;

/* KitKat introduced a new bug: swiping away the app from the 
 * "Recent Apps" list causes all background services to shut 
 * down. To circumvent this issue, this dummy activity will 
 * launch momentarily and close (it will be invisible to the 
 * user). This will fool the OS into thinking that the service 
 * still has an Activity bound to it, and prevent it from being 
 * killed.
 * 
 * ISSUE #53313:
 * https://code.google.com/p/android/issues/detail?id=53313
 * 
 * ISSUE #63618:
 * https://code.google.com/p/android/issues/detail?id=63618
 * 
 * General discussion thread:
 * https://groups.google.com/forum/#!topic/android-developers/LtmA9xbrD5A
 */
public class KitKatFixActivity extends Activity {
	
	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);
		finish();
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Services;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.widget.RemoteViews;
import android.widget.RemoteViewsService;

import com.jams.music.player.R;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Utils.Common;
import com.nostra13.universalimageloader.core.DisplayImageOptions;
import com.nostra13.universalimageloader.core.assist.ImageScaleType;
import com.nostra13.universalimageloader.core.assist.ImageSize;
import com.nostra13.universalimageloader.core.display.FadeInBitmapDisplayer;

public class LargeWidgetAdapterService extends RemoteViewsService {
	
    @Override
    public RemoteViewsFactory onGetViewFactory(Intent intent) {
        return new StackRemoteViewsFactory(this.getApplicationContext(), intent);
    }
    
}

class StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {

    private Context mContext;
    private SharedPreferences sharedPreferences;
    private Cursor cursor;
    private Common mApp;
    private DisplayImageOptions displayImageOptions;
    private String mWidgetColor = "DARK";
    
    public StackRemoteViewsFactory(Context context, Intent intent) {
        mContext = context;
        mApp = (Common) mContext.getApplicationContext();
        
        sharedPreferences = context.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
        cursor = mApp.getService().getCursor();
        mWidgetColor = intent.getStringExtra("WIDGET_COLOR");

        //Create a set of options to optimize the bitmap memory usage.
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        options.inJustDecodeBounds = false;
        options.inPurgeable = true;
        
        //Display Image Options.
        displayImageOptions = new DisplayImageOptions.Builder()
        						  .showImageForEmptyUri(R.drawable.default_album_art)
        						  .showImageOnFail(R.drawable.default_album_art)
        						  .cacheInMemory(true)
        						  .cacheOnDisc(true)
        						  .decodingOptions(options)
        						  .imageScaleType(ImageScaleType.EXACTLY)
        						  .bitmapConfig(Bitmap.Config.RGB_565)
        						  .displayer(new FadeInBitmapDisplayer(400))
        						  .build();
        
    }
    
    @Override
    public int getCount() {
    	if (cursor!=null) {
            return cursor.getCount();
    	} else {
    		return 0;
    	}
    	
    }

    @Override
    public RemoteViews getViewAt(int position) {
        RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.large_widget_listview_layout);
        if (position <= getCount()) {
        	
        	try {
        		if (mApp.getService().getPlaybackIndecesList()!=null && mApp.getService().getPlaybackIndecesList().size()!=0) {
            		if (cursor.getCount() > mApp.getService().getPlaybackIndecesList().get(position)) {
                		cursor.moveToPosition(mApp.getService().getPlaybackIndecesList().get(position));
                	} else {
                		return null;
                	}
            		
            	} else {
            		return null;
            	}
        	} catch (Exception e) {
        		return null;
        	}
        	
        	//Set the song title, album, and artist fields.
        	String songTitle = cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_TITLE));
        	String songAlbumArtPath = cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_ALBUM_ART_PATH));
        	ImageSize imageSize = new ImageSize(100, 100);
        	
            //Set the duration of the song.
            long songDurationInMillis = 0;
            try {
            	songDurationInMillis = Long.parseLong(cursor.getString(cursor.getColumnIndex(DBAccessHelper.SONG_DURATION)));
            } catch (Exception e) {
            	songDurationInMillis = 0;
            }
        	
        	rv.setTextViewText(R.id.widget_listview_song_name, songTitle);
            rv.setTextViewText(R.id.widget_listview_duration, convertMillisToMinsSecs(songDurationInMillis));
            
            if (mWidgetColor.equals("LIGHT")) {
    			rv.setTextColor(R.id.widget_listview_song_name, Color.BLACK);
    			rv.setTextColor(R.id.widget_listview_duration, Color.BLACK);
    		}
            
            Bitmap bitmap = mApp.getImageLoader().loadImageSync(songAlbumArtPath, imageSize, displayImageOptions);
            rv.setImageViewBitmap(R.id.widget_listview_thumbnail, bitmap);
            
        }
        
        /* This intent latches itself onto the pendingIntentTemplate from 
         * LargeWidgetProvider.java and adds the extra "INDEX" argument to it. */
        Intent fillInIntent = new Intent();
        fillInIntent.putExtra("INDEX", position);
        rv.setOnClickFillInIntent(R.id.widget_listview_layout, fillInIntent);
        
        return rv;
    }
    
    @Override
    public RemoteViews getLoadingView() {
        return null;
    }

    @Override
    public int getViewTypeCount() {
        return 1;
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public boolean hasStableIds() {
        return true;
    }

    @Override
    public void onDataSetChanged() {
        
        if (sharedPreferences.getBoolean("SERVICE_RUNNING", false)==true) {
        	cursor = mApp.getService().getCursor();
        }
    	
    }
    
	//Convert millisseconds to hh:mm:ss format.
    private String convertMillisToMinsSecs(long milliseconds) {
    	
    	int secondsValue = (int) (milliseconds / 1000) % 60 ;
    	int minutesValue = (int) ((milliseconds / (1000*60)) % 60);
    	int hoursValue  = (int) ((milliseconds / (1000*60*60)) % 24);
    	
    	String seconds = "";
    	String minutes = "";
    	String hours = "";
    	
    	if (secondsValue < 10) {
    		seconds = "0" + secondsValue;
    	} else {
    		seconds = "" + secondsValue;
    	}

    	if (minutesValue < 10) {
    		minutes = "0" + minutesValue;
    	} else {
    		minutes = "" + minutesValue;
    	}
    	
    	if (hoursValue < 10) {
    		hours = "0" + hoursValue;
    	} else {
    		hours = "" + hoursValue;
    	}
    	
    	
    	String output = "";
    	
    	if (hoursValue!=0) {
    		output = hours + ":" + minutes + ":" + seconds;
    	} else {
    		output = minutes + ":" + seconds;
    	}
    	
    	return output;
    }

	@Override
	public void onDestroy() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void onCreate() {
		// TODO Auto-generated method stub
		
	}
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Services;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.IBinder;
import android.support.v4.app.NotificationCompat;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncPinSongsTask;

public class PinGMusicSongsService extends Service {
	
	private Context mContext;
	public static Notification notification;
	
	public static NotificationManager mNotifyManager;
    public static NotificationCompat.Builder mBuilder;
    public static int notificationID = 233235;
	
	//Prepare the media player for first use.
	@Override
	public void onCreate() {
		
        mContext = this;
		super.onCreate();
		
	}
	
	//This method is called when the service is created.
	@Override
    public int onStartCommand(Intent intent, int flags, int startId) {

		//The initial notification will display a "Starting download" message + indeterminate progress bar.
    	mNotifyManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    	mBuilder = new NotificationCompat.Builder(mContext);
    	mBuilder.setContentTitle(mContext.getResources().getString(R.string.starting_download));
    	mBuilder.setTicker(mContext.getResources().getString(R.string.starting_download));
    	mBuilder.setSmallIcon(R.drawable.pin_light);
    	mBuilder.setProgress(0, 0, true);
    	mNotifyManager.notify(notificationID, mBuilder.build());
        
        //Call the AsyncTask that kicks off the pinning process.
        AsyncPinSongsTask task = new AsyncPinSongsTask(mContext);
        task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (String[]) null);
        
        return START_STICKY;
    }
	
	@Override
	public IBinder onBind(Intent arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void onDestroy() {
		super.onDestroy();

	}

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;


import main.java.de.psdev.licensesdialog.LicensesDialog;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentTransaction;

import com.jams.music.player.R;
import com.jams.music.player.Dialogs.AddMusicLibraryDialog;
import com.jams.music.player.Dialogs.AlbumArtSourceDialog;
import com.jams.music.player.Dialogs.ApplicationThemeDialog;
import com.jams.music.player.Dialogs.BlacklistedElementsDialog;
import com.jams.music.player.Dialogs.CoverArtStyleDialog;
import com.jams.music.player.Dialogs.CustomizeScreensDialog;
import com.jams.music.player.Dialogs.EditDeleteMusicLibraryDialog;
import com.jams.music.player.Dialogs.GooglePlayMusicAuthenticationDialog;
import com.jams.music.player.Dialogs.NowPlayingColorSchemesDialog;
import com.jams.music.player.Dialogs.ScanFrequencyDialog;
import com.jams.music.player.Utils.Common;

/*************************************************************************
 * This class displays a dummy activity which fires up a FragmentDialog 
 * from PreferencesActivity.
 * 
 * @author Saravan Pantham
 *************************************************************************/
public class PreferenceDialogLauncherActivity extends FragmentActivity {

    private Context mContext;
    private Common mApp;

	@Override
	public void onCreate(Bundle savedInstanceState) {

        mContext = this;
        mApp = (Common) mContext.getApplicationContext();

		if (mApp.getCurrentTheme()==Common.DARK_THEME) {
			this.setTheme(R.style.AppThemeTransparent);
		} else {
			this.setTheme(R.style.AppThemeTransparentLight);
		}
		
		super.onCreate(savedInstanceState);
		
		//Get the index that specifies which dialog to launch.
		int index = getIntent().getExtras().getInt("INDEX");
		
		if (index==0) {
			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
	        ApplicationThemeDialog appThemeDialog = new ApplicationThemeDialog();
	        //appThemeDialog.show(ft, "appThemeDialog");
		} else if (index==1) {
			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
	        NowPlayingColorSchemesDialog appThemeDialog = new NowPlayingColorSchemesDialog();
	        //appThemeDialog.show(ft, "colorSchemesDialog");
		} else if (index==2) {
			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
	        CustomizeScreensDialog screensDialog = new CustomizeScreensDialog();
	        screensDialog.show(ft, "customizeScreensDialog");
		} else if (index==3) {
			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
	        CoverArtStyleDialog coverArtStyleDialog = new CoverArtStyleDialog();
	        coverArtStyleDialog.show(ft, "coverArtStyleDialog");
		} else if (index==4) {
			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
	        AlbumArtSourceDialog albumArtSourceDialog = new AlbumArtSourceDialog();
	        albumArtSourceDialog.show(ft, "albumArtSourceDialog");
		} else if (index==5) {

			
		} else if (index==6) {	
			//Seting the "REBUILD_LIBRARY" flag to true will force MainActivity to rescan the folders.
			mApp.getSharedPreferences().edit().putBoolean("REBUILD_LIBRARY", true).commit();
	    	
			//Restart the app.
			Intent i = getBaseContext().getPackageManager().getLaunchIntentForPackage(getBaseContext().getPackageName());
			i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
			finish();
			startActivity(i);
							
		} else if (index==7) {
			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
			Bundle bundle = new Bundle();
			bundle.putBoolean("CALLED_FROM_WELCOME", false);
	        ScanFrequencyDialog scanFrequencyDialog = new ScanFrequencyDialog();
	        scanFrequencyDialog.setArguments(bundle);
	        scanFrequencyDialog.show(ft, "scanFrequencyDialog");
	        
		} else if (index==8) {
			
/*			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
			BlacklistManagerDialog blacklistDialog = new BlacklistManagerDialog();
			blacklistDialog.show(ft, "blacklistManagerDialog");*/
			
			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
			BlacklistedElementsDialog dialog = new BlacklistedElementsDialog();
			Bundle bundle = new Bundle();
			bundle.putString("MANAGER_TYPE", "ARTISTS");
			dialog.setArguments(bundle);
			dialog.show(ft, "blacklistedElementsDialog");
	        
		} else if (index==9) { 
			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
			Bundle bundle = new Bundle();
			bundle.putBoolean("CALLED_FROM_WELCOME", false);
	        ScanFrequencyDialog scanFrequencyDialog = new ScanFrequencyDialog();
	        scanFrequencyDialog.setArguments(bundle);
	        scanFrequencyDialog.show(ft, "scanFrequencyDialog");
	        
		} else if (index==12) {
			/*FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
	        LicensesDialog appThemeDialog = new LicensesDialog();
	        appThemeDialog.show(ft, "licensesDialog");*/
			
			new LicensesDialog(this, R.raw.notices, false, false).show();
	        
		} else if (index==13) {
			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
			AddMusicLibraryDialog addMusicLibraryDialog = new AddMusicLibraryDialog();
			addMusicLibraryDialog.show(ft, "addMusicLibraryDialog");
		
		} else if (index==14) {
			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
			EditDeleteMusicLibraryDialog deleteMusicLibraryDialog = new EditDeleteMusicLibraryDialog();
			Bundle bundle = getIntent().getExtras();
			deleteMusicLibraryDialog.setArguments(bundle);
			deleteMusicLibraryDialog.show(ft, "editDeleteMusicLibraryDialog");
			
		} else if (index==15) {
			FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
			GooglePlayMusicAuthenticationDialog dialog = new GooglePlayMusicAuthenticationDialog();
			Bundle bundle = new Bundle();
			bundle.putBoolean(Common.FIRST_RUN, false);
			dialog.setArguments(bundle);
			dialog.show(ft, "gMusicAuthDialog");
			
		}

	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.Fragment;
import android.content.Context;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.jams.music.player.Utils.Common;

/**
 * @author Saravan Pantham
 */
public class SettingsAboutFragment extends Fragment {

    private Context mContext;
    private Common mApp;
    private View mRootView;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;


        return mRootView;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.content.Context;
import android.os.Build;
import android.os.Bundle;
import android.preference.PreferenceActivity;
import android.util.TypedValue;
import android.view.View;
import android.widget.TextView;

import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

import java.util.List;

/**
 *
 *
 * @author Saravan Pantham
 */
public class SettingsActivity extends PreferenceActivity {

    private Context mContext;
    private SettingsActivity mActivity;
    private Common mApp;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        mContext = this.getApplicationContext();
        mActivity = this;
        mApp = (Common) mContext;

        setTheme(R.style.SettingsThemeLight);
        super.onCreate(savedInstanceState);

        //Set the ActionBar background and text color.
        getActionBar().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));
        getActionBar().setTitle(R.string.settings);
        int titleId = getResources().getIdentifier("action_bar_title", "id", "android");
        TextView actionBarText = (TextView) findViewById(titleId);
        actionBarText.setTextColor(0xFFFFFFFF);

    }

    /**
     * Applies KitKat specific translucency.
     */
    public void applyKitKatTranslucency() {
        if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT) {

            //Calculate ActionBar and navigation bar height.
            TypedValue tv = new TypedValue();
            int actionBarHeight = 0;
            if (getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) {
                actionBarHeight = TypedValue.complexToDimensionPixelSize(tv.data, getResources().getDisplayMetrics());
            }

            ((View) this.getListView().getParent()).setPadding(0, actionBarHeight + mApp.getStatusBarHeight(mContext),
                                                               0, 0);

            this.getListView().setBackgroundColor(0xFFEEEEEE);
            this.getListView().setPadding(0, 0, 0, mApp.getNavigationBarHeight(mContext));
            this.getListView().setClipToPadding(false);

            //Set the window color.
            getWindow().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));

        }

    }

    @Override
    public void onBuildHeaders(List<Header> target) {
        loadHeadersFromResource(R.xml.settings_headers, target);
        applyKitKatTranslucency();

    }

    @Override
    protected boolean isValidFragment (String fragmentName) {
       return true;

    }

    @Override
    public void onResume() {
        super.onResume();
        applyKitKatTranslucency();
        getActionBar().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));

    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Paint;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.preference.Preference;
import android.preference.Preference.OnPreferenceClickListener;
import android.preference.PreferenceActivity;
import android.preference.PreferenceCategory;
import android.preference.PreferenceManager;
import android.preference.PreferenceScreen;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.RelativeLayout;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncGoogleMusicAuthenticationTask;
import com.jams.music.player.BlacklistManagerActivity.BlacklistManagerActivity;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.InAppBilling.IabHelper;
import com.jams.music.player.InAppBilling.IabResult;
import com.jams.music.player.InAppBilling.Purchase;
import com.jams.music.player.Services.AutoFetchAlbumArtService;
import com.jams.music.player.Utils.Common;

public class SettingsActivity____ extends PreferenceActivity {
	 
	//Context.
	public static Context mContext;
	public static SettingsActivity____ mSettingsActivity;
	private Common mApp;
	
	//Preference Manager.
	private SharedPreferences sharedPreferences;
	private PreferenceManager preferenceManager;
	
	//Upgrade Preferences.
	private Preference upgradePreference;
	
	//Customization Preferences.
	private Preference appThemePreference;
	private Preference playerColorSchemePreference;
	private Preference trackChangeAnimationPreference;
	private Preference defaultScreenPreference;
	private Preference artistsLayoutPreference;
	private Preference albumArtistsLayoutPreference;
	private Preference albumsLayoutPreference;
	private Preference lockscreenControlsPreference;
	
	//Google Play Music Preferences.
	private Preference chooseGooglePlayMusicAccountPreference;
	private Preference getPinnedSongsPreference;
	
	//Folder View Preferences.
	private Preference defaultFolderPreference;
	
	//Music Libraries Preferences.
	private Preference addMusicLibraryPreference;
	private Preference editMusicLibraryPreference;
	private Preference deleteMusicLibraryPreference;
	
	//Album Art Preferences.
	private Preference albumArtStylePreference;
	private Preference albumArtSourcesPreference;
	private Preference albumArtScanDownloadPreference;
	
	//Music Folders Preferences.
	private Preference selectFoldersPreference;
	private Preference rescanFoldersPreference;
	private Preference scanFrequencyPreference;
	
	//Blacklist Preferences.
	private Preference blacklistManagerPreference;
	private Preference unblacklistAllPreference;
	
	//Scrobbling Preference.
	private Preference scrobblingPreference;
	
	//Audio Settings Preferences.
	private Preference headphonesUnplugActionPreference;
	private Preference crossfadeTracksPreference;
	private Preference crossfadeTracksDurationPreference;
	private Preference equalizerPreference;
	
	//About & Contact Preferences.
	private Preference licensesPreference;
	private Preference contactUsPreference;
	
	public static Dialog dialogHolder;
	public static String mAccountName = "";
	public static boolean accountPicked = false;
	private IabHelper mHelper;
	static final String ITEM_SKU = "com.jams.music.player.unlock";
    protected boolean mPurchased;
	
    //Misc.
	private AlertDialog mTrackChangeAnimationDialog;
    
	@SuppressWarnings("deprecation")
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		
		//Context.
		mContext = this;
		mSettingsActivity = this;
		mApp = (Common) mContext.getApplicationContext();
		
		//Initialize SharedPreferences.
        sharedPreferences = this.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
    	
    	//Set the UI theme.
    	if (mApp.getCurrentTheme()==Common.DARK_THEME) {
    		this.setTheme(R.style.AppThemeNoActionBar);
    	} else {
    		this.setTheme(R.style.AppThemeNoActionBarLight);
    	}
		
		super.onCreate(savedInstanceState);
    	addPreferencesFromResource(R.xml.preferences);
    	
    	preferenceManager = this.getPreferenceManager();
    	
    	//Retrieve the preferences based on their unique keys.
    	upgradePreference = preferenceManager.findPreference("preference_key_upgrade");
    	
    	appThemePreference = preferenceManager.findPreference("preference_key_app_theme");
    	playerColorSchemePreference = preferenceManager.findPreference("preference_key_player_color_scheme");
    	trackChangeAnimationPreference = preferenceManager.findPreference("preference_key_track_change_animation");
    	defaultScreenPreference = preferenceManager.findPreference("preference_key_startup_screen");
    	artistsLayoutPreference = preferenceManager.findPreference("preference_key_artists_layout");
    	albumArtistsLayoutPreference = preferenceManager.findPreference("preference_key_album_artists_layout");
    	albumsLayoutPreference = preferenceManager.findPreference("preference_key_albums_layout");
    	lockscreenControlsPreference = preferenceManager.findPreference("preference_key_lockscreen_controls");
    	
    	albumArtStylePreference = preferenceManager.findPreference("preference_key_album_art_style");
    	albumArtSourcesPreference = preferenceManager.findPreference("preference_key_album_art_sources");
    	albumArtScanDownloadPreference = preferenceManager.findPreference("preference_key_scan_download_album_art");
    	
    	chooseGooglePlayMusicAccountPreference = preferenceManager.findPreference("preference_key_google_play_music_account");
    	getPinnedSongsPreference = preferenceManager.findPreference("preference_key_get_pinned_songs");
    	
    	defaultFolderPreference = preferenceManager.findPreference("preference_key_default_folder");
    	
    	addMusicLibraryPreference = preferenceManager.findPreference("preference_key_add_music_library");
    	editMusicLibraryPreference = preferenceManager.findPreference("preference_key_edit_music_library");
    	deleteMusicLibraryPreference = preferenceManager.findPreference("preference_key_delete_music_library");
    	
    	selectFoldersPreference = preferenceManager.findPreference("preference_key_select_folders");
    	rescanFoldersPreference = preferenceManager.findPreference("preference_key_rescan_folders");
    	scanFrequencyPreference = preferenceManager.findPreference("preference_key_scan_frequency");
    	
    	blacklistManagerPreference = preferenceManager.findPreference("preference_key_blacklist_manager");
    	unblacklistAllPreference = preferenceManager.findPreference("preference_key_unblacklist_all");
    	
    	scrobblingPreference = preferenceManager.findPreference("preference_key_scrobbling");
    	
    	headphonesUnplugActionPreference = preferenceManager.findPreference("preference_key_headphones_unplug_action");
    	crossfadeTracksPreference = preferenceManager.findPreference("preference_key_crossfade_tracks");
    	crossfadeTracksDurationPreference = preferenceManager.findPreference("preference_key_crossfade_tracks_duration");
    	equalizerPreference = preferenceManager.findPreference("preference_key_equalizer_toggle");
    	
    	licensesPreference = preferenceManager.findPreference("preference_key_licenses");
    	contactUsPreference = preferenceManager.findPreference("preference_key_contact_us");
    	
    	//Set the preference icons.
    	upgradePreference.setIcon(UIElementsHelper.getIcon(mContext, "checkmark"));
    	
    	appThemePreference.setIcon(UIElementsHelper.getIcon(mContext, "color_palette"));
    	playerColorSchemePreference.setIcon(UIElementsHelper.getIcon(mContext, "color_palette_play"));
    	trackChangeAnimationPreference.setIcon(UIElementsHelper.getIcon(mContext, "customize_screens"));
    	defaultScreenPreference.setIcon(UIElementsHelper.getIcon(mContext, "default_screen"));
    	artistsLayoutPreference.setIcon(UIElementsHelper.getIcon(mContext, "mic"));
    	albumArtistsLayoutPreference.setIcon(UIElementsHelper.getIcon(mContext, "album_artists"));
    	albumsLayoutPreference.setIcon(UIElementsHelper.getIcon(mContext, "albums"));
    	lockscreenControlsPreference.setIcon(UIElementsHelper.getIcon(mContext, "lockscreen_controls"));
    	
    	getPinnedSongsPreference.setIcon(UIElementsHelper.getIcon(mContext, "pin_settings"));
    	chooseGooglePlayMusicAccountPreference.setIcon(UIElementsHelper.getIcon(mContext, "accounts"));
    	
    	addMusicLibraryPreference.setIcon(UIElementsHelper.getIcon(mContext, "add_new_library"));
    	editMusicLibraryPreference.setIcon(UIElementsHelper.getIcon(mContext, "edit_library"));
    	deleteMusicLibraryPreference.setIcon(UIElementsHelper.getIcon(mContext, "delete_library"));
    	
    	albumArtStylePreference.setIcon(UIElementsHelper.getIcon(mContext, "cover_art_icon"));
    	albumArtSourcesPreference.setIcon(UIElementsHelper.getIcon(mContext, "album_art_source"));
    	albumArtScanDownloadPreference.setIcon(UIElementsHelper.getIcon(mContext, "auto_cover_fetch"));
    	
    	defaultFolderPreference.setIcon(UIElementsHelper.getIcon(mContext, "folders_settings"));
    	
    	selectFoldersPreference.setIcon(UIElementsHelper.getIcon(mContext, "folders_settings"));
    	rescanFoldersPreference.setIcon(UIElementsHelper.getIcon(mContext, "rescan"));
    	scanFrequencyPreference.setIcon(UIElementsHelper.getIcon(mContext, "scan_frequency"));
    	
    	blacklistManagerPreference.setIcon(UIElementsHelper.getIcon(mContext, "manage_blacklists"));
    	unblacklistAllPreference.setIcon(UIElementsHelper.getIcon(mContext, "unblacklist_all"));
    	
    	scrobblingPreference.setIcon(UIElementsHelper.getIcon(mContext, "scrobbling"));
    	
    	headphonesUnplugActionPreference.setIcon(UIElementsHelper.getIcon(mContext, "headphones"));
    	crossfadeTracksPreference.setIcon(UIElementsHelper.getIcon(mContext, "crossfade_tracks"));
    	crossfadeTracksDurationPreference.setIcon(UIElementsHelper.getIcon(mContext, "crossfade_tracks_duration"));
    	equalizerPreference.setIcon(UIElementsHelper.getIcon(mContext, "equalizer_settings"));
    	
    	licensesPreference.setIcon(UIElementsHelper.getIcon(mContext, "licenses"));
    	contactUsPreference.setIcon(UIElementsHelper.getIcon(mContext, "contact_us"));
    	
    	if (sharedPreferences.getBoolean("TRIAL", true)==false) {
    		PreferenceScreen screen = getPreferenceScreen();
    		PreferenceCategory upgradePrefCategory = (PreferenceCategory) preferenceManager.findPreference("upgrade_pref_category");
    		screen.removePreference(upgradePrefCategory);
    	}
    	
    	upgradePreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {
				//initInAppBilling();
				Intent intent = new Intent(mContext, com.jams.music.player.LauncherActivity.LauncherActivity.class);
				intent.putExtra("UPGRADE", true);
				startActivity(intent);
				finish();
				return false;
			}
    		
    	});
    	
    	//Set click listeners on each preference.
    	appThemePreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {

				Intent intent = new Intent(mContext, PreferenceDialogLauncherActivity.class);
				intent.putExtra("INDEX", 0);
				startActivity(intent);
		        
				return false;
			}
    		
    	});
    	
    	playerColorSchemePreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
				Intent intent = new Intent(mContext, PreferenceDialogLauncherActivity.class);
				intent.putExtra("INDEX", 1);
				startActivity(intent);
				
				return false;
			}
    		
    	});
    	
    	trackChangeAnimationPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {

				int selectedIndex = sharedPreferences.getInt("TRACK_CHANGE_ANIMATION", 0);
				
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
				builder.setTitle(R.string.track_change_animation);
				View layoutView = mSettingsActivity.getLayoutInflater().inflate(R.layout.generic_message_listview_dialog_layout, null);
				
				TextView message = (TextView) layoutView.findViewById(R.id.generic_message);
				ListView listView = (ListView) layoutView.findViewById(R.id.generic_listview);
				
				message.setTypeface(TypefaceHelper.getTypeface(mContext, "RobotoCondensed-Light"));
				message.setPaintFlags(message.getPaintFlags() | Paint.ANTI_ALIAS_FLAG | Paint.SUBPIXEL_TEXT_FLAG);
				message.setText(R.string.track_change_animation_info);
				
				String[] values = { mSettingsActivity.getResources().getString(R.string.slide_away), 
									mSettingsActivity.getResources().getString(R.string.zoom_out_and_slide_away), 
									mSettingsActivity.getResources().getString(R.string.depth_transformer) };
				
				ArrayAdapter<String> adapter = new ArrayAdapter<String>(mSettingsActivity, 
																		android.R.layout.simple_list_item_single_choice, 
																		android.R.id.text1, 
																		values);
		        listView.setAdapter(adapter);
		        listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
		        listView.setItemChecked(selectedIndex, true);
		        listView.setOnItemClickListener(new OnItemClickListener() {

					@Override
					public void onItemClick(AdapterView<?> arg0, View arg1, int which, long arg3) {
						Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
						sharedPreferences.edit().putInt("TRACK_CHANGE_ANIMATION", which).commit();
						mTrackChangeAnimationDialog.dismiss();
						
					}
		        	
		        });
				
		        builder.setView(layoutView);
		        mTrackChangeAnimationDialog = builder.create();
				mTrackChangeAnimationDialog.show();
				
				return false;
			}
    		
    	});
    	
    	defaultScreenPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {
				
				//Get the current preference.
				int currentPreference = sharedPreferences.getInt("STARTUP_SCREEN", 0);
				
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
				//builder.setTitle(R.string.startup_screen);
				builder.setSingleChoiceItems(R.array.startup_screen_items, currentPreference, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						sharedPreferences.edit().putInt("STARTUP_SCREEN", which).commit();
						dialog.dismiss();
						Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
						
					}
					
				});
				
				builder.create().show();
				return false;
			}
    		
    	});
    	
    	artistsLayoutPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {
				
				//Get the current preference.
				int currentPreference = sharedPreferences.getInt("ARTISTS_LAYOUT_PREF", 0);
				
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
				builder.setTitle(R.string.artists_layout);
				builder.setSingleChoiceItems(R.array.layout_preference_items, currentPreference, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						sharedPreferences.edit().putInt("ARTISTS_LAYOUT_PREF", which).commit();
						dialog.dismiss();
						Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
						
					}
					
				});
				
				builder.create().show();
				return false;
			}
    		
    	});
    	
    	albumArtistsLayoutPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {
				
				//Get the current preference.
				int currentPreference = sharedPreferences.getInt("ALBUM_ARTISTS_LAYOUT_PREF", 0);
				
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
				builder.setTitle(R.string.album_artists_layout);
				builder.setSingleChoiceItems(R.array.layout_preference_items, currentPreference, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						sharedPreferences.edit().putInt("ALBUM_ARTISTS_LAYOUT_PREF", which).commit();
						dialog.dismiss();
						Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
						
					}
					
				});
				
				builder.create().show();
				return false;
			}
    		
    	});
    	
    	albumsLayoutPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {
				
				//Get the current preference.
				int currentPreference = sharedPreferences.getInt("ALBUMS_LAYOUT_PREF", 0);
				
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
				builder.setTitle(R.string.albums_layout);
				builder.setSingleChoiceItems(R.array.layout_preference_items, currentPreference, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						sharedPreferences.edit().putInt("ALBUMS_LAYOUT_PREF", which).commit();
						dialog.dismiss();
						Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
						
					}
					
				});
				
				builder.create().show();
				return false;
			}
    		
    	});
    	
    	lockscreenControlsPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {
				
				//Get the current preference.
				int currentPreference = sharedPreferences.getInt(Common.SHOW_LOCKSCREEN_CONTROLS, 0);
				
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
				//builder.setTitle(R.string.lockscreen_controls);
				builder.setSingleChoiceItems(R.array.enable_disable, currentPreference, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						sharedPreferences.edit().putInt(Common.SHOW_LOCKSCREEN_CONTROLS, which).commit();
						dialog.dismiss();

						//Enable/disable the lockscreen controls for this session.
						try {
							if (which==0) {
								Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
								if (sharedPreferences.getBoolean("SERVICE_RUNNING", false)==true) {
									mApp.getService().initRemoteControlClient();	
									mApp.getService().updateRemoteControlClients(mApp.getService().getCurrentSong());
								}
								
							} else if (which==1) {
								if (sharedPreferences.getBoolean("SERVICE_RUNNING", false)==true) {
									Toast.makeText(mContext, R.string.lockscreen_controls_disabled_next_run, Toast.LENGTH_LONG).show();
								} else {
									Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
								}
								
							}
							
						} catch (Exception e) {
							e.printStackTrace();
						}
						
					}
					
				});
				
				builder.create().show();
				return false;
			}
    		
    	});
    	
    	defaultFolderPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
				builder.setTitle(R.string.default_folder_for_folders_view);
				builder.setMessage(R.string.default_folder_for_folders_view_info);
				
				builder.setPositiveButton(R.string.ok, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						dialog.dismiss();
						
					}
					
				});
				
				builder.create().show();
				return false;
			}
    		
    	});
    	
    	chooseGooglePlayMusicAccountPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
				final AccountManager accountManager = AccountManager.get(mContext);
		        final Account[] accounts = accountManager.getAccounts();
		        final int size = accounts.length;
		        final String[] accountNames = new String[size+1];
		        accountNames[0] = "Don't use Google Play Music";
		        
		        //Create a new array with a list of all account names on the device.
		        for (int i=0; i < accounts.length; i++) {
		        	accountNames[i+1] = accounts[i].name;
		        }
		        
		        //Get the current account name (if it exists) and get the index of the account name.
		        String currentAccountName = sharedPreferences.getString("GOOGLE_PLAY_MUSIC_ACCOUNT", "");
		        int accountIndex = -1;
		        if (!currentAccountName.isEmpty()) {
		        	for (int i=0; i < accounts.length; i++) {
		        		if (currentAccountName.equals(accountNames[i+1])) {
		        			accountIndex = i+1;
		        		}
		        		
		        	}
		        } else {
		        	accountIndex = 0;
		        }
		        
				
				//Display a list of all accounts that are currently on the device.
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
				builder.setTitle(R.string.select_google_account);
				builder.setSingleChoiceItems(accountNames, accountIndex, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int position) {
						if (position!=0) {
							//Start the sign-in process.
							Toast.makeText(mContext, R.string.signing_in_dot_dot_dot, Toast.LENGTH_SHORT).show();
							
							sharedPreferences.edit().putString("GOOGLE_PLAY_MUSIC_ACCOUNT", accountNames[position]).commit();
							AsyncGoogleMusicAuthenticationTask task = new AsyncGoogleMusicAuthenticationTask(mContext.getApplicationContext(), 
																											 mSettingsActivity,
																											 false,
																											 accountNames[position]);
							
							task.execute();
						} else {
							Toast.makeText(mContext, R.string.google_play_music_disabled, Toast.LENGTH_SHORT).show();
							sharedPreferences.edit().putBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false).commit();
							sharedPreferences.edit().putString("GOOGLE_PLAY_MUSIC_ACCOUNT", "").commit();
							
							//Restart the app.
							final Intent i = getBaseContext().getPackageManager().getLaunchIntentForPackage(getBaseContext().getPackageName());
							
							i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
							finish();
							startActivity(i);
							
						}
						
						dialog.dismiss();
					}
					
				});

				AlertDialog dialog = builder.create();
				dialog.show();
				
				return false;
			}
    		
    	});
    	
    	getPinnedSongsPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				mApp.queueSongsToPin(true, false, null);
				return false;
			}
    		
    	});
    	
    	addMusicLibraryPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
				Intent intent = new Intent(mContext, PreferenceDialogLauncherActivity.class);
				intent.putExtra("INDEX", 13);
				startActivity(intent);
				
				return false;
			}
    		
    	});
    	
    	editMusicLibraryPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {
				Intent intent = new Intent(mContext, PreferenceDialogLauncherActivity.class);
				intent.putExtra("INDEX", 14);
				intent.putExtra("OPERATION", "EDIT");
				startActivity(intent);
				
				return false;
			}
    		
    	});
    	
    	deleteMusicLibraryPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				Intent intent = new Intent(mContext, PreferenceDialogLauncherActivity.class);
				intent.putExtra("INDEX", 14);
				intent.putExtra("OPERATION", "DELETE");
				startActivity(intent);
				
				return false;
			}
    		
    	});
    	
    	albumArtStylePreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
				Intent intent = new Intent(mContext, PreferenceDialogLauncherActivity.class);
				intent.putExtra("INDEX", 3);
				startActivity(intent);
				
				return false;
			}
    		
    	});
    	
    	albumArtSourcesPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
				Intent intent = new Intent(mContext, PreferenceDialogLauncherActivity.class);
				intent.putExtra("INDEX", 4);
				startActivity(intent);
				
				return false;
			}
    		
    	});
    	
    	albumArtScanDownloadPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
		        //Start the service that will download album art.
				mContext.startService(new Intent(mContext, AutoFetchAlbumArtService.class));
				
				return false;
			}
    		
    	});
    	
    	
    	selectFoldersPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
				Intent intent = new Intent(mContext, PreferenceDialogLauncherActivity.class);
				intent.putExtra("INDEX", 5);
				startActivity(intent);
				
				return false;
			}
    		
    	});
    	
    	rescanFoldersPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
				//Seting the "REBUILD_LIBRARY" flag to true will force MainActivity to rescan the folders.
				sharedPreferences.edit().putBoolean("REBUILD_LIBRARY", true).commit();
				
				//Restart the app.
				final Intent i = getBaseContext().getPackageManager().getLaunchIntentForPackage(getBaseContext().getPackageName());
				
				i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
				finish();
				startActivity(i);
				
				return false;
			}
    		
    	});
    	
    	scanFrequencyPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
				Intent intent = new Intent(mContext, PreferenceDialogLauncherActivity.class);
				intent.putExtra("INDEX", 7);
				startActivity(intent);
				
				return false;
			}
    		
    	});
    	
    	blacklistManagerPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
/*				Intent intent = new Intent(mContext, PreferenceDialogLauncherActivity.class);
				intent.putExtra("INDEX", 8);
				startActivity(intent);*/
				
				/*String[] blacklistManagerChoices = { mContext.getResources().getString(R.string.manage_blacklisted_artists),
						 							 mContext.getResources().getString(R.string.manage_blacklisted_albums), 
						 							 mContext.getResources().getString(R.string.manage_blacklisted_songs), 
						 							 mContext.getResources().getString(R.string.manage_blacklisted_playlists) };
				
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);

		        //Set the dialog title.
		        builder.setTitle(R.string.blacklist_manager);
		        builder.setItems(blacklistManagerChoices, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						Bundle bundle = new Bundle();
						
						if (which==0) {
							bundle.putString("MANAGER_TYPE", "ARTISTS");
						} else if (which==1) {
							bundle.putString("MANAGER_TYPE", "ALBUMS");
						} else if (which==2) {
							bundle.putString("MANAGER_TYPE", "SONGS");
						} else if (which==3) {
							bundle.putString("MANAGER_TYPE", "PLAYLISTS");
						}
						
						dialog.dismiss();
						Intent intent = new Intent(mContext, BlacklistManagerActivity.class);
						intent.putExtras(bundle);
						startActivity(intent);
						
					}
		        	
		        });
		        
		        builder.create().show();*/
				
				Intent intent = new Intent(mContext, BlacklistManagerActivity.class);
				startActivity(intent);
				
				return false;
			}
    		
    	});
    	
    	unblacklistAllPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				AsyncUnblacklistAllSongsTask task = new AsyncUnblacklistAllSongsTask();
				task.execute();
				
				return false;
			}
    		
    	});
    	
/*    	bluetoothControlsPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				// TODO Auto-generated method stub
				return false;
			}
    		
    	});
    	
    	headphonesUnplugActionPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				// TODO Auto-generated method stub
				return false;
			}
    		
    	});*/
    	
    	scrobblingPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {
				
				int currentSelection = 0;
				if (sharedPreferences.getInt("SCROBBLING", 0)==0) {
					currentSelection = 0;
				} else if (sharedPreferences.getInt("SCROBBLING", 0)==1) {
					currentSelection = 1;
				} else if (sharedPreferences.getInt("SCROBBLING", 0)==2) {
					currentSelection = 2;
				}
				
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
				builder.setTitle(R.string.scrobbling);
				builder.setSingleChoiceItems(R.array.scrobbling_options, currentSelection, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						dialog.dismiss();
						Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
						sharedPreferences.edit().putInt("SCROBBLING", which).commit();
						
					}
					
				});
				
				builder.create().show();
				return false;
			}
    		
    	});
    	
    	headphonesUnplugActionPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {

				//Get the current selection.
				int currentSelection;
				if (sharedPreferences.getString("UNPLUG_ACTION", "DO_NOTHING").equals("DO_NOTHING")) {
					currentSelection = 0;
				} else {
					currentSelection = 1;
				}
				
				String[] unplugActionsArray = mContext.getResources().getStringArray(R.array.headphones_unplug_actions);
				
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
				builder.setTitle(R.string.headphones_unplug_action);
				builder.setSingleChoiceItems(unplugActionsArray, currentSelection, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						
						dialog.dismiss();
						Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
						if (which==0) {
							sharedPreferences.edit().putString("UNPLUG_ACTION", "DO_NOTHING").commit();
							if (sharedPreferences.getBoolean("SERVICE_RUNNING", false)==true) {
								mApp.getService().unregisterReceiver(mApp.getService().getHeadsetPlugReceiver());
							}
						} else {
							sharedPreferences.edit().putString("UNPLUG_ACTION", "PAUSE_MUSIC_PLAYBACK").commit();
							if (sharedPreferences.getBoolean("SERVICE_RUNNING", false)==true) {
								mApp.getService().registerHeadsetPlugReceiver();
							}
							
						}
						
					}
					
				});
				
				builder.create().show();
				
				return false;
			}
    		
    	});
    	
    	crossfadeTracksPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {
				
				int currentSelection;
				if (sharedPreferences.getBoolean(Common.CROSSFADE_ENABLED, false)==true) {
					currentSelection = 0;
				} else {
					currentSelection = 1;
				}
				
				String[] enableDisableArray = mContext.getResources().getStringArray(R.array.enable_disable);
				
				AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
				builder.setTitle(R.string.crossfade_tracks);
				builder.setSingleChoiceItems(enableDisableArray, currentSelection, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						
						dialog.dismiss();
						Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
						if (which==0) {
							sharedPreferences.edit().putBoolean(Common.CROSSFADE_ENABLED, true).commit();
							
							//Enable crossfade for the current queue.
							if (mApp.isServiceRunning() && mApp.getService().getHandler()!=null) {
								mApp.getService().getHandler().post(mApp.getService().startCrossFadeRunnable);
							}
							
						} else {
							sharedPreferences.edit().putBoolean(Common.CROSSFADE_ENABLED, false).commit();
							
							//Disable crossfade for the current queue.
							if (mApp.isServiceRunning() && mApp.getService().getHandler()!=null) {
								mApp.getService().getHandler().removeCallbacks(mApp.getService().startCrossFadeRunnable);
								mApp.getService().getHandler().removeCallbacks(mApp.getService().crossFadeRunnable);
							}
							
						}
						
					}
					
				});
				
				builder.create().show();
				return false;
			}
    		
    	});
    	
    	crossfadeTracksDurationPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {
				AlertDialog.Builder builder = new AlertDialog.Builder(mSettingsActivity);
				builder.setTitle(R.string.crossfade_duration);
				
				RelativeLayout dialogView = (RelativeLayout) mSettingsActivity.getLayoutInflater().inflate(R.layout.dialog_crossfade_duration, null);
				final TextView durationText = (TextView) dialogView.findViewById(R.id.crossfade_duration_text);
				final SeekBar durationSeekBar = (SeekBar) dialogView.findViewById(R.id.crossfade_duration_seekbar);
				
				int currentSeekBarDuration = sharedPreferences.getInt(Common.CROSSFADE_DURATION, 5);
				durationSeekBar.setMax(14);
				durationSeekBar.setProgress(currentSeekBarDuration);
				durationText.setText(currentSeekBarDuration + " secs");
				
				durationSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {

					@Override
					public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
						sharedPreferences.edit().putInt(Common.CROSSFADE_DURATION, (progress+1)).commit();
						durationText.setText((progress + 1) + " secs");
						
					}

					@Override
					public void onStartTrackingTouch(SeekBar seekBar) {
						// TODO Auto-generated method stub
						
					}

					@Override
					public void onStopTrackingTouch(SeekBar seekBar) {
						// TODO Auto-generated method stub
						
					}
					
				});
				
				builder.setView(dialogView);
				builder.setPositiveButton(R.string.ok, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int arg1) {
						dialog.dismiss();
						Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
						
					}
					
				});
				
				builder.create().show();			
				return false;
			}
    		
    	});
    	
    	equalizerPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference preference) {

				boolean currentSetting = sharedPreferences.getBoolean("EQUALIZER_ENABLED", true);
				int intCurrentSetting = -1;
				if (currentSetting==true)
					intCurrentSetting = 0;
				else
					intCurrentSetting = 1;
				
				AlertDialog.Builder builder = new AlertDialog.Builder(mSettingsActivity);
				builder.setTitle(R.string.equalizer);
				builder.setSingleChoiceItems(R.array.enable_disable, intCurrentSetting, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						
						boolean isEnabled;
						if (which==0)
							isEnabled = true;
						else
							isEnabled = false;
						
						sharedPreferences.edit().putBoolean("EQUALIZER_ENABLED", isEnabled).commit();
						Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();
						
						if (Build.PRODUCT.contains("HTC") && which==0) {
							showHTCEqualizerIssueDialog();
						}
						
						if (sharedPreferences.getBoolean("SERVICE_RUNNING", false)==true && which==0) {
							mApp.getService().initAudioFX();
						} else if (sharedPreferences.getBoolean("SERVICE_RUNNING", false)==true && which==1) {
							try {
								mApp.getService().getEqualizerHelper().releaseEQObjects();
							} catch (Exception e) {
								e.printStackTrace();
							}
							
						}
						
						dialog.dismiss();
					}

					private void showHTCEqualizerIssueDialog() {
						AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
						builder.setTitle(R.string.htc_devices);
						builder.setMessage(R.string.htc_devices_equalizer_issue);
						builder.setPositiveButton(R.string.ok, new OnClickListener() {

							@Override
							public void onClick(DialogInterface dialog, int which) {
								dialog.dismiss();
								
							}
							
						});
						
						builder.create().show();
						
					}
					
				});
				
				builder.create().show();
				return false;
			}
    		
    	});
    	
    	licensesPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
				Intent intent = new Intent(mContext, PreferenceDialogLauncherActivity.class);
				intent.putExtra("INDEX", 12);
				startActivity(intent);
				
				return false;
			}
    		
    	});
    	
    	contactUsPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

			@Override
			public boolean onPreferenceClick(Preference arg0) {
				
				Intent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.fromParts("mailto","jamsmusicplayer@gmail.com", null));
				emailIntent.putExtra(Intent.EXTRA_SUBJECT, "Jams Music Player Support");
				startActivity(Intent.createChooser(emailIntent, "Send email"));
				
				return false;
			}
    		
    	});
    	
	}
	
	@Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    	//Result Code 45 = UserRecoverableAuthenticationException from GooglePlayMusicAuthenticationDialog.
    	if (requestCode==45) {
    		
    		final Intent finalData = data;
    		final int finalResultCode = resultCode;
    		
    		runOnUiThread(new Runnable() {

				@Override
				public void run() {
					//An unknown error occurred.
		            if (finalData==null) {
						Toast.makeText(mContext, R.string.unknown_error_google_music, Toast.LENGTH_LONG).show();
		                return;
		            }
		            
		            //The user handled the exception properly.
		            if (finalResultCode==RESULT_OK) {
		            	
		            	sharedPreferences.edit().putBoolean("GOOGLE_PLAY_MUSIC_ENABLED", true).commit();
		            	sharedPreferences.edit().putString("GOOGLE_PLAY_MUSIC_ACCOUNT", mAccountName).commit();
				        return;
		            }
		            
		            if (finalResultCode==RESULT_CANCELED) {

				        return;
		            }
		            
		            Toast.makeText(mContext, R.string.unknown_error_google_music, Toast.LENGTH_LONG).show();
		            
				}
    			
    		});
    		
    	}
    	
    }
	
	/*private void initInAppBilling() {
		
		String base64EncodedPublicKey = "";
		base64EncodedPublicKey = Common.uid4 + 
								 Common.uid2 +
								 Common.uid6 +
								 Common.uid1 +
								 Common.uid3 +
								 Common.uid5;

    	mHelper = new IabHelper(this, base64EncodedPublicKey);
    	mHelper.startSetup(new IabHelper.OnIabSetupFinishedListener() {
    		
    		@Override
    		public void onIabSetupFinished(IabResult result) {
    			if (!result.isSuccess()) {
    				//In-app billing could not be initialized.
    				Toast.makeText(mSettingsActivity, R.string.unable_to_reach_google_play, Toast.LENGTH_LONG).show();
    			} else {             
    				//In-app billing was initialized successfully.
    				try {
    					mHelper.launchPurchaseFlow(mSettingsActivity, ITEM_SKU, 10001, mPurchaseFinishedListener, "");
    				} catch (Exception e) {
    					e.printStackTrace();
    					Toast.makeText(mContext, R.string.unable_to_reach_google_play, Toast.LENGTH_LONG).show();
    					finish();
    				}
    			}
    			
    		}
    		
    	});
    	
	}*/
	
	IabHelper.OnIabPurchaseFinishedListener mPurchaseFinishedListener = new IabHelper.OnIabPurchaseFinishedListener() {
		
		public void onIabPurchaseFinished(IabResult result, Purchase purchase) {
			
			if (result.isFailure()) {
				Toast.makeText(mContext, R.string.unable_to_purchase, Toast.LENGTH_LONG).show();
				sharedPreferences.edit().putBoolean("TRIAL", true).commit();
				return;
			} else if (purchase.getSku().equals(ITEM_SKU)) {

				Toast.makeText(mContext, R.string.jams_trial_time_removed, Toast.LENGTH_LONG).show();
				mApp.getSharedPreferences().edit().putBoolean("TRIAL", false).commit();
				PreferenceCategory upgradePrefCategory = (PreferenceCategory) preferenceManager.findPreference("upgrade_pref_category");
	    		upgradePrefCategory.removeAll();
	    		
			}
	      
		}
	   
	};

	class AsyncUnblacklistAllSongsTask extends AsyncTask<String, Void, Void> {

		private ProgressDialog pd;
		
		@Override
		public void onPreExecute() {
			super.onPreExecute();
			
			pd = new ProgressDialog(mSettingsActivity);
			pd.setTitle(R.string.reset_blacklist);
			pd.setProgressStyle(ProgressDialog.STYLE_SPINNER);
			pd.setMessage(getResources().getString(R.string.resetting_blacklist));
			pd.show();
			
		}
		
		@Override
		protected Void doInBackground(String... params) {
			return null;
		}
		
		@Override
		public void onPostExecute(Void result) {
			super.onPostExecute(result);
			
			pd.dismiss();
			Toast.makeText(mContext, R.string.blacklist_reset, Toast.LENGTH_SHORT).show();
		}
		
	}
	
	@Override
	public void onBackPressed() {
		super.onBackPressed();
		finish();
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.Fragment;
import android.content.Context;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.jams.music.player.Utils.Common;

/**
 * @author Saravan Pantham
 */
public class SettingsAlbumArtFragment extends Fragment {

    private Context mContext;
    private Common mApp;
    private View mRootView;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;


        return mRootView;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.AlertDialog;
import android.app.FragmentTransaction;
import android.content.Context;
import android.content.DialogInterface;
import android.os.Build;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.Preference;
import android.preference.PreferenceFragment;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.Dialogs.ApplicationThemeDialog;
import com.jams.music.player.Dialogs.NowPlayingColorSchemesDialog;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

/**
 * @author Saravan Pantham
 */
public class SettingsAppearanceFragment extends PreferenceFragment {

    private Context mContext;
    private Common mApp;

    private View mRootView;
    private ListView mListView;

    private Preference mAppThemePreference;
    private Preference mColorPreference;
    private Preference mDefaultScreenPreference;
    private CheckBoxPreference mLockscreenControlsPreference;

    @Override
    public void onCreate(Bundle onSavedInstanceState) {
        super.onCreate(onSavedInstanceState);
        addPreferencesFromResource(R.xml.settings_appearance);

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle onSavedInstanceState) {
        mRootView = super.onCreateView(inflater, container, onSavedInstanceState);

        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;
        mListView = (ListView) mRootView.findViewById(android.R.id.list);

        //Set the ActionBar background and text color.
        applyKitKatTranslucency();
        getActivity().getActionBar().setTitle(R.string.settings);
        int titleId = getResources().getIdentifier("action_bar_title", "id", "android");
        TextView actionBarText = (TextView) getActivity().findViewById(titleId);
        actionBarText.setTextColor(0xFFFFFFFF);

        mAppThemePreference = getPreferenceManager().findPreference("preference_key_app_theme");
        mColorPreference = getPreferenceManager().findPreference("preference_key_player_color_scheme");
        mDefaultScreenPreference = getPreferenceManager().findPreference("preference_key_startup_screen");
        mLockscreenControlsPreference = (CheckBoxPreference) getPreferenceManager().findPreference("preference_key_lockscreen_controls");

        //Apply the click listeners.
        mAppThemePreference.setOnPreferenceClickListener(appThemeClickListener);
        mColorPreference.setOnPreferenceClickListener(colorClickListener);
        mDefaultScreenPreference.setOnPreferenceClickListener(defaultScreenClickListener);
        mLockscreenControlsPreference.setOnPreferenceChangeListener(lockscreenControlsClickListener);

        return mRootView;
    }

    /**
     * Applies KitKat specific translucency.
     */
    private void applyKitKatTranslucency() {
        if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT) {

            //Calculate ActionBar and navigation bar height.
            TypedValue tv = new TypedValue();
            int actionBarHeight = 0;
            if (getActivity().getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) {
                actionBarHeight = TypedValue.complexToDimensionPixelSize(tv.data, getResources().getDisplayMetrics());
            }

            mListView.setBackgroundColor(0xFFEEEEEE);
            mRootView.setPadding(0, actionBarHeight + mApp.getStatusBarHeight(mContext),
                                 0, 0);
            mListView.setPadding(10, 0, 10, mApp.getNavigationBarHeight(mContext));
            mListView.setClipToPadding(false);

            //Set the window color.
            getActivity().getWindow().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));

        }

    }

    /**
     * Click listener for the app theme preference.
     */
    private Preference.OnPreferenceClickListener appThemeClickListener = new Preference.OnPreferenceClickListener() {

        @Override
        public boolean onPreferenceClick(Preference preference) {
            FragmentTransaction ft = getChildFragmentManager().beginTransaction();
            ApplicationThemeDialog appThemeDialog = new ApplicationThemeDialog();
            appThemeDialog.show(ft, "appThemeDialog");

            return false;
        }

    };

    /**
     * Click listener for the color preference.
     */
    private Preference.OnPreferenceClickListener colorClickListener = new Preference.OnPreferenceClickListener() {

        @Override
        public boolean onPreferenceClick(Preference preference) {
            FragmentTransaction ft = getChildFragmentManager().beginTransaction();
            NowPlayingColorSchemesDialog appThemeDialog = new NowPlayingColorSchemesDialog();
            appThemeDialog.show(ft, "colorSchemesDialog");

            return false;
        }

    };

    /**
     * Click listener for the default browser preference.
     */
    private Preference.OnPreferenceClickListener defaultScreenClickListener = new Preference.OnPreferenceClickListener() {

        @Override
        public boolean onPreferenceClick(Preference preference) {
            //Get the current preference.
            int currentPreference = mApp.getSharedPreferences().getInt(Common.STARTUP_BROWSER, 0);

            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setTitle(R.string.default_browser);
            builder.setSingleChoiceItems(R.array.startup_screen_items, currentPreference, new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface dialog, int which) {
                    mApp.getSharedPreferences().edit().putInt(Common.STARTUP_BROWSER, which).commit();
                    dialog.dismiss();
                    Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();

                }

            });

            builder.create().show();
            return false;
        }

    };

    /**
     * Checkbox click listener for the lockscreen controls preference.
     */
    private Preference.OnPreferenceChangeListener lockscreenControlsClickListener = new Preference.OnPreferenceChangeListener() {

        @Override
        public boolean onPreferenceChange(Preference preference, Object newValue) {
            boolean value = (Boolean) newValue;
            mApp.getSharedPreferences().edit().putBoolean(Common.SHOW_LOCKSCREEN_CONTROLS, value).commit();
            ((CheckBoxPreference) preference).setChecked(value);
            return false;
        }
    };

    @Override
    public void onResume() {
        super.onResume();

        if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT)
            getActivity().getActionBar().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));

    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.Fragment;
import android.content.Context;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.jams.music.player.Utils.Common;

/**
 * @author Saravan Pantham
 */
public class SettingsAudioFragment extends Fragment {

    private Context mContext;
    private Common mApp;
    private View mRootView;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;


        return mRootView;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.Fragment;
import android.content.Context;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.jams.music.player.Utils.Common;

/**
 * @author Saravan Pantham
 */
public class SettingsBlacklistsFragment extends Fragment {

    private Context mContext;
    private Common mApp;
    private View mRootView;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;


        return mRootView;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.Fragment;
import android.content.Context;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.jams.music.player.Utils.Common;

/**
 * @author Saravan Pantham
 */
public class SettingsFoldersFragment extends Fragment {

    private Context mContext;
    private Common mApp;
    private View mRootView;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;


        return mRootView;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.Fragment;
import android.content.Context;
import android.os.Bundle;
import android.preference.PreferenceFragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.jams.music.player.Utils.Common;

/**
 * @author Saravan Pantham
 */
public class SettingsFragment extends PreferenceFragment {

    private Context mContext;
    private Common mApp;
    private View mRootView;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;


        return mRootView;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.Fragment;
import android.content.Context;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.jams.music.player.Utils.Common;

/**
 * @author Saravan Pantham
 */
public class SettingsGMusicFragment extends Fragment {

    private Context mContext;
    private Common mApp;
    private View mRootView;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;


        return mRootView;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.Fragment;
import android.content.Context;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.jams.music.player.Utils.Common;

/**
 * @author Saravan Pantham
 */
public class SettingsLabelsFragment extends Fragment {

    private Context mContext;
    private Common mApp;
    private View mRootView;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;


        return mRootView;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.os.Build;
import android.os.Bundle;
import android.preference.Preference;
import android.preference.PreferenceFragment;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

/**
 * @author Saravan Pantham
 */
public class SettingsLayoutsFragment extends PreferenceFragment {

    private Context mContext;
    private Common mApp;

    private View mRootView;
    private ListView mListView;

    private Preference mArtistsPreference;
    private Preference mAlbumArtistsPreference;
    private Preference mAlbumsPreference;
    private Preference mGenresPreference;
    private Preference mPlaylistsPreference;
    private Preference mFoldersPreference;

    @Override
    public void onCreate(Bundle onSavedInstanceState) {
        super.onCreate(onSavedInstanceState);
        addPreferencesFromResource(R.xml.settings_layouts);

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle onSavedInstanceState) {
        mRootView = super.onCreateView(inflater, container, onSavedInstanceState);

        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;
        mListView = (ListView) mRootView.findViewById(android.R.id.list);

        //Set the ActionBar background and text color.
        applyKitKatTranslucency();
        getActivity().getActionBar().setTitle(R.string.settings);
        int titleId = getResources().getIdentifier("action_bar_title", "id", "android");
        TextView actionBarText = (TextView) getActivity().findViewById(titleId);
        actionBarText.setTextColor(0xFFFFFFFF);

        mArtistsPreference = getPreferenceManager().findPreference("preference_key_artists_layout");
        mAlbumArtistsPreference = getPreferenceManager().findPreference("preference_key_album_artists_layout");
        mAlbumsPreference = getPreferenceManager().findPreference("preference_key_albums_layout");
        mPlaylistsPreference = getPreferenceManager().findPreference("preference_key_playlists_layout");
        mGenresPreference = getPreferenceManager().findPreference("preference_key_genres_layout");
        mFoldersPreference = getPreferenceManager().findPreference("preference_key_folders_layout");

        //Apply the click listeners.
        mArtistsPreference.setOnPreferenceClickListener(artistsLayoutClickListener);
        mAlbumArtistsPreference.setOnPreferenceClickListener(albumArtistsClickListener);
        mAlbumsPreference.setOnPreferenceClickListener(albumsLayoutClickListener);
        mPlaylistsPreference.setOnPreferenceClickListener(playlistsClickListener);
        mGenresPreference.setOnPreferenceClickListener(genresClickListener);
        mFoldersPreference.setOnPreferenceClickListener(foldersClickListener);

        return mRootView;
    }

    /**
     * Applies KitKat specific translucency.
     */
    private void applyKitKatTranslucency() {
        if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT) {

            //Calculate ActionBar and navigation bar height.
            TypedValue tv = new TypedValue();
            int actionBarHeight = 0;
            if (getActivity().getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) {
                actionBarHeight = TypedValue.complexToDimensionPixelSize(tv.data, getResources().getDisplayMetrics());
            }

            mListView.setBackgroundColor(0xFFEEEEEE);
            mRootView.setPadding(0, actionBarHeight + mApp.getStatusBarHeight(mContext),
                    0, 0);
            mListView.setPadding(10, 0, 10, mApp.getNavigationBarHeight(mContext));
            mListView.setClipToPadding(false);

            //Set the window color.
            getActivity().getWindow().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));

        }

    }

    /**
     * Click listener for Artists Layout.
     */
    private Preference.OnPreferenceClickListener artistsLayoutClickListener = new Preference.OnPreferenceClickListener() {

        @Override
        public boolean onPreferenceClick(Preference preference) {

            //Get the current preference.
            int currentPreference = mApp.getSharedPreferences().getInt(Common.ARTISTS_LAYOUT, 0);

            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setTitle(R.string.artists_layout);
            builder.setSingleChoiceItems(R.array.layout_preference_items, currentPreference, new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface dialog, int which) {
                    mApp.getSharedPreferences().edit().putInt(Common.ARTISTS_LAYOUT, which).commit();
                    dialog.dismiss();
                    Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();

                }

            });

            builder.create().show();
            return false;
        }

    };

    /**
     * Click listener for Albums Layout.
     */
    private Preference.OnPreferenceClickListener albumsLayoutClickListener = new Preference.OnPreferenceClickListener() {

        @Override
        public boolean onPreferenceClick(Preference preference) {

            //Get the current preference.
            int currentPreference = mApp.getSharedPreferences().getInt(Common.ALBUMS_LAYOUT, 0);

            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setTitle(R.string.albums_layout);
            builder.setSingleChoiceItems(R.array.layout_preference_items, currentPreference, new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface dialog, int which) {
                    mApp.getSharedPreferences().edit().putInt(Common.ALBUMS_LAYOUT, which).commit();
                    dialog.dismiss();
                    Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();

                }

            });

            builder.create().show();
            return false;
        }

    };

    /**
     * Click listener for Album Artists layout.
     */
    private Preference.OnPreferenceClickListener albumArtistsClickListener = new Preference.OnPreferenceClickListener() {

        @Override
        public boolean onPreferenceClick(Preference preference) {

            //Get the current preference.
            int currentPreference = mApp.getSharedPreferences().getInt(Common.ALBUM_ARTISTS_LAYOUT, 0);

            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setTitle(R.string.album_artists_layout);
            builder.setSingleChoiceItems(R.array.layout_preference_items, currentPreference, new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface dialog, int which) {
                    mApp.getSharedPreferences().edit().putInt(Common.ALBUM_ARTISTS_LAYOUT, which).commit();
                    dialog.dismiss();
                    Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();

                }

            });

            builder.create().show();
            return false;
        }

    };

    /**
     * Click listener for Playlists layout.
     */
    private Preference.OnPreferenceClickListener playlistsClickListener = new Preference.OnPreferenceClickListener() {

        @Override
        public boolean onPreferenceClick(Preference preference) {
            
            //Get the current preference.
            int currentPreference = mApp.getSharedPreferences().getInt(Common.PLAYLISTS_LAYOUT, 0);

            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setTitle(R.string.playlists_layout);
            builder.setSingleChoiceItems(R.array.layout_preference_items, currentPreference, new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface dialog, int which) {
                    mApp.getSharedPreferences().edit().putInt(Common.PLAYLISTS_LAYOUT, which).commit();
                    dialog.dismiss();
                    Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();

                }

            });

            builder.create().show();
            return false;
        }

    };

    /**
     * Click listener for Genres layout.
     */
    private Preference.OnPreferenceClickListener genresClickListener = new Preference.OnPreferenceClickListener() {

        @Override
        public boolean onPreferenceClick(Preference preference) {
            
            //Get the current preference.
            int currentPreference = mApp.getSharedPreferences().getInt(Common.GENRES_LAYOUT, 0);

            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setTitle(R.string.genres_layout);
            builder.setSingleChoiceItems(R.array.layout_preference_items, currentPreference, new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface dialog, int which) {
                    mApp.getSharedPreferences().edit().putInt(Common.GENRES_LAYOUT, which).commit();
                    dialog.dismiss();
                    Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();

                }

            });

            builder.create().show();
            return false;
        }

    };

    /**
     * Click listener for Folders layout.
     */
    private Preference.OnPreferenceClickListener foldersClickListener = new Preference.OnPreferenceClickListener() {

        @Override
        public boolean onPreferenceClick(Preference preference) {
            
            //Get the current preference.
            int currentPreference = mApp.getSharedPreferences().getInt(Common.FOLDERS_LAYOUT, 0);

            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setTitle(R.string.folders_layout);
            builder.setSingleChoiceItems(R.array.layout_preference_items, currentPreference, new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface dialog, int which) {
                    mApp.getSharedPreferences().edit().putInt(Common.FOLDERS_LAYOUT, which).commit();
                    dialog.dismiss();
                    Toast.makeText(mContext, R.string.changes_saved, Toast.LENGTH_SHORT).show();

                }

            });

            builder.create().show();
            return false;
        }

    };

    @Override
    public void onResume() {
        super.onResume();

        if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT)
            getActivity().getActionBar().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));

    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.content.Context;
import android.graphics.Color;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;

import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.MusicFoldersSelectionFragment.MusicFoldersSelectionFragment;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;

import java.util.Set;

public class SettingsMultiselectAdapter extends ArrayAdapter<String> {

	private Context mContext;
	private Common mApp;
	private SettingsMusicFoldersDialog mFragment;
	private boolean mDirChecked;
	private boolean mWelcomeSetup;
   
    public SettingsMultiselectAdapter(Context context,
                                      SettingsMusicFoldersDialog fragment,
                                      boolean welcomeSetup,
                                      boolean dirChecked) {
    	
    	super(context, -1, fragment.getFileFolderNamesList());
    	
    	mContext = context;
    	mApp = (Common) mContext.getApplicationContext();
    	mFragment = fragment;
    	mDirChecked = dirChecked; //Indicates if this entire dir is a music folder.
    	mWelcomeSetup = welcomeSetup;
    	
    }
    
    @Override
    public View getView(int position, View convertView, ViewGroup parent){
		FoldersMultiselectHolder holder = null;

		if (convertView==null) {
			convertView = LayoutInflater.from(mContext).inflate(R.layout.folder_view_layout_multiselect, parent, false);

			holder = new FoldersMultiselectHolder();
			holder.fileFolderNameText = (TextView) convertView.findViewById(R.id.file_folder_title_multiselect);
			holder.fileFoldersCheckbox = (CheckBox) convertView.findViewById(R.id.music_folder_select_checkbox);
			holder.fileFoldersImage = (ImageView) convertView.findViewById(R.id.file_folder_icon);
			holder.fileFolderSizeText = (TextView) convertView.findViewById(R.id.file_folder_size_multiselect);

            holder.fileFolderNameText.setTextColor(Color.parseColor("#2F2F2F"));
            holder.fileFolderSizeText.setTextColor(UIElementsHelper.getSmallTextColor(mContext));

			holder.fileFolderNameText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			holder.fileFolderSizeText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
			
			holder.fileFoldersImage.setImageResource(R.drawable.icon_folderblue);
			convertView.setTag(holder);
			
		} else {
		    holder = (FoldersMultiselectHolder) convertView.getTag();
		}
		
		try {
			holder.fileFolderNameText.setText(mFragment.getFileFolderNamesList().get(position));
			holder.fileFolderSizeText.setText(mFragment.getFileFolderSizesList().get(position));
			
			//Set the corresponding path of the checkbox as it's tag.
			holder.fileFoldersCheckbox.setTag(mFragment.getFileFolderPathsList().get(position));
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		//Set the checkbox status.
		String folderPath = mFragment.getFileFolderPathsList().get(position);
		if (mDirChecked) {
			holder.fileFoldersCheckbox.setChecked(true);
			if (mFragment.getMusicFoldersHashMap().get(folderPath)!=null && 
				mFragment.getMusicFoldersHashMap().get(folderPath)==false) {
				holder.fileFoldersCheckbox.setChecked(false);
			}
			
		} else {
			holder.fileFoldersCheckbox.setChecked(false);
			if (mFragment.getMusicFoldersHashMap().get(folderPath)!=null && 
				mFragment.getMusicFoldersHashMap().get(folderPath)==true) {
				holder.fileFoldersCheckbox.setChecked(true);
			}
			
		}
		
		holder.fileFoldersCheckbox.setOnCheckedChangeListener(checkChangeListener);
		return convertView;
	}
    
    /**
	 * Checkbox status listener.
     */
    private OnCheckedChangeListener checkChangeListener = new OnCheckedChangeListener() {

		@Override
		public void onCheckedChanged(CompoundButton checkBox, boolean isChecked) {
			
			//Only respond to user presses.
			if (checkBox.isPressed()) {
				String filePath = (String) checkBox.getTag();
                if (isChecked)
				    mFragment.getMusicFoldersHashMap().put(filePath, true);
                else
                    if (mFragment.getMusicFoldersHashMap().containsKey(filePath))
                        removeKeyAndSubFolders(filePath);
                    else
                        mFragment.getMusicFoldersHashMap().put(filePath, false);
				
			}
			
		}
    	
    };

    /**
     * Loops through the HashMap and removes the specified key and
     * all other keys that start with the specified key.
     */
    private void removeKeyAndSubFolders(String key) {
        //Get a list of all file paths (keys).
        Set<String> keySet = mFragment.getMusicFoldersHashMap().keySet();
        String[] keyArray = new String[keySet.size()];
        keySet.toArray(keyArray);

        if (keyArray==null || keyArray.length==0)
            return;

        for (int i=0; i < keyArray.length; i++)
            if (keyArray[i].startsWith(key))
                mFragment.getMusicFoldersHashMap().remove(keyArray[i]);

    }

    static class FoldersMultiselectHolder {
		public TextView fileFolderNameText;
		public TextView fileFolderSizeText;
		public CheckBox fileFoldersCheckbox;
		public ImageView fileFoldersImage;

    }
   
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.annotation.SuppressLint;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.Cursor;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.support.v4.app.Fragment;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.jams.music.player.AsyncTasks.AsyncSaveMusicFoldersTask;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.MusicFoldersSelectionFragment.MultiselectListViewAdapter;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.WelcomeActivity.WelcomeActivity;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

public class SettingsMusicFoldersDialog extends DialogFragment {
	
	private Context mContext;
	private Common mApp;
	private boolean mWelcomeSetup = false;

    private RelativeLayout mUpLayout;
    private ImageView mUpIcon;
    private TextView mUpText;
    private TextView mCurrentFolderText;

	private ListView mFoldersListView;
	private Cursor mCursor;
	
	private String mRootDir;
	private String mCurrentDir;
	
	private List<String> mFileFolderNamesList; 
	private List<String> mFileFolderPathsList;
	private List<String> mFileFolderSizesList;
	private HashMap<String, Boolean> mMusicFolders;

    @Override
    public Dialog onCreateDialog(Bundle onSavedInstanceState) {
        AlertDialog.Builder builder =  new  AlertDialog.Builder(getActivity());

        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;
        View rootView = getActivity().getLayoutInflater().inflate(R.layout.fragment_folders_selection, null);
        mMusicFolders = new HashMap<String, Boolean>();

        mFoldersListView = (ListView) rootView.findViewById(R.id.folders_list_view);
        mFoldersListView.setFastScrollEnabled(true);
        mWelcomeSetup = getArguments().getBoolean("com.jams.music.player.WELCOME");

        mUpLayout = (RelativeLayout) rootView.findViewById(R.id.folders_up_layout);
        mUpIcon = (ImageView) rootView.findViewById(R.id.folders_up_icon);
        mUpText = (TextView) rootView.findViewById(R.id.folders_up_text);
        mCurrentFolderText = (TextView) rootView.findViewById(R.id.folders_current_directory_text);

        mUpText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        mCurrentFolderText.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));

        mUpLayout.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                try {
                    getDir(new File(mCurrentDir).getParentFile().getCanonicalPath());
                } catch (Exception e) {
                    e.printStackTrace();
                }

            }

        });

        if (mWelcomeSetup) {
            mFoldersListView.setDivider(getResources().getDrawable(R.drawable.icon_list_divider_light));
            mUpIcon.setImageResource(R.drawable.up);
        } else {
            mUpIcon.setImageResource(UIElementsHelper.getIcon(mContext, "up"));

            if (mApp.getCurrentTheme()==Common.DARK_THEME) {
                mUpIcon.setImageResource(R.drawable.icon_list_divider_light);
            } else {
                mUpIcon.setImageResource(R.drawable.icon_list_divider);
            }

        }

        mFoldersListView.setDividerHeight(1);
        mRootDir = Environment.getExternalStorageDirectory().getAbsolutePath().toString();
        mCurrentDir = mRootDir;

        //Get a mCursor with a list of all the current folder paths (will be empty if this is the first run).
        mCursor = mApp.getDBAccessHelper().getAllMusicFolderPaths();

        //Get a list of all the paths that are currently stored in the DB.
        for (int i=0; i < mCursor.getCount(); i++) {
            mCursor.moveToPosition(i);

            //Filter out any double slashes.
            String path = mCursor.getString(mCursor.getColumnIndex(DBAccessHelper.FOLDER_PATH));
            if (path.contains("//")) {
                path.replace("//", "/");
            }

            mMusicFolders.put(path, true);
        }

        //Close the cursor.
        if (mCursor!=null)
            mCursor.close();

        //Get the folder hierarchy of the selected folder.
        getDir(mRootDir);

        mFoldersListView.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> arg0, View arg1, int index, long arg3) {
                String newPath = mFileFolderPathsList.get(index);
                getDir(newPath);

            }

        });

        builder.setTitle(R.string.select_music_folders);
        builder.setView(rootView);
        builder.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                getActivity().finish();

                Intent intent = new Intent(mContext, WelcomeActivity.class);
                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
                intent.putExtra("REFRESH_MUSIC_LIBRARY", true);
                mContext.startActivity(intent);

            }

        });

        builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                dialog.dismiss();

            }

        });

        return builder.create();
    }

    /**
     * Sets the current directory's text.
     */
    private void setCurrentDirText() {
        mCurrentFolderText.setText(mCurrentDir);
    }
	
	/**
	 * Retrieves the folder hierarchy for the specified folder 
	 * (this method is NOT recursive and doesn't go into the parent 
	 * folder's subfolders. 
	 */
    private void getDir(String dirPath) {

		mFileFolderNamesList = new ArrayList<String>();
		mFileFolderPathsList = new ArrayList<String>();
		mFileFolderSizesList = new ArrayList<String>();
		
		File f = new File(dirPath);
		File[] files = f.listFiles();
		Arrays.sort(files);
		 
		if (files!=null) {
			
			for(int i=0; i < files.length; i++) {
				
				File file = files[i];
			 
				if(!file.isHidden() && file.canRead()) {
					
					if (file.isDirectory()) {
						
						/*
						 * Starting with Android 4.2, /storage/emulated/legacy/... 
						 * is a symlink that points to the actual directory where 
						 * the user's files are stored. We need to detect the 
						 * actual directory's file path here.
						 */
						String filePath;
						if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) 
							filePath = getRealFilePath(file.getAbsolutePath());
						else
							filePath = file.getAbsolutePath();
							
						mFileFolderPathsList.add(filePath);
						mFileFolderNamesList.add(file.getName());
						
						File[] listOfFiles = file.listFiles();
						
						if (listOfFiles!=null) {
							if (listOfFiles.length==1) {
								mFileFolderSizesList.add("" + listOfFiles.length + " item");
							} else {
								mFileFolderSizesList.add("" + listOfFiles.length + " items");
							}
							
						}
						
					}
					
				} 
			
			}
			
		}
		
		boolean dirChecked = false;

        //Get the directory and the parent dir.
        String concatatedString = "";
        int secondSlashIndex = dirPath.lastIndexOf("/", dirPath.lastIndexOf("/")-1);
        if ((secondSlashIndex < dirPath.length()) && secondSlashIndex!=-1)
            concatatedString = dirPath.substring(secondSlashIndex, dirPath.length());

		if (getMusicFoldersHashMap().get(concatatedString)!=null)
			dirChecked = getMusicFoldersHashMap().get(concatatedString);

		SettingsMultiselectAdapter mFoldersListViewAdapter = new SettingsMultiselectAdapter(getActivity(),
																							this, 
																							mWelcomeSetup,
																							dirChecked);
		
		mFoldersListView.setAdapter(mFoldersListViewAdapter);
		mFoldersListViewAdapter.notifyDataSetChanged();

        mCurrentDir = dirPath;
        setCurrentDirText();
		
    }
    
    /**
     * Resolves the /storage/emulated/legacy paths to 
     * their true folder path representations. Required 
     * for Nexuses and other devices with no SD card.
     */
    @SuppressLint("SdCardPath") 
    private String getRealFilePath(String filePath) {
    	
    	if (filePath.equals("/storage/emulated/0") || 
    		filePath.equals("/storage/emulated/0/") ||
    		filePath.equals("/storage/emulated/legacy") ||
    		filePath.equals("/storage/emulated/legacy/") ||
    		filePath.equals("/storage/sdcard0") || 
    		filePath.equals("/storage/sdcard0/") ||
    		filePath.equals("/sdcard") || 
    		filePath.equals("/sdcard/") || 
    		filePath.equals("/mnt/sdcard") || 
    		filePath.equals("/mnt/sdcard/")) {
    		
    		return Environment.getExternalStorageDirectory().toString();
    	}

    	return filePath;
    }

	@Override
	public void onDestroyView() {
		super.onDestroyView();

		if (isRemoving()) {
			mCursor.close();
			mCursor = null;

            //Clear the DB and insert the new selections (along with the old ones).
            mApp.getDBAccessHelper().deleteAllMusicFolderPaths();
            try {
                mApp.getDBAccessHelper().getWritableDatabase().beginTransaction();

                //Retrieve a list of all keys in the hash map (key = music folder path).
                ArrayList<String> mPathsList = new ArrayList<String>(mMusicFolders.keySet());

                for (int i=0; i < mMusicFolders.size(); i++) {
                    String path = mPathsList.get(i);
                    boolean include = mMusicFolders.get(path);

                    //Trim down the folder path to include only the folder and its parent.
                    int secondSlashIndex = path.lastIndexOf("/", path.lastIndexOf("/")-1);
                    if ((secondSlashIndex < path.length()) && secondSlashIndex!=-1)
                        path = path.substring(secondSlashIndex, path.length());

                    ContentValues values = new ContentValues();
                    values.put(DBAccessHelper.FOLDER_PATH, path);
                    values.put(DBAccessHelper.INCLUDE, include);

                    mApp.getDBAccessHelper().getWritableDatabase().insert(DBAccessHelper.MUSIC_FOLDERS_TABLE, null, values);
                }

            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                mApp.getDBAccessHelper().getWritableDatabase().setTransactionSuccessful();
                mApp.getDBAccessHelper().getWritableDatabase().endTransaction();
            }

		}
		
	}
	
	/*
	 * Getter methods.
	 */
	public HashMap<String, Boolean> getMusicFoldersHashMap() {
		return mMusicFolders;
	}
	
	public ArrayList<String> getMusicFolderPaths() {
		return new ArrayList<String>(mMusicFolders.keySet());
	}
	
	public List<String> getFileFolderNamesList() {
		return mFileFolderNamesList;
	}
	
	public List<String> getFileFolderSizesList() {
		return mFileFolderSizesList;
	}
	
	public List<String> getFileFolderPathsList() {
		return mFileFolderPathsList;
	}
	
}


@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.AlertDialog;
import android.app.FragmentTransaction;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.Preference;
import android.preference.PreferenceFragment;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import com.jams.music.player.Dialogs.ApplicationThemeDialog;
import com.jams.music.player.Dialogs.NowPlayingColorSchemesDialog;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.MusicFoldersSelectionFragment.MusicFoldersSelectionFragment;
import com.jams.music.player.R;
import com.jams.music.player.Utils.Common;
import com.jams.music.player.WelcomeActivity.WelcomeActivity;

/**
 * @author Saravan Pantham
 */
public class SettingsMusicLibraryFragment extends PreferenceFragment {

    private Context mContext;
    private Common mApp;

    private View mRootView;
    private ListView mListView;

    private Preference mSelectMusicFoldersPreference;
    private Preference mRefreshMusicFoldersPreference;

    @Override
    public void onCreate(Bundle onSavedInstanceState) {
        super.onCreate(onSavedInstanceState);
        addPreferencesFromResource(R.xml.settings_music_library);

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle onSavedInstanceState) {
        mRootView = super.onCreateView(inflater, container, onSavedInstanceState);

        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;
        mListView = (ListView) mRootView.findViewById(android.R.id.list);

        //Set the ActionBar background and text color.
        applyKitKatTranslucency();
        getActivity().getActionBar().setTitle(R.string.settings);
        int titleId = getResources().getIdentifier("action_bar_title", "id", "android");
        TextView actionBarText = (TextView) getActivity().findViewById(titleId);
        actionBarText.setTextColor(0xFFFFFFFF);

        mSelectMusicFoldersPreference = getPreferenceManager().findPreference("preference_key_music_folders");
        mRefreshMusicFoldersPreference = getPreferenceManager().findPreference("preference_key_refresh_music_library");

        mSelectMusicFoldersPreference.setOnPreferenceClickListener(selectMusicFoldersClickListener);
        mRefreshMusicFoldersPreference.setOnPreferenceClickListener(refreshMusicFoldersClickListener);

        return mRootView;
    }

    /**
     * Applies KitKat specific translucency.
     */
    private void applyKitKatTranslucency() {
        if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT) {

            //Calculate ActionBar and navigation bar height.
            TypedValue tv = new TypedValue();
            int actionBarHeight = 0;
            if (getActivity().getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) {
                actionBarHeight = TypedValue.complexToDimensionPixelSize(tv.data, getResources().getDisplayMetrics());
            }

            mListView.setBackgroundColor(0xFFEEEEEE);
            mRootView.setPadding(0, actionBarHeight + mApp.getStatusBarHeight(mContext),
                    0, 0);
            mListView.setPadding(10, 0, 10, mApp.getNavigationBarHeight(mContext));
            mListView.setClipToPadding(false);

            //Set the window color.
            getActivity().getWindow().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));

        }

    }

    /**
     * Click listener for "Select Music Folders".
     */
    private Preference.OnPreferenceClickListener selectMusicFoldersClickListener = new Preference.OnPreferenceClickListener() {

        @Override
        public boolean onPreferenceClick(Preference preference) {
            FragmentTransaction ft = getChildFragmentManager().beginTransaction();
            Bundle bundle = new Bundle();
            SettingsMusicFoldersDialog foldersDialog = new SettingsMusicFoldersDialog();
            foldersDialog.setArguments(bundle);
            foldersDialog.show(ft, "foldersDialog");

            return false;
        }

    };

    /**
     * Click listener for "Refresh Music Folders".
     */
    private Preference.OnPreferenceClickListener refreshMusicFoldersClickListener = new Preference.OnPreferenceClickListener() {

        @Override
        public boolean onPreferenceClick(Preference preference) {
            getActivity().finish();

            Intent intent = new Intent(mContext, WelcomeActivity.class);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
            intent.putExtra("REFRESH_MUSIC_LIBRARY", true);
            mContext.startActivity(intent);

            return false;
        }

    };

    @Override
    public void onResume() {
        super.onResume();

        if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT)
            getActivity().getActionBar().setBackgroundDrawable(UIElementsHelper.getGeneralActionBarBackground(mContext));

    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.SettingsActivity;

import android.app.Fragment;
import android.content.Context;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.jams.music.player.Utils.Common;

/**
 * @author Saravan Pantham
 */
public class SettingsScrobblingFragment extends Fragment {

    private Context mContext;
    private Common mApp;
    private View mRootView;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mContext = getActivity().getApplicationContext();
        mApp = (Common) mContext;


        return mRootView;
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Transformers;

import android.graphics.Camera;
import android.graphics.Matrix;
import android.view.View;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.Transformation;

public class CardFlipAnimation extends Animation {
    private Camera camera;
 
    private View fromView;
    private View toView;
 
    private float centerX;
    private float centerY;
 
    private boolean forward = true;
 
    /**
     * Creates a 3D flip animation between two views.
     *
     * @param fromView First fragment in the transition.
     * @param toView Second fragment in the transition.
     */
    public CardFlipAnimation(View fromView, View toView) {
        this.fromView = fromView;
        this.toView = toView;
 
        setDuration(400);
        setFillAfter(false);
        setInterpolator(new AccelerateDecelerateInterpolator());
    }
 
    public void reverse() {
        forward = false;
        View switchView = toView;
        toView = fromView;
        fromView = switchView;
    }
 
    @Override
    public void initialize(int width, int height, int parentWidth, int parentHeight) {
        super.initialize(width, height, parentWidth, parentHeight);
        centerX = width/2;
        centerY = height/2;
        camera = new Camera();
    }
 
    @Override
    protected void applyTransformation(float interpolatedTime, Transformation t) {
        /* Angle around the y-axis of the rotation at the given time
         * calculated both in radians and degrees.
         */
        final double radians = Math.PI * interpolatedTime;
        float degrees = (float) (180.0 * radians / Math.PI);
 
        /* Once we reach the midpoint in the animation, we need to hide the
         * source fragment and show the destination fragment. We also need to change
         * the angle by 180 degrees so that the destination does not come in
         * flipped around.
         */
        if (interpolatedTime >= 0.5f) {
            degrees -= 180.f;
            fromView.setVisibility(View.GONE);
            toView.setVisibility(View.VISIBLE);
            
        }
 
        if (forward) {
        	degrees = -degrees; //Determines the direction of rotation when the flip begins.
        }
 
        final Matrix matrix = t.getMatrix();
        camera.save();
        camera.rotateY(degrees);
        camera.getMatrix(matrix);
        camera.restore();
        matrix.preTranslate(-centerX, -centerY);
        matrix.postTranslate(centerX, centerY);
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Transformers;

import android.support.v4.view.ViewPager.PageTransformer;
import android.view.View;

public class DepthPageTransformer implements PageTransformer {
    private static float MIN_SCALE = 0.75f;

    public void transformPage(View view, float position) {
        int pageWidth = view.getWidth();

        if (position < -1) { // [-Infinity,-1)
            // This page is way off-screen to the left.
            view.setAlpha(0);

        } else if (position <= 0) { // [-1,0]
            // Use the default slide transition when moving to the left page
            view.setAlpha(1);
            view.setTranslationX(0);
            view.setScaleX(1);
            view.setScaleY(1);

        } else if (position <= 1) { // (0,1]
            // Fade the page out.
            view.setAlpha(1 - position);

            // Counteract the default slide transition
            view.setTranslationX(pageWidth * -position);

            // Scale the page down (between MIN_SCALE and 1)
            float scaleFactor = MIN_SCALE
                    + (1 - MIN_SCALE) * (1 - Math.abs(position));
            view.setScaleX(scaleFactor);
            view.setScaleY(scaleFactor);

        } else { // (1,+Infinity]
            // This page is way off-screen to the right.
            view.setAlpha(0);
        }
    }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Transformers;

import android.view.View;

import com.velocity.view.pager.library.VelocityViewPager.PageTransformer;

public class ZoomOutPageTransformer implements PageTransformer {
    public static float MIN_SCALE = 0.85f;
    public static float MIN_ALPHA = 0.5f;
    
    public ZoomOutPageTransformer(float minScale) {
    	MIN_SCALE = minScale;
    }

    @Override
    public void transformPage(View view, float position) {
        int pageWidth = view.getWidth();
        int pageHeight = view.getHeight();

        if (position < -1) { // [-Infinity,-1)
            // This page is way off-screen to the left.
            view.setAlpha(0);

        } else if (position <= 1) { // [-1,1]
            // Modify the default slide transition to shrink the page as well
            float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));
            float vertMargin = pageHeight * (1 - scaleFactor) / 2;
            float horzMargin = pageWidth * (1 - scaleFactor) / 2;
            if (position < 0) {
                view.setTranslationX(horzMargin - vertMargin / 2);
            } else {
                view.setTranslationX(-horzMargin + vertMargin / 2);
            }

            // Scale the page down (between MIN_SCALE and 1)
            view.setScaleX(scaleFactor);
            view.setScaleY(scaleFactor);

            // Fade the page relative to its size.
            view.setAlpha(MIN_ALPHA +
                    (scaleFactor - MIN_SCALE) /
                    (1 - MIN_SCALE) * (1 - MIN_ALPHA));

        } else { // (1,+Infinity]
            // This page is way off-screen to the right.
            view.setAlpha(0);
        }
        
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Utils;

import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.content.Context;
import android.content.SharedPreferences;
import android.util.Base64;

public class Base64SharedPreferences {

    @SuppressWarnings("serial")
	public static class SecurePreferencesException extends RuntimeException {
	    public SecurePreferencesException(Throwable e) {
            super(e);
	    }

    }

    private static final String TRANSFORMATION = "AES/CBC/PKCS5Padding";
    private static final String KEY_TRANSFORMATION = "AES/ECB/PKCS5Padding";
    private static final String SECRET_KEY_HASH_TRANSFORMATION = "SHA-256";
    private static final String CHARSET = "UTF-8";

    private final boolean encryptKeys;
    private final Cipher writer;
    private final Cipher reader;
    private final Cipher keyWriter;
    private final SharedPreferences preferences;

    /**
     * This will initialize an instance of the SecurePreferences class
     * @param context your current context.
     * @param preferenceName name of preferences file (preferenceName.xml)
     * @param secureKey the key used for encryption, finding a good key scheme is hard. 
     * Hardcoding your key in the application is bad, but better than plaintext preferences. Having the user enter the key upon application launch is a safe(r) alternative, but annoying to the user.
     * @param encryptKeys settings this to false will only encrypt the values, 
     * true will encrypt both values and keys. Keys can contain a lot of information about 
     * the plaintext value of the value which can be used to decipher the value.
     * @throws SecurePreferencesException
     */
    public Base64SharedPreferences(Context context, String preferenceName, String secureKey, boolean encryptKeys) throws SecurePreferencesException {
        try {
                this.writer = Cipher.getInstance(TRANSFORMATION);
                this.reader = Cipher.getInstance(TRANSFORMATION);
                this.keyWriter = Cipher.getInstance(KEY_TRANSFORMATION);

                initCiphers(secureKey);

                this.preferences = context.getSharedPreferences(preferenceName, Context.MODE_PRIVATE);

                this.encryptKeys = encryptKeys;
        }
        catch (GeneralSecurityException e) {
                throw new SecurePreferencesException(e);
        }
        catch (UnsupportedEncodingException e) {
                throw new SecurePreferencesException(e);
        }
    }

    protected void initCiphers(String secureKey) 
    		throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeyException, InvalidAlgorithmParameterException {
        IvParameterSpec ivSpec = getIv();
        SecretKeySpec secretKey = getSecretKey(secureKey);

        writer.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);
        reader.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);
        keyWriter.init(Cipher.ENCRYPT_MODE, secretKey);
    }
    
    protected IvParameterSpec getIv() {
        byte[] iv = new byte[writer.getBlockSize()];
        System.arraycopy("fldsjfodasjifudslfjdsaofshaufihadsf".getBytes(), 0, iv, 0, writer.getBlockSize());
        return new IvParameterSpec(iv);
    }
    
    protected SecretKeySpec getSecretKey(String key) throws UnsupportedEncodingException, NoSuchAlgorithmException {
        byte[] keyBytes = createKeyBytes(key);
        return new SecretKeySpec(keyBytes, TRANSFORMATION);
    }

    protected byte[] createKeyBytes(String key) throws UnsupportedEncodingException, NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance(SECRET_KEY_HASH_TRANSFORMATION);
        md.reset();
        byte[] keyBytes = md.digest(key.getBytes(CHARSET));
        return keyBytes;
    }

    public void put(String key, String value) {
        if (value == null) {
                preferences.edit().remove(toKey(key)).commit();
        }
        else {
                putValue(toKey(key), value);
        }
    }

    public boolean containsKey(String key) {
        return preferences.contains(toKey(key));
    }

    public void removeValue(String key) {
        preferences.edit().remove(toKey(key)).commit();
    }

    public String getString(String key) throws SecurePreferencesException {
        if (preferences.contains(toKey(key))) {
                String securedEncodedValue = preferences.getString(toKey(key), "");
                return decrypt(securedEncodedValue);
        }
        return null;
    }

    public void clear() {
        preferences.edit().clear().commit();
    }

    private String toKey(String key) {
        if (encryptKeys)
                return encrypt(key, keyWriter);
        else return key;
    }

    private void putValue(String key, String value) throws SecurePreferencesException {
        String secureValueEncoded = encrypt(value, writer);

        preferences.edit().putString(key, secureValueEncoded).commit();
    }

    protected String encrypt(String value, Cipher writer) throws SecurePreferencesException {
        byte[] secureValue;
        try {
                secureValue = convert(writer, value.getBytes(CHARSET));
        }
        catch (UnsupportedEncodingException e) {
                throw new SecurePreferencesException(e);
        }
        String secureValueEncoded = Base64.encodeToString(secureValue, Base64.NO_WRAP);
        return secureValueEncoded;
    }

    protected String decrypt(String securedEncodedValue) {
        byte[] securedValue = Base64.decode(securedEncodedValue, Base64.NO_WRAP);
        byte[] value = convert(reader, securedValue);
        try {
                return new String(value, CHARSET);
        }
        catch (UnsupportedEncodingException e) {
                throw new SecurePreferencesException(e);
        }
    }

    private static byte[] convert(Cipher cipher, byte[] bs) throws SecurePreferencesException {
        try {
                return cipher.doFinal(bs);
        }
        catch (Exception e) {
                throw new SecurePreferencesException(e);
        }
    }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Utils;

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

import android.content.Context;
import android.media.MediaMetadataRetriever;

import com.nostra13.universalimageloader.core.download.BaseImageDownloader;

/**
 * This custom loader class allows the UniversalImageLoader to decode 
 * raw image data from three different sources: byte[], standard files, 
 * and the internet. It does this by checking the uri's pattern and 
 * passing the appropriate input stream back to the loader.
 * 
 * @author Saravan Pantham
 */
public class ByteArrayUniversalImageLoader extends BaseImageDownloader {

    private static final String SCHEME_DB = "byte";
    private static final String DB_URI_PREFIX = SCHEME_DB + "://";
    private static final String SCHEME_FILE = "/";

    public ByteArrayUniversalImageLoader(Context context) {
        super(context);
    }

    @Override
    protected InputStream getStreamFromOtherSource(String imageUri, Object extra) throws IOException {
        if (imageUri.startsWith(DB_URI_PREFIX)) {
        	
            String path = imageUri.substring(DB_URI_PREFIX.length());
            MediaMetadataRetriever mmdr = new MediaMetadataRetriever();
            byte[] imageData = null;
            try {
            	mmdr.setDataSource(path);
                imageData = mmdr.getEmbeddedPicture();
            } catch (Exception e) {
            	return super.getStreamFromOtherSource(imageUri, extra);
            }
            		
            return new ByteArrayInputStream(imageData);
        } else if (imageUri.startsWith(SCHEME_FILE)) { 
        	return new FileInputStream(imageUri);
    	} else {
            return super.getStreamFromOtherSource(imageUri, extra);
        }
        
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Utils;

import android.app.Activity;
import android.app.Application;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.database.Cursor;
import android.database.MergeCursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.support.v4.content.LocalBroadcastManager;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.Window;
import android.webkit.WebView;
import android.widget.RelativeLayout;
import android.widget.Toast;

import com.google.android.gms.common.images.ImageManager;
import com.jams.music.player.AsyncTasks.AsyncGoogleMusicAuthenticationTask;
import com.jams.music.player.DBHelpers.DBAccessHelper;
import com.jams.music.player.GMusicHelpers.GMusicClientCalls;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.NowPlayingActivity.NowPlayingActivity;
import com.jams.music.player.PlaybackKickstarter.PlaybackKickstarter;
import com.jams.music.player.R;
import com.jams.music.player.Services.AudioPlaybackService;
import com.jams.music.player.Services.PinGMusicSongsService;
import com.nostra13.universalimageloader.cache.memory.impl.WeakMemoryCache;
import com.nostra13.universalimageloader.core.DisplayImageOptions;
import com.nostra13.universalimageloader.core.ImageLoader;
import com.nostra13.universalimageloader.core.ImageLoaderConfiguration;
import com.nostra13.universalimageloader.core.assist.ImageScaleType;
import com.nostra13.universalimageloader.core.display.FadeInBitmapDisplayer;
import com.squareup.picasso.Picasso;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

/**
 * Singleton class that provides access to common objects
 * and methods used in the application.
 *
 * @author Saravan Pantham
 */
public class Common extends Application {

	//Context.
	private Context mContext;

	//Service reference and flags.
	private AudioPlaybackService mService;
	private boolean mIsServiceRunning = false;

	//Playback kickstarter object.
	private PlaybackKickstarter mPlaybackKickstarter;

	//NowPlayingActivity reference.
	private NowPlayingActivity mNowPlayingActivity;

	//SharedPreferences.
	private static SharedPreferences mSharedPreferences;

	//Database access helper object.
	private static DBAccessHelper mDBAccessHelper;

    //Picasso instance.
    private Picasso mPicasso;

	//Indicates if the library is currently being built.
	private boolean mIsBuildingLibrary = false;
	private boolean mIsScanFinished = false;

	//Google Play Music access object.
	private GMusicClientCalls mGMusicClientCalls;
	private boolean mIsGMusicLoggedIn = false;

	//ImageManager for asynchronous image downloading.
	private ImageManager mImageManager;

	//ImageLoader/ImageLoaderConfiguration objects for ListViews and GridViews.
	private ImageLoader mImageLoader;
	private ImageLoaderConfiguration mImageLoaderConfiguration;

	//Image display options.
	private DisplayImageOptions mDisplayImageOptions;

	//Cursor that stores the songs that are currently queued for download.
	private Cursor mPinnedSongsCursor;

	//Specifies whether the app is currently downloading pinned songs from the GMusic app.
	private boolean mIsFetchingPinnedSongs = false;

	public static final String uid4 = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvFlvWGADp9cW2LPuOIjDPB";
	public static final String uid2 = "ormNR2mpS8HR8utvhNHKs2AJzV8GLPh35m3rE6GPND4GsOdrbySPETG4+0fvagBr5E";
	public static final String uid6 = "QgMR7z76DJlRqy+VyVzmx7cly2JiXo+ZnISYKKn71oP+Xw+dO/eRKFy3EFCO7khMxc";
	public static final String uid1 = "6QouPH11nHJPzXspzdkJbTcifIIGFtEkquXjA0y19Gouab7Gir8yLOA4V3m0URRivP";
	public static final String uid3 = "QeOx8JsY766F6FgU8uJABWRDZbqHEYRwT7iGmn7ukt7h5z+DOsYWSRmZxwJh3cpkGo";
	public static final String uid5 = "Vyqp4UZWnzGiiq/fWFKs5rrc+m3obsEpUxteGavKAhhXJZKgwAGFgkUQIDAQAB";

	//GAnalytics flag.
	private boolean mIsGAnalyticsEnabled = true;

	//Broadcast elements.
	private LocalBroadcastManager mLocalBroadcastManager;
	public static final String UPDATE_UI_BROADCAST = "com.jams.music.player.NEW_SONG_UPDATE_UI";

	//Update UI broadcast flags.
	public static final String SHOW_AUDIOBOOK_TOAST = "AudiobookToast";
	public static final String UPDATE_SEEKBAR_DURATION = "UpdateSeekbarDuration";
	public static final String UPDATE_PAGER_POSTIION = "UpdatePagerPosition";
	public static final String UPDATE_PLAYBACK_CONTROLS = "UpdatePlabackControls";
	public static final String SERVICE_STOPPING = "ServiceStopping";
	public static final String SHOW_STREAMING_BAR = "ShowStreamingBar";
	public static final String HIDE_STREAMING_BAR = "HideStreamingBar";
	public static final String UPDATE_BUFFERING_PROGRESS = "UpdateBufferingProgress";
	public static final String INIT_PAGER = "InitPager";
	public static final String NEW_QUEUE_ORDER = "NewQueueOrder";
	public static final String UPDATE_EQ_FRAGMENT = "UpdateEQFragment";

	//Contants for identifying each fragment/activity.
	public static final String FRAGMENT_ID = "FragmentId";
	public static final int ARTISTS_FRAGMENT = 0;
	public static final int ALBUM_ARTISTS_FRAGMENT = 1;
	public static final int ALBUMS_FRAGMENT = 2;
	public static final int SONGS_FRAGMENT = 3;
	public static final int PLAYLISTS_FRAGMENT = 4;
	public static final int GENRES_FRAGMENT = 5;
	public static final int FOLDERS_FRAGMENT = 6;
	public static final int ARTISTS_FLIPPED_FRAGMENT = 7;
	public static final int ARTISTS_FLIPPED_SONGS_FRAGMENT = 8;
	public static final int ALBUM_ARTISTS_FLIPPED_FRAGMENT = 9;
	public static final int ALBUM_ARTISTS_FLIPPED_SONGS_FRAGMENT = 10;
	public static final int ALBUMS_FLIPPED_FRAGMENT = 11;
	public static final int GENRES_FLIPPED_FRAGMENT = 12;
	public static final int GENRES_FLIPPED_SONGS_FRAGMENT = 13;

    //Constants for identifying playback routes.
    public static final int PLAY_ALL_SONGS = 0;
    public static final int PLAY_ALL_BY_ARTIST = 1;
    public static final int PLAY_ALL_BY_ALBUM_ARTIST = 2;
    public static final int PLAY_ALL_BY_ALBUM = 3;
    public static final int PLAY_ALL_IN_PLAYLIST = 4;
    public static final int PLAY_ALL_IN_GENRE = 5;
    public static final int PLAY_ALL_IN_FOLDER = 6;

	//Device orientation constants.
	public static final int ORIENTATION_PORTRAIT = 0;
	public static final int ORIENTATION_LANDSCAPE = 1;

    //Device screen size/orientation identifiers.
    public static final String REGULAR = "regular";
    public static final String SMALL_TABLET = "small_tablet";
    public static final String LARGE_TABLET = "large_tablet";
    public static final String XLARGE_TABLET = "xlarge_tablet";
    public static final int REGULAR_SCREEN_PORTRAIT = 0;
    public static final int REGULAR_SCREEN_LANDSCAPE = 1;
    public static final int SMALL_TABLET_PORTRAIT = 2;
    public static final int SMALL_TABLET_LANDSCAPE = 3;
    public static final int LARGE_TABLET_PORTRAIT = 4;
    public static final int LARGE_TABLET_LANDSCAPE = 5;
    public static final int XLARGE_TABLET_PORTRAIT = 6;
    public static final int XLARGE_TABLET_LANDSCAPE = 7;

    //Miscellaneous flags/identifiers.
    public static final String SONG_ID = "SongId";
    public static final String SONG_TITLE = "SongTitle";
    public static final String SONG_ALBUM = "SongAlbum";
    public static final String SONG_ARTIST = "SongArtist";
    public static final String ALBUM_ART = "AlbumArt";
    public static final String CURRENT_THEME = "CurrentTheme";
    public static final int DARK_THEME = 0;
    public static final int LIGHT_THEME = 1;

    //SharedPreferences keys.
    public static final String CROSSFADE_ENABLED = "CrossfadeEnabled";
    public static final String CROSSFADE_DURATION = "CrossfadeDuration";
    public static final String REPEAT_MODE = "RepeatMode";
    public static final String MUSIC_PLAYING = "MusicPlaying";
    public static final String SERVICE_RUNNING = "ServiceRunning";
    public static final String CURRENT_LIBRARY = "CurrentLibrary";
    public static final String CURRENT_LIBRARY_POSITION = "CurrentLibraryPosition";
    public static final String SHUFFLE_ON = "ShuffleOn";
    public static final String FIRST_RUN = "FirstRun";
    public static final String STARTUP_BROWSER = "StartupBrowser";
    public static final String SHOW_LOCKSCREEN_CONTROLS = "ShowLockscreenControls";
    public static final String ARTISTS_LAYOUT = "ArtistsLayout";
    public static final String ALBUM_ARTISTS_LAYOUT = "AlbumArtistsLayout";
    public static final String ALBUMS_LAYOUT = "AlbumsLayout";
    public static final String PLAYLISTS_LAYOUT = "PlaylistsLayout";
    public static final String GENRES_LAYOUT = "GenresLayout";
    public static final String FOLDERS_LAYOUT = "FoldersLayout";

    //Repeat mode constants.
    public static final int REPEAT_OFF = 0;
    public static final int REPEAT_PLAYLIST = 1;
    public static final int REPEAT_SONG = 2;
    public static final int A_B_REPEAT = 3;

	@Override
	public void onCreate() {
		super.onCreate();

		//Application context.
		mContext = getApplicationContext();

		//SharedPreferences.
		mSharedPreferences = this.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);

		//Init the database.
		mDBAccessHelper = new DBAccessHelper(mContext);

    	//Playback kickstarter.
    	mPlaybackKickstarter = new PlaybackKickstarter(this.getApplicationContext());

        //Picasso.
        mPicasso = new Picasso.Builder(mContext).build();

    	//ImageLoader.
    	mImageLoader = ImageLoader.getInstance();
    	mImageLoaderConfiguration = new ImageLoaderConfiguration.Builder(getApplicationContext())
    														   .memoryCache(new WeakMemoryCache())
    														   .memoryCacheSizePercentage(13)
    														   .imageDownloader(new ByteArrayUniversalImageLoader(mContext))
    														   .build();
    	mImageLoader.init(mImageLoaderConfiguration);

        //Init DisplayImageOptions.
        initDisplayImageOptions();

		//Log the user into Google Play Music only if the account is currently set up and active.
		if (mSharedPreferences.getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {

			//Create a temp WebView to retrieve the user agent string.
			String userAgentString = "";
			if (mSharedPreferences.getBoolean("GOT_USER_AGENT", false)==false) {
				WebView webView = new WebView(getApplicationContext());
				webView.setVisibility(View.GONE);
				webView.loadUrl("http://www.google.com");
				userAgentString = webView.getSettings().getUserAgentString();
				mSharedPreferences.edit().putBoolean("GOT_USER_AGENT", true).commit();
				mSharedPreferences.edit().putString("USER_AGENT", userAgentString).commit();
				webView = null;
			}

			setGMusicClientCalls(GMusicClientCalls.getInstance(getApplicationContext()));
			GMusicClientCalls.setWebClientUserAgent(userAgentString);
			String accountName = mSharedPreferences.getString("GOOGLE_PLAY_MUSIC_ACCOUNT", "");

			//Authenticate with Google.
			AsyncGoogleMusicAuthenticationTask task = new AsyncGoogleMusicAuthenticationTask(mContext, false, accountName);
			task.execute();

		}

	}

    /**
     * Initializes a DisplayImageOptions object. The drawable shown
     * while an image is loading is based on the current theme.
     */
    public void initDisplayImageOptions() {

        //Create a set of options to optimize the bitmap memory usage.
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        options.inJustDecodeBounds = false;
        options.inPurgeable = true;

        int emptyColorPatch = UIElementsHelper.getEmptyColorPatch(this);
        mDisplayImageOptions = null;
        mDisplayImageOptions = new DisplayImageOptions.Builder()
                                                      .showImageForEmptyUri(emptyColorPatch)
                                                      .showImageOnFail(emptyColorPatch)
                                                      .showImageOnLoading(emptyColorPatch)
                                                      .cacheInMemory(true)
                                                      .cacheOnDisc(true)
                                                      .decodingOptions(options)
                                                      .imageScaleType(ImageScaleType.IN_SAMPLE_POWER_OF_2)
                                                      .bitmapConfig(Bitmap.Config.ARGB_4444)
                                                      .delayBeforeLoading(400)
                                                      .displayer(new FadeInBitmapDisplayer(200))
                                                      .build();

    }

	/**
	 * Sends out a local broadcast that notifies all receivers to update
	 * their respective UI elements.
	 */
	public void broadcastUpdateUICommand(String[] updateFlags, String[] flagValues) {
		Intent intent = new Intent(UPDATE_UI_BROADCAST);
		for (int i=0; i < updateFlags.length; i++) {
			intent.putExtra(updateFlags[i], flagValues[i]);
		}

		mLocalBroadcastManager = LocalBroadcastManager.getInstance(mContext);
		mLocalBroadcastManager.sendBroadcast(intent);

	}

	/**
	 * Toggles the equalizer.
	 */
	public void toggleEqualizer() {
		if (isEqualizerEnabled()) {
			getSharedPreferences().edit().putBoolean("EQUALIZER_ENABLED", true).commit();

			if (isServiceRunning()) {
				try {
					getService().getEqualizerHelper().getEqualizer().setEnabled(false);
					getService().getEqualizerHelper().getEqualizer2().setEnabled(false);
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

			}

		} else {
			getSharedPreferences().edit().putBoolean("EQUALIZER_ENABLED", true).commit();

			if (isServiceRunning()) {
				try {
					getService().getEqualizerHelper().getEqualizer().setEnabled(true);
					getService().getEqualizerHelper().getEqualizer2().setEnabled(true);
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

			}

		}

		//Reload the EQ settings.
		if (isServiceRunning()) {
			try {
				getService().getEqualizerHelper().releaseEQObjects();
				getService().initAudioFX();
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}

	}

 	/**
	 * Used to downsample a bitmap that's been downloaded from the internet.
	 */
	public Bitmap getDownsampledBitmap(Context ctx, URL url, int targetWidth, int targetHeight) {
        Bitmap bitmap = null;
        try {
            BitmapFactory.Options outDimens = getBitmapDimensions(url);

            int sampleSize = calculateSampleSize(outDimens.outWidth, outDimens.outHeight, targetWidth, targetHeight);

            bitmap = downsampleBitmap(url, sampleSize);

        } catch (Exception e) {
            //handle the exception(s)
        }

        return bitmap;
    }

	/**
	 * Retrieves the image dimensions of the input file.
	 *
	 * @param url Url of the input file.
	 * @return A BitmapFactory.Options object with the output image dimensions.
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
    public BitmapFactory.Options getBitmapDimensions(URL url) throws FileNotFoundException, IOException {
        BitmapFactory.Options outDimens = new BitmapFactory.Options();
        outDimens.inJustDecodeBounds = true; // the decoder will return null (no bitmap)

        InputStream is = url.openStream();
        // if Options requested only the size will be returned
        BitmapFactory.decodeStream(is, null, outDimens);
        is.close();

        return outDimens;
    }

    /**
     * Resamples a resource image to avoid OOM errors.
     *
     * @param resID Resource ID of the image to be downsampled.
     * @param reqWidth Width of output image.
     * @param reqHeight Height of output image.
     *
     * @return A bitmap of the resampled image.
     */
    public Bitmap decodeSampledBitmapFromResource(int resID, int reqWidth, int reqHeight) {

	    final BitmapFactory.Options options = new BitmapFactory.Options();
	    options.inJustDecodeBounds = true;
	    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
	    options.inJustDecodeBounds = false;
	    options.inPurgeable = true;

	    return BitmapFactory.decodeResource(mContext.getResources(), resID, options);
    }

    /**
     * Resamples the specified input image file to avoid OOM errors.
     *
     * @param inputFile Input file to be downsampled
     * @param reqWidth Width of the output file.
     * @param reqHeight Height of the output file.
     * @return The downsampled bitmap.
     */
    public Bitmap decodeSampledBitmapFromFile(File inputFile, int reqWidth, int reqHeight) {

    	InputStream is = null;
        try {

        	try {
				is = new FileInputStream(inputFile);
			} catch (Exception e) {
				//Return a null bitmap if there's an error reading the file.
				return null;
			}

            final BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;
            BitmapFactory.decodeStream(is, null, options);

            options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
            options.inJustDecodeBounds = false;
            options.inPurgeable = true;

            try {
				is = new FileInputStream(inputFile);
			} catch (FileNotFoundException e) {
				//Return a null bitmap if there's an error reading the file.
				return null;
			}

            return BitmapFactory.decodeStream(is, null, options);
        } finally {
            try {
            	if (is!=null) {
            		is.close();
            	}
            } catch (IOException e) {
                e.printStackTrace();
            }

        }

    }

    /**
     * Calculates the sample size for the resampling process.
     *
     * @param options
     * @param reqWidth
     * @param reqHeight
     * @return The sample size.
     */
	private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
	    final int height = options.outHeight;
	    final int width = options.outWidth;
	    int inSampleSize = 1;

	    if (height > reqHeight || width > reqWidth) {
	        if (width > height) {
	            inSampleSize = Math.round((float) height / (float) reqHeight);
	        } else {
	            inSampleSize = Math.round((float) width / (float) reqWidth);
	        }
	    }

	    return inSampleSize;
	}

    /**
     * Calculates the sample size for the resampling process.
	 *
     * @return The sample size.
     */
    public int calculateSampleSize(int width, int height, int targetWidth, int targetHeight) {
        float bitmapWidth = width;
        float bitmapHeight = height;

        int bitmapResolution = (int) (bitmapWidth * bitmapHeight);
        int targetResolution = targetWidth * targetHeight;

        int sampleSize = 1;

        if (targetResolution == 0) {
            return sampleSize;
        }

        for (int i = 1; (bitmapResolution / i) > targetResolution; i *= 2) {
            sampleSize = i;
        }

        return sampleSize;
    }

    /**
     *
     * @param url
     * @param sampleSize
     * @return
     * @throws FileNotFoundException
     * @throws IOException
     */
    public Bitmap downsampleBitmap(URL url, int sampleSize) throws FileNotFoundException, IOException {
        Bitmap resizedBitmap;
        BitmapFactory.Options outBitmap = new BitmapFactory.Options();
        outBitmap.inJustDecodeBounds = false; // the decoder will return a bitmap
        outBitmap.inSampleSize = sampleSize;

        InputStream is = url.openStream();
        resizedBitmap = BitmapFactory.decodeStream(is, null, outBitmap);
        is.close();

        return resizedBitmap;
    }

    /*
     * Returns the status bar height for the current layout configuration.
     */
    public static int getStatusBarHeight(Context context) {
    	int result = 0;
    	int resourceId = context.getResources().getIdentifier("status_bar_height", "dimen", "android");
    	if (resourceId > 0) {
    		result = context.getResources().getDimensionPixelSize(resourceId);
    	}

    	return result;
    }

    /*
     * Returns the navigation bar height for the current layout configuration.
     */
    public static int getNavigationBarHeight(Context context) {
        Resources resources = context.getResources();
        int resourceId = resources.getIdentifier("navigation_bar_height", "dimen", "android");
        if (resourceId > 0) {
            return resources.getDimensionPixelSize(resourceId);
        }

        return 0;
    }

    /**
     * Returns the view container for the ActionBar.
     * @return
     */
    public View getActionBarView(Activity activity) {
        Window window = activity.getWindow();
        View view = window.getDecorView();
        int resId = getResources().getIdentifier("action_bar_container", "id", "android");

        return view.findViewById(resId);
    }

    /**
     * Download Manager implementation for pinning songs.
     */
    public void queueSongsToPin(boolean getAllPinnedSongs, boolean pinPlaylist, String selection) {
    	//If the current cursor is empty or null, retrieve the cursor using the selection parameter.
    	if (mPinnedSongsCursor==null || mPinnedSongsCursor.getCount()<=0) {

    		if (getAllPinnedSongs==true) {
    			mPinnedSongsCursor = null;
    			mIsFetchingPinnedSongs = true;
    			Toast.makeText(mContext, R.string.getting_pinned_songs, Toast.LENGTH_LONG).show();
    		} else if (pinPlaylist==true) {
    			//Pinning from a playlist, so we'll need to use a db call that utilizes a JOIN.
    			mPinnedSongsCursor = mDBAccessHelper.getAllSongsInPlaylistSearchable(selection);
    		} else {
    			//Check if we're pinning a smart playlist.
    			if (selection.equals("TOP_25_PLAYED_SONGS")) {
    	            mPinnedSongsCursor = mDBAccessHelper.getTop25PlayedTracks(selection);
    	        } else if (selection.equals("RECENTLY_ADDED")) {
    	        	mPinnedSongsCursor = mDBAccessHelper.getRecentlyAddedSongs(selection);
    	        } else if (selection.equals("TOP_RATED")) {
    	        	mPinnedSongsCursor = mDBAccessHelper.getTopRatedSongs(selection);
    	        } else if (selection.equals("RECENTLY_PLAYED")) {
    	        	mPinnedSongsCursor = mDBAccessHelper.getRecentlyPlayedSongs(selection);
    	        } else {
    	        	//Not playing from a smart playlist. Just use a regular db query that searches songs.
        			mPinnedSongsCursor = mDBAccessHelper.getAllSongsSearchable(selection);
    	        }

    		}

    		Intent intent = new Intent(this, PinGMusicSongsService.class);
    		startService(intent);

    	} else {
    		//mPinnedSongsCursor already has songs queued, so append a new intermCursor;
    		Cursor intermCursor = null;
    		if (getAllPinnedSongs==true) {
    			Toast.makeText(mContext, R.string.wait_until_pinning_complete, Toast.LENGTH_SHORT).show();
    			return;
    		} else if (pinPlaylist==true) {
    			//Pinning from a playlist, so we'll need to use a db call that utilizes a JOIN.
    			intermCursor = mDBAccessHelper.getAllSongsInPlaylistSearchable(selection);
    		} else {
    			//Check if we're pinning a smart playlist.
    			if (selection.equals("TOP_25_PLAYED_SONGS")) {
    				intermCursor = mDBAccessHelper.getTop25PlayedTracks(selection);
    	        } else if (selection.equals("RECENTLY_ADDED")) {
    	        	intermCursor = mDBAccessHelper.getRecentlyAddedSongs(selection);
    	        } else if (selection.equals("TOP_RATED")) {
    	        	intermCursor = mDBAccessHelper.getTopRatedSongs(selection);
    	        } else if (selection.equals("RECENTLY_PLAYED")) {
    	        	intermCursor = mDBAccessHelper.getRecentlyPlayedSongs(selection);
    	        } else {
    	        	//Not playing from a smart playlist. Just use a regular db query that searches songs.
    	        	intermCursor = mDBAccessHelper.getAllSongsSearchable(selection);
    	        }

    		}

    		Cursor[] cursorArray = { mPinnedSongsCursor, intermCursor };
     		MergeCursor mergeCursor = new MergeCursor(cursorArray);
     		mPinnedSongsCursor = (Cursor) mergeCursor;

    	}

    }

    /**
     * Converts dp unit to equivalent pixels, depending on device density.
     *
     * @param dp A value in dp (density independent pixels) unit. Which we need to convert into pixels
     * @param context Context to get resources and device specific display metrics
     * @return A float value to represent px equivalent to dp depending on device density
     */
    public float convertDpToPixels(float dp, Context context){
        Resources resources = context.getResources();
        DisplayMetrics metrics = resources.getDisplayMetrics();
        float px = dp * (metrics.densityDpi / 160f);
        return px;
    }

    /**
     * Converts device specific pixels to density independent pixels.
     *
     * @param px A value in px (pixels) unit. Which we need to convert into db
     * @param context Context to get resources and device specific display metrics
     * @return A float value to represent dp equivalent to px value
     */
    public float convertPixelsToDp(float px, Context context){
        Resources resources = context.getResources();
        DisplayMetrics metrics = resources.getDisplayMetrics();
        float dp = px / (metrics.densityDpi / 160f);
        return dp;
    }

    /**
     * Returns the orientation of the device.
     */
    public int getOrientation() {
        if (getResources().getDisplayMetrics().widthPixels >
            getResources().getDisplayMetrics().heightPixels) {
            return ORIENTATION_LANDSCAPE;
        } else {
            return ORIENTATION_PORTRAIT;
        }

    }

    /**
     * Returns the current screen configuration of the device.
     */
    public int getDeviceScreenConfiguration() {
        String screenSize = getResources().getString(R.string.screen_size);
        boolean landscape = getResources().getBoolean(R.bool.landscape);

        if (screenSize.equals(REGULAR) && !landscape)
            return REGULAR_SCREEN_PORTRAIT;
        else if (screenSize.equals(REGULAR) && landscape)
            return REGULAR_SCREEN_LANDSCAPE;
        else if (screenSize.equals(SMALL_TABLET) && !landscape)
            return SMALL_TABLET_PORTRAIT;
        else if (screenSize.equals(SMALL_TABLET) && landscape)
            return SMALL_TABLET_LANDSCAPE;
        else if (screenSize.equals(LARGE_TABLET) && !landscape)
            return LARGE_TABLET_PORTRAIT;
        else if (screenSize.equals(LARGE_TABLET) && landscape)
            return LARGE_TABLET_LANDSCAPE;
        else if (screenSize.equals(XLARGE_TABLET) && !landscape)
            return XLARGE_TABLET_PORTRAIT;
        else if (screenSize.equals(XLARGE_TABLET) && landscape)
            return XLARGE_TABLET_LANDSCAPE;
        else
            return REGULAR_SCREEN_PORTRAIT;
    }

    public boolean isTabletInLandscape() {
        int screenConfig = getDeviceScreenConfiguration();
        if (screenConfig==SMALL_TABLET_LANDSCAPE ||
            screenConfig==LARGE_TABLET_LANDSCAPE ||
            screenConfig==XLARGE_TABLET_LANDSCAPE)
            return true;
        else
            return false;

    }

    public boolean isTabletInPortrait() {
        int screenConfig = getDeviceScreenConfiguration();
        if (screenConfig==SMALL_TABLET_PORTRAIT ||
            screenConfig==LARGE_TABLET_PORTRAIT ||
            screenConfig==XLARGE_TABLET_PORTRAIT)
            return true;
        else
            return false;

    }

    public boolean isPhoneInLandscape() {
        int screenConfig = getDeviceScreenConfiguration();
        if (screenConfig==REGULAR_SCREEN_LANDSCAPE)
            return true;
        else
            return false;
    }

    public boolean isPhoneInPortrait() {
        int screenConfig = getDeviceScreenConfiguration();
        if (screenConfig==REGULAR_SCREEN_PORTRAIT)
            return true;
        else
            return false;
    }

    public boolean isShuffleOn() {
        return getSharedPreferences().getBoolean(SHUFFLE_ON, false);
    }

    /**
     * Converts milliseconds to hh:mm:ss format.
     */
    public String convertMillisToMinsSecs(long milliseconds) {

        int secondsValue = (int) (milliseconds / 1000) % 60 ;
        int minutesValue = (int) ((milliseconds / (1000*60)) % 60);
        int hoursValue  = (int) ((milliseconds / (1000*60*60)) % 24);

        String seconds = "";
        String minutes = "";
        String hours = "";

        if (secondsValue < 10) {
            seconds = "0" + secondsValue;
        } else {
            seconds = "" + secondsValue;
        }

        if (minutesValue < 10) {
            minutes = "0" + minutesValue;
        } else {
            minutes = "" + minutesValue;
        }

        if (hoursValue < 10) {
            hours = "0" + hoursValue;
        } else {
            hours = "" + hoursValue;
        }

        String output = "";
        if (hoursValue!=0) {
            output = hours + ":" + minutes + ":" + seconds;
        } else {
            output = minutes + ":" + seconds;
        }

        return output;
    }
    
    /*
     * Getter methods.
     */
    
    public boolean isGoogleAnalyticsEnabled() {
    	return mIsGAnalyticsEnabled;
    }
    
    public DBAccessHelper getDBAccessHelper() {
    	return DBAccessHelper.getInstance(mContext);
    }
    
    public SharedPreferences getSharedPreferences() {
    	return mSharedPreferences;
    }
    
	public GMusicClientCalls getGMusicClientCalls() {
		return mGMusicClientCalls;
	}

    public Picasso getPicasso() {
        return mPicasso;
    }
	
	public ImageManager getImageManager() {
		return mImageManager;
	}
	
	public boolean isBuildingLibrary() {
		return mIsBuildingLibrary;
	}
	
	public boolean isScanFinished() {
		return mIsScanFinished;
	}
	
	public boolean isGMusicLoggedIn() {
		return mIsGMusicLoggedIn;
	}
	
    public Cursor getPinnedSongsCursor() {
    	return mPinnedSongsCursor;
    }
    
    public boolean isFetchingPinnedSongs() {
    	return mIsFetchingPinnedSongs;
    }
    
    public AudioPlaybackService getService() {
    	return mService;
    }
    
    public NowPlayingActivity getNowPlayingActivity() {
    	return mNowPlayingActivity;
    }
    
    public DisplayImageOptions getDisplayImageOptions() {
    	return mDisplayImageOptions;
    }
    
    public ImageLoader getImageLoader() {
    	return mImageLoader;
    }

    public int getCurrentTheme() {
        return getSharedPreferences().getInt(CURRENT_THEME, DARK_THEME);
    }
    
    public boolean isServiceRunning() {
    	return mIsServiceRunning;
    }
    
    public boolean isEqualizerEnabled() {
    	return getSharedPreferences().getBoolean("EQUALIZER_ENABLED", true);
    }
    
    public boolean isCrossfadeEnabled() {
    	return getSharedPreferences().getBoolean(CROSSFADE_ENABLED, false);
    }

    public int getCrossfadeDuration() {
        return getSharedPreferences().getInt(CROSSFADE_DURATION, 5);
    }

    public boolean isGooglePlayMusicEnabled() {
    	return getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false);
    }
    
    public String getCurrentLibrary() {
    	return getSharedPreferences().getString(CURRENT_LIBRARY, mContext.getResources()
    																	   .getString(R.string.all_libraries));
    }
	
    public String getCurrentLibraryNormalized() {
    	return getCurrentLibrary().replace("'", "''");
    }
    
    public PlaybackKickstarter getPlaybackKickstarter() {
    	return mPlaybackKickstarter;
    }

    public int getCurrentLibraryIndex() {
        return getSharedPreferences().getInt(CURRENT_LIBRARY_POSITION, 0);
    }

	/*
	 * Setter methods.
	 */
	
	public void setIsBuildingLibrary(boolean isBuildingLibrary) {
		mIsBuildingLibrary = isBuildingLibrary;
	}
	
	public void setIsScanFinished(boolean isScanFinished) {
		mIsScanFinished = isScanFinished;
	}
	
	public void setIsGMusicLoggedIn(boolean isGMusicLoggedIn) {
		mIsGMusicLoggedIn = isGMusicLoggedIn;
	}
	
	public void setService(AudioPlaybackService service) {
		mService = service;
	}
	
	public void setNowPlayingActivity(NowPlayingActivity activity) {
		mNowPlayingActivity = activity;
	}
	
	public void setIsServiceRunning(boolean running) {
		mIsServiceRunning = running;
	}
	
	public void setIsEqualizerEnabled(boolean isEnabled) {
		getSharedPreferences().edit().putBoolean("EQUALIZER_ENABLED", isEnabled).commit();
		
		//Reload the EQ settings.
		if (isServiceRunning()) {
			try {
				getService().getEqualizerHelper().releaseEQObjects();
				getService().initAudioFX();
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}
		
	}

	public void setGMusicClientCalls(GMusicClientCalls gMusicClientCalls) {
		this.mGMusicClientCalls = gMusicClientCalls;
	}
	
	public void setPinnedSongsCursor(Cursor cursor) {
		this.mPinnedSongsCursor = cursor;
	}
	
	public void setIsFetchingPinnedSongs(boolean fetching) {
		this.mIsFetchingPinnedSongs = fetching;
	}
	
	public void setIsGoogleAnalyticsEnabled(boolean enabled) {
		this.mIsGAnalyticsEnabled = enabled;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Utils;

import android.view.animation.Interpolator;

public class EaseInOutInterpolator implements Interpolator {

    private EasingType.Type type;

    public EaseInOutInterpolator(EasingType.Type type) {
        this.type = type;
    }

    public float getInterpolation(float t) {
        if (type == EasingType.Type.IN) {
            return in(t);
        } else if (type == EasingType.Type.OUT) {
            return out(t);
        } else if (type == EasingType.Type.INOUT) {
            return inout(t);
        }

        return 0;
    }

    private float in(float t) {
        return (float) (-Math.cos(t * (Math.PI/2)) + 1);
    }
    private float out(float t) {
        return (float) Math.sin(t * (Math.PI/2));
    }
    private float inout(float t) {
        return (float) (-0.5f * (Math.cos(Math.PI*t) - 1));
    }

    public static class EasingType {
        public enum Type {
            IN, OUT, INOUT
        }

    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Utils;

import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Bitmap;
import android.os.Build.VERSION;
import android.renderscript.Allocation;
import android.renderscript.Element;
import android.renderscript.RenderScript;
import android.renderscript.ScriptIntrinsicBlur;
import android.util.Log;

/******************************************************
 * Takes in an input bitmap, applies a gaussian blur
 * effect to it, and returns the blurred bitmap.
 ******************************************************/
public class GaussianBlur {

    @SuppressLint("NewApi")
    public static Bitmap fastblur(Context context, Bitmap sentBitmap, int radius) {

    	try {
    		if (VERSION.SDK_INT > 16) {
                Bitmap bitmap = sentBitmap.copy(sentBitmap.getConfig(), true);

                final RenderScript rs = RenderScript.create(context);
                final Allocation input = Allocation.createFromBitmap(rs, sentBitmap, Allocation.MipmapControl.MIPMAP_NONE,
                                Allocation.USAGE_SCRIPT);
                final Allocation output = Allocation.createTyped(rs, input.getType());
                final ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));
                script.setRadius(radius /* e.g. 3.f */);
                script.setInput(input);
                script.forEach(output);
                output.copyTo(bitmap);
                return bitmap;
	        }
	
	        // Stack Blur v1.0 from
	        // http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html
	        //
	        // Java Author: Mario Klingemann <mario at quasimondo.com>
	        // http://incubator.quasimondo.com
	        // created Feburary 29, 2004
	        // Android port : Yahel Bouaziz <yahel at kayenko.com>
	        // http://www.kayenko.com
	        // ported april 5th, 2012
	
	        // This is a compromise between Gaussian Blur and Box blur
	        // It creates much better looking blurs than Box Blur, but is
	        // 7x faster than my Gaussian Blur implementation.
	        //
	        // I called it Stack Blur because this describes best how this
	        // filter works internally: it creates a kind of moving stack
	        // of colors whilst scanning through the image. Thereby it
	        // just has to add one new block of color to the right side
	        // of the stack and remove the leftmost color. The remaining
	        // colors on the topmost layer of the stack are either added on
	        // or reduced by one, depending on if they are on the right or
	        // on the left side of the stack.
	        //
	        // If you are using this algorithm in your code please add
	        // the following line:
	        //
	        // Stack Blur Algorithm by Mario Klingemann <mario@quasimondo.com>
	
	        Bitmap bitmap = sentBitmap.copy(sentBitmap.getConfig(), true);
	
	        if (radius < 1) {
	                return (null);
	        }
	
	        int w = bitmap.getWidth();
	        int h = bitmap.getHeight();
	
	        int[] pix = new int[w * h];
	        Log.e("pix", w + " " + h + " " + pix.length);
	        bitmap.getPixels(pix, 0, w, 0, 0, w, h);
	
	        int wm = w - 1;
	        int hm = h - 1;
	        int wh = w * h;
	        int div = radius + radius + 1;
	
	        int r[] = new int[wh];
	        int g[] = new int[wh];
	        int b[] = new int[wh];
	        int rsum, gsum, bsum, x, y, i, p, yp, yi, yw;
	        int vmin[] = new int[Math.max(w, h)];
	
	        int divsum = (div + 1) >> 1;
	        divsum *= divsum;
	        int dv[] = new int[256 * divsum];
	        for (i = 0; i < 256 * divsum; i++) {
	                dv[i] = (i / divsum);
	        }
	
	        yw = yi = 0;
	
	        int[][] stack = new int[div][3];
	        int stackpointer;
	        int stackstart;
	        int[] sir;
	        int rbs;
	        int r1 = radius + 1;
	        int routsum, goutsum, boutsum;
	        int rinsum, ginsum, binsum;
	
	        for (y = 0; y < h; y++) {
	                rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;
	                for (i = -radius; i <= radius; i++) {
	                        p = pix[yi + Math.min(wm, Math.max(i, 0))];
	                        sir = stack[i + radius];
	                        sir[0] = (p & 0xff0000) >> 16;
	                        sir[1] = (p & 0x00ff00) >> 8;
	                        sir[2] = (p & 0x0000ff);
	                        rbs = r1 - Math.abs(i);
	                        rsum += sir[0] * rbs;
	                        gsum += sir[1] * rbs;
	                        bsum += sir[2] * rbs;
	                        if (i > 0) {
	                                rinsum += sir[0];
	                                ginsum += sir[1];
	                                binsum += sir[2];
	                        } else {
	                                routsum += sir[0];
	                                goutsum += sir[1];
	                                boutsum += sir[2];
	                        }
	                }
	                stackpointer = radius;
	
	                for (x = 0; x < w; x++) {
	
	                        r[yi] = dv[rsum];
	                        g[yi] = dv[gsum];
	                        b[yi] = dv[bsum];
	
	                        rsum -= routsum;
	                        gsum -= goutsum;
	                        bsum -= boutsum;
	
	                        stackstart = stackpointer - radius + div;
	                        sir = stack[stackstart % div];
	
	                        routsum -= sir[0];
	                        goutsum -= sir[1];
	                        boutsum -= sir[2];
	
	                        if (y == 0) {
	                                vmin[x] = Math.min(x + radius + 1, wm);
	                        }
	                        p = pix[yw + vmin[x]];
	
	                        sir[0] = (p & 0xff0000) >> 16;
	                        sir[1] = (p & 0x00ff00) >> 8;
	                        sir[2] = (p & 0x0000ff);
	
	                        rinsum += sir[0];
	                        ginsum += sir[1];
	                        binsum += sir[2];
	
	                        rsum += rinsum;
	                        gsum += ginsum;
	                        bsum += binsum;
	
	                        stackpointer = (stackpointer + 1) % div;
	                        sir = stack[(stackpointer) % div];
	
	                        routsum += sir[0];
	                        goutsum += sir[1];
	                        boutsum += sir[2];
	
	                        rinsum -= sir[0];
	                        ginsum -= sir[1];
	                        binsum -= sir[2];
	
	                        yi++;
	                }
	                yw += w;
	        }
	        for (x = 0; x < w; x++) {
	                rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;
	                yp = -radius * w;
	                for (i = -radius; i <= radius; i++) {
	                        yi = Math.max(0, yp) + x;
	
	                        sir = stack[i + radius];
	
	                        sir[0] = r[yi];
	                        sir[1] = g[yi];
	                        sir[2] = b[yi];
	
	                        rbs = r1 - Math.abs(i);
	
	                        rsum += r[yi] * rbs;
	                        gsum += g[yi] * rbs;
	                        bsum += b[yi] * rbs;
	
	                        if (i > 0) {
	                                rinsum += sir[0];
	                                ginsum += sir[1];
	                                binsum += sir[2];
	                        } else {
	                                routsum += sir[0];
	                                goutsum += sir[1];
	                                boutsum += sir[2];
	                        }
	
	                        if (i < hm) {
	                                yp += w;
	                        }
	                }
	                yi = x;
	                stackpointer = radius;
	                for (y = 0; y < h; y++) {
	                        // Preserve alpha channel: ( 0xff000000 & pix[yi] )
	                        pix[yi] = (0xff000000 & pix[yi]) | (dv[rsum] << 16) | (dv[gsum] << 8) | dv[bsum];
	
	                        rsum -= routsum;
	                        gsum -= goutsum;
	                        bsum -= boutsum;
	
	                        stackstart = stackpointer - radius + div;
	                        sir = stack[stackstart % div];
	
	                        routsum -= sir[0];
	                        goutsum -= sir[1];
	                        boutsum -= sir[2];
	
	                        if (x == 0) {
	                                vmin[y] = Math.min(y + r1, hm) * w;
	                        }
	                        p = x + vmin[y];
	
	                        sir[0] = r[p];
	                        sir[1] = g[p];
	                        sir[2] = b[p];
	
	                        rinsum += sir[0];
	                        ginsum += sir[1];
	                        binsum += sir[2];
	
	                        rsum += rinsum;
	                        gsum += ginsum;
	                        bsum += binsum;
	
	                        stackpointer = (stackpointer + 1) % div;
	                        sir = stack[stackpointer];
	
	                        routsum += sir[0];
	                        goutsum += sir[1];
	                        boutsum += sir[2];
	
	                        rinsum -= sir[0];
	                        ginsum -= sir[1];
	                        binsum -= sir[2];
	
	                        yi += w;
	                }
	        }
	
	        Log.e("pix", w + " " + h + " " + pix.length);
	        bitmap.setPixels(pix, 0, w, 0, 0, w, h);
	        return (bitmap);
        
    	} catch (Exception e) {
    		e.printStackTrace();
    		return null;
    	}
            
    }

}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Utils;

import java.lang.ref.WeakReference;
import java.util.LinkedHashMap;
import java.util.Map;

import android.content.Context;
import android.util.Log;

/**
 * Static library version of {@code android.util.LruCache}. Used to write apps
 * that run on API levels prior to 12. When running on API level 12 or above,
 * this implementation is still used; it does not try to switch to the
 * framework's implementation. See the framework SDK documentation for a class
 * overview.
 */
public class LruSoftCache<K, V> {
	private static final String LOG_TAG = LruSoftCache.class.getSimpleName();

	private final LinkedHashMap<K, WeakReference<V>> map;

	/** Size of this cache in units. Not necessarily the number of elements. */
	private int size;
	private int maxSize;

	private int putCount;
	private int createCount;
	private int evictionCount;
	private int hitCount;
	private int missCount;

	/**
	 * @param maxSize
	 *            for caches that do not override {@link #sizeOf}, this is the
	 *            maximum number of entries in the cache. For all other caches,
	 *            this is the maximum sum of the sizes of the entries in this
	 *            cache.
	 */
	public LruSoftCache(int maxSize) {
		if (maxSize <= 0) {
			throw new IllegalArgumentException("maxSize <= 0");
		}
		this.maxSize = maxSize;
		this.map = new LinkedHashMap<K, WeakReference<V>>(0, 0.75f, true);
	}

	/**
	 * Returns the value for {@code key} if it exists in the cache or can be
	 * created by {@code #create}. If a value was returned, it is moved to the
	 * head of the queue. This returns null if a value is not cached and cannot
	 * be created.
	 */
	public final V get(Context context, K key) {
		if (key == null) {
			//throw new NullPointerException("key == null");
			return null;
		}

		WeakReference<V> mapValue;
		V mapReferent = null;
		synchronized (this) {
			mapValue = map.get(key);
			if (mapValue != null) {
				mapReferent = mapValue.get();
			}
			if (mapReferent != null) {
				hitCount++;
				return mapReferent;
			}
			if (mapValue != null) {
				size -= safeSizeOf(key, null);
			}
			map.remove(key);
			missCount++;
		}

		/*
		 * Attempt to create a value. This may take a long time, and the map may
		 * be different when create() returns. If a conflicting value was added
		 * to the map while create() was working, we leave that value in the map
		 * and release the created value.
		 */

		V createdReferent = create(context, key);
		if (createdReferent == null) {
			return null;
		}

		synchronized (this) {
			createCount++;
			mapValue = map.put(key, new WeakReference<V>(createdReferent));
			mapReferent = mapValue.get();

			if (mapValue != null && mapReferent != null) {
				// There was a conflict so undo that last put
				map.put(key, mapValue);
			} else {
				size += safeSizeOf(key, createdReferent);
			}
		}

		if (mapValue != null && mapReferent != null) {
			entryRemoved(false, key, createdReferent, mapReferent);
			return mapReferent;
		} else {
			trimToSize(maxSize);
			return createdReferent;
		}
	}

	/**
	 * Caches {@code value} for {@code key}. The value is moved to the head of
	 * the queue.
	 * 
	 * @return the previous value mapped by {@code key}.
	 */
	public final V put(K key, V referent) {
		if (key == null || referent == null) {
			throw new NullPointerException("key == null || value == null");
		}
		WeakReference<V> value = new WeakReference<V>(referent);

		WeakReference<V> previousValue;
		V previousReferent = null;
		synchronized (this) {
			putCount++;
			size += safeSizeOf(key, referent);
			previousValue = map.put(key, value);
			if (previousValue != null) {
				previousReferent = previousValue.get();
				size -= safeSizeOf(key, previousReferent);
			}
		}

		if (previousValue != null) {
			entryRemoved(false, key, previousReferent, referent);
		}

		trimToSize(maxSize);

		return previousReferent;
	}

	/**
	 * @param maxSize
	 *            the maximum size of the cache before returning. May be -1 to
	 *            evict even 0-sized elements.
	 */
	private void trimToSize(int maxSize) {
		while (true) {
			K key;
			WeakReference<V> value;
			V referent;
			synchronized (this) {
				if (size < 0 || (map.isEmpty() && size != 0)) {
					size = 0;
					map.clear();
					Log.e(LOG_TAG,
							getClass().getName()
									+ ".sizeOf() is reporting inconsistent results! size: "
									+ size + ", maxSize: " + maxSize);
					break;
				}

				if (size <= maxSize || map.isEmpty()) {
					break;
				}

				Map.Entry<K, WeakReference<V>> toEvict = map.entrySet()
						.iterator().next();
				key = toEvict.getKey();
				value = toEvict.getValue();
				referent = (value != null) ? value.get() : null;
				map.remove(key);
				size -= safeSizeOf(key, referent);
				evictionCount++;
			}

			entryRemoved(true, key, referent, null);
		}
	}

	/**
	 * Removes the entry for {@code key} if it exists.
	 * 
	 * @return the previous value mapped by {@code key}.
	 */
	public final V remove(K key) {
		if (key == null) {
			throw new NullPointerException("key == null");
		}

		WeakReference<V> previousValue;
		V previousReferent = null;
		synchronized (this) {
			previousValue = map.remove(key);
			if (previousValue != null) {
				previousReferent = previousValue.get();
				size -= safeSizeOf(key, previousReferent);
			}
		}

		if (previousValue != null) {
			entryRemoved(false, key, previousReferent, null);
		}

		return previousReferent;
	}

	/**
	 * Called for entries that have been evicted or removed. This method is
	 * invoked when a value is evicted to make space, removed by a call to
	 * {@link #remove}, or replaced by a call to {@link #put}. The default
	 * implementation does nothing.
	 * 
	 * <p>
	 * The method is called without synchronization: other threads may access
	 * the cache while this method is executing.
	 * 
	 * @param evicted
	 *            true if the entry is being removed to make space, false if the
	 *            removal was caused by a {@link #put} or {@link #remove}.
	 * @param newValue
	 *            the new value for {@code key}, if it exists. If non-null, this
	 *            removal was caused by a {@link #put}. Otherwise it was caused
	 *            by an eviction or a {@link #remove}.
	 */
	protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {
	}

	/**
	 * Called after a cache miss to compute a value for the corresponding key.
	 * Returns the computed value or null if no value can be computed. The
	 * default implementation returns null.
	 * 
	 * <p>
	 * The method is called without synchronization: other threads may access
	 * the cache while this method is executing.
	 * 
	 * <p>
	 * If a value for {@code key} exists in the cache when this method returns,
	 * the created value will be released with {@link #entryRemoved} and
	 * discarded. This can occur when multiple threads request the same key at
	 * the same time (causing multiple values to be created), or when one thread
	 * calls {@link #put} while another is creating a value for the same key.
	 */
	protected V create(Context context, K key) {
		return null;
	}

	private int safeSizeOf(K key, V value) {
		int result = sizeOf(key, value);
		if (result < 0) {
			throw new IllegalStateException("Negative size: " + key + "="
					+ value);
		}
		return result;
	}

	/**
	 * Returns the size of the entry for {@code key} and {@code value} in
	 * user-defined units. The default implementation returns 1 so that size is
	 * the number of entries and max size is the maximum number of entries.
	 * 
	 * <p>
	 * An entry's size must not change while it is in the cache.
	 */
	private final int sizeOf(K key, V value) {
		return 1;
	}

	/**
	 * Clear the cache, calling {@link #entryRemoved} on each removed entry.
	 */
	public final void evictAll() {
		trimToSize(-1); // -1 will evict 0-sized elements
	}

	/**
	 * For caches that do not override {@link #sizeOf}, this returns the number
	 * of entries in the cache. For all other caches, this returns the sum of
	 * the sizes of the entries in this cache.
	 */
	public synchronized final int size() {
		return size;
	}

	/**
	 * For caches that do not override {@link #sizeOf}, this returns the maximum
	 * number of entries in the cache. For all other caches, this returns the
	 * maximum sum of the sizes of the entries in this cache.
	 */
	public synchronized final int maxSize() {
		return maxSize;
	}

	/**
	 * Returns the number of times {@link #get} returned a value.
	 */
	public synchronized final int hitCount() {
		return hitCount;
	}

	/**
	 * Returns the number of times {@link #get} returned null or required a new
	 * value to be created.
	 */
	public synchronized final int missCount() {
		return missCount;
	}

	/**
	 * Returns the number of times {@link #create(Object)} returned a value.
	 */
	public synchronized final int createCount() {
		return createCount;
	}

	/**
	 * Returns the number of times {@link #put} was called.
	 */
	public synchronized final int putCount() {
		return putCount;
	}

	/**
	 * Returns the number of values that have been evicted.
	 */
	public synchronized final int evictionCount() {
		return evictionCount;
	}

	@Override
	public synchronized final String toString() {
		int accesses = hitCount + missCount;
		int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
		return String
				.format("LruCache[size=%d,mapSize=%d,maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
						size, map.size(), maxSize, hitCount, missCount,
						hitPercent);
	}
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Utils;

import android.content.Context;
import android.graphics.Paint;
import android.graphics.Typeface;
import android.support.v4.util.LruCache;
import android.text.TextPaint;
import android.text.style.MetricAffectingSpan;

public class TypefaceSpan extends MetricAffectingSpan {

	private static LruCache<String, Typeface> sTypefaceCache = new LruCache<String, Typeface>(12);
  	private Typeface mTypeface;

  	public TypefaceSpan(Context context, String typefaceName) {
      	mTypeface = sTypefaceCache.get(typefaceName);

      	if (mTypeface == null) {
          	mTypeface = Typeface.createFromAsset(context.getApplicationContext().getAssets(), String.format("fonts/%s.ttf", typefaceName));

          	// Cache the loaded Typeface
          	sTypefaceCache.put(typefaceName, mTypeface);
      	}
  	}

  	@Override
  	public void updateMeasureState(TextPaint p) {
      	p.setTypeface(mTypeface);

      	// Note: This flag is required for proper typeface rendering
      	p.setFlags(p.getFlags() | Paint.SUBPIXEL_TEXT_FLAG);
  	}

  	@Override
	public void updateDrawState(TextPaint tp) {
    	tp.setTypeface(mTypeface);
     	// Note: This flag is required for proper typeface rendering
    	tp.setFlags(tp.getFlags() | Paint.SUBPIXEL_TEXT_FLAG);
	}
  
}

@#$
/*
 * Copyright (C) Stephan Tittel, Peter Sinnott, Thomas Barrasso
 *
 * https://code.google.com/p/range-seek-bar/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Views;

import java.math.BigDecimal;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.RectF;
import android.os.Bundle;
import android.os.Parcelable;
import android.view.MotionEvent;
import android.view.ViewConfiguration;
import android.widget.ImageView;

import com.jams.music.player.R;

/**
 * Widget that lets users select a minimum and maximum value on a given numerical range. The range value types can be one of Long, Double, Integer, Float, Short, Byte or BigDecimal.<br />
 * <br />
 * Improved {@link MotionEvent} handling for smoother use, anti-aliased painting for improved aesthetics.
 * 
 * @author Stephan Tittel (stephan.tittel@kom.tu-darmstadt.de)
 * @author Peter Sinnott (psinnott@gmail.com)
 * @author Thomas Barrasso (tbarrasso@sevenplusandroid.org)
 * 
 * @param <T>
 *            The Number type of the range values. One of Long, Double, Integer, Float, Short, Byte or BigDecimal.
 */
public class RangeSeekBar<T extends Number> extends ImageView {
        private final Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        private final Bitmap thumbImage = BitmapFactory.decodeResource(getResources(), R.drawable.seek_thumb_normal);
        private final Bitmap thumbPressedImage = BitmapFactory.decodeResource(getResources(), R.drawable.seek_thumb_pressed);
        private final float thumbWidth = thumbImage.getWidth();
        private final float thumbHalfWidth = 0.5f * thumbWidth;
        private final float thumbHalfHeight = 0.5f * thumbImage.getHeight();
        private final float lineHeight = 0.3f * thumbHalfHeight;
        private final float padding = thumbHalfWidth;
        private final T absoluteMinValue, absoluteMaxValue;
        private final NumberType numberType;
        private final double absoluteMinValuePrim, absoluteMaxValuePrim;
        private double normalizedMinValue = 0d;
        private double normalizedMaxValue = 1d;
        private Thumb pressedThumb = null;
        private boolean notifyWhileDragging = false;
        private OnRangeSeekBarChangeListener<T> listener;

        /**
         * Default color of a {@link RangeSeekBar}, #FF33B5E5. This is also known as "Ice Cream Sandwich" blue.
         */
        public static final int DEFAULT_COLOR = Color.argb(0xFF, 0x33, 0xB5, 0xE5);

        /**
         * An invalid pointer id.
         */
        public static final int INVALID_POINTER_ID = 255;

        // Localized constants from MotionEvent for compatibility
        // with API < 8 "Froyo".
        public static final int ACTION_POINTER_UP = 0x6, ACTION_POINTER_INDEX_MASK = 0x0000ff00, ACTION_POINTER_INDEX_SHIFT = 8;

        private float mDownMotionX;
        private int mActivePointerId = INVALID_POINTER_ID;

        /**
         * On touch, this offset plus the scaled value from the position of the touch will form the progress value. Usually 0.
         */
        float mTouchProgressOffset;

        private int mScaledTouchSlop;
        private boolean mIsDragging;

        /**
         * Creates a new RangeSeekBar.
         * 
         * @param absoluteMinValue
         *            The minimum value of the selectable range.
         * @param absoluteMaxValue
         *            The maximum value of the selectable range.
         * @param context
         * @throws IllegalArgumentException
         *             Will be thrown if min/max value type is not one of Long, Double, Integer, Float, Short, Byte or BigDecimal.
         */
        public RangeSeekBar(T absoluteMinValue, T absoluteMaxValue, Context context) throws IllegalArgumentException {
                super(context);
                this.absoluteMinValue = absoluteMinValue;
                this.absoluteMaxValue = absoluteMaxValue;
                absoluteMinValuePrim = absoluteMinValue.doubleValue();
                absoluteMaxValuePrim = absoluteMaxValue.doubleValue();
                numberType = NumberType.fromNumber(absoluteMinValue);

                // make RangeSeekBar focusable. This solves focus handling issues in case EditText widgets are being used along with the RangeSeekBar within ScollViews.
                setFocusable(true);
                setFocusableInTouchMode(true);
                init();
        }

        private final void init() {
                mScaledTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();
        }

        public boolean isNotifyWhileDragging() {
                return notifyWhileDragging;
        }

        /**
         * Should the widget notify the listener callback while the user is still dragging a thumb? Default is false.
         * 
         * @param flag
         */
        public void setNotifyWhileDragging(boolean flag) {
                this.notifyWhileDragging = true;
        }

        /**
         * Returns the absolute minimum value of the range that has been set at construction time.
         * 
         * @return The absolute minimum value of the range.
         */
        public T getAbsoluteMinValue() {
                return absoluteMinValue;
        }

        /**
         * Returns the absolute maximum value of the range that has been set at construction time.
         * 
         * @return The absolute maximum value of the range.
         */
        public T getAbsoluteMaxValue() {
                return absoluteMaxValue;
        }

        /**
         * Returns the currently selected min value.
         * 
         * @return The currently selected min value.
         */
        public T getSelectedMinValue() {
                return normalizedToValue(normalizedMinValue);
        }

        /**
         * Sets the currently selected minimum value. The widget will be invalidated and redrawn.
         * 
         * @param value
         *            The Number value to set the minimum value to. Will be clamped to given absolute minimum/maximum range.
         */
        public void setSelectedMinValue(T value) {
                // in case absoluteMinValue == absoluteMaxValue, avoid division by zero when normalizing.
                if (0 == (absoluteMaxValuePrim - absoluteMinValuePrim)) {
                        setNormalizedMinValue(0d);
                }
                else {
                        setNormalizedMinValue(valueToNormalized(value));
                }
        }

        /**
         * Returns the currently selected max value.
         * 
         * @return The currently selected max value.
         */
        public T getSelectedMaxValue() {
                return normalizedToValue(normalizedMaxValue);
        }

        /**
         * Sets the currently selected maximum value. The widget will be invalidated and redrawn.
         * 
         * @param value
         *            The Number value to set the maximum value to. Will be clamped to given absolute minimum/maximum range.
         */
        public void setSelectedMaxValue(T value) {
                // in case absoluteMinValue == absoluteMaxValue, avoid division by zero when normalizing.
                if (0 == (absoluteMaxValuePrim - absoluteMinValuePrim)) {
                        setNormalizedMaxValue(1d);
                }
                else {
                        setNormalizedMaxValue(valueToNormalized(value));
                }
        }

        /**
         * Registers given listener callback to notify about changed selected values.
         * 
         * @param listener
         *            The listener to notify about changed selected values.
         */
        public void setOnRangeSeekBarChangeListener(OnRangeSeekBarChangeListener<T> listener) {
                this.listener = listener;
        }

        /**
         * Handles thumb selection and movement. Notifies listener callback on certain events.
         */
        @Override
        public boolean onTouchEvent(MotionEvent event) {

                if (!isEnabled())
                        return false;

                int pointerIndex;

                final int action = event.getAction();
                switch (action & MotionEvent.ACTION_MASK) {

                case MotionEvent.ACTION_DOWN:
                        // Remember where the motion event started
                        mActivePointerId = event.getPointerId(event.getPointerCount() - 1);
                        pointerIndex = event.findPointerIndex(mActivePointerId);
                        mDownMotionX = event.getX(pointerIndex);

                        pressedThumb = evalPressedThumb(mDownMotionX);

                        // Only handle thumb presses.
                        if (pressedThumb == null)
                                return super.onTouchEvent(event);

                        setPressed(true);
                        invalidate();
                        onStartTrackingTouch();
                        trackTouchEvent(event);
                        attemptClaimDrag();

                        break;
                case MotionEvent.ACTION_MOVE:
                        if (pressedThumb != null) {

                                if (mIsDragging) {
                                        trackTouchEvent(event);
                                }
                                else {
                                        // Scroll to follow the motion event
                                        pointerIndex = event.findPointerIndex(mActivePointerId);
                                        final float x = event.getX(pointerIndex);

                                        if (Math.abs(x - mDownMotionX) > mScaledTouchSlop) {
                                                setPressed(true);
                                                invalidate();
                                                onStartTrackingTouch();
                                                trackTouchEvent(event);
                                                attemptClaimDrag();
                                        }
                                }

                                listener.onRangeSeekBarValuesChanged(this, getSelectedMinValue(), getSelectedMaxValue());
                                if (notifyWhileDragging && listener != null) {
                                        listener.onRangeSeekBarValuesChanged(this, getSelectedMinValue(), getSelectedMaxValue());
                                }
                        }
                        break;
                case MotionEvent.ACTION_UP:
                        if (mIsDragging) {
                                trackTouchEvent(event);
                                onStopTrackingTouch();
                                setPressed(false);
                        }
                        else {
                                // Touch up when we never crossed the touch slop threshold
                                // should be interpreted as a tap-seek to that location.
                                onStartTrackingTouch();
                                trackTouchEvent(event);
                                onStopTrackingTouch();
                        }

                        pressedThumb = null;
                        invalidate();
                        if (listener != null) {
                                listener.onRangeSeekBarValuesChanged(this, getSelectedMinValue(), getSelectedMaxValue());
                        }
                        break;
                case MotionEvent.ACTION_POINTER_DOWN: {
                        final int index = event.getPointerCount() - 1;
                        // final int index = ev.getActionIndex();
                        mDownMotionX = event.getX(index);
                        mActivePointerId = event.getPointerId(index);
                        invalidate();
                        break;
                }
                case MotionEvent.ACTION_POINTER_UP:
                        onSecondaryPointerUp(event);
                        invalidate();
                        break;
                case MotionEvent.ACTION_CANCEL:
                        if (mIsDragging) {
                                onStopTrackingTouch();
                                setPressed(false);
                        }
                        invalidate(); // see above explanation
                        break;
                }
                return true;
        }

        private final void onSecondaryPointerUp(MotionEvent ev) {
                final int pointerIndex = (ev.getAction() & ACTION_POINTER_INDEX_MASK) >> ACTION_POINTER_INDEX_SHIFT;

                final int pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == mActivePointerId) {
                        // This was our active pointer going up. Choose
                        // a new active pointer and adjust accordingly.
                        // TODO: Make this decision more intelligent.
                        final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                        mDownMotionX = ev.getX(newPointerIndex);
                        mActivePointerId = ev.getPointerId(newPointerIndex);
                }
        }

        private final void trackTouchEvent(MotionEvent event) {
                final int pointerIndex = event.findPointerIndex(mActivePointerId);
                final float x = event.getX(pointerIndex);

                if (Thumb.MIN.equals(pressedThumb)) {
                        setNormalizedMinValue(screenToNormalized(x));
                }
                else if (Thumb.MAX.equals(pressedThumb)) {
                        setNormalizedMaxValue(screenToNormalized(x));
                }
        }

        /**
         * Tries to claim the user's drag motion, and requests disallowing any ancestors from stealing events in the drag.
         */
        private void attemptClaimDrag() {
                if (getParent() != null) {
                        getParent().requestDisallowInterceptTouchEvent(true);
                }
        }

        /**
         * This is called when the user has started touching this widget.
         */
        void onStartTrackingTouch() {
                mIsDragging = true;
        }

        /**
         * This is called when the user either releases his touch or the touch is canceled.
         */
        void onStopTrackingTouch() {
                mIsDragging = false;
        }

        /**
         * Ensures correct size of the widget.
         */
        @Override
        protected synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                int width = 200;
                if (MeasureSpec.UNSPECIFIED != MeasureSpec.getMode(widthMeasureSpec)) {
                        width = MeasureSpec.getSize(widthMeasureSpec);
                }
                int height = thumbImage.getHeight();
                if (MeasureSpec.UNSPECIFIED != MeasureSpec.getMode(heightMeasureSpec)) {
                        height = Math.min(height, MeasureSpec.getSize(heightMeasureSpec));
                }
                setMeasuredDimension(width, height);
        }

        /**
         * Draws the widget on the given canvas.
         */
        @Override
        protected synchronized void onDraw(Canvas canvas) {
                super.onDraw(canvas);

                // draw seek bar background line
                final RectF rect = new RectF(padding, 0.5f * (getHeight() - lineHeight), getWidth() - padding, 0.5f * (getHeight() + lineHeight));
                paint.setStyle(Style.FILL);
                paint.setColor(Color.GRAY);
                paint.setAntiAlias(true);
                canvas.drawRect(rect, paint);

                // draw seek bar active range line
                rect.left = normalizedToScreen(normalizedMinValue);
                rect.right = normalizedToScreen(normalizedMaxValue);

                // orange color
                paint.setColor(DEFAULT_COLOR);
                canvas.drawRect(rect, paint);

                // draw minimum thumb
                drawThumb(normalizedToScreen(normalizedMinValue), Thumb.MIN.equals(pressedThumb), canvas);

                // draw maximum thumb
                drawThumb(normalizedToScreen(normalizedMaxValue), Thumb.MAX.equals(pressedThumb), canvas);
        }

        /**
         * Overridden to save instance state when device orientation changes. This method is called automatically if you assign an id to the RangeSeekBar widget using the {@link #setId(int)} method. Other members of this class than the normalized min and max values don't need to be saved.
         */
        @Override
        protected Parcelable onSaveInstanceState() {
                final Bundle bundle = new Bundle();
                bundle.putParcelable("SUPER", super.onSaveInstanceState());
                bundle.putDouble("MIN", normalizedMinValue);
                bundle.putDouble("MAX", normalizedMaxValue);
                return bundle;
        }

        /**
         * Overridden to restore instance state when device orientation changes. This method is called automatically if you assign an id to the RangeSeekBar widget using the {@link #setId(int)} method.
         */
        @Override
        protected void onRestoreInstanceState(Parcelable parcel) {
                final Bundle bundle = (Bundle) parcel;
                super.onRestoreInstanceState(bundle.getParcelable("SUPER"));
                normalizedMinValue = bundle.getDouble("MIN");
                normalizedMaxValue = bundle.getDouble("MAX");
        }

        /**
         * Draws the "normal" resp. "pressed" thumb image on specified x-coordinate.
         * 
         * @param screenCoord
         *            The x-coordinate in screen space where to draw the image.
         * @param pressed
         *            Is the thumb currently in "pressed" state?
         * @param canvas
         *            The canvas to draw upon.
         */
        private void drawThumb(float screenCoord, boolean pressed, Canvas canvas) {
                canvas.drawBitmap(pressed ? thumbPressedImage : thumbImage, screenCoord - thumbHalfWidth, (float) ((0.5f * getHeight()) - thumbHalfHeight), paint);
        }

        /**
         * Decides which (if any) thumb is touched by the given x-coordinate.
         * 
         * @param touchX
         *            The x-coordinate of a touch event in screen space.
         * @return The pressed thumb or null if none has been touched.
         */
        private Thumb evalPressedThumb(float touchX) {
                Thumb result = null;
                boolean minThumbPressed = isInThumbRange(touchX, normalizedMinValue);
                boolean maxThumbPressed = isInThumbRange(touchX, normalizedMaxValue);
                if (minThumbPressed && maxThumbPressed) {
                        // if both thumbs are pressed (they lie on top of each other), choose the one with more room to drag. this avoids "stalling" the thumbs in a corner, not being able to drag them apart anymore.
                        result = (touchX / getWidth() > 0.5f) ? Thumb.MIN : Thumb.MAX;
                }
                else if (minThumbPressed) {
                        result = Thumb.MIN;
                }
                else if (maxThumbPressed) {
                        result = Thumb.MAX;
                }
                return result;
        }

        /**
         * Decides if given x-coordinate in screen space needs to be interpreted as "within" the normalized thumb x-coordinate.
         * 
         * @param touchX
         *            The x-coordinate in screen space to check.
         * @param normalizedThumbValue
         *            The normalized x-coordinate of the thumb to check.
         * @return true if x-coordinate is in thumb range, false otherwise.
         */
        private boolean isInThumbRange(float touchX, double normalizedThumbValue) {
                return Math.abs(touchX - normalizedToScreen(normalizedThumbValue)) <= thumbHalfWidth;
        }

        /**
         * Sets normalized min value to value so that 0 <= value <= normalized max value <= 1. The View will get invalidated when calling this method.
         * 
         * @param value
         *            The new normalized min value to set.
         */
        public void setNormalizedMinValue(double value) {
                normalizedMinValue = Math.max(0d, Math.min(1d, Math.min(value, normalizedMaxValue)));
                invalidate();
        }

        /**
         * Sets normalized max value to value so that 0 <= normalized min value <= value <= 1. The View will get invalidated when calling this method.
         * 
         * @param value
         *            The new normalized max value to set.
         */
        public void setNormalizedMaxValue(double value) {
                normalizedMaxValue = Math.max(0d, Math.min(1d, Math.max(value, normalizedMinValue)));
                invalidate();
        }

        /**
         * Converts a normalized value to a Number object in the value space between absolute minimum and maximum.
         * 
         * @param normalized
         * @return
         */
        @SuppressWarnings("unchecked")
        private T normalizedToValue(double normalized) {
                return (T) numberType.toNumber(absoluteMinValuePrim + normalized * (absoluteMaxValuePrim - absoluteMinValuePrim));
        }

        /**
         * Converts the given Number value to a normalized double.
         * 
         * @param value
         *            The Number value to normalize.
         * @return The normalized double.
         */
        private double valueToNormalized(T value) {
                if (0 == absoluteMaxValuePrim - absoluteMinValuePrim) {
                        // prevent division by zero, simply return 0.
                        return 0d;
                }
                return (value.doubleValue() - absoluteMinValuePrim) / (absoluteMaxValuePrim - absoluteMinValuePrim);
        }

        /**
         * Converts a normalized value into screen space.
         * 
         * @param normalizedCoord
         *            The normalized value to convert.
         * @return The converted value in screen space.
         */
        private float normalizedToScreen(double normalizedCoord) {
                return (float) (padding + normalizedCoord * (getWidth() - 2 * padding));
        }

        /**
         * Converts screen space x-coordinates into normalized values.
         * 
         * @param screenCoord
         *            The x-coordinate in screen space to convert.
         * @return The normalized value.
         */
        private double screenToNormalized(float screenCoord) {
                int width = getWidth();
                if (width <= 2 * padding) {
                        // prevent division by zero, simply return 0.
                        return 0d;
                }
                else {
                        double result = (screenCoord - padding) / (width - 2 * padding);
                        return Math.min(1d, Math.max(0d, result));
                }
        }

        /**
         * Callback listener interface to notify about changed range values.
         * 
         * @author Stephan Tittel (stephan.tittel@kom.tu-darmstadt.de)
         * 
         * @param <T>
         *            The Number type the RangeSeekBar has been declared with.
         */
        public interface OnRangeSeekBarChangeListener<T> {
                public void onRangeSeekBarValuesChanged(RangeSeekBar<?> bar, T minValue, T maxValue);
        }

        /**
         * Thumb constants (min and max).
         */
        private static enum Thumb {
                MIN, MAX
        };

        /**
         * Utility enumaration used to convert between Numbers and doubles.
         * 
         * @author Stephan Tittel (stephan.tittel@kom.tu-darmstadt.de)
         * 
         */
        private static enum NumberType {
                LONG, DOUBLE, INTEGER, FLOAT, SHORT, BYTE, BIG_DECIMAL;

                public static <E extends Number> NumberType fromNumber(E value) throws IllegalArgumentException {
                        if (value instanceof Long) {
                                return LONG;
                        }
                        if (value instanceof Double) {
                                return DOUBLE;
                        }
                        if (value instanceof Integer) {
                                return INTEGER;
                        }
                        if (value instanceof Float) {
                                return FLOAT;
                        }
                        if (value instanceof Short) {
                                return SHORT;
                        }
                        if (value instanceof Byte) {
                                return BYTE;
                        }
                        if (value instanceof BigDecimal) {
                                return BIG_DECIMAL;
                        }
                        throw new IllegalArgumentException("Number class '" + value.getClass().getName() + "' is not supported");
                }

                public Number toNumber(double value) {
                        switch (this) {
                        case LONG:
                                return new Long((long) value);
                        case DOUBLE:
                                return value;
                        case INTEGER:
                                return new Integer((int) value);
                        case FLOAT:
                                return new Float(value);
                        case SHORT:
                                return new Short((short) value);
                        case BYTE:
                                return new Byte((byte) value);
                        case BIG_DECIMAL:
                                return new BigDecimal(value);
                        }
                        throw new InstantiationError("can't convert " + this + " to a Number object");
                }
        }
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Views;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Path;
import android.graphics.RectF;
import android.util.AttributeSet;
import android.widget.ImageView;

public class RoundedImageView extends ImageView {

	public RoundedImageView(Context context) {
		super(context);
	}

	public RoundedImageView(Context context, AttributeSet attrs) {
	    super(context, attrs);
	}

	public RoundedImageView(Context context, AttributeSet attrs, int defStyle) {
	    super(context, attrs, defStyle);
	}

	@Override
	protected void onDraw(Canvas canvas) {
		float radius = 5.0f; // angle of round corners
	    Path clipPath = new Path();
	    RectF rect = new RectF(0, 0, this.getWidth(), this.getHeight());
	    clipPath.addRoundRect(rect, radius, radius, Path.Direction.CW);
	    canvas.clipPath(clipPath);

	    super.onDraw(canvas);
	}
	  
}


@#$
/*
 * Copyright (C) Hackskrieg
 *
 * http://hackskrieg.wordpress.com/2012/04/20/working-vertical-seekbar-for-android/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.Views;

import android.content.Context;
import android.graphics.Canvas;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.widget.SeekBar;

//Creates a Vertical SeekBar using Android's basic UI elements.
public class VerticalSeekBar extends SeekBar {
	 
    public VerticalSeekBar(Context context) {
        super(context);
    }
 
    public VerticalSeekBar(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }
 
    public VerticalSeekBar(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
 
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(h, w, oldh, oldw);
    }
 
    @Override
    protected synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(heightMeasureSpec, widthMeasureSpec);
        setMeasuredDimension(getMeasuredHeight(), getMeasuredWidth());
    }
 
    protected void onDraw(Canvas c) {
        c.rotate(-90);
        c.translate(-getHeight(), 0);
 
        super.onDraw(c);
    }
 
    private OnSeekBarChangeListener onChangeListener;
    @Override
    public void setOnSeekBarChangeListener(OnSeekBarChangeListener onChangeListener){
        this.onChangeListener = onChangeListener;
    }
 
    private int lastProgress = 0;
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (!isEnabled()) {
            return false;
        }
 
        switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            onChangeListener.onStartTrackingTouch(this);
            setPressed(true);
            setSelected(true);
            break;
        case MotionEvent.ACTION_MOVE:
            super.onTouchEvent(event);
            int progress = getMax() - (int) (getMax() * event.getY() / getHeight());
             
            // Ensure progress stays within boundaries
            if(progress < 0) {progress = 0;}
            if(progress > getMax()) {progress = getMax();}
            setProgress(progress);  // Draw progress
            if(progress != lastProgress) {
                // Only enact listener if the progress has actually changed
                lastProgress = progress;
                onChangeListener.onProgressChanged(this, progress, true);
            }
             
            onSizeChanged(getWidth(), getHeight() , 0, 0);
            setPressed(true);
            setSelected(true);
            break;
        case MotionEvent.ACTION_UP:
            onChangeListener.onStopTrackingTouch(this);
            setPressed(false);
            setSelected(false);
            break;
        case MotionEvent.ACTION_CANCEL:
            super.onTouchEvent(event);
            setPressed(false);
            setSelected(false);
            break;
        }
        return true;
    }
 
    public synchronized void setProgressAndThumb(int progress) {
        setProgress(progress);
        onSizeChanged(getWidth(), getHeight() , 0, 0);
        if(progress != lastProgress) {
            // Only enact listener if the progress has actually changed
            lastProgress = progress;
            onChangeListener.onProgressChanged(this, progress, true);
        }
        
    }
 
    public synchronized void setMaximum(int maximum) {
        setMax(maximum);
    }
 
    public synchronized int getMaximum() {
        return getMax();
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WelcomeActivity;

import android.content.Context;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.RadioGroup.OnCheckedChangeListener;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Utils.Common;

public class AlbumArtFragment extends Fragment {
	
	private Context mContext;
	private Common mApp;
	
	private TextView welcomeHeader;
	private TextView welcomeText1;
	
	private RadioGroup radioGroup;
	private RadioButton mPickWhatsBestRadioButton;
	private RadioButton mUseEmbeddedArtOnlyRadioButton;
	private RadioButton mUseFolderArtOnlyRadioButton;
	
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		
		mContext =  getActivity().getApplicationContext();
		mApp = (Common) mContext;
		View rootView = (View) getActivity().getLayoutInflater().inflate(R.layout.fragment_welcome_screen_4, null);	
		
		welcomeHeader = (TextView) rootView.findViewById(R.id.welcome_header);
		welcomeHeader.setTypeface(TypefaceHelper.getTypeface(getActivity(), "Roboto-Light"));
		
		welcomeText1 = (TextView) rootView.findViewById(R.id.welcome_text_1);
		welcomeText1.setTypeface(TypefaceHelper.getTypeface(getActivity(), "Roboto-Regular"));
        
        radioGroup = (RadioGroup) rootView.findViewById(R.id.album_art_radio_group);
        mPickWhatsBestRadioButton = (RadioButton) rootView.findViewById(R.id.pick_whats_best_for_me);
        mUseEmbeddedArtOnlyRadioButton = (RadioButton) rootView.findViewById(R.id.use_embedded_art_only);
        mUseFolderArtOnlyRadioButton = (RadioButton) rootView.findViewById(R.id.use_folder_art_only);
        
		mPickWhatsBestRadioButton.setTypeface(TypefaceHelper.getTypeface(getActivity(), "Roboto-Regular"));
		mUseEmbeddedArtOnlyRadioButton.setTypeface(TypefaceHelper.getTypeface(getActivity(), "Roboto-Regular"));
		mUseFolderArtOnlyRadioButton.setTypeface(TypefaceHelper.getTypeface(getActivity(), "Roboto-Regular"));
        
        //Check which album art source is selected and set the appropriate flag.
        if (mApp.getSharedPreferences().getInt("ALBUM_ART_SOURCE", 0)==0) {
        	mPickWhatsBestRadioButton.setChecked(true);
        } else if (mApp.getSharedPreferences().getInt("ALBUM_ART_SOURCE", 0)==1) {
        	mUseEmbeddedArtOnlyRadioButton.setChecked(true);
        } else if (mApp.getSharedPreferences().getInt("ALBUM_ART_SOURCE", 0)==2) {
        	mUseFolderArtOnlyRadioButton.setChecked(true);
        }
        
        radioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				switch(checkedId) {
				case R.id.pick_whats_best_for_me:
					mApp.getSharedPreferences().edit().putInt("ALBUM_ART_SOURCE", 0).commit();
					break;
				case R.id.use_embedded_art_only:
					mApp.getSharedPreferences().edit().putInt("ALBUM_ART_SOURCE", 1).commit();
					break;
				case R.id.use_folder_art_only:
					mApp.getSharedPreferences().edit().putInt("ALBUM_ART_SOURCE", 2).commit();
					break;
				}
				
			}
        	
        });

        return rootView;
    }
	
}


@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WelcomeActivity;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.content.Context;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.RadioGroup.OnCheckedChangeListener;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncGoogleMusicAuthenticationTask;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.Helpers.UIElementsHelper;
import com.jams.music.player.Utils.Common;

public class GooglePlayMusicFragment extends Fragment {

	private Context mContext;
	private Common mApp;

	private Account account;
	private RadioGroup radioGroup;
	private TextView welcomeHeader;
	private TextView welcomeText1;
	private TextView googlePlayMusicDisclaimer;
	
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		mContext =  getActivity().getApplicationContext();
		mApp = (Common) mContext;
		View rootView = (View) inflater.inflate(R.layout.fragment_welcome_screen_5, null);
		
		welcomeHeader = (TextView) rootView.findViewById(R.id.welcome_header);
		welcomeHeader.setTypeface(TypefaceHelper.getTypeface(getActivity(), "Roboto-Light"));
		
		welcomeText1 = (TextView) rootView.findViewById(R.id.welcome_text_1);
		welcomeText1.setTypeface(TypefaceHelper.getTypeface(getActivity(), "Roboto-Regular"));
        
		googlePlayMusicDisclaimer = (TextView) rootView.findViewById(R.id.google_play_music_disclaimer);
		googlePlayMusicDisclaimer.setTypeface(TypefaceHelper.getTypeface(getActivity(), "Roboto-Regular"));

        radioGroup = (RadioGroup) rootView.findViewById(R.id.google_play_music_radio_group);
        
        final AccountManager accountManager = AccountManager.get(getActivity().getApplicationContext());
        final Account[] accounts = accountManager.getAccountsByType("com.google");
        final int size = accounts.length+1; //We're adding 1 here to account (no pun intended) for the extra "Don't use Google Play Music" option.
        
        final RadioButton[] radioButton = new RadioButton[size];
        
        //Add a new radio button the group for each username.
        for (int i=0; i < size; i++) {
        	radioButton[i] = new RadioButton(getActivity());
        	radioGroup.addView(radioButton[i]);
        	
        	//The first radio button will always be "Don't use Google Play Music".
        	if (i==0) {
        		radioButton[i].setChecked(true);
        		radioButton[i].setText(R.string.dont_use_google_play_music);
        	} else {
        		radioButton[i].setText(accounts[i-1].name);
        	}
        	
        	radioButton[i].setTag(i);
        	radioButton[i].setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        	
        }
        
        radioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {

				int radioButtonID = group.getCheckedRadioButtonId();
				View radioButton = group.findViewById(radioButtonID);
				int index = group.indexOfChild(radioButton);
				
				if (index!=0) {
					
					account = accounts[index-1];
					mApp.getSharedPreferences()
						.edit()
						.putString("GOOGLE_PLAY_MUSIC_ACCOUNT", account.name)
						.commit();
					
					AsyncGoogleMusicAuthenticationTask task = new AsyncGoogleMusicAuthenticationTask(mContext, 
																									 getActivity(),
																									 true,
																									 account.name);
					
					task.execute();
				} else {
					mApp.getSharedPreferences().edit().putString("GOOGLE_PLAY_MUSIC_ACCOUNT", "").commit();
					mApp.getSharedPreferences().edit().putBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false).commit();
				}
				
			}
        	
        });
		
		return rootView;
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WelcomeActivity;

import android.content.Context;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.TranslateAnimation;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.RadioGroup.OnCheckedChangeListener;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;
import com.jams.music.player.MusicFoldersSelectionFragment.MusicFoldersSelectionFragment;
import com.jams.music.player.Utils.Common;

public class MusicFoldersFragment extends Fragment {
	
	private Context mContext;
	private Common mApp;
	private FragmentManager mChildFragmentManager;
	private MusicFoldersSelectionFragment mMusicFoldersSelectionFragment = null;
	private TextView mWelcomeHeader;
	private RadioGroup mMusicFoldersOptions;
	private TranslateAnimation mSlideInAnimation;
	private TranslateAnimation mSlideOutAnimation;
	private RelativeLayout mFoldersLayout;
	
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		
		mContext =  getActivity().getApplicationContext();
		mApp = (Common) mContext;
		View rootView = (View) getActivity().getLayoutInflater().inflate(R.layout.fragment_welcome_screen_2, null);		
		
		mFoldersLayout = (RelativeLayout) rootView.findViewById(R.id.folders_fragment_holder);
		if (mApp.getSharedPreferences().getInt("MUSIC_FOLDERS_SELECTION", 0)==0) {
			mFoldersLayout.setVisibility(View.INVISIBLE);
			mFoldersLayout.setEnabled(false);
		} else {
			mFoldersLayout.setVisibility(View.VISIBLE);
			mFoldersLayout.setEnabled(true);
		}
		
		mSlideInAnimation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f, 
				  								   Animation.RELATIVE_TO_SELF, 0.0f, 
				  								   Animation.RELATIVE_TO_SELF, 2.0f, 
				  								   Animation.RELATIVE_TO_SELF, 0.0f);

		mSlideInAnimation.setDuration(600);
		mSlideInAnimation.setInterpolator(new AccelerateDecelerateInterpolator());
		mSlideInAnimation.setAnimationListener(slideInListener);
		
		mSlideOutAnimation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f, 
				   								    Animation.RELATIVE_TO_SELF, 0.0f, 
				   								    Animation.RELATIVE_TO_SELF, 0.0f, 
				   								    Animation.RELATIVE_TO_SELF, 2.0f);
		mSlideOutAnimation.setDuration(600);
		mSlideOutAnimation.setInterpolator(new AccelerateDecelerateInterpolator());
		mSlideOutAnimation.setAnimationListener(slideOutListener);
		
		mChildFragmentManager = this.getChildFragmentManager();
		mChildFragmentManager.beginTransaction()
	 	 					 .add(R.id.folders_fragment_holder, getMusicFoldersSelectionFragment())
	 	 					 .commit();
		
		mWelcomeHeader = (TextView) rootView.findViewById(R.id.welcome_header);
		mWelcomeHeader.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Light"));
		
        mMusicFoldersOptions = (RadioGroup) rootView.findViewById(R.id.music_library_welcome_radio_group);
        RadioButton getAllSongsRadioButton = (RadioButton) mMusicFoldersOptions.findViewById(R.id.get_all_songs_radio);
        RadioButton letMePickFoldersRadioButton = (RadioButton) mMusicFoldersOptions.findViewById(R.id.pick_folders_radio);
        
        getAllSongsRadioButton.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        letMePickFoldersRadioButton.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        
        mMusicFoldersOptions.setOnCheckedChangeListener(onCheckedChangeListener);
        return rootView;
    }
	
	/**
	 * RadioButton selection listener.
	 */
	private OnCheckedChangeListener onCheckedChangeListener = new OnCheckedChangeListener() {

		@Override
		public void onCheckedChanged(RadioGroup radioGroup, int radioButtonId) {
			switch(radioButtonId) {
			case R.id.get_all_songs_radio:
				mFoldersLayout.startAnimation(mSlideOutAnimation);
				mFoldersLayout.setEnabled(false);
				break;
			case R.id.pick_folders_radio:
				mFoldersLayout.startAnimation(mSlideInAnimation);
				mFoldersLayout.setEnabled(true);
				break;
			}
			
		}
		
	};
	
	/**
	 * Slide out animation listener.
	 */
	private AnimationListener slideOutListener = new AnimationListener() {

		@Override
		public void onAnimationEnd(Animation arg0) {
			mFoldersLayout.setVisibility(View.INVISIBLE);
			
		}

		@Override
		public void onAnimationRepeat(Animation arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onAnimationStart(Animation arg0) {
			mFoldersLayout.setVisibility(View.VISIBLE);
			
		}
		
	};
	
	/**
	 * Slide in animation listener.
	 */
	private AnimationListener slideInListener = new AnimationListener() {

		@Override
		public void onAnimationEnd(Animation arg0) {
			mFoldersLayout.setVisibility(View.VISIBLE);
			
		}

		@Override
		public void onAnimationRepeat(Animation arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onAnimationStart(Animation arg0) {
			mFoldersLayout.setVisibility(View.VISIBLE);
			
		}
		
	};	
	
	/**
	 * Instantiates a new fragment if mMusicFoldersSelectionFragment is null. 
	 * Returns the current fragment, otherwise.
	 */
	public MusicFoldersSelectionFragment getMusicFoldersSelectionFragment() {
		if (mMusicFoldersSelectionFragment==null) {
			mMusicFoldersSelectionFragment = new MusicFoldersSelectionFragment();
			
			Bundle bundle = new Bundle();
			bundle.putBoolean("com.jams.music.player.WELCOME", true);
			mMusicFoldersSelectionFragment.setArguments(bundle);
		}
		
		return mMusicFoldersSelectionFragment;
	}
	
}


@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WelcomeActivity;

import android.content.Context;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;

public class ReadyToScanFragment extends Fragment {
	
	private Context mContext;
	private TextView welcomeHeader;
	private TextView welcomeText1;
	private TextView swipeLeftToContinue;
	
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		
		mContext = getActivity().getApplication();
		View rootView = (View) getActivity().getLayoutInflater().inflate(R.layout.fragment_welcome_screen_6, null);		
		
		welcomeHeader = (TextView) rootView.findViewById(R.id.welcome_header);
		welcomeHeader.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Light"));
		
		welcomeText1 = (TextView) rootView.findViewById(R.id.welcome_text_1);
		welcomeText1.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));
        
		swipeLeftToContinue = (TextView) rootView.findViewById(R.id.swipe_left_to_continue);
		swipeLeftToContinue.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));

        return rootView;
    }
	
}


@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WelcomeActivity;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentStatePagerAdapter;
import android.support.v4.view.ViewPager;
import android.support.v4.view.ViewPager.OnPageChangeListener;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnTouchListener;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.AnimationUtils;
import android.widget.Toast;

import com.jams.music.player.R;
import com.jams.music.player.AsyncTasks.AsyncSaveMusicFoldersTask;
import com.jams.music.player.MiscFragments.BuildingLibraryProgressFragment;
import com.jams.music.player.Services.BuildMusicLibraryService;
import com.jams.music.player.Utils.Common;
import com.viewpagerindicator.LinePageIndicator;

public class WelcomeActivity extends FragmentActivity {
	
	private Context mContext;
	private Common mApp;
	private ViewPager welcomeViewPager;
	private LinePageIndicator indicator;
	private String mAccountName;
	
	private MusicFoldersFragment mMusicFoldersFragment;
	public static BuildingLibraryProgressFragment mBuildingLibraryProgressFragment;
	
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		mContext = this;
		mApp = (Common) this.getApplicationContext();
		overridePendingTransition(R.anim.fade_in, R.anim.fade_out);

		setContentView(R.layout.activity_welcome);
		setTheme(R.style.AppThemeLight);
		
		if (getActionBar()!=null)
			getActionBar().hide();

		welcomeViewPager = (ViewPager) findViewById(R.id.welcome_pager);	
		
		FragmentManager fm = getSupportFragmentManager();
		welcomeViewPager.setAdapter(new WelcomePagerAdapter(fm));
		welcomeViewPager.setOffscreenPageLimit(6);
		
		indicator = (LinePageIndicator) findViewById(R.id.indicator);
		indicator.setViewPager(welcomeViewPager);
		
        final float density = getResources().getDisplayMetrics().density;
        indicator.setSelectedColor(0x880099CC);
        indicator.setUnselectedColor(0xFF4F4F4F);
        indicator.setStrokeWidth(2 * density);
        indicator.setLineWidth(30 * density);
        indicator.setOnPageChangeListener(pageChangeListener);

        //Check if the library needs to be rebuilt and this isn't the first run.
        if (getIntent().hasExtra("REFRESH_MUSIC_LIBRARY"))
            showBuildingLibraryProgress();

	}
	
	/**
	 * Page scroll listener.
	 */
	private OnPageChangeListener pageChangeListener = new OnPageChangeListener() {

		@Override
		public void onPageScrollStateChanged(int scrollState) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onPageSelected(int page) {

			/* If the user swiped away from the music folders 
			 * selection fragment, save the music folders to 
			 * the database.
			 */
			if (page==0 || page==2) {
				new AsyncSaveMusicFoldersTask(mContext.getApplicationContext(), 
											  mMusicFoldersFragment.getMusicFoldersSelectionFragment()
											  				       .getMusicFoldersHashMap())
											 .execute();
			}
			
			/* If the user scrolls away from the Google Play Music page and 
			 * they have selected an account, check if the default Google Play 
			 * Music app is installed. */
			if (page==3) {
				
				if (mApp.getSharedPreferences().getBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false)==true) {
					//Check if the Google Play Music app is installed.
			    	PackageManager pm = mContext.getPackageManager();
			    	boolean installed = false;
			    	try {
						pm.getPackageInfo("com.google.android.music", PackageManager.GET_ACTIVITIES);
						installed = true;
					} catch (NameNotFoundException e1) {
						//The app isn't installed.
						installed = false;
					}

			    	if (installed==false) {
			    		//Prompt the user to install Google Play Music.
			    		promptUserInstallGooglePlayMusic();
			    	}
				
				}
		    	
			}
			
			//Launch the scanning AsyncTask.
			if (page==5)
                showBuildingLibraryProgress();
			
		}
    	
    };

    private void showBuildingLibraryProgress() {

        //Disables swiping events on the pager.
        welcomeViewPager.setCurrentItem(5);
        welcomeViewPager.setOnTouchListener(new OnTouchListener() {

            @Override
            public boolean onTouch(View arg0, MotionEvent arg1) {
                return true;
            }

        });

        //Fade out the ViewPager indicator.
        Animation fadeOutAnim = AnimationUtils.loadAnimation(mContext, R.anim.fade_out);
        fadeOutAnim.setDuration(600);
        fadeOutAnim.setAnimationListener(fadeOutListener);
        indicator.startAnimation(fadeOutAnim);

    }
    
    /**
     * Fade out animation listener.
     */
    private AnimationListener fadeOutListener = new AnimationListener() {

		@Override
		public void onAnimationEnd(Animation arg0) {
			indicator.setVisibility(View.INVISIBLE);

            Intent intent = new Intent(mContext, BuildMusicLibraryService.class);
            startService(intent);
			
		}

		@Override
		public void onAnimationRepeat(Animation arg0) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void onAnimationStart(Animation arg0) {
			// TODO Auto-generated method stub
			
		}
    	
    };
	
    /**
     * Asks the user to install the GMusic app.
     */
	private void promptUserInstallGooglePlayMusic() {
		AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
		AlertDialog dialog;
		builder.setTitle(R.string.google_play_music_no_asterisk);
		builder.setMessage(R.string.prompt_user_install_google_play_music);
		builder.setPositiveButton(R.string.yes, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				dialog.dismiss();
				Intent intent = new Intent(Intent.ACTION_VIEW);
				intent.setData(Uri.parse("market://details?id=com.google.android.music"));
				startActivity(intent);

			}
			
		});
		
		builder.setNegativeButton(R.string.no, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				mApp.getSharedPreferences().edit().putBoolean("GOOGLE_PLAY_MUSIC_ENABLED", false).commit();
				Toast.makeText(mContext, R.string.google_play_music_disabled, Toast.LENGTH_LONG).show();
				dialog.dismiss();
				
			}
			
		});
		
		dialog = builder.create();
		dialog.show();
	}
	
	/**
	 * Ask the user to set up GMusic.
	 */
	private void promptUserSetUpGooglePlayMusic() {
		AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
		AlertDialog dialog;
		builder.setTitle(R.string.tip);
		builder.setMessage(R.string.prompt_user_set_up_google_play_music);
		builder.setPositiveButton(R.string.let_me_check, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				Intent intent = getPackageManager().getLaunchIntentForPackage("com.google.android.music");
				startActivity(intent);
				dialog.dismiss();
	
			}
			
		});
		
		builder.setNeutralButton(R.string.sync_manually, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				dialog.dismiss();
				
			}
			
		});
		
		builder.setNegativeButton(R.string.set_up_already, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				dialog.dismiss();
				
			}
			
		});
		
		dialog = builder.create();
		dialog.show();
	}
	
	@Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    	//Result Code 45 = UserRecoverableAuthenticationException from GooglePlayMusicAuthenticationDialog.
    	if (requestCode==45) {
    		
    		final Intent finalData = data;
    		final int finalResultCode = resultCode;
    		
    		runOnUiThread(new Runnable() {

				@Override
				public void run() {
					//An unknown error occurred.
		            if (finalData==null) {
						Toast.makeText(mContext, R.string.unknown_error_google_music, Toast.LENGTH_LONG).show();
		                return;
		            }
		            
		            //The user handled the exception properly.
		            if (finalResultCode==RESULT_OK) {
		            	
		            	mApp.getSharedPreferences().edit().putBoolean("GOOGLE_PLAY_MUSIC_ENABLED", true).commit();
		            	mApp.getSharedPreferences().edit().putString("GOOGLE_PLAY_MUSIC_ACCOUNT", mAccountName).commit();

				        return;
		            }
		            
		            if (finalResultCode==RESULT_CANCELED) {
		            	finish();
		            }
		            
		            Toast.makeText(mContext, R.string.unknown_error_google_music, Toast.LENGTH_LONG).show();
				}
    			
    		});
    		
    	} else if (resultCode==10001) {
    		
    	}
    	
    }
	
	class WelcomePagerAdapter extends FragmentStatePagerAdapter {
		
        public WelcomePagerAdapter(FragmentManager fm) {
            super(fm);
        }

        //This method controls which fragment should be shown on a specific screen.
        @Override
        public Fragment getItem(int position) {
        	
        	//Assign the appropriate screen to the fragment object, based on which screen is displayed.
        	switch (position) {
        	case 0:
        		return new WelcomeFragment();
        	case 1:
        		mMusicFoldersFragment = new MusicFoldersFragment();
        		return mMusicFoldersFragment;
        	case 2:
        		return new AlbumArtFragment();
        	case 3:
        		return new GooglePlayMusicFragment();
        	case 4:
        		return new ReadyToScanFragment();
        	case 5:
        		mBuildingLibraryProgressFragment = new BuildingLibraryProgressFragment();
        		return mBuildingLibraryProgressFragment;
        	default:
        		return null;
        	}
        	
        }

		@Override
		public int getCount() {
			return 6;
		}
        
	}
	
	@Override
	public void onPause() {
		super.onPause();
		finish();
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WelcomeActivity;

import android.content.Context;
import android.graphics.Paint;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.jams.music.player.R;
import com.jams.music.player.Helpers.TypefaceHelper;

public class WelcomeFragment extends Fragment {
	
	private Context mContext;
	private TextView welcomeHeader;
	private TextView welcomeText1;
	
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		
		mContext =  getActivity().getApplicationContext();
		View rootView = (View) getActivity().getLayoutInflater().inflate(R.layout.fragment_welcome_screen, null);		
		
		welcomeHeader = (TextView) rootView.findViewById(R.id.welcome_header);
		welcomeHeader.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Light"));
		
		welcomeText1 = (TextView) rootView.findViewById(R.id.welcome_text_1);
		welcomeText1.setTypeface(TypefaceHelper.getTypeface(mContext, "Roboto-Regular"));

        return rootView;
    }
	
}


@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WidgetProviders;

import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.Context;
import android.content.Intent;

import com.jams.music.player.AsyncTasks.AsyncUpdateAlbumArtWidgetTask;

public class AlbumArtWidgetProvider extends AppWidgetProvider {
	
	private Context mContext;
	
	@Override
	public void onReceive(Context context, Intent intent) {
		super.onReceive(context, intent);

	}
	
	@Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
		super.onUpdate(context, appWidgetManager, appWidgetIds);
		mContext = context;
        final int N = appWidgetIds.length;

        AsyncUpdateAlbumArtWidgetTask task = new AsyncUpdateAlbumArtWidgetTask(mContext, N, appWidgetIds, appWidgetManager);
        task.execute();
 
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WidgetProviders;

import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.Context;
import android.content.Intent;

import com.jams.music.player.AsyncTasks.AsyncUpdateBlurredWidgetTask;

public class BlurredWidgetProvider extends AppWidgetProvider {
	
	private Context mContext;
	
	@Override
	public void onReceive(Context context, Intent intent) {
		super.onReceive(context, intent);

	}
	
	@Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
		super.onUpdate(context, appWidgetManager, appWidgetIds);
		mContext = context;
        final int N = appWidgetIds.length;

        AsyncUpdateBlurredWidgetTask task = new AsyncUpdateBlurredWidgetTask(mContext, N, appWidgetIds, appWidgetManager);
        task.execute();
 
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WidgetProviders;

import android.app.Activity;
import android.app.AlertDialog;
import android.appwidget.AppWidgetManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.widget.RemoteViews;

import com.jams.music.player.R;

public class LargeWidgetConfigActivity extends Activity {

	private SharedPreferences sharedPreferences;
	private int mAppWidgetId;
	
	@Override
	public void onCreate(Bundle savedInstanceState) {
		setTheme(android.R.style.Theme_Holo_Dialog);
		super.onCreate(savedInstanceState);
		setResult(RESULT_CANCELED, new Intent());
		sharedPreferences = this.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);

		//Retrieve the id of the widget that called this activity.
		Intent intent = getIntent();
		Bundle extras = intent.getExtras();
		if (extras!=null) {
			mAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID, 
		            					 AppWidgetManager.INVALID_APPWIDGET_ID);
		}
		
		AlertDialog.Builder builder = new AlertDialog.Builder(this);
		builder.setTitle(R.string.select_widget_color);
		builder.setCancelable(false);
		builder.setSingleChoiceItems(R.array.widget_color_options, -1, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				if (which==0) {
					//Light theme.
					sharedPreferences.edit().putString("" + mAppWidgetId, "LIGHT").commit();
				} else if (which==1) {
					//Dark theme.
					sharedPreferences.edit().putString("" + mAppWidgetId, "DARK").commit();
				}
				
				updateWidgetConfig();
			}
			
		});
		
		builder.create().show();
	}
	
	private void updateWidgetConfig() {
		AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(this);
		RemoteViews views = new RemoteViews(getPackageName(),
											R.layout.large_widget_layout);
											appWidgetManager.updateAppWidget(mAppWidgetId, views);
											
		Intent resultValue = new Intent();
		resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);
		setResult(RESULT_OK, resultValue);
		updateWidget();
		finish();
	}
	
	private void updateWidget() {
		try {
			Intent largeWidgetIntent = new Intent(this, LargeWidgetProvider.class);
			largeWidgetIntent.setAction("android.appwidget.action.APPWIDGET_UPDATE");
			int largeWidgetIds[] = AppWidgetManager.getInstance(this).getAppWidgetIds(new ComponentName(this, LargeWidgetProvider.class));
			largeWidgetIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, largeWidgetIds);
			this.sendBroadcast(largeWidgetIntent);

		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WidgetProviders;

import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;

import com.jams.music.player.AsyncTasks.AsyncUpdateLargeWidgetTask;

public class LargeWidgetProvider extends AppWidgetProvider {

	private Context mContext;
	
	public static final String PREVIOUS_ACTION = "com.jams.music.player.PREVIOUS_ACTION";
	public static final String PLAY_PAUSE_ACTION = "com.jams.music.player.PLAY_PAUSE_ACTION";
	public static final String NEXT_ACTION = "com.jams.music.player.NEXT_ACTION";
	
	@Override
	public void onReceive(Context context, Intent intent) {
		super.onReceive(context, intent); 
		
		AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
		ComponentName thisAppWidget = new ComponentName(context.getPackageName(), LargeWidgetProvider.class.getName());
		int[] appWidgetIds = appWidgetManager.getAppWidgetIds(thisAppWidget);

		onUpdate(context, appWidgetManager, appWidgetIds);

	}
	
	@Override
	public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
    	mContext = context;
        final int N = appWidgetIds.length;
        
        AsyncUpdateLargeWidgetTask task = new AsyncUpdateLargeWidgetTask(mContext, N, appWidgetIds, appWidgetManager);
        task.execute();
        
    }
    
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WidgetProviders;

import android.app.Activity;
import android.app.AlertDialog;
import android.appwidget.AppWidgetManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.widget.RemoteViews;

import com.jams.music.player.R;

public class SmallWidgetConfigActivity extends Activity {

	private SharedPreferences sharedPreferences;
	private int mAppWidgetId;
	
	@Override
	public void onCreate(Bundle savedInstanceState) {
		setTheme(android.R.style.Theme_Holo_Dialog);
		super.onCreate(savedInstanceState);
		setResult(RESULT_CANCELED, new Intent());
		sharedPreferences = this.getSharedPreferences("com.jams.music.player", Context.MODE_PRIVATE);
		
		//Retrieve the id of the widget that called this activity.
		Intent intent = getIntent();
		Bundle extras = intent.getExtras();
		if (extras!=null) {
			mAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID, 
		            					 AppWidgetManager.INVALID_APPWIDGET_ID);
		}
		
		AlertDialog.Builder builder = new AlertDialog.Builder(this);
		builder.setTitle(R.string.select_widget_color);
		builder.setCancelable(false);
		builder.setSingleChoiceItems(R.array.widget_color_options, -1, new OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				if (which==0) {
					//Light theme.
					sharedPreferences.edit().putString("" + mAppWidgetId, "LIGHT").commit();
				} else if (which==1) {
					//Dark theme.
					sharedPreferences.edit().putString("" + mAppWidgetId, "DARK").commit();
				}
				
				updateWidgetConfig();
			}
			
		});
		
		builder.create().show();
	}
	
	private void updateWidgetConfig() {
		AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(this);
		RemoteViews views = new RemoteViews(getPackageName(),
											R.layout.small_widget_layout);
											appWidgetManager.updateAppWidget(mAppWidgetId, views);
											
		Intent resultValue = new Intent();
		resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);
		setResult(RESULT_OK, resultValue);
		updateWidget();
		finish();
	}
	
	private void updateWidget() {
		try {
			Intent smallWidgetIntent = new Intent(this, SmallWidgetProvider.class);
			smallWidgetIntent.setAction("android.appwidget.action.APPWIDGET_UPDATE");
			int smallWidgetIds[] = AppWidgetManager.getInstance(this).getAppWidgetIds(new ComponentName(this, SmallWidgetProvider.class));
			smallWidgetIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, smallWidgetIds);
			this.sendBroadcast(smallWidgetIntent);

		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	
}

@#$
/*
 * Copyright (C) 2014 Saravan Pantham
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jams.music.player.WidgetProviders;

import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.Context;
import android.content.Intent;

import com.jams.music.player.AsyncTasks.AsyncUpdateSmallWidgetTask;

public class SmallWidgetProvider extends AppWidgetProvider {
	
	private Context mContext;
	
	@Override
	public void onReceive(Context context, Intent intent) {
		super.onReceive(context, intent);

	}
	
	@Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
		super.onUpdate(context, appWidgetManager, appWidgetIds);
		mContext = context;
        final int N = appWidgetIds.length;

        AsyncUpdateSmallWidgetTask task = new AsyncUpdateSmallWidgetTask(mContext, N, appWidgetIds, appWidgetManager);
        task.execute();
 
    }
    
}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog;

import java.util.HashMap;
import java.util.Map;

import main.java.de.psdev.licensesdialog.licenses.ApacheSoftwareLicense20;
import main.java.de.psdev.licensesdialog.licenses.BSD3ClauseLicense;
import main.java.de.psdev.licensesdialog.licenses.ISCLicense;
import main.java.de.psdev.licensesdialog.licenses.License;
import main.java.de.psdev.licensesdialog.licenses.MITLicense;

public final class LicenseResolver {

    private static final int INITIAL_LICENSES_COUNT = 4;
    private static final Map<String, License> sLicenses = new HashMap<String, License>(INITIAL_LICENSES_COUNT);

    static {
        registerDefaultLicenses();
    }

    static void registerDefaultLicenses() {
        sLicenses.clear();
        registerLicense(new ApacheSoftwareLicense20());
        registerLicense(new BSD3ClauseLicense());
        registerLicense(new ISCLicense());
        registerLicense(new MITLicense());
    }

    /**
     * Register an additional license.
     *
     * @param license the license to register
     */
    public static void registerLicense(final License license) {
        sLicenses.put(license.getName(), license);
    }

    /**
     * Get a license by name
     *
     * @param license license name
     * @return License
     * @throws java.lang.IllegalStateException when unknown license is requested
     */
    public static License read(final String license) {
        final String trimmedLicense = license.trim();
        if (sLicenses.containsKey(trimmedLicense)) {
            return sLicenses.get(trimmedLicense);
        } else {
            throw new IllegalStateException(String.format("no such license available: %s, did you forget to register it?", trimmedLicense));
        }
    }

    private LicenseResolver() {
    }
}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog;

import java.util.List;

import main.java.de.psdev.licensesdialog.licenses.ApacheSoftwareLicense20;
import main.java.de.psdev.licensesdialog.model.Notice;
import main.java.de.psdev.licensesdialog.model.Notices;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.webkit.WebView;
import de.psdev.licensesdialog.R;

public class LicensesDialog {
    public static final Notice LICENSES_DIALOG_NOTICE = new Notice("LicensesDialog", "http://psdev.de/LicensesDialog", "Copyright 2013 Philip Schiffer",
            new ApacheSoftwareLicense20());

    private final Context mContext;
    private final String mTitleText;
    private final String mLicensesText;
    private final String mCloseText;

    //
    private DialogInterface.OnDismissListener mOnDismissListener;

    public LicensesDialog(final Context context, final int rawNoticesResourceId, final boolean showFullLicenseText, boolean includeOwnLicense) {
        mContext = context;
        // Load defaults
        final String style = context.getString(R.string.notices_default_style);
        mTitleText = context.getString(R.string.notices_title);
        try {
            final Resources resources = context.getResources();
            if ("raw".equals(resources.getResourceTypeName(rawNoticesResourceId))) {
                final Notices notices = NoticesXmlParser.parse(resources.openRawResource(rawNoticesResourceId));
                if (includeOwnLicense) {
                    final List<Notice> noticeList = notices.getNotices();
                    noticeList.add(LICENSES_DIALOG_NOTICE);
                }
                mLicensesText = NoticesHtmlBuilder.create(mContext).setShowFullLicenseText(showFullLicenseText).setNotices(notices).setStyle(style).build();
            } else {
                throw new IllegalStateException("not a raw resource");
            }
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
        mCloseText = context.getString(R.string.notices_close);
    }

    public LicensesDialog(final Context context, final String titleText, final String licensesText, final String closeText) {
        mContext = context;
        mTitleText = titleText;
        mLicensesText = licensesText;
        mCloseText = closeText;
    }

    public LicensesDialog setOnDismissListener(final DialogInterface.OnDismissListener onDismissListener) {
        mOnDismissListener = onDismissListener;
        return this;
    }

    public Dialog create() {
        //Get resources
        final WebView webView = new WebView(mContext);
        webView.loadDataWithBaseURL(null, mLicensesText, "text/html", "utf-8", null);
        final AlertDialog.Builder builder = new AlertDialog.Builder(mContext)
                .setTitle(mTitleText)
                .setView(webView)
                .setPositiveButton(mCloseText, new Dialog.OnClickListener() {
                    public void onClick(final DialogInterface dialogInterface, final int i) {
                        dialogInterface.dismiss();
                    }
                });
        final AlertDialog dialog = builder.create();
        dialog.setOnDismissListener(new DialogInterface.OnDismissListener() {
            @Override
            public void onDismiss(final DialogInterface dialog) {
                if (mOnDismissListener != null) {
                    mOnDismissListener.onDismiss(dialog);
                }
            }
        });
        return dialog;
    }

    public void show() {
        create().show();
    }

    //


}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog;

import main.java.de.psdev.licensesdialog.model.Notices;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.os.Bundle;
import de.psdev.licensesdialog.R;

public class LicensesDialogFragment extends DialogFragment {

    private static final String ARGUMENT_NOTICES_XML_ID = "ARGUMENT_NOTICES_XML_ID";
    private static final String ARGUMENT_INCLUDE_OWN_LICENSE = "ARGUMENT_INCLUDE_OWN_LICENSE";
    private static final String STATE_TITLE_TEXT = "title_text";
    private static final String STATE_LICENSES_TEXT = "licenses_text";
    private static final String STATE_CLOSE_TEXT = "close_text";

    //
    private String mTitleText;
    private String mCloseButtonText;
    private String mLicensesText;

    private DialogInterface.OnDismissListener mOnDismissListener;

    public static LicensesDialogFragment newInstance(final int rawNoticesResourceId, final boolean includeOwnLicense) {
        final LicensesDialogFragment licensesDialogFragment = new LicensesDialogFragment();
        final Bundle args = new Bundle();
        args.putInt(ARGUMENT_NOTICES_XML_ID, rawNoticesResourceId);
        args.putBoolean(ARGUMENT_INCLUDE_OWN_LICENSE, includeOwnLicense);
        licensesDialogFragment.setArguments(args);
        return licensesDialogFragment;
    }

    public LicensesDialogFragment() {
    }

    @Override
    public void onCreate(final Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        final Resources resources = getResources();

        if (savedInstanceState != null) {
            mTitleText = savedInstanceState.getString(STATE_TITLE_TEXT);
            mLicensesText = savedInstanceState.getString(STATE_LICENSES_TEXT);
            mCloseButtonText = savedInstanceState.getString(STATE_CLOSE_TEXT);
        } else {
            mTitleText = resources.getString(R.string.notices_title);
            mCloseButtonText = resources.getString(R.string.notices_close);
            try {
                final Notices notices = NoticesXmlParser.parse(resources.openRawResource(getNoticesXmlResourceId()));
                if(getArguments() != null && getArguments().getBoolean(ARGUMENT_INCLUDE_OWN_LICENSE, false)) {
                    notices.getNotices().add(LicensesDialog.LICENSES_DIALOG_NOTICE);
                }
                mLicensesText = NoticesHtmlBuilder.create(getActivity()).setNotices(notices).build();
            } catch (final Exception e) {
                throw new IllegalStateException(e);
            }
        }
    }

    @Override
    public void onSaveInstanceState(final Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putString(STATE_TITLE_TEXT, mTitleText);
        outState.putString(STATE_LICENSES_TEXT, mLicensesText);
        outState.putString(STATE_CLOSE_TEXT, mCloseButtonText);
    }

    @Override
    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        return new LicensesDialog(getActivity(), mTitleText, mLicensesText, mCloseButtonText).create();
    }

    @Override
    public void onDismiss(final DialogInterface dialog) {
        super.onDismiss(dialog);
        if (mOnDismissListener != null) {
            mOnDismissListener.onDismiss(dialog);
        }
    }

    //

    public DialogInterface.OnDismissListener getOnDismissListener() {
        return mOnDismissListener;
    }

    public void setOnDismissListener(final DialogInterface.OnDismissListener onDismissListener) {
        mOnDismissListener = onDismissListener;
    }

    //

    private int getNoticesXmlResourceId() {
        int resourceId = R.raw.notices;
        final Bundle arguments = getArguments();
        if (arguments != null && arguments.containsKey(ARGUMENT_NOTICES_XML_ID)) {
            resourceId = arguments.getInt(ARGUMENT_NOTICES_XML_ID);
            if (!"raw".equalsIgnoreCase(getResources().getResourceTypeName(resourceId))) {
                throw new IllegalStateException("not a raw resource");
            }
        }

        return resourceId;
    }
}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog;

import main.java.de.psdev.licensesdialog.licenses.License;
import main.java.de.psdev.licensesdialog.model.Notice;
import main.java.de.psdev.licensesdialog.model.Notices;
import android.content.Context;
import de.psdev.licensesdialog.R;

public final class NoticesHtmlBuilder {

    private final Context mContext;
    private Notices mNotices;
    private Notice mNotice;
    private String mStyle;
    private boolean mShowFullLicenseText;

    public static NoticesHtmlBuilder create(final Context context) {
        return new NoticesHtmlBuilder(context);
    }

    private NoticesHtmlBuilder(final Context context) {
        mContext = context;
        mStyle = context.getResources().getString(R.string.notices_default_style);
        mShowFullLicenseText = false;
    }

    public NoticesHtmlBuilder setNotices(final Notices notices) {
        mNotices = notices;
        mNotice = null;
        return this;
    }

    public NoticesHtmlBuilder setNotice(final Notice notice) {
        mNotice = notice;
        mNotices = null;
        return this;
    }

    public NoticesHtmlBuilder setStyle(final String style) {
        mStyle = style;
        return this;
    }

    public NoticesHtmlBuilder setShowFullLicenseText(final boolean showFullLicenseText) {
        mShowFullLicenseText = showFullLicenseText;
        return this;
    }

    public String build() {
        final StringBuilder noticesHtmlBuilder = new StringBuilder(500);
        appendNoticesContainerStart(noticesHtmlBuilder);
        if (mNotice != null) {
            appendNoticeBlock(noticesHtmlBuilder, mNotice);
        } else if (mNotices != null) {
            for (final Notice notice : mNotices.getNotices()) {
                appendNoticeBlock(noticesHtmlBuilder, notice);
            }
        } else {
            throw new IllegalStateException("no notice(s) set");
        }
        appendNoticesContainerEnd(noticesHtmlBuilder);
        return noticesHtmlBuilder.toString();
    }

    //

    private void appendNoticesContainerStart(final StringBuilder noticesHtmlBuilder) {
        noticesHtmlBuilder.append("<!DOCTYPE html><html><head>")
                .append("<style type=\"text/css\">").append(mStyle).append("</style>")
                .append("</head><body>");
    }

    private void appendNoticeBlock(final StringBuilder noticesHtmlBuilder, final Notice notice) {
        noticesHtmlBuilder.append("<ul><li>").append(notice.getName());
        final String currentNoticeUrl = notice.getUrl();
        if (currentNoticeUrl != null && currentNoticeUrl.length() > 0) {
            noticesHtmlBuilder.append(" (<a href=\"").append(currentNoticeUrl).append("\">").append(currentNoticeUrl).append("</a>)");
        }
        noticesHtmlBuilder.append("</li></ul>");
        noticesHtmlBuilder.append("<pre>");
        final String copyright = notice.getCopyright();
        if (copyright != null) {
            noticesHtmlBuilder.append(copyright).append("<br/><br/>");
        }
        noticesHtmlBuilder.append(getLicenseText(notice.getLicense())).append("</pre>");
    }

    private void appendNoticesContainerEnd(final StringBuilder noticesHtmlBuilder) {
        noticesHtmlBuilder.append("</body></html>");
    }

    private String getLicenseText(final License license) {
        if (license != null) {
            return mShowFullLicenseText ? license.getFullText(mContext) : license.getSummaryText(mContext);
        }
        return "";
    }
}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog;

import java.io.IOException;
import java.io.InputStream;

import main.java.de.psdev.licensesdialog.licenses.License;
import main.java.de.psdev.licensesdialog.model.Notice;
import main.java.de.psdev.licensesdialog.model.Notices;

import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;

import android.util.Xml;

public final class NoticesXmlParser {

    private NoticesXmlParser() {
    }

    public static Notices parse(final InputStream inputStream) throws Exception {
        try {
            final XmlPullParser parser = Xml.newPullParser();
            parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false);
            parser.setInput(inputStream, null);
            parser.nextTag();
            return parse(parser);
        } finally {
            inputStream.close();
        }
    }

    private static Notices parse(final XmlPullParser parser) throws IOException, XmlPullParserException {
        final Notices notices = new Notices();
        parser.require(XmlPullParser.START_TAG, null, "notices");
        while (parser.next() != XmlPullParser.END_TAG) {
            if (parser.getEventType() != XmlPullParser.START_TAG) {
                continue;
            }
            final String name = parser.getName();
            // Starts by looking for the entry tag
            if ("notice".equals(name)) {
                notices.addNotice(readNotice(parser));
            } else {
                skip(parser);
            }
        }
        return notices;
    }

    private static Notice readNotice(final XmlPullParser parser) throws IOException,
        XmlPullParserException {
        parser.require(XmlPullParser.START_TAG, null, "notice");
        String name = null;
        String url = null;
        String copyright = null;
        License license = null;
        while (parser.next() != XmlPullParser.END_TAG) {
            if (parser.getEventType() != XmlPullParser.START_TAG) {
                continue;
            }
            final String element = parser.getName();
            if ("name".equals(element)) {
                name = readName(parser);
            } else if ("url".equals(element)) {
                url = readUrl(parser);
            } else if ("copyright".equals(element)) {
                copyright = readCopyright(parser);
            } else if ("license".equals(element)) {
                license = readLicense(parser);
            } else {
                skip(parser);
            }
        }
        return new Notice(name, url, copyright, license);
    }

    private static String readName(final XmlPullParser parser) throws IOException, XmlPullParserException {
        return readTag(parser, "name");
    }

    private static String readUrl(final XmlPullParser parser) throws IOException, XmlPullParserException {
        return readTag(parser, "url");
    }

    private static String readCopyright(final XmlPullParser parser) throws IOException, XmlPullParserException {
        return readTag(parser, "copyright");
    }

    private static License readLicense(final XmlPullParser parser) throws IOException, XmlPullParserException {
        final String license = readTag(parser, "license");
        return LicenseResolver.read(license);
    }

    private static String readTag(final XmlPullParser parser, final String tag) throws IOException, XmlPullParserException {
        parser.require(XmlPullParser.START_TAG, null, tag);
        final String title = readText(parser);
        parser.require(XmlPullParser.END_TAG, null, tag);
        return title;
    }

    private static String readText(final XmlPullParser parser) throws IOException, XmlPullParserException {
        String result = "";
        if (parser.next() == XmlPullParser.TEXT) {
            result = parser.getText();
            parser.nextTag();
        }
        return result;
    }

    private static void skip(final XmlPullParser parser) {
    }
}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog;

import main.java.de.psdev.licensesdialog.model.Notice;
import android.content.Context;
import de.psdev.licensesdialog.R;

public class SingleLicenseDialog extends LicensesDialog {

    public SingleLicenseDialog(final Context context, final Notice notice, final boolean showFullLicenseText) {
        super(context, getTitleText(context), getLicenseText(context, notice, showFullLicenseText), getCloseText(context));
    }

    public SingleLicenseDialog(final Context context, final String titleText, final String licensesText, final String closeText) {
        super(context, titleText, licensesText, closeText);
    }

    private static String getTitleText(final Context context) {
        return context.getString(R.string.notices_title);
    }

    private static String getLicenseText(final Context context, final Notice notice, final boolean showFullLicenseText) {
        final String defaultStyle = context.getString(R.string.notices_default_style);
        return NoticesHtmlBuilder.create(context).setNotice(notice).setShowFullLicenseText(showFullLicenseText).setStyle(defaultStyle).build();
    }

    private static String getCloseText(final Context context) {
        return context.getString(R.string.notices_close);
    }


}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog;

import main.java.de.psdev.licensesdialog.model.Notice;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.os.Bundle;
import de.psdev.licensesdialog.R;

public class SingleLicenseDialogFragment extends DialogFragment {

    private static final String ARGUMENT_NOTICE = "ARGUMENT_NOTICE";
    private static final String STATE_LICENSE_TEXT = "license_text";
    private static final String STATE_TITLE_TEXT = "title_text";
    private static final String STATE_CLOSE_TEXT = "close_text";

    //
    private String mTitleText;
    private String mCloseButtonText;
    private String mLicenseText;

    //
    private boolean mShowFullLicenseText;
    private DialogInterface.OnDismissListener mOnDismissListener;

    public static SingleLicenseDialogFragment newInstance(final Notice notice) {
        final SingleLicenseDialogFragment fragment = new SingleLicenseDialogFragment();
        final Bundle args = new Bundle();
        args.putSerializable(ARGUMENT_NOTICE, notice);
        fragment.setArguments(args);
        return fragment;
    }

    public SingleLicenseDialogFragment() {
    }

    @Override
    public void onCreate(final Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        final Resources resources = getResources();

        if (savedInstanceState != null) {
            mTitleText = savedInstanceState.getString(STATE_TITLE_TEXT);
            mLicenseText = savedInstanceState.getString(STATE_LICENSE_TEXT);
            mCloseButtonText = savedInstanceState.getString(STATE_CLOSE_TEXT);
        } else {
            mTitleText = resources.getString(R.string.notices_title);
            mCloseButtonText = resources.getString(R.string.notices_close);

            try {
                final Notice notice = getNotice();
                mLicenseText = NoticesHtmlBuilder.create(getActivity()).setNotice(notice).build();
            } catch (final Exception e) {
                throw new IllegalStateException(e);
            }
        }
    }

    @Override
    public void onSaveInstanceState(final Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putString(STATE_TITLE_TEXT, mTitleText);
        outState.putString(STATE_LICENSE_TEXT, mLicenseText);
        outState.putString(STATE_CLOSE_TEXT, mCloseButtonText);
    }

    @Override
    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        return new SingleLicenseDialog(getActivity(), mTitleText, mLicenseText, mCloseButtonText).create();
    }

    @Override
    public void onDismiss(final DialogInterface dialog) {
        super.onDismiss(dialog);
        if (mOnDismissListener != null) {
            mOnDismissListener.onDismiss(dialog);
        }
    }

    //

    public DialogInterface.OnDismissListener getOnDismissListener() {
        return mOnDismissListener;
    }

    public void setOnDismissListener(final DialogInterface.OnDismissListener onDismissListener) {
        mOnDismissListener = onDismissListener;
    }

    public boolean isShowFullLicenseText() {
        return mShowFullLicenseText;
    }

    public void setShowFullLicenseText(final boolean showFullLicenseText) {
        mShowFullLicenseText = showFullLicenseText;
    }

    //

    private Notice getNotice() {
        final Bundle arguments = getArguments();
        if (arguments != null && arguments.containsKey(ARGUMENT_NOTICE)) {
            return (Notice) arguments.getSerializable(ARGUMENT_NOTICE);
        }

        throw new IllegalStateException("no notice provided");
    }
}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog.licenses;

import android.content.Context;
import de.psdev.licensesdialog.R;

public class ApacheSoftwareLicense20 extends License {

    private static final long serialVersionUID = 4854000061990891449L;

    @Override
    public String getName() {
        return "Apache Software License 2.0";
    }

    @Override
    public String getSummaryText(final Context context) {
        return getContent(context, R.raw.asl_20_summary);
    }

    @Override
    public String getFullText(final Context context) {
        return getContent(context, R.raw.asl_20_full);
    }

    @Override
    public String getVersion() {
        return "2.0";
    }

    @Override
    public String getUrl() {
        return "http://www.apache.org/licenses/LICENSE-2.0.txt";
    }


}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog.licenses;

import android.content.Context;
import de.psdev.licensesdialog.R;

public class BSD3ClauseLicense extends License {

    private static final long serialVersionUID = -5205394619884057474L;

    @Override
    public String getName() {
        return "BSD 3-Clause License";
    }

    @Override
    public String getSummaryText(final Context context) {
        return getContent(context, R.raw.bsd3_summary);
    }

    @Override
    public String getFullText(final Context context) {
        return getContent(context, R.raw.bsd3_full);
    }

    @Override
    public String getVersion() {
        return "";
    }

    @Override
    public String getUrl() {
        return "http://opensource.org/licenses/BSD-3-Clause";
    }

}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog.licenses;

import android.content.Context;
import de.psdev.licensesdialog.R;

public class GNULesserGeneralPublicLicense extends License {

    private static final long serialVersionUID = 4854000061990891449L;

    @Override
    public String getName() {
        return "GNU Lesser General Public License";
    }

    @Override
    public String getSummaryText(final Context context) {
        return getContent(context, R.raw.gnu_lesser_general_public_license);
    }

    @Override
    public String getFullText(final Context context) {
        return getContent(context, R.raw.gnu_lesser_general_public_license);
    }

    @Override
    public String getVersion() {
        return "3.0";
    }

    @Override
    public String getUrl() {
        return "http://www.gnu.org/copyleft/lesser.html";
    }


}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog.licenses;

import android.content.Context;
import de.psdev.licensesdialog.R;

public class ISCLicense extends License {
    private static final long serialVersionUID = -4636435634132169860L;

    @Override
    public String getName() {
        return "ISC License";
    }

    @Override
    public String getSummaryText(final Context context) {
        return getContent(context, R.raw.isc_summary);
    }

    @Override
    public String getFullText(final Context context) {
        return getContent(context, R.raw.isc_full);
    }

    @Override
    public String getVersion() {
        return "";
    }

    @Override
    public String getUrl() {
        return "http://opensource.org/licenses/isc-license.txt";
    }
}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog.licenses;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Serializable;
import java.util.logging.Logger;

import android.content.Context;

public abstract class License implements Serializable {

    private static final long serialVersionUID = 3100331505738956523L;

    public abstract String getName();

    public abstract String getSummaryText(final Context context);

    public abstract String getFullText(final Context context);

    public abstract String getVersion();

    public abstract String getUrl();

    //

    protected String getContent(final Context context, final int contentResourceId) {
        BufferedReader reader = null;
        try {
            final InputStream inputStream = context.getResources().openRawResource(contentResourceId);
            if (inputStream != null) {
                reader = new BufferedReader(new InputStreamReader(inputStream));
                return toString(reader);
            }
            throw new IOException("Error opening license file.");
        } catch (final IOException e) {
            return "";
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (final IOException e) {
                    // Don't care.
                }
            }
        }
    }

    private String toString(final BufferedReader reader) throws IOException {
        final StringBuilder builder = new StringBuilder();
        String line = null;
        while ((line = reader.readLine()) != null) {
            builder.append(line);
        }
        return builder.toString();
    }

}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog.licenses;

import android.content.Context;
import de.psdev.licensesdialog.R;

public class MITLicense extends License {

    private static final long serialVersionUID = 5673599951781482594L;

	@Override
	public String getName() {
		return "MIT License";
	}

    @Override
    public String getSummaryText(final Context context) {
        return getContent(context, R.raw.mit_summary);
    }

    @Override
    public String getFullText(final Context context) {
        return getContent(context, R.raw.mit_full);
    }

    @Override
    public String getVersion() {
        return "";
    }

    @Override
    public String getUrl() {
        return "http://opensource.org/licenses/MIT";
    }

}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog.model;

import java.io.Serializable;

import main.java.de.psdev.licensesdialog.licenses.License;

public class Notice implements Serializable {
    private static final long serialVersionUID = -6257913944601445939L;

    private String mName;
    private String mUrl;
    private String mCopyright;
    private License mLicense;

    //

    public Notice() {
    }

    public Notice(final String name, final String url, final String copyright, final License license) {
        mName = name;
        mUrl = url;
        mCopyright = copyright;
        mLicense = license;
    }

    // Setter / Getter

    public void setName(final String name) {
        mName = name;
    }

    public void setUrl(final String url) {
        mUrl = url;
    }

    public void setCopyright(final String copyright) {
        mCopyright = copyright;
    }

    public void setLicense(final License license) {
        mLicense = license;
    }

    public String getName() {
        return mName;
    }

    public String getUrl() {
        return mUrl;
    }

    public String getCopyright() {
        return mCopyright;
    }

    public License getLicense() {
        return mLicense;
    }
}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main.java.de.psdev.licensesdialog.model;

import java.util.ArrayList;
import java.util.List;

public class Notices {

    private final List<Notice> mNotices = new ArrayList<Notice>();

    // Setter / Getter

    public void addNotice(final Notice notice) {
        mNotices.add(notice);
    }

    public List<Notice> getNotices() {
        return mNotices;
    }
}

@#$
/*
 * Copyright 2013 Philip Schiffer
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 

package test.java.de.psdev.licensesdialog;

import main.java.de.psdev.licensesdialog.LicenseResolver;
import main.java.de.psdev.licensesdialog.licenses.License;
import android.content.Context;

public class LicenseResolverTest {

    public static final String TEST_LICENSE_NAME = "TestLicense";

    @Before
    public void setUp() throws Exception {
        LicenseResolver.registerDefaultLicenses();
    }

    @Test
    public void testRegisterLicense() throws Exception {
        LicenseResolver.registerLicense(new TestLicense());
        final License license = LicenseResolver.read(TEST_LICENSE_NAME);
        assertNotNull(license);
        assertEquals(TEST_LICENSE_NAME, license.getName());
    }

    @Test(expected = IllegalStateException.class)
    public void testReadUnknownLicense() throws Exception {
        LicenseResolver.read(TEST_LICENSE_NAME);
    }

    @Test
    public void testReadKnownLicense() throws Exception {
        final License license = LicenseResolver.read("MIT License");
        assertNotNull(license);
        assertEquals("MIT License", license.getName());
    }

    // Inner classes

    private static class TestLicense extends License {

        @Override
        public String getName() {
            return TEST_LICENSE_NAME;
        }

        @Override
        public String getSummaryText(final Context context) {
            return "Testing license";
        }

        @Override
        public String getFullText(final Context context) {
            return "Full testing license";
        }

        @Override
        public String getVersion() {
            return "1.0";
        }

        @Override
        public String getUrl() {
            return "http://example.org";
        }
    }
}
*/
@#$
package test.java.de.psdev.licensesdialog;

import java.io.InputStream;

import main.java.de.psdev.licensesdialog.NoticesXmlParser;
import main.java.de.psdev.licensesdialog.model.Notices;


public class NoticesXmlParserTest {

    public void testParse() throws Exception {
        final InputStream noticesXmlStream = getClass().getResourceAsStream("notices.xml");
        final Notices parse = NoticesXmlParser.parse(noticesXmlStream);
    }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;

abstract class Action<T> {
  static class RequestWeakReference<T> extends WeakReference<T> {
    final Action action;

    public RequestWeakReference(Action action, T referent, ReferenceQueue<? super T> q) {
      super(referent, q);
      this.action = action;
    }
  }

  final Picasso picasso;
  final Request request;
  final WeakReference<T> target;
  final boolean skipCache;
  final boolean noFade;
  final int errorResId;
  final Drawable errorDrawable;
  final String key;

  boolean willReplay;
  boolean cancelled;

  Action(Picasso picasso, T target, Request request, boolean skipCache, boolean noFade,
      int errorResId, Drawable errorDrawable, String key) {
    this.picasso = picasso;
    this.request = request;
    this.target = new RequestWeakReference<T>(this, target, picasso.referenceQueue);
    this.skipCache = skipCache;
    this.noFade = noFade;
    this.errorResId = errorResId;
    this.errorDrawable = errorDrawable;
    this.key = key;
  }

  abstract void complete(Bitmap result, Picasso.LoadedFrom from);

  abstract void error();

  void cancel() {
    cancelled = true;
  }

  Request getRequest() {
    return request;
  }

  T getTarget() {
    return target.get();
  }

  String getKey() {
    return key;
  }

  boolean isCancelled() {
    return cancelled;
  }

  boolean willReplay() {
    return willReplay;
  }

  Picasso getPicasso() {
    return picasso;
  }
}

@#$
package com.squareup.picasso;

import android.content.Context;
import android.content.res.AssetManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import java.io.IOException;
import java.io.InputStream;

import static android.content.ContentResolver.SCHEME_FILE;
import static com.squareup.picasso.Picasso.LoadedFrom.DISK;

class AssetBitmapHunter extends BitmapHunter {
  protected static final String ANDROID_ASSET = "android_asset";
  private static final int ASSET_PREFIX_LENGTH =
      (SCHEME_FILE + ":///" + ANDROID_ASSET + "/").length();

  private final AssetManager assetManager;

  public AssetBitmapHunter(Context context, Picasso picasso, Dispatcher dispatcher, Cache cache,
      Stats stats, Action action) {
    super(picasso, dispatcher, cache, stats, action);
    assetManager = context.getAssets();
  }

  @Override Bitmap decode(Request data) throws IOException {
    String filePath = data.uri.toString().substring(ASSET_PREFIX_LENGTH);
    return decodeAsset(filePath);
  }

  @Override Picasso.LoadedFrom getLoadedFrom() {
    return DISK;
  }

  Bitmap decodeAsset(String filePath) throws IOException {
    final BitmapFactory.Options options = createBitmapOptions(data);
    if (requiresInSampleSize(options)) {
      InputStream is = null;
      try {
        is = assetManager.open(filePath);
        BitmapFactory.decodeStream(is, null, options);
      } finally {
        Utils.closeQuietly(is);
      }
      calculateInSampleSize(data.targetWidth, data.targetHeight, options);
    }
    InputStream is = assetManager.open(filePath);
    try {
      return BitmapFactory.decodeStream(is, null, options);
    } finally {
      Utils.closeQuietly(is);
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.net.NetworkInfo;
import android.net.Uri;
import android.provider.MediaStore;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Future;

import static android.content.ContentResolver.SCHEME_ANDROID_RESOURCE;
import static android.content.ContentResolver.SCHEME_CONTENT;
import static android.content.ContentResolver.SCHEME_FILE;
import static android.provider.ContactsContract.Contacts;
import static com.squareup.picasso.AssetBitmapHunter.ANDROID_ASSET;
import static com.squareup.picasso.Picasso.LoadedFrom.MEMORY;
import static com.squareup.picasso.Utils.OWNER_HUNTER;
import static com.squareup.picasso.Utils.VERB_DECODED;
import static com.squareup.picasso.Utils.VERB_EXECUTING;
import static com.squareup.picasso.Utils.VERB_JOINED;
import static com.squareup.picasso.Utils.VERB_REMOVED;
import static com.squareup.picasso.Utils.VERB_TRANSFORMED;
import static com.squareup.picasso.Utils.getLogIdsForHunter;
import static com.squareup.picasso.Utils.log;

abstract class BitmapHunter implements Runnable {

  /**
   * Global lock for bitmap decoding to ensure that we are only are decoding one at a time. Since
   * this will only ever happen in background threads we help avoid excessive memory thrashing as
   * well as potential OOMs. Shamelessly stolen from Volley.
   */
  private static final Object DECODE_LOCK = new Object();

  private static final ThreadLocal<StringBuilder> NAME_BUILDER = new ThreadLocal<StringBuilder>() {
    @Override protected StringBuilder initialValue() {
      return new StringBuilder(Utils.THREAD_PREFIX);
    }
  };

  final Picasso picasso;
  final Dispatcher dispatcher;
  final Cache cache;
  final Stats stats;
  final String key;
  final Request data;
  final boolean skipMemoryCache;

  Action action;
  List<Action> actions;
  Bitmap result;
  Future<?> future;
  Picasso.LoadedFrom loadedFrom;
  Exception exception;
  int exifRotation; // Determined during decoding of original resource.

  BitmapHunter(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats, Action action) {
    this.picasso = picasso;
    this.dispatcher = dispatcher;
    this.cache = cache;
    this.stats = stats;
    this.key = action.getKey();
    this.data = action.getRequest();
    this.skipMemoryCache = action.skipCache;
    this.action = action;
  }

  protected void setExifRotation(int exifRotation) {
    this.exifRotation = exifRotation;
  }

  @Override public void run() {
    try {
      updateThreadName(data);

      if (picasso.loggingEnabled) {
        log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this));
      }

      result = hunt();

      if (result == null) {
        dispatcher.dispatchFailed(this);
      } else {
        dispatcher.dispatchComplete(this);
      }
    } catch (Downloader.ResponseException e) {
      exception = e;
      dispatcher.dispatchFailed(this);
    } catch (IOException e) {
      exception = e;
      dispatcher.dispatchRetry(this);
    } catch (OutOfMemoryError e) {
      StringWriter writer = new StringWriter();
      stats.createSnapshot().dump(new PrintWriter(writer));
      exception = new RuntimeException(writer.toString(), e);
      dispatcher.dispatchFailed(this);
    } catch (Exception e) {
      exception = e;
      dispatcher.dispatchFailed(this);
    } finally {
      Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);
    }
  }

  abstract Bitmap decode(Request data) throws IOException;

  Bitmap hunt() throws IOException {
    Bitmap bitmap;

    if (!skipMemoryCache) {
      bitmap = cache.get(key);
      if (bitmap != null) {
        stats.dispatchCacheHit();
        loadedFrom = MEMORY;
        if (picasso.loggingEnabled) {
          log(OWNER_HUNTER, VERB_DECODED, data.logId(), "from cache");
        }
        return bitmap;
      }
    }

    bitmap = decode(data);

    if (bitmap != null) {
      if (picasso.loggingEnabled) {
        log(OWNER_HUNTER, VERB_DECODED, data.logId());
      }
      stats.dispatchBitmapDecoded(bitmap);
      if (data.needsTransformation() || exifRotation != 0) {
        synchronized (DECODE_LOCK) {
          if (data.needsMatrixTransform() || exifRotation != 0) {
            bitmap = transformResult(data, bitmap, exifRotation);
            if (picasso.loggingEnabled) {
              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());
            }
          }
          if (data.hasCustomTransformations()) {
            bitmap = applyCustomTransformations(data.transformations, bitmap);
            if (picasso.loggingEnabled) {
              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), "from custom transformations");
            }
          }
        }
        if (bitmap != null) {
          stats.dispatchBitmapTransformed(bitmap);
        }
      }
    }

    return bitmap;
  }

  void attach(Action action) {
    boolean loggingEnabled = picasso.loggingEnabled;
    Request request = action.request;

    if (this.action == null) {
      this.action = action;
      if (loggingEnabled) {
        if (actions == null || actions.isEmpty()) {
          log(OWNER_HUNTER, VERB_JOINED, request.logId(), "to empty hunter");
        } else {
          log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, "to "));
        }
      }
      return;
    }

    if (actions == null) {
      actions = new ArrayList<Action>(3);
    }

    actions.add(action);

    if (loggingEnabled) {
      log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, "to "));
    }
  }

  void detach(Action action) {
    if (this.action == action) {
      this.action = null;
    } else if (actions != null) {
      actions.remove(action);
    }

    if (picasso.loggingEnabled) {
      log(OWNER_HUNTER, VERB_REMOVED, action.request.logId(), getLogIdsForHunter(this, "from "));
    }
  }

  boolean cancel() {
    return action == null
        && (actions == null || actions.isEmpty())
        && future != null
        && future.cancel(false);
  }

  boolean isCancelled() {
    return future != null && future.isCancelled();
  }

  boolean shouldSkipMemoryCache() {
    return skipMemoryCache;
  }

  boolean shouldRetry(boolean airplaneMode, NetworkInfo info) {
    return false;
  }

  boolean supportsReplay() {
    return false;
  }

  Bitmap getResult() {
    return result;
  }

  String getKey() {
    return key;
  }

  Request getData() {
    return data;
  }

  Action getAction() {
    return action;
  }

  Picasso getPicasso() {
    return picasso;
  }

  List<Action> getActions() {
    return actions;
  }

  Exception getException() {
    return exception;
  }

  Picasso.LoadedFrom getLoadedFrom() {
    return loadedFrom;
  }

  static void updateThreadName(Request data) {
    String name = data.getName();

    StringBuilder builder = NAME_BUILDER.get();
    builder.ensureCapacity(Utils.THREAD_PREFIX.length() + name.length());
    builder.replace(Utils.THREAD_PREFIX.length(), builder.length(), name);

    Thread.currentThread().setName(builder.toString());
  }

  static BitmapHunter forRequest(Context context, Picasso picasso, Dispatcher dispatcher,
      Cache cache, Stats stats, Action action, Downloader downloader) {
      if (action.getRequest().resourceId != 0) {
          return new ResourceBitmapHunter(context, picasso, dispatcher, cache, stats, action);
      }
      Uri uri = action.getRequest().uri;
      String scheme = uri.getScheme();
    if (("byte").equals(scheme)) {
      return new ByteStreamBitmapHunter(context, picasso, dispatcher, cache, stats, action);
    } else if (SCHEME_FILE.equals(scheme)) {
        if (!uri.getPathSegments().isEmpty() && ANDROID_ASSET.equals(uri.getPathSegments().get(0))) {
            return new AssetBitmapHunter(context, picasso, dispatcher, cache, stats, action);
        }
        return new FileBitmapHunter(context, picasso, dispatcher, cache, stats, action);
    } else if (SCHEME_CONTENT.equals(scheme)) {
      if (Contacts.CONTENT_URI.getHost().equals(uri.getHost()) //
          && !uri.getPathSegments().contains(Contacts.Photo.CONTENT_DIRECTORY)) {
        return new ContactsPhotoBitmapHunter(context, picasso, dispatcher, cache, stats, action);
      } else if (MediaStore.AUTHORITY.equals(uri.getAuthority())) {
        return new MediaStoreBitmapHunter(context, picasso, dispatcher, cache, stats, action);
      } else {
        return new ContentStreamBitmapHunter(context, picasso, dispatcher, cache, stats, action);
      }
    } else if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
      return new ResourceBitmapHunter(context, picasso, dispatcher, cache, stats, action);
    } else {
      return new NetworkBitmapHunter(picasso, dispatcher, cache, stats, action, downloader);
    }
  }

  /**
   * Lazily create {@link android.graphics.BitmapFactory.Options} based in given
   * {@link com.squareup.picasso.Request}, only instantiating them if needed.
   */
  static BitmapFactory.Options createBitmapOptions(Request data) {
    final boolean justBounds = data.hasSize();
    final boolean hasConfig = data.config != null;
    BitmapFactory.Options options = null;
    if (justBounds || hasConfig) {
      options = new BitmapFactory.Options();
      options.inJustDecodeBounds = justBounds;
      if (hasConfig) {
        options.inPreferredConfig = data.config;
      }
    }
    return options;
  }

  static boolean requiresInSampleSize(BitmapFactory.Options options) {
    return options != null && options.inJustDecodeBounds;
  }

  static void calculateInSampleSize(int reqWidth, int reqHeight, BitmapFactory.Options options) {
    calculateInSampleSize(reqWidth, reqHeight, options.outWidth, options.outHeight, options);
  }

  static void calculateInSampleSize(int reqWidth, int reqHeight, int width, int height,
      BitmapFactory.Options options) {
    int sampleSize = 1;
    if (height > reqHeight || width > reqWidth) {
      final int heightRatio = Math.round((float) height / (float) reqHeight);
      final int widthRatio = Math.round((float) width / (float) reqWidth);
      sampleSize = heightRatio < widthRatio ? heightRatio : widthRatio;
    }
    options.inSampleSize = sampleSize;
    options.inJustDecodeBounds = false;
  }

  static Bitmap applyCustomTransformations(List<Transformation> transformations, Bitmap result) {
    for (int i = 0, count = transformations.size(); i < count; i++) {
      final Transformation transformation = transformations.get(i);
      Bitmap newResult = transformation.transform(result);

      if (newResult == null) {
        final StringBuilder builder = new StringBuilder() //
            .append("Transformation ")
            .append(transformation.key())
            .append(" returned null after ")
            .append(i)
            .append(" previous transformation(s).\n\nTransformation list:\n");
        for (Transformation t : transformations) {
          builder.append(t.key()).append('\n');
        }
        Picasso.HANDLER.post(new Runnable() {
          @Override public void run() {
            throw new NullPointerException(builder.toString());
          }
        });
        return null;
      }

      if (newResult == result && result.isRecycled()) {
        Picasso.HANDLER.post(new Runnable() {
          @Override public void run() {
            throw new IllegalStateException("Transformation "
                + transformation.key()
                + " returned input Bitmap but recycled it.");
          }
        });
        return null;
      }

      // If the transformation returned a new bitmap ensure they recycled the original.
      if (newResult != result && !result.isRecycled()) {
        Picasso.HANDLER.post(new Runnable() {
          @Override public void run() {
            throw new IllegalStateException("Transformation "
                + transformation.key()
                + " mutated input Bitmap but failed to recycle the original.");
          }
        });
        return null;
      }

      result = newResult;
    }
    return result;
  }

  static Bitmap transformResult(Request data, Bitmap result, int exifRotation) {
    int inWidth = result.getWidth();
    int inHeight = result.getHeight();

    int drawX = 0;
    int drawY = 0;
    int drawWidth = inWidth;
    int drawHeight = inHeight;

    Matrix matrix = new Matrix();

    if (data.needsMatrixTransform()) {
      int targetWidth = data.targetWidth;
      int targetHeight = data.targetHeight;

      float targetRotation = data.rotationDegrees;
      if (targetRotation != 0) {
        if (data.hasRotationPivot) {
          matrix.setRotate(targetRotation, data.rotationPivotX, data.rotationPivotY);
        } else {
          matrix.setRotate(targetRotation);
        }
      }

      if (data.centerCrop) {
        float widthRatio = targetWidth / (float) inWidth;
        float heightRatio = targetHeight / (float) inHeight;
        float scale;
        if (widthRatio > heightRatio) {
          scale = widthRatio;
          int newSize = (int) Math.ceil(inHeight * (heightRatio / widthRatio));
          drawY = (inHeight - newSize) / 2;
          drawHeight = newSize;
        } else {
          scale = heightRatio;
          int newSize = (int) Math.ceil(inWidth * (widthRatio / heightRatio));
          drawX = (inWidth - newSize) / 2;
          drawWidth = newSize;
        }
        matrix.preScale(scale, scale);
      } else if (data.centerInside) {
        float widthRatio = targetWidth / (float) inWidth;
        float heightRatio = targetHeight / (float) inHeight;
        float scale = widthRatio < heightRatio ? widthRatio : heightRatio;
        matrix.preScale(scale, scale);
      } else if (targetWidth != 0 && targetHeight != 0 //
          && (targetWidth != inWidth || targetHeight != inHeight)) {
        // If an explicit target size has been specified and they do not match the results bounds,
        // pre-scale the existing matrix appropriately.
        float sx = targetWidth / (float) inWidth;
        float sy = targetHeight / (float) inHeight;
        matrix.preScale(sx, sy);
      }
    }

    if (exifRotation != 0) {
      matrix.preRotate(exifRotation);
    }

    Bitmap newResult =
        Bitmap.createBitmap(result, drawX, drawY, drawWidth, drawHeight, matrix, true);
    if (newResult != result) {
      result.recycle();
      result = newResult;
    }

    return result;
  }
}

@#$
package com.squareup.picasso;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.media.MediaMetadataRetriever;

import java.io.ByteArrayInputStream;
import java.io.IOException;

import static com.squareup.picasso.Picasso.LoadedFrom.DISK;

class ByteStreamBitmapHunter extends BitmapHunter {
  protected static final String SCHEME_BYTE = "byte";
  private static final int BYTE_PREFIX_LENGTH =
      (SCHEME_BYTE + "://").length();

  public ByteStreamBitmapHunter(Context context, Picasso picasso, Dispatcher dispatcher, Cache cache,
                                Stats stats, Action action) {
    super(picasso, dispatcher, cache, stats, action);
  }

  @Override Bitmap decode(Request data) throws IOException {
    String filePath = data.uri.toString().substring(BYTE_PREFIX_LENGTH);
    Bitmap bitmap = null;
    try {
        bitmap = decodeAsset(filePath);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return bitmap;
  }

  @Override Picasso.LoadedFrom getLoadedFrom() {
    return DISK;
  }

  Bitmap decodeAsset(String filePath) throws IOException {
    final BitmapFactory.Options options = createBitmapOptions(data);
    byte[] imageData = null;
    if (requiresInSampleSize(options)) {
        calculateInSampleSize(data.targetWidth, data.targetHeight, options);
    }

    try {
        MediaMetadataRetriever mmdr = new MediaMetadataRetriever();
        mmdr.setDataSource(filePath);
        imageData = mmdr.getEmbeddedPicture();
    } catch (Exception e) {
        return null;
    }

    ByteArrayInputStream is = new ByteArrayInputStream(imageData);
    try {
      return BitmapFactory.decodeStream(is, null, options);
    } finally {
      Utils.closeQuietly(is);
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.graphics.Bitmap;

/**
 * A memory cache for storing the most recently used images.
 * <p>
 * <em>Note:</em> The {@link Cache} is accessed by multiple threads. You must ensure
 * your {@link Cache} implementation is thread safe when {@link Cache#get(String)} or {@link
 * Cache#set(String, android.graphics.Bitmap)} is called.
 */
public interface Cache {
  /** Retrieve an image for the specified {@code key} or {@code null}. */
  Bitmap get(String key);

  /** Store an image in the cache for the specified {@code key}. */
  void set(String key, Bitmap bitmap);

  /** Returns the current size of the cache in bytes. */
  int size();

  /** Returns the maximum size in bytes that the cache can hold. */
  int maxSize();

  /** Clears the cache. */
  void clear();

  /** A cache which does not store any values. */
  Cache NONE = new Cache() {
    @Override public Bitmap get(String key) {
      return null;
    }

    @Override public void set(String key, Bitmap bitmap) {
      // Ignore.
    }

    @Override public int size() {
      return 0;
    }

    @Override public int maxSize() {
      return 0;
    }

    @Override public void clear() {
    }
  };
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

public interface Callback {
  void onSuccess();

  void onError();

  public static class EmptyCallback implements Callback {

    @Override public void onSuccess() {
    }

    @Override public void onError() {
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.annotation.TargetApi;
import android.content.ContentResolver;
import android.content.Context;
import android.content.UriMatcher;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.provider.ContactsContract;

import java.io.IOException;
import java.io.InputStream;

import static android.os.Build.VERSION.SDK_INT;
import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
import static android.provider.ContactsContract.Contacts.openContactPhotoInputStream;
import static com.squareup.picasso.Picasso.LoadedFrom.DISK;

class ContactsPhotoBitmapHunter extends BitmapHunter {
  /** A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537) */
  private static final int ID_LOOKUP = 1;
  /** A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo) */
  private static final int ID_THUMBNAIL = 2;
  /** A contact uri (e.g. content://com.android.contacts/contacts/38) */
  private static final int ID_CONTACT = 3;
  /**
   * A contact display photo (high resolution) uri
   * (e.g. content://com.android.contacts/display_photo/5)
   */
  private static final int ID_DISPLAY_PHOTO = 4;

  private static final UriMatcher matcher;

  static {
    matcher = new UriMatcher(UriMatcher.NO_MATCH);
    matcher.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_LOOKUP);
    matcher.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_LOOKUP);
    matcher.addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_THUMBNAIL);
    matcher.addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACT);
    matcher.addURI(ContactsContract.AUTHORITY, "display_photo/#", ID_DISPLAY_PHOTO);
  }

  final Context context;

  ContactsPhotoBitmapHunter(Context context, Picasso picasso, Dispatcher dispatcher, Cache cache,
      Stats stats, Action action) {
    super(picasso, dispatcher, cache, stats, action);
    this.context = context;
  }

  @Override Bitmap decode(Request data) throws IOException {
    InputStream is = null;
    try {
      is = getInputStream();
      return decodeStream(is, data);
    } finally {
      Utils.closeQuietly(is);
    }
  }

  @Override Picasso.LoadedFrom getLoadedFrom() {
    return DISK;
  }

  private InputStream getInputStream() throws IOException {
    ContentResolver contentResolver = context.getContentResolver();
    Uri uri = getData().uri;
    switch (matcher.match(uri)) {
      case ID_LOOKUP:
        uri = ContactsContract.Contacts.lookupContact(contentResolver, uri);
        if (uri == null) {
          return null;
        }
        // Resolved the uri to a contact uri, intentionally fall through to process the resolved uri
      case ID_CONTACT:
        if (SDK_INT < ICE_CREAM_SANDWICH) {
          return openContactPhotoInputStream(contentResolver, uri);
        } else {
          return ContactPhotoStreamIcs.get(contentResolver, uri);
        }
      case ID_THUMBNAIL:
      case ID_DISPLAY_PHOTO:
        return contentResolver.openInputStream(uri);
      default:
        throw new IllegalStateException("Invalid uri: " + uri);
    }
  }

  private Bitmap decodeStream(InputStream stream, Request data) throws IOException {
    if (stream == null) {
      return null;
    }
    final BitmapFactory.Options options = createBitmapOptions(data);
    if (requiresInSampleSize(options)) {
      InputStream is = getInputStream();
      try {
        BitmapFactory.decodeStream(is, null, options);
      } finally {
        Utils.closeQuietly(is);
      }
      calculateInSampleSize(data.targetWidth, data.targetHeight, options);
    }
    return BitmapFactory.decodeStream(stream, null, options);
  }

  @TargetApi(ICE_CREAM_SANDWICH)
  private static class ContactPhotoStreamIcs {
    static InputStream get(ContentResolver contentResolver, Uri uri) {
      return openContactPhotoInputStream(contentResolver, uri, true);
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.content.ContentResolver;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import java.io.IOException;
import java.io.InputStream;

import static com.squareup.picasso.Picasso.LoadedFrom.DISK;

class ContentStreamBitmapHunter extends BitmapHunter {
  final Context context;

  ContentStreamBitmapHunter(Context context, Picasso picasso, Dispatcher dispatcher, Cache cache,
      Stats stats, Action action) {
    super(picasso, dispatcher, cache, stats, action);
    this.context = context;
  }

  @Override Bitmap decode(Request data)
      throws IOException {
    return decodeContentStream(data);
  }

  @Override Picasso.LoadedFrom getLoadedFrom() {
    return DISK;
  }

  protected Bitmap decodeContentStream(Request data) throws IOException {
    ContentResolver contentResolver = context.getContentResolver();
    final BitmapFactory.Options options = createBitmapOptions(data);
    if (requiresInSampleSize(options)) {
      InputStream is = null;
      try {
        is = contentResolver.openInputStream(data.uri);
        BitmapFactory.decodeStream(is, null, options);
      } finally {
        Utils.closeQuietly(is);
      }
      calculateInSampleSize(data.targetWidth, data.targetHeight, options);
    }
    InputStream is = contentResolver.openInputStream(data.uri);
    try {
      return BitmapFactory.decodeStream(is, null, options);
    } finally {
      Utils.closeQuietly(is);
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.view.ViewTreeObserver;
import android.widget.ImageView;
import java.lang.ref.WeakReference;
import org.jetbrains.annotations.TestOnly;

class DeferredRequestCreator implements ViewTreeObserver.OnPreDrawListener {

  final RequestCreator creator;
  final WeakReference<ImageView> target;
  Callback callback;

  @TestOnly DeferredRequestCreator(RequestCreator creator, ImageView target) {
    this(creator, target, null);
  }

  DeferredRequestCreator(RequestCreator creator, ImageView target, Callback callback) {
    this.creator = creator;
    this.target = new WeakReference<ImageView>(target);
    this.callback = callback;
    target.getViewTreeObserver().addOnPreDrawListener(this);
  }

  @Override public boolean onPreDraw() {
    ImageView target = this.target.get();
    if (target == null) {
      return true;
    }
    ViewTreeObserver vto = target.getViewTreeObserver();
    if (!vto.isAlive()) {
      return true;
    }

    int width = target.getMeasuredWidth();
    int height = target.getMeasuredHeight();

    if (width <= 0 || height <= 0) {
      return true;
    }

    vto.removeOnPreDrawListener(this);

    this.creator.unfit().resize(width, height).into(target, callback);
    return true;
  }

  void cancel() {
    callback = null;
    ImageView target = this.target.get();
    if (target == null) {
      return;
    }
    ViewTreeObserver vto = target.getViewTreeObserver();
    if (!vto.isAlive()) {
      return;
    }
    vto.removeOnPreDrawListener(this);
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.Manifest;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Message;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;

import static android.content.Context.CONNECTIVITY_SERVICE;
import static android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED;
import static android.net.ConnectivityManager.CONNECTIVITY_ACTION;
import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
import static com.squareup.picasso.BitmapHunter.forRequest;
import static com.squareup.picasso.Utils.OWNER_DISPATCHER;
import static com.squareup.picasso.Utils.VERB_BATCHED;
import static com.squareup.picasso.Utils.VERB_CANCELED;
import static com.squareup.picasso.Utils.VERB_DELIVERED;
import static com.squareup.picasso.Utils.VERB_ENQUEUED;
import static com.squareup.picasso.Utils.VERB_IGNORED;
import static com.squareup.picasso.Utils.VERB_REPLAYING;
import static com.squareup.picasso.Utils.VERB_RETRYING;
import static com.squareup.picasso.Utils.getLogIdsForHunter;
import static com.squareup.picasso.Utils.getService;
import static com.squareup.picasso.Utils.hasPermission;
import static com.squareup.picasso.Utils.log;

class Dispatcher {
  static final int REQUEST_SUBMIT = 1;
  static final int REQUEST_CANCEL = 2;
  static final int REQUEST_GCED = 3;
  static final int HUNTER_COMPLETE = 4;
  static final int HUNTER_RETRY = 5;
  static final int HUNTER_DECODE_FAILED = 6;
  static final int HUNTER_DELAY_NEXT_BATCH = 7;
  static final int HUNTER_BATCH_COMPLETE = 8;
  static final int NETWORK_STATE_CHANGE = 9;
  static final int AIRPLANE_MODE_CHANGE = 10;
  private static final int RETRY_DELAY = 500;
  private static final int AIRPLANE_MODE_ON = 1;
  private static final int AIRPLANE_MODE_OFF = 0;
  private static final String DISPATCHER_THREAD_NAME = "Dispatcher";
  private static final int BATCH_DELAY = 200; // ms

  final DispatcherThread dispatcherThread;
  final Context context;
  final ExecutorService service;
  final Downloader downloader;
  final Map<String, BitmapHunter> hunterMap;
  final Map<Object, Action> failedActions;
  final Handler handler;
  final Handler mainThreadHandler;
  final Cache cache;
  final Stats stats;
  final List<BitmapHunter> batch;
  final NetworkBroadcastReceiver receiver;
  final boolean scansNetworkChanges;
  final DispatchingQueue dispatchingQueue;

  boolean airplaneMode;

  Dispatcher(Context context, ExecutorService service, Handler mainThreadHandler,
      Downloader downloader, Cache cache, Stats stats) {
    this.dispatcherThread = new DispatcherThread();
    this.dispatcherThread.start();
    this.context = context;
    this.service = service;
    this.hunterMap = new LinkedHashMap<String, BitmapHunter>();
    this.failedActions = new WeakHashMap<Object, Action>();
    this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this);
    this.dispatchingQueue = new DispatchingQueue(handler);
    this.downloader = downloader;
    this.mainThreadHandler = mainThreadHandler;
    this.cache = cache;
    this.stats = stats;
    this.batch = new ArrayList<BitmapHunter>(4);
    this.airplaneMode = Utils.isAirplaneModeOn(this.context);
    this.scansNetworkChanges = hasPermission(context, Manifest.permission.ACCESS_NETWORK_STATE);
    this.receiver = new NetworkBroadcastReceiver(this);
    receiver.register();
  }

  void shutdown() {
    service.shutdown();
    dispatcherThread.quit();
    receiver.unregister();
    dispatchingQueue.clear();
  }

  void dispatchSubmit(Action action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));
  }

  void dispatchCancel(Action action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action));
  }

  void dispatchComplete(BitmapHunter hunter) {
    dispatchingQueue.dispatchComplete(hunter);
  }

  void dispatchRetry(BitmapHunter hunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY);
  }

  void dispatchFailed(BitmapHunter hunter) {
    dispatchingQueue.dispatchComplete(hunter);
  }

  void dispatchNetworkStateChange(NetworkInfo info) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info));
  }

  void dispatchAirplaneModeChange(boolean airplaneMode) {
    handler.sendMessage(handler.obtainMessage(AIRPLANE_MODE_CHANGE,
        airplaneMode ? AIRPLANE_MODE_ON : AIRPLANE_MODE_OFF, 0));
  }

  void performSubmit(Action action) {
    BitmapHunter hunter = hunterMap.get(action.getKey());
    if (hunter != null) {
      hunter.attach(action);
      return;
    }

    if (service.isShutdown()) {
      if (action.getPicasso().loggingEnabled) {
        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), "because shut down");
      }
      return;
    }

    hunter = forRequest(context, action.getPicasso(), this, cache, stats, action, downloader);
    hunter.future = service.submit(hunter);
    hunterMap.put(action.getKey(), hunter);
    failedActions.remove(action.getTarget());

    if (action.getPicasso().loggingEnabled) {
      log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());
    }
  }

  void performCancel(Action action) {
    String key = action.getKey();
    BitmapHunter hunter = hunterMap.get(key);
    if (hunter != null) {
      hunter.detach(action);
      if (hunter.cancel()) {
        hunterMap.remove(key);
        dispatchingQueue.dequeue(hunter);
        if (action.getPicasso().loggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.getRequest().logId());
        }
      }
    }
    Action remove = failedActions.remove(action.getTarget());
    if (remove != null && remove.getPicasso().loggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.getRequest().logId(), "from replaying");
    }
  }

  void performRetry(BitmapHunter hunter) {
    if (hunter.isCancelled()) return;

    if (service.isShutdown()) {
      performError(hunter, false);
      return;
    }

    NetworkInfo networkInfo = null;
    if (scansNetworkChanges) {
      ConnectivityManager connectivityManager = getService(context, CONNECTIVITY_SERVICE);
      networkInfo = connectivityManager.getActiveNetworkInfo();
    }

    boolean hasConnectivity = networkInfo != null && networkInfo.isConnected();
    boolean shouldRetryHunter = hunter.shouldRetry(airplaneMode, networkInfo);
    boolean supportsReplay = hunter.supportsReplay();

    if (!shouldRetryHunter) {
      // Mark for replay only if we observe network info changes and support replay.
      boolean willReplay = scansNetworkChanges && supportsReplay;
      performError(hunter, willReplay);
      if (willReplay) {
        markForReplay(hunter);
      }
      return;
    }

    // If we don't scan for network changes (missing permission) or if we have connectivity, retry.
    if (!scansNetworkChanges || hasConnectivity) {
      if (hunter.getPicasso().loggingEnabled) {
        log(OWNER_DISPATCHER, VERB_RETRYING, getLogIdsForHunter(hunter));
      }
      hunter.future = service.submit(hunter);
      return;
    }

    performError(hunter, supportsReplay);

    if (supportsReplay) {
      markForReplay(hunter);
    }
  }

  void performComplete(BitmapHunter hunter) {
    if (hunter.getResult() == null) {
      performError(hunter, false);
      return;
    }

    if (!hunter.shouldSkipMemoryCache()) {
      cache.set(hunter.getKey(), hunter.getResult());
    }
    hunterMap.remove(hunter.getKey());
    batch(hunter);
    if (hunter.getPicasso().loggingEnabled) {
      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), "for completion");
    }
  }

  void performBatchComplete() {
    List<BitmapHunter> copy = new ArrayList<BitmapHunter>(batch);
    batch.clear();
    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));
    logBatch(copy);
  }

  void performError(BitmapHunter hunter, boolean willReplay) {
    if (hunter.getPicasso().loggingEnabled) {
      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter),
          "for error" + (willReplay ? " (will replay)" : ""));
    }
    hunterMap.remove(hunter.getKey());
    batch(hunter);
  }

  void performAirplaneModeChange(boolean airplaneMode) {
    this.airplaneMode = airplaneMode;
  }

  void performNetworkStateChange(NetworkInfo info) {
    if (service instanceof PicassoExecutorService) {
      ((PicassoExecutorService) service).adjustThreadCount(info);
    }
    // Intentionally check only if isConnected() here before we flush out failed actions.
    if (info != null && info.isConnected()) {
      flushFailedActions();
    }
  }

  private void flushFailedActions() {
    if (!failedActions.isEmpty()) {
      Iterator<Action> iterator = failedActions.values().iterator();
      while (iterator.hasNext()) {
        Action action = iterator.next();
        iterator.remove();
        if (action.getPicasso().loggingEnabled) {
          log(OWNER_DISPATCHER, VERB_REPLAYING, action.getRequest().logId());
        }
        performSubmit(action);
      }
    }
  }

  private void markForReplay(BitmapHunter hunter) {
    Action action = hunter.getAction();
    if (action != null) {
      markForReplay(action);
    }
    List<Action> joined = hunter.getActions();
    if (joined != null) {
      //noinspection ForLoopReplaceableByForEach
      for (int i = 0, n = joined.size(); i < n; i++) {
        Action join = joined.get(i);
        markForReplay(join);
      }
    }
  }

  private void markForReplay(Action action) {
    Object target = action.getTarget();
    if (target != null) {
      action.willReplay = true;
      failedActions.put(target, action);
    }
  }

  private void batch(BitmapHunter hunter) {
    if (hunter.isCancelled()) {
      return;
    }
    batch.add(hunter);
    if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) {
      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);
    }
  }

  public void interruptDispatching() {

    dispatchingQueue.interruptDispatching();
    if (service instanceof PicassoExecutorService) {
      ((PicassoExecutorService) service).pause();
    }
  }

  public void continueDispatching() {

    dispatchingQueue.continueDispatching();
    if (service instanceof PicassoExecutorService) {
      ((PicassoExecutorService) service).resume();
    }
  }

  private void logBatch(List<BitmapHunter> copy) {
    if (copy == null || copy.isEmpty()) return;
    BitmapHunter hunter = copy.get(0);
    Picasso picasso = hunter.getPicasso();
    if (picasso.loggingEnabled) {
      StringBuilder builder = new StringBuilder();
      for (BitmapHunter bitmapHunter : copy) {
        if (builder.length() > 0) builder.append(", ");
        builder.append(Utils.getLogIdsForHunter(bitmapHunter));
      }
      log(OWNER_DISPATCHER, VERB_DELIVERED, builder.toString());
    }
  }

  private static class DispatcherHandler extends Handler {
    private final Dispatcher dispatcher;

    public DispatcherHandler(Looper looper, Dispatcher dispatcher) {
      super(looper);
      this.dispatcher = dispatcher;
    }

    @Override public void handleMessage(final Message msg) {
      switch (msg.what) {
        case REQUEST_SUBMIT: {
          Action action = (Action) msg.obj;
          dispatcher.performSubmit(action);
          break;
        }
        case REQUEST_CANCEL: {
          Action action = (Action) msg.obj;
          dispatcher.performCancel(action);
          break;
        }
        case HUNTER_COMPLETE: {
          BitmapHunter hunter = (BitmapHunter) msg.obj;
          dispatcher.performComplete(hunter);
          break;
        }
        case HUNTER_RETRY: {
          BitmapHunter hunter = (BitmapHunter) msg.obj;
          dispatcher.performRetry(hunter);
          break;
        }
        case HUNTER_DECODE_FAILED: {
          BitmapHunter hunter = (BitmapHunter) msg.obj;
          dispatcher.performError(hunter, false);
          break;
        }
        case HUNTER_DELAY_NEXT_BATCH: {
          dispatcher.performBatchComplete();
          break;
        }
        case NETWORK_STATE_CHANGE: {
          NetworkInfo info = (NetworkInfo) msg.obj;
          dispatcher.performNetworkStateChange(info);
          break;
        }
        case AIRPLANE_MODE_CHANGE: {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON);
          break;
        }
        default:
          Picasso.HANDLER.post(new Runnable() {
            @Override public void run() {
              throw new AssertionError("Unknown handler message received: " + msg.what);
            }
          });
      }
    }
  }

  static class DispatcherThread extends HandlerThread {
    DispatcherThread() {
      super(Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME, THREAD_PRIORITY_BACKGROUND);
    }
  }

  static class NetworkBroadcastReceiver extends BroadcastReceiver {
    static final String EXTRA_AIRPLANE_STATE = "state";

    private final Dispatcher dispatcher;

    NetworkBroadcastReceiver(Dispatcher dispatcher) {
      this.dispatcher = dispatcher;
    }

    void register() {
      IntentFilter filter = new IntentFilter();
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED);
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION);
      }
      dispatcher.context.registerReceiver(this, filter);
    }

    void unregister() {
      dispatcher.context.unregisterReceiver(this);
    }

    @Override public void onReceive(Context context, Intent intent) {
      // On some versions of Android this may be called with a null Intent,
      // also without extras (getExtras() == null), in such case we use defaults.
      if (intent == null) {
        return;
      }
      final String action = intent.getAction();
      if (ACTION_AIRPLANE_MODE_CHANGED.equals(action)) {
        if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
          return; // No airplane state, ignore it. Should we query Utils.isAirplaneModeOn?
        }
        dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false));
      } else if (CONNECTIVITY_ACTION.equals(action)) {
        ConnectivityManager connectivityManager = getService(context, CONNECTIVITY_SERVICE);
        dispatcher.dispatchNetworkStateChange(connectivityManager.getActiveNetworkInfo());
      }
    }
  }
}

@#$
package com.squareup.picasso;

import android.os.Handler;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * A queue that manages dispatching the BitmapHunter result
 *
 * @author Hannes Dorfmann
 */
public class DispatchingQueue {

  final Map<BitmapHunter, DispatchJob> hunterMap;
  final Queue<DispatchJob> jobQueue;
  final Handler handler;
  boolean dispatching;

  public DispatchingQueue(Handler handler) {
    this.handler = handler;
    this.jobQueue = new ConcurrentLinkedQueue<DispatchJob>();
    this.hunterMap = new ConcurrentHashMap<BitmapHunter, DispatchJob>();
    this.dispatching = true;
  }

  public void interruptDispatching() {
    Utils.checkMain();
    dispatching = false;
  }

  public void continueDispatching() {
    Utils.checkMain();
    dispatching = true;
    dispatchNextFromQueue();
  }

  public boolean isDispatchingEnabled() {
    return dispatching;
  }

  private void scheduleJob(DispatchJob job) {
    boolean added = jobQueue.offer(job);

    if (added) {
      hunterMap.put(job.getBitmapHunter(), job);
    }
  }

  public void dispatchComplete(BitmapHunter hunter) {

    if (isDispatchingEnabled()) {
      // dispatch directly; avoid object creation overhead
      handler.sendMessage(handler.obtainMessage(Dispatcher.HUNTER_COMPLETE, hunter));
    } else {
      // dispatching is disabled temporally
      CompleteDispatchJob job = new CompleteDispatchJob(handler, hunter);
      scheduleJob(job);
    }
  }

  public void dispatchFailed(BitmapHunter hunter) {

    if (isDispatchingEnabled()) {
      // dispatch directly; avoid object creation overhead
      handler.sendMessage(handler.obtainMessage(Dispatcher.HUNTER_DECODE_FAILED, hunter));
    } else {
      // dispatching is disabled temporally
      FailedDispatchJob job = new FailedDispatchJob(handler, hunter);
      scheduleJob(job);
    }
  }

  public void dispatchNextFromQueue() {

    while (!jobQueue.isEmpty()) {
      DispatchJob job = jobQueue.poll();

      if (job != null) {
        hunterMap.remove(job.getBitmapHunter());
        job.dispatch();
      }
    }
  }

  public void dequeue(BitmapHunter hunter) {

    DispatchJob job = hunterMap.get(hunter);
    if (job != null) {
      // Remove the waiting jo from queue
      jobQueue.remove(job);
      hunterMap.remove(hunter);
    }
  }

  public void clear() {
    jobQueue.clear();
    hunterMap.clear();
  }

  /**
   * Base class for dispatch jobs
   */
  abstract static class DispatchJob {

    protected final Handler handler;
    protected final BitmapHunter hunter;

    protected DispatchJob(Handler handler, BitmapHunter hunter) {
      this.handler = handler;
      this.hunter = hunter;
    }

    public BitmapHunter getBitmapHunter() {
      return hunter;
    }

    /**
     * Dispatches the message
     */
    public abstract void dispatch();
  }

  /**
   * A job that will dispatch that the BitmapHunter has completetd his job
   */
  static class CompleteDispatchJob extends DispatchJob {

    protected CompleteDispatchJob(Handler handler, BitmapHunter hunter) {
      super(handler, hunter);
    }

    public void dispatch() {
      handler.sendMessage(handler.obtainMessage(Dispatcher.HUNTER_COMPLETE, hunter));
    }
  }

  /**
   * A job to dispatch that the BitmapHunter has failed
   */
  static class FailedDispatchJob extends DispatchJob {

    FailedDispatchJob(Handler handler, BitmapHunter hunter) {
      super(handler, hunter);
    }

    public void dispatch() {
      handler.sendMessage(handler.obtainMessage(Dispatcher.HUNTER_DECODE_FAILED, hunter));
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.graphics.Bitmap;
import android.net.Uri;
import java.io.IOException;
import java.io.InputStream;

/** A mechanism to load images from external resources such as a disk cache and/or the internet. */
public interface Downloader {
  /**
   * Download the specified image {@code url} from the internet.
   *
   * @param uri Remote image URL.
   * @param localCacheOnly If {@code true} the URL should only be loaded if available in a local
   * disk cache.
   * @return {@link Response} containing either a {@link Bitmap} representation of the request or an
   * {@link InputStream} for the image data. {@code null} can be returned to indicate a problem
   * loading the bitmap.
   * @throws IOException if the requested URL cannot successfully be loaded.
   */
  Response load(Uri uri, boolean localCacheOnly) throws IOException;

  /** Thrown for non-2XX responses. */
  class ResponseException extends IOException {
    public ResponseException(String message) {
      super(message);
    }
  }

  /** Response stream or bitmap and info. */
  class Response {
    final InputStream stream;
    final Bitmap bitmap;
    final boolean cached;
    final long contentLength;

    /**
     * Response image and info.
     *
     * @param bitmap Image.
     * @param loadedFromCache {@code true} if the source of the image is from a local disk cache.
     * @deprecated Use {@link Response#Response(android.graphics.Bitmap, boolean, long)} instead.
     */
    @Deprecated @SuppressWarnings("UnusedDeclaration")
    public Response(Bitmap bitmap, boolean loadedFromCache) {
      this(bitmap, loadedFromCache, -1);
    }

    /**
     * Response stream and info.
     *
     * @param stream Image data stream.
     * @param loadedFromCache {@code true} if the source of the stream is from a local disk cache.
     * @deprecated Use {@link Response#Response(java.io.InputStream, boolean, long)} instead.
     */
    @Deprecated @SuppressWarnings("UnusedDeclaration")
    public Response(InputStream stream, boolean loadedFromCache) {
      this(stream, loadedFromCache, -1);
    }

    /**
     * Response image and info.
     *
     * @param bitmap Image.
     * @param loadedFromCache {@code true} if the source of the image is from a local disk cache.
     * @param contentLength The content length of the response, typically derived by the
     * {@code Content-Length} HTTP header.
     */
    public Response(Bitmap bitmap, boolean loadedFromCache, long contentLength) {
      if (bitmap == null) {
        throw new IllegalArgumentException("Bitmap may not be null.");
      }
      this.stream = null;
      this.bitmap = bitmap;
      this.cached = loadedFromCache;
      this.contentLength = contentLength;
    }

    /**
     * Response stream and info.
     *
     * @param stream Image data stream.
     * @param loadedFromCache {@code true} if the source of the stream is from a local disk cache.
     * @param contentLength The content length of the response, typically derived by the
     * {@code Content-Length} HTTP header.
     */
    public Response(InputStream stream, boolean loadedFromCache, long contentLength) {
      if (stream == null) {
        throw new IllegalArgumentException("Stream may not be null.");
      }
      this.stream = stream;
      this.bitmap = null;
      this.cached = loadedFromCache;
      this.contentLength = contentLength;
    }

    /**
     * Input stream containing image data.
     * <p>
     * If this returns {@code null}, image data will be available via {@link #getBitmap()}.
     */
    public InputStream getInputStream() {
      return stream;
    }

    /**
     * Bitmap representing the image.
     * <p>
     * If this returns {@code null}, image data will be available via {@link #getInputStream()}.
     */
    public Bitmap getBitmap() {
      return bitmap;
    }

    /** Content length of the response. */
    public long getContentLength() {
      return contentLength;
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.graphics.Bitmap;

class FetchAction extends Action<Void> {
  FetchAction(Picasso picasso, Request data, boolean skipCache, String key) {
    super(picasso, null, data, skipCache, false, 0, null, key);
  }

  @Override void complete(Bitmap result, Picasso.LoadedFrom from) {
  }

  @Override public void error() {
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.content.Context;
import android.graphics.Bitmap;
import android.media.ExifInterface;
import android.net.Uri;
import java.io.IOException;

import static android.media.ExifInterface.ORIENTATION_NORMAL;
import static android.media.ExifInterface.ORIENTATION_ROTATE_180;
import static android.media.ExifInterface.ORIENTATION_ROTATE_270;
import static android.media.ExifInterface.ORIENTATION_ROTATE_90;
import static android.media.ExifInterface.TAG_ORIENTATION;

class FileBitmapHunter extends ContentStreamBitmapHunter {

  FileBitmapHunter(Context context, Picasso picasso, Dispatcher dispatcher, Cache cache,
      Stats stats, Action action) {
    super(context, picasso, dispatcher, cache, stats, action);
  }

  @Override Bitmap decode(Request data)
      throws IOException {
    setExifRotation(getFileExifRotation(data.uri));
    return super.decode(data);
  }

  static int getFileExifRotation(Uri uri) throws IOException {
    ExifInterface exifInterface = new ExifInterface(uri.getPath());
    int orientation = exifInterface.getAttributeInt(TAG_ORIENTATION, ORIENTATION_NORMAL);
    switch (orientation) {
      case ORIENTATION_ROTATE_90:
        return 90;
      case ORIENTATION_ROTATE_180:
        return 180;
      case ORIENTATION_ROTATE_270:
        return 270;
      default:
        return 0;
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.graphics.Bitmap;

class GetAction extends Action<Void> {
  GetAction(Picasso picasso, Request data, boolean skipCache, String key) {
    super(picasso, null, data, skipCache, false, 0, null, key);
  }

  @Override void complete(Bitmap result, Picasso.LoadedFrom from) {
  }

  @Override public void error() {
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.widget.ImageView;

class ImageViewAction extends Action<ImageView> {

  Callback callback;

  ImageViewAction(Picasso picasso, ImageView imageView, Request data, boolean skipCache,
      boolean noFade, int errorResId, Drawable errorDrawable, String key, Callback callback) {
    super(picasso, imageView, data, skipCache, noFade, errorResId, errorDrawable, key);
    this.callback = callback;
  }

  @Override public void complete(Bitmap result, Picasso.LoadedFrom from) {
    if (result == null) {
      throw new AssertionError(
          String.format("Attempted to complete action with no result!\n%s", this));
    }

    ImageView target = this.target.get();
    if (target == null) {
      return;
    }

    Context context = picasso.context;
    boolean indicatorsEnabled = picasso.indicatorsEnabled;
    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);

    if (callback != null) {
      callback.onSuccess();
    }
  }

  @Override public void error() {
    ImageView target = this.target.get();
    if (target == null) {
      return;
    }
    if (errorResId != 0) {
      target.setImageResource(errorResId);
    } else if (errorDrawable != null) {
      target.setImageDrawable(errorDrawable);
    }

    if (callback != null) {
      callback.onError();
    }
  }

  @Override void cancel() {
    super.cancel();
    if (callback != null) {
      callback = null;
    }
  }
}

@#$
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.content.Context;
import android.graphics.Bitmap;
import java.util.LinkedHashMap;
import java.util.Map;

/** A memory cache which uses a least-recently used eviction policy. */
public class LruCache implements Cache {
  final LinkedHashMap<String, Bitmap> map;
  private final int maxSize;

  private int size;
  private int putCount;
  private int evictionCount;
  private int hitCount;
  private int missCount;

  /** Create a cache using an appropriate portion of the available RAM as the maximum size. */
  public LruCache(Context context) {
    this(Utils.calculateMemoryCacheSize(context));
  }

  /** Create a cache with a given maximum size in bytes. */
  public LruCache(int maxSize) {
    if (maxSize <= 0) {
      throw new IllegalArgumentException("Max size must be positive.");
    }
    this.maxSize = maxSize;
    this.map = new LinkedHashMap<String, Bitmap>(0, 0.75f, true);
  }

  @Override public Bitmap get(String key) {
    if (key == null) {
      throw new NullPointerException("key == null");
    }

    Bitmap mapValue;
    synchronized (this) {
      mapValue = map.get(key);
      if (mapValue != null) {
        hitCount++;
        return mapValue;
      }
      missCount++;
    }

    return null;
  }

  @Override public void set(String key, Bitmap bitmap) {
    if (key == null || bitmap == null) {
      throw new NullPointerException("key == null || bitmap == null");
    }

    Bitmap previous;
    synchronized (this) {
      putCount++;
      size += Utils.getBitmapBytes(bitmap);
      previous = map.put(key, bitmap);
      if (previous != null) {
        size -= Utils.getBitmapBytes(previous);
      }
    }

    trimToSize(maxSize);
  }

  private void trimToSize(int maxSize) {
    while (true) {
      String key;
      Bitmap value;
      synchronized (this) {
        if (size < 0 || (map.isEmpty() && size != 0)) {
          throw new IllegalStateException(
              getClass().getName() + ".sizeOf() is reporting inconsistent results!");
        }

        if (size <= maxSize || map.isEmpty()) {
          break;
        }

        Map.Entry<String, Bitmap> toEvict = map.entrySet().iterator().next();
        key = toEvict.getKey();
        value = toEvict.getValue();
        map.remove(key);
        size -= Utils.getBitmapBytes(value);
        evictionCount++;
      }
    }
  }

  /** Clear the cache. */
  public final void evictAll() {
    trimToSize(-1); // -1 will evict 0-sized elements
  }

  /** Returns the sum of the sizes of the entries in this cache. */
  public final synchronized int size() {
    return size;
  }

  /** Returns the maximum sum of the sizes of the entries in this cache. */
  public final synchronized int maxSize() {
    return maxSize;
  }

  public final synchronized void clear() {
    evictAll();
  }

  /** Returns the number of times {@link #get} returned a value. */
  public final synchronized int hitCount() {
    return hitCount;
  }

  /** Returns the number of times {@link #get} returned {@code null}. */
  public final synchronized int missCount() {
    return missCount;
  }

  /** Returns the number of times {@link #set(String, Bitmap)} was called. */
  public final synchronized int putCount() {
    return putCount;
  }

  /** Returns the number of values that have been evicted. */
  public final synchronized int evictionCount() {
    return evictionCount;
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * An input stream wrapper that supports unlimited independent cursors for
 * marking and resetting. Each cursor is a token, and it's the caller's
 * responsibility to keep track of these.
 */
final class MarkableInputStream extends InputStream {
  private static final int DEFAULT_BUFFER_SIZE = 4096;

  private final InputStream in;

  private long offset;
  private long reset;
  private long limit;
  private long defaultMark = -1;

  public MarkableInputStream(InputStream in) {
    this(in, DEFAULT_BUFFER_SIZE);
  }

  public MarkableInputStream(InputStream in, int size) {
    if (!in.markSupported()) {
      in = new BufferedInputStream(in, size);
    }
    this.in = in;
  }

  /** Marks this place in the stream so we can reset back to it later. */
  @Override public void mark(int readLimit) {
    defaultMark = savePosition(readLimit);
  }

  /**
   * Returns an opaque token representing the current position in the stream.
   * Call {@link #reset(long)} to return to this position in the stream later.
   * It is an error to call {@link #reset(long)} after consuming more than
   * {@code readLimit} bytes from this stream.
   */
  public long savePosition(int readLimit) {
    long offsetLimit = offset + readLimit;
    if (limit < offsetLimit) {
      setLimit(offsetLimit);
    }
    return offset;
  }

  /**
   * Makes sure that the underlying stream can backtrack the full range from
   * {@code reset} thru {@code limit}. Since we can't call {@code mark()}
   * without also adjusting the reset-to-position on the underlying stream this
   * method resets first and then marks the union of the two byte ranges. On
   * buffered streams this additional cursor motion shouldn't result in any
   * additional I/O.
   */
  private void setLimit(long limit) {
    try {
      if (reset < offset && offset <= this.limit) {
        in.reset();
        in.mark((int) (limit - reset));
        skip(reset, offset);
      } else {
        reset = offset;
        in.mark((int) (limit - offset));
      }
      this.limit = limit;
    } catch (IOException e) {
      throw new IllegalStateException("Unable to mark: " + e);
    }
  }

  /** Resets the stream to the most recent {@link #mark mark}. */
  @Override public void reset() throws IOException {
    reset(defaultMark);
  }

  /** Resets the stream to the position recorded by {@code token}. */
  public void reset(long token) throws IOException {
    if (offset > limit || token < reset) {
      throw new IOException("Cannot reset");
    }
    in.reset();
    skip(reset, token);
    offset = token;
  }

  /** Skips {@code target - current} bytes and returns. */
  private void skip(long current, long target) throws IOException {
    while (current < target) {
      long skipped = in.skip(target - current);
      if (skipped == 0) {
        if (read() == -1) {
          break; // EOF
        } else {
          skipped = 1;
        }
      }
      current += skipped;
    }
  }

  @Override public int read() throws IOException {
    int result = in.read();
    if (result != -1) {
      offset++;
    }
    return result;
  }

  @Override public int read(byte[] buffer) throws IOException {
    int count = in.read(buffer);
    if (count != -1) {
      offset += count;
    }
    return count;
  }

  @Override public int read(byte[] buffer, int offset, int length) throws IOException {
    int count = in.read(buffer, offset, length);
    if (count != -1) {
      this.offset += count;
    }
    return count;
  }

  @Override public long skip(long byteCount) throws IOException {
    long skipped = in.skip(byteCount);
    offset += skipped;
    return skipped;
  }

  @Override public int available() throws IOException {
    return in.available();
  }

  @Override public void close() throws IOException {
    in.close();
  }

  @Override public boolean markSupported() {
    return in.markSupported();
  }
}

@#$
/*
 * Copyright (C) 2014 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.content.ContentResolver;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import java.io.IOException;

import static android.content.ContentUris.parseId;
import static android.provider.MediaStore.Images;
import static android.provider.MediaStore.Video;
import static android.provider.MediaStore.Images.Thumbnails.FULL_SCREEN_KIND;
import static android.provider.MediaStore.Images.Thumbnails.MICRO_KIND;
import static android.provider.MediaStore.Images.Thumbnails.MINI_KIND;
import static com.squareup.picasso.MediaStoreBitmapHunter.PicassoKind.FULL;
import static com.squareup.picasso.MediaStoreBitmapHunter.PicassoKind.MICRO;
import static com.squareup.picasso.MediaStoreBitmapHunter.PicassoKind.MINI;

class MediaStoreBitmapHunter extends ContentStreamBitmapHunter {
  private static final String[] CONTENT_ORIENTATION = new String[] {
      Images.ImageColumns.ORIENTATION
  };

  MediaStoreBitmapHunter(Context context, Picasso picasso, Dispatcher dispatcher, Cache cache,
      Stats stats, Action action) {
    super(context, picasso, dispatcher, cache, stats, action);
  }

  @Override Bitmap decode(Request data) throws IOException {
    ContentResolver contentResolver = context.getContentResolver();
    setExifRotation(getExifOrientation(contentResolver, data.uri));
    String mimeType = contentResolver.getType(data.uri);
    boolean isVideo = mimeType != null && mimeType.startsWith("video/");

    if (data.hasSize()) {
      PicassoKind picassoKind = getPicassoKind(data.targetWidth, data.targetHeight);
      if (!isVideo && picassoKind == FULL) {
        return super.decode(data);
      }

      long id = parseId(data.uri);

      BitmapFactory.Options options = createBitmapOptions(data);
      options.inJustDecodeBounds = true;

      calculateInSampleSize(data.targetWidth, data.targetHeight, picassoKind.width,
          picassoKind.height, options);

      Bitmap result;

      if (isVideo) {
        // Since MediaStore doesn't provide the full screen kind thumbnail, we use the mini kind
        // instead which is the largest thumbnail size can be fetched from MediaStore.
        int kind = (picassoKind == FULL) ? Video.Thumbnails.MINI_KIND : picassoKind.androidKind;
        result = Video.Thumbnails.getThumbnail(contentResolver, id, kind, options);
      } else {
        result =
            Images.Thumbnails.getThumbnail(contentResolver, id, picassoKind.androidKind, options);
      }

      if (result != null) {
        return result;
      }
    }

    return super.decode(data);
  }

  static PicassoKind getPicassoKind(int targetWidth, int targetHeight) {
    if (targetWidth <= MICRO.width && targetHeight <= MICRO.height) {
      return MICRO;
    } else if (targetWidth <= MINI.width && targetHeight <= MINI.height) {
      return MINI;
    }
    return FULL;
  }

  static int getExifOrientation(ContentResolver contentResolver, Uri uri) {
    Cursor cursor = null;
    try {
      cursor = contentResolver.query(uri, CONTENT_ORIENTATION, null, null, null);
      if (cursor == null || !cursor.moveToFirst()) {
        return 0;
      }
      return cursor.getInt(0);
    } catch (RuntimeException ignored) {
      // If the orientation column doesn't exist, assume no rotation.
      return 0;
    } finally {
      if (cursor != null) {
        cursor.close();
      }
    }
  }

  enum PicassoKind {
    MICRO(MICRO_KIND, 96, 96),
    MINI(MINI_KIND, 512, 384),
    FULL(FULL_SCREEN_KIND, -1, -1);

    final int androidKind;
    final int width;
    final int height;

    PicassoKind(int androidKind, int width, int height) {
      this.androidKind = androidKind;
      this.width = width;
      this.height = height;
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.NetworkInfo;
import java.io.IOException;
import java.io.InputStream;

import static com.squareup.picasso.Downloader.Response;
import static com.squareup.picasso.Picasso.LoadedFrom.DISK;
import static com.squareup.picasso.Picasso.LoadedFrom.NETWORK;

class NetworkBitmapHunter extends BitmapHunter {
  static final int DEFAULT_RETRY_COUNT = 2;
  private static final int MARKER = 65536;

  private final Downloader downloader;

  int retryCount;

  public NetworkBitmapHunter(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,
      Action action, Downloader downloader) {
    super(picasso, dispatcher, cache, stats, action);
    this.downloader = downloader;
    this.retryCount = DEFAULT_RETRY_COUNT;
  }

  @Override Bitmap decode(Request data) throws IOException {
    boolean loadFromLocalCacheOnly = retryCount == 0;

    Response response = downloader.load(data.uri, loadFromLocalCacheOnly);
    if (response == null) {
      return null;
    }

    loadedFrom = response.cached ? DISK : NETWORK;

    Bitmap result = response.getBitmap();
    if (result != null) {
      return result;
    }

    InputStream is = response.getInputStream();
    if (is == null) {
      return null;
    }
    // Sometimes response content length is zero when requests are being replayed. Haven't found
    // root cause to this but retrying the request seems safe to do so.
    if (response.getContentLength() == 0) {
      Utils.closeQuietly(is);
      throw new IOException("Received response with 0 content-length header.");
    }
    if (loadedFrom == NETWORK && response.getContentLength() > 0) {
      stats.dispatchDownloadFinished(response.getContentLength());
    }
    try {
      return decodeStream(is, data);
    } finally {
      Utils.closeQuietly(is);
    }
  }

  @Override boolean shouldRetry(boolean airplaneMode, NetworkInfo info) {
    boolean hasRetries = retryCount > 0;
    if (!hasRetries) {
      return false;
    }
    retryCount--;
    return info == null || info.isConnected();
  }

  @Override boolean supportsReplay() {
    return true;
  }

  private Bitmap decodeStream(InputStream stream, Request data) throws IOException {
    MarkableInputStream markStream = new MarkableInputStream(stream);
    stream = markStream;

    long mark = markStream.savePosition(MARKER);

    final BitmapFactory.Options options = createBitmapOptions(data);
    final boolean calculateSize = requiresInSampleSize(options);

    boolean isWebPFile = Utils.isWebPFile(stream);
    markStream.reset(mark);
    // When decode WebP network stream, BitmapFactory throw JNI Exception and make app crash.
    // Decode byte array instead
    if (isWebPFile) {
      byte[] bytes = Utils.toByteArray(stream);
      if (calculateSize) {
        BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options);
        calculateInSampleSize(data.targetWidth, data.targetHeight, options);
      }
      return BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options);
    } else {
      if (calculateSize) {
        BitmapFactory.decodeStream(stream, null, options);
        calculateInSampleSize(data.targetWidth, data.targetHeight, options);

        markStream.reset(mark);
      }
      Bitmap bitmap = BitmapFactory.decodeStream(stream, null, options);
      if (bitmap == null) {
        // Treat null as an IO exception, we will eventually retry.
        throw new IOException("Failed to decode stream.");
      }
      return bitmap;
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.content.Context;
import android.net.Uri;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.OkUrlFactory;
import java.io.File;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;

import static com.squareup.picasso.Utils.parseResponseSourceHeader;

/** A {@link Downloader} which uses OkHttp to download images. */
public class OkHttpDownloader implements Downloader {
  static final String RESPONSE_SOURCE_ANDROID = "X-Android-Response-Source";
  static final String RESPONSE_SOURCE_OKHTTP = "OkHttp-Response-Source";

  private final OkUrlFactory urlFactory;

  /**
   * Create new downloader that uses OkHttp. This will install an image cache into your application
   * cache directory.
   */
  public OkHttpDownloader(final Context context) {
    this(Utils.createDefaultCacheDir(context));
  }

  /**
   * Create new downloader that uses OkHttp. This will install an image cache into your application
   * cache directory.
   *
   * @param cacheDir The directory in which the cache should be stored
   */
  public OkHttpDownloader(final File cacheDir) {
    this(cacheDir, Utils.calculateDiskCacheSize(cacheDir));
  }

  /**
   * Create new downloader that uses OkHttp. This will install an image cache into your application
   * cache directory.
   *
   * @param maxSize The size limit for the cache.
   */
  public OkHttpDownloader(final Context context, final long maxSize) {
    this(Utils.createDefaultCacheDir(context), maxSize);
  }

  /**
   * Create new downloader that uses OkHttp. This will install an image cache into your application
   * cache directory.
   *
   * @param cacheDir The directory in which the cache should be stored
   * @param maxSize The size limit for the cache.
   */
  public OkHttpDownloader(final File cacheDir, final long maxSize) {
    this(new OkHttpClient());
    try {
      urlFactory.client().setCache(new com.squareup.okhttp.Cache(cacheDir, maxSize));
    } catch (IOException ignored) {
    }
  }

  /**
   * Create a new downloader that uses the specified OkHttp instance. A response cache will not be
   * automatically configured.
   */
  public OkHttpDownloader(OkHttpClient client) {
    this.urlFactory = new OkUrlFactory(client);
  }

  protected HttpURLConnection openConnection(Uri uri) throws IOException {
    HttpURLConnection connection = urlFactory.open(new URL(uri.toString()));
    connection.setConnectTimeout(Utils.DEFAULT_CONNECT_TIMEOUT);
    connection.setReadTimeout(Utils.DEFAULT_READ_TIMEOUT);
    return connection;
  }

  protected OkHttpClient getClient() {
    return urlFactory.client();
  }

  @Override public Response load(Uri uri, boolean localCacheOnly) throws IOException {
    HttpURLConnection connection = openConnection(uri);
    connection.setUseCaches(true);
    if (localCacheOnly) {
      connection.setRequestProperty("Cache-Control", "only-if-cached,max-age=" + Integer.MAX_VALUE);
    }

    int responseCode = connection.getResponseCode();
    if (responseCode >= 300) {
      connection.disconnect();
      throw new ResponseException(responseCode + " " + connection.getResponseMessage());
    }

    String responseSource = connection.getHeaderField(RESPONSE_SOURCE_OKHTTP);
    if (responseSource == null) {
      responseSource = connection.getHeaderField(RESPONSE_SOURCE_ANDROID);
    }

    long contentLength = connection.getHeaderFieldInt("Content-Length", -1);
    boolean fromCache = parseResponseSourceHeader(responseSource);

    return new Response(connection.getInputStream(), fromCache, contentLength);
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.os.Process;
import android.widget.ImageView;
import java.io.File;
import java.lang.ref.ReferenceQueue;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;

import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
import static com.squareup.picasso.Action.RequestWeakReference;
import static com.squareup.picasso.Dispatcher.HUNTER_BATCH_COMPLETE;
import static com.squareup.picasso.Dispatcher.REQUEST_GCED;
import static com.squareup.picasso.Utils.OWNER_MAIN;
import static com.squareup.picasso.Utils.THREAD_PREFIX;
import static com.squareup.picasso.Utils.VERB_COMPLETED;
import static com.squareup.picasso.Utils.VERB_ERRORED;
import static com.squareup.picasso.Utils.checkMain;
import static com.squareup.picasso.Utils.log;

/**
 * Image downloading, transformation, and caching manager.
 * <p>
 * Use {@link #with(android.content.Context)} for the global singleton instance or construct your
 * own instance with {@link Builder}.
 */
public class Picasso {

  static final String TAG = "Picasso";
  static final Handler HANDLER = new Handler(Looper.getMainLooper()) {
    @Override public void handleMessage(Message msg) {
      switch (msg.what) {
        case HUNTER_BATCH_COMPLETE: {
          @SuppressWarnings("unchecked") List<BitmapHunter> batch = (List<BitmapHunter>) msg.obj;
          //noinspection ForLoopReplaceableByForEach
          for (int i = 0, n = batch.size(); i < n; i++) {
            BitmapHunter hunter = batch.get(i);
            hunter.picasso.complete(hunter);
          }
          break;
        }
        case REQUEST_GCED: {
          Action action = (Action) msg.obj;
          action.picasso.cancelExistingRequest(action.getTarget());
          break;
        }
        default:
          throw new AssertionError("Unknown handler message received: " + msg.what);
      }
    }
  };

  static Picasso singleton = null;
  final Context context;
  final Dispatcher dispatcher;
  final Cache cache;
  final Stats stats;
  final Map<Object, Action> targetToAction;
  final Map<ImageView, DeferredRequestCreator> targetToDeferredRequestCreator;
  final ReferenceQueue<Object> referenceQueue;
  private final Listener listener;
  private final RequestTransformer requestTransformer;
  private final CleanupThread cleanupThread;
  boolean indicatorsEnabled;
  volatile boolean loggingEnabled;
  boolean shutdown;



  Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener,
      RequestTransformer requestTransformer, Stats stats, boolean indicatorsEnabled,
      boolean loggingEnabled) {
    this.context = context;
    this.dispatcher = dispatcher;
    this.cache = cache;
    this.listener = listener;
    this.requestTransformer = requestTransformer;
    this.stats = stats;
    this.targetToAction = new WeakHashMap<Object, Action>();
    this.targetToDeferredRequestCreator = new WeakHashMap<ImageView, DeferredRequestCreator>();
    this.indicatorsEnabled = indicatorsEnabled;
    this.loggingEnabled = loggingEnabled;
    this.referenceQueue = new ReferenceQueue<Object>();
    this.cleanupThread = new CleanupThread(referenceQueue, HANDLER);
    this.cleanupThread.start();
  }

  /**
   * The global default {@link Picasso} instance.
   * <p>
   * This instance is automatically initialized with defaults that are suitable to most
   * implementations.
   * <ul>
   * <li>LRU memory cache of 15% the available application RAM</li>
   * <li>Disk cache of 2% storage space up to 50MB but no less than 5MB. (Note: this is only
   * available on API 14+ <em>or</em> if you are using a standalone library that provides a disk
   * cache on all API levels like OkHttp)</li>
   * <li>Three download threads for disk and network access.</li>
   * </ul>
   * <p>
   * If these settings do not meet the requirements of your application you can construct your own
   * instance with full control over the configuration by using {@link Picasso.Builder}.
   */
  public static Picasso with(Context context) {
    if (singleton == null) {
      synchronized (Picasso.class) {
        if (singleton == null) {
          singleton = new Builder(context).build();
        }
      }
    }
    return singleton;
  }

  /** Cancel any existing requests for the specified target {@link ImageView}. */
  public void cancelRequest(ImageView view) {
    cancelExistingRequest(view);
  }

  /** Cancel any existing requests for the specified {@link Target} instance. */
  public void cancelRequest(Target target) {
    cancelExistingRequest(target);
  }

  /**
   * Start an image request using the specified URI.
   * <p>
   * Passing {@code null} as a {@code uri} will not trigger any request but will set a placeholder,
   * if one is specified.
   *
   * @see #load(File)
   * @see #load(String)
   * @see #load(int)
   */
  public RequestCreator load(Uri uri) {
    return new RequestCreator(this, uri, 0);
  }

  /**
   * Start an image request using the specified path. This is a convenience method for calling
   * {@link #load(Uri)}.
   * <p>
   * This path may be a remote URL, file resource (prefixed with {@code file:}), content resource
   * (prefixed with {@code content:}), or android resource (prefixed with {@code
   * android.resource:}.
   * <p>
   * Passing {@code null} as a {@code path} will not trigger any request but will set a
   * placeholder, if one is specified.
   *
   * @throws IllegalArgumentException if {@code path} is empty or blank string.
   * @see #load(Uri)
   * @see #load(File)
   * @see #load(int)
   */
  public RequestCreator load(String path) {
    if (path == null) {
      return new RequestCreator(this, null, 0);
    }
    if (path.trim().length() == 0) {
      return load(Uri.parse(" "));
    }
    return load(Uri.parse(path));
  }

  /**
   * Start an image request using the specified image file. This is a convenience method for
   * calling {@link #load(Uri)}.
   * <p>
   * Passing {@code null} as a {@code file} will not trigger any request but will set a
   * placeholder, if one is specified.
   * <p>
   * Equivalent to calling {@link #load(Uri) load(Uri.fromFile(file))}.
   *
   * @see #load(Uri)
   * @see #load(String)
   * @see #load(int)
   */
  public RequestCreator load(File file) {
    if (file == null) {
      return new RequestCreator(this, null, 0);
    }
    return load(Uri.fromFile(file));
  }

  /**
   * Start an image request using the specified drawable resource ID.
   *
   * @see #load(Uri)
   * @see #load(String)
   * @see #load(File)
   */
  public RequestCreator load(int resourceId) {
    if (resourceId == 0) {
      throw new IllegalArgumentException("Resource ID must not be zero.");
    }
    return new RequestCreator(this, null, resourceId);
  }

  /**
   * {@code true} if debug display, logging, and statistics are enabled.
   * <p>
   *
   * @deprecated Use {@link #areIndicatorsEnabled()} and {@link #isLoggingEnabled()} instead.
   */
  @SuppressWarnings("UnusedDeclaration") @Deprecated public boolean isDebugging() {
    return areIndicatorsEnabled() && isLoggingEnabled();
  }

  /**
   * Toggle whether debug display, logging, and statistics are enabled.
   * <p>
   *
   * @deprecated Use {@link #setIndicatorsEnabled(boolean)} and {@link #setLoggingEnabled(boolean)}
   * instead.
   */
  @SuppressWarnings("UnusedDeclaration") @Deprecated public void setDebugging(boolean debugging) {
    setIndicatorsEnabled(debugging);
  }

  /** Toggle whether to display debug indicators on images. */
  @SuppressWarnings("UnusedDeclaration") public void setIndicatorsEnabled(boolean enabled) {
    indicatorsEnabled = enabled;
  }

  /** {@code true} if debug indicators should are displayed on images. */
  @SuppressWarnings("UnusedDeclaration") public boolean areIndicatorsEnabled() {
    return indicatorsEnabled;
  }

  /** {@code true} if debug logging is enabled. */
  public boolean isLoggingEnabled() {
    return loggingEnabled;
  }

  /**
   * Toggle whether debug logging is enabled.
   * <p>
   * <b>WARNING:</b> Enabling this will result in excessive object allocation. This should be only
   * be used for debugging Picasso behavior. Do NOT pass {@code BuildConfig.DEBUG}.
   */
  public void setLoggingEnabled(boolean enabled) {
    loggingEnabled = enabled;
  }

  /**
   * Creates a {@link StatsSnapshot} of the current stats for this instance.
   * <p>
   * <b>NOTE:</b> The snapshot may not always be completely up-to-date if requests are still in
   * progress.
   */
  @SuppressWarnings("UnusedDeclaration") public StatsSnapshot getSnapshot() {
    return stats.createSnapshot();
  }

  /** Stops this instance from accepting further requests. */
  public void shutdown() {
    if (this == singleton) {
      throw new UnsupportedOperationException("Default singleton instance cannot be shutdown.");
    }
    if (shutdown) {
      return;
    }
    cache.clear();
    cleanupThread.shutdown();
    stats.shutdown();
    dispatcher.shutdown();
    for (DeferredRequestCreator deferredRequestCreator : targetToDeferredRequestCreator.values()) {
      deferredRequestCreator.cancel();
    }
    targetToDeferredRequestCreator.clear();
    shutdown = true;
  }

  Request transformRequest(Request request) {
    Request transformed = requestTransformer.transformRequest(request);
    if (transformed == null) {
      throw new IllegalStateException("Request transformer "
          + requestTransformer.getClass().getCanonicalName()
          + " returned null for "
          + request);
    }
    return transformed;
  }

  void defer(ImageView view, DeferredRequestCreator request) {
    targetToDeferredRequestCreator.put(view, request);
  }

  void enqueueAndSubmit(Action action) {
    Object target = action.getTarget();
    if (target != null) {
      // This will also check we are on the main thread.
      cancelExistingRequest(target);
      targetToAction.put(target, action);
    }
    submit(action);
  }

  void submit(Action action) {
    dispatcher.dispatchSubmit(action);
  }

  Bitmap quickMemoryCacheCheck(String key) {
    Bitmap cached = cache.get(key);
    if (cached != null) {
      stats.dispatchCacheHit();
    } else {
      stats.dispatchCacheMiss();
    }
    return cached;
  }

  void complete(BitmapHunter hunter) {
    Action single = hunter.getAction();
    List<Action> joined = hunter.getActions();

    boolean hasMultiple = joined != null && !joined.isEmpty();
    boolean shouldDeliver = single != null || hasMultiple;

    if (!shouldDeliver) {
      return;
    }

    Uri uri = hunter.getData().uri;
    Exception exception = hunter.getException();
    Bitmap result = hunter.getResult();
    LoadedFrom from = hunter.getLoadedFrom();

    if (single != null) {
      deliverAction(result, from, single);
    }

    if (hasMultiple) {
      //noinspection ForLoopReplaceableByForEach
      for (int i = 0, n = joined.size(); i < n; i++) {
        Action join = joined.get(i);
        deliverAction(result, from, join);
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, uri, exception);
    }
  }

  private void deliverAction(Bitmap result, LoadedFrom from, Action action) {
    if (action.isCancelled()) {
      return;
    }
    if (!action.willReplay()) {
      targetToAction.remove(action.getTarget());
    }
    if (result != null) {
      if (from == null) {
        throw new AssertionError("LoadedFrom cannot be null.");
      }
      action.complete(result, from);
      if (loggingEnabled) {
        log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), "from " + from);
      }
    } else {
      action.error();
      if (loggingEnabled) {
        log(OWNER_MAIN, VERB_ERRORED, action.request.logId());
      }
    }
  }

  private void cancelExistingRequest(Object target) {
    checkMain();
    Action action = targetToAction.remove(target);
    if (action != null) {
      action.cancel();
      dispatcher.dispatchCancel(action);
    }
    if (target instanceof ImageView) {
      ImageView targetImageView = (ImageView) target;
      DeferredRequestCreator deferredRequestCreator =
          targetToDeferredRequestCreator.remove(targetImageView);
      if (deferredRequestCreator != null) {
        deferredRequestCreator.cancel();
      }
    }
  }

  public void interruptDispatching() {
    if (dispatcher == null) {
      throw new NullPointerException("The dispatcher is null");
    }

    dispatcher.interruptDispatching();
  }

  public void continueDispatching() {
    if (dispatcher == null) {
      throw new NullPointerException("The dispatcher is null");
    }

    dispatcher.continueDispatching();
  }

  /** Describes where the image was loaded from. */
  public enum LoadedFrom {
    MEMORY(Color.GREEN),
    DISK(Color.YELLOW),
    NETWORK(Color.RED);

    final int debugColor;

    private LoadedFrom(int debugColor) {
      this.debugColor = debugColor;
    }
  }

  /** Callbacks for Picasso events. */
  public interface Listener {
    /**
     * Invoked when an image has failed to load. This is useful for reporting image failures to a
     * remote analytics service, for example.
     */
    void onImageLoadFailed(Picasso picasso, Uri uri, Exception exception);
  }

  /**
   * A transformer that is called immediately before every request is submitted. This can be used
   * to
   * modify any information about a request.
   * <p>
   * For example, if you use a CDN you can change the hostname for the image based on the current
   * location of the user in order to get faster download speeds.
   * <p>
   * <b>NOTE:</b> This is a beta feature. The API is subject to change in a backwards incompatible
   * way at any time.
   */
  public interface RequestTransformer {
    /** A {@link RequestTransformer} which returns the original request. */
    RequestTransformer IDENTITY = new RequestTransformer() {
      @Override public Request transformRequest(Request request) {
        return request;
      }
    };

    /**
     * Transform a request before it is submitted to be processed.
     *
     * @return The original request or a new request to replace it. Must not be null.
     */
    Request transformRequest(Request request);
  }

  private static class CleanupThread extends Thread {
    private final ReferenceQueue<?> referenceQueue;
    private final Handler handler;

    CleanupThread(ReferenceQueue<?> referenceQueue, Handler handler) {
      this.referenceQueue = referenceQueue;
      this.handler = handler;
      setDaemon(true);
      setName(THREAD_PREFIX + "refQueue");
    }

    @Override public void run() {
      Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND);
      while (true) {
        try {
          RequestWeakReference<?> remove = (RequestWeakReference<?>) referenceQueue.remove();
          handler.sendMessage(handler.obtainMessage(REQUEST_GCED, remove.action));
        } catch (InterruptedException e) {
          break;
        } catch (final Exception e) {
          handler.post(new Runnable() {
            @Override public void run() {
              throw new RuntimeException(e);
            }
          });
          break;
        }
      }
    }

    void shutdown() {
      interrupt();
    }
  }

  /** Fluent API for creating {@link Picasso} instances. */
  @SuppressWarnings("UnusedDeclaration") // Public API.
  public static class Builder {
    private final Context context;
    private Downloader downloader;
    private ExecutorService service;
    private Cache cache;
    private Listener listener;
    private RequestTransformer transformer;

    private boolean indicatorsEnabled;
    private boolean loggingEnabled;

    /** Start building a new {@link Picasso} instance. */
    public Builder(Context context) {
      if (context == null) {
        throw new IllegalArgumentException("Context must not be null.");
      }
      this.context = context.getApplicationContext();
    }

    /** Specify the {@link Downloader} that will be used for downloading images. */
    public Builder downloader(Downloader downloader) {
      if (downloader == null) {
        throw new IllegalArgumentException("Downloader must not be null.");
      }
      if (this.downloader != null) {
        throw new IllegalStateException("Downloader already set.");
      }
      this.downloader = downloader;
      return this;
    }

    /** Specify the executor service for loading images in the background. */
    public Builder executor(ExecutorService executorService) {
      if (executorService == null) {
        throw new IllegalArgumentException("Executor service must not be null.");
      }
      if (this.service != null) {
        throw new IllegalStateException("Executor service already set.");
      }
      this.service = executorService;
      return this;
    }

    /** Specify the memory cache used for the most recent images. */
    public Builder memoryCache(Cache memoryCache) {
      if (memoryCache == null) {
        throw new IllegalArgumentException("Memory cache must not be null.");
      }
      if (this.cache != null) {
        throw new IllegalStateException("Memory cache already set.");
      }
      this.cache = memoryCache;
      return this;
    }

    /** Specify a listener for interesting events. */
    public Builder listener(Listener listener) {
      if (listener == null) {
        throw new IllegalArgumentException("Listener must not be null.");
      }
      if (this.listener != null) {
        throw new IllegalStateException("Listener already set.");
      }
      this.listener = listener;
      return this;
    }

    /**
     * Specify a transformer for all incoming requests.
     * <p>
     * <b>NOTE:</b> This is a beta feature. The API is subject to change in a backwards
     * incompatible
     * way at any time.
     */
    public Builder requestTransformer(RequestTransformer transformer) {
      if (transformer == null) {
        throw new IllegalArgumentException("Transformer must not be null.");
      }
      if (this.transformer != null) {
        throw new IllegalStateException("Transformer already set.");
      }
      this.transformer = transformer;
      return this;
    }

    /**
     * @deprecated Use {@link #indicatorsEnabled(boolean)} instead.
     * Whether debugging is enabled or not.
     */
    @Deprecated public Builder debugging(boolean debugging) {
      return indicatorsEnabled(debugging);
    }

    /** Toggle whether to display debug indicators on images. */
    public Builder indicatorsEnabled(boolean enabled) {
      this.indicatorsEnabled = enabled;
      return this;
    }

    /**
     * Toggle whether debug logging is enabled.
     * <p>
     * <b>WARNING:</b> Enabling this will result in excessive object allocation. This should be
     * only
     * be used for debugging purposes. Do NOT pass {@code BuildConfig.DEBUG}.
     */
    public Builder loggingEnabled(boolean enabled) {
      this.loggingEnabled = enabled;
      return this;
    }

    /** Create the {@link Picasso} instance. */
    public Picasso build() {
      Context context = this.context;

      if (downloader == null) {
        downloader = Utils.createDefaultDownloader(context);
      }
      if (cache == null) {
        cache = new LruCache(context);
      }
      if (service == null) {
        service = new PicassoExecutorService();
      }
      if (transformer == null) {
        transformer = RequestTransformer.IDENTITY;
      }

      Stats stats = new Stats(cache);

      Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);

      return new Picasso(context, dispatcher, cache, listener, transformer, stats,
          indicatorsEnabled, loggingEnabled);
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.ColorFilter;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.Point;
import android.graphics.Rect;
import android.graphics.drawable.AnimationDrawable;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.SystemClock;
import android.widget.ImageView;

import static android.graphics.Color.WHITE;
import static com.squareup.picasso.Picasso.LoadedFrom.MEMORY;

final class PicassoDrawable extends BitmapDrawable {
  // Only accessed from main thread.
  private static final Paint DEBUG_PAINT = new Paint();
  private static final float FADE_DURATION = 400f; //ms

  /**
   * Create or update the drawable on the target {@link ImageView} to display the supplied bitmap
   * image.
   */
  static void setBitmap(ImageView target, Context context, Bitmap bitmap,
      Picasso.LoadedFrom loadedFrom, boolean noFade, boolean debugging) {
    Drawable placeholder = target.getDrawable();
    if (placeholder instanceof AnimationDrawable) {
      ((AnimationDrawable) placeholder).stop();
    }
    PicassoDrawable drawable =
        new PicassoDrawable(context, bitmap, placeholder, loadedFrom, noFade, debugging);
    target.setImageDrawable(drawable);
  }

  /**
   * Create or update the drawable on the target {@link ImageView} to display the supplied
   * placeholder image.
   */
  static void setPlaceholder(ImageView target, int placeholderResId, Drawable placeholderDrawable) {
    if (placeholderResId != 0) {
      target.setImageResource(placeholderResId);
    } else {
      target.setImageDrawable(placeholderDrawable);
    }
    if (target.getDrawable() instanceof AnimationDrawable) {
      ((AnimationDrawable) target.getDrawable()).start();
    }
  }

  private final boolean debugging;
  private final float density;
  private final Picasso.LoadedFrom loadedFrom;

  Drawable placeholder;

  long startTimeMillis;
  boolean animating;
  int alpha = 0xFF;

  PicassoDrawable(Context context, Bitmap bitmap, Drawable placeholder,
      Picasso.LoadedFrom loadedFrom, boolean noFade, boolean debugging) {
    super(context.getResources(), bitmap);

    this.debugging = debugging;
    this.density = context.getResources().getDisplayMetrics().density;

    this.loadedFrom = loadedFrom;

    boolean fade = loadedFrom != MEMORY && !noFade;
    if (fade) {
      this.placeholder = placeholder;
      animating = true;
      startTimeMillis = SystemClock.uptimeMillis();
    }
  }

  @Override public void draw(Canvas canvas) {
    if (!animating) {
      super.draw(canvas);
    } else {
      float normalized = (SystemClock.uptimeMillis() - startTimeMillis) / FADE_DURATION;
      if (normalized >= 1f) {
        animating = false;
        placeholder = null;
        super.draw(canvas);
      } else {
        if (placeholder != null) {
          placeholder.draw(canvas);
        }

        int partialAlpha = (int) (alpha * normalized);
        setAlpha(partialAlpha);
        super.draw(canvas);
        setAlpha(alpha);
        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.GINGERBREAD_MR1) {
          invalidateSelf();
        }
      }
    }

    if (debugging) {
      drawDebugIndicator(canvas);
    }
  }

  @Override public void setAlpha(int alpha) {
    if (placeholder != null) {
      placeholder.setAlpha(alpha);
    }
    super.setAlpha(alpha);
  }

  @Override public void setColorFilter(ColorFilter cf) {
    if (placeholder != null) {
      placeholder.setColorFilter(cf);
    }
    super.setColorFilter(cf);
  }

  @Override protected void onBoundsChange(Rect bounds) {
    if (placeholder != null) {
      placeholder.setBounds(bounds);
    }
    super.onBoundsChange(bounds);
  }

  private void drawDebugIndicator(Canvas canvas) {
    DEBUG_PAINT.setColor(WHITE);
    Path path = getTrianglePath(new Point(0, 0), (int) (16 * density));
    canvas.drawPath(path, DEBUG_PAINT);

    DEBUG_PAINT.setColor(loadedFrom.debugColor);
    path = getTrianglePath(new Point(0, 0), (int) (15 * density));
    canvas.drawPath(path, DEBUG_PAINT);
  }

  private static Path getTrianglePath(Point p1, int width) {
    Point p2 = new Point(p1.x + width, p1.y);
    Point p3 = new Point(p1.x, p1.y + width);

    Path path = new Path();
    path.moveTo(p1.x, p1.y);
    path.lineTo(p2.x, p2.y);
    path.lineTo(p3.x, p3.y);

    return path;
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.telephony.TelephonyManager;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * The default {@link java.util.concurrent.ExecutorService} used for new {@link Picasso} instances.
 * <p>
 * Exists as a custom type so that we can differentiate the use of defaults versus a user-supplied
 * instance.
 */
class PicassoExecutorService extends ThreadPoolExecutor {
  private static final int DEFAULT_THREAD_COUNT = 3;
  private boolean isPaused;
  private ReentrantLock pauseLock = new ReentrantLock();
  private Condition unpaused = pauseLock.newCondition();

  PicassoExecutorService() {
    super(DEFAULT_THREAD_COUNT, DEFAULT_THREAD_COUNT, 0, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(), new Utils.PicassoThreadFactory());
  }

  void adjustThreadCount(NetworkInfo info) {
    if (info == null || !info.isConnectedOrConnecting()) {
      setThreadCount(DEFAULT_THREAD_COUNT);
      return;
    }
    switch (info.getType()) {
      case ConnectivityManager.TYPE_WIFI:
      case ConnectivityManager.TYPE_WIMAX:
      case ConnectivityManager.TYPE_ETHERNET:
        setThreadCount(4);
        break;
      case ConnectivityManager.TYPE_MOBILE:
        switch (info.getSubtype()) {
          case TelephonyManager.NETWORK_TYPE_LTE:  // 4G
          case TelephonyManager.NETWORK_TYPE_HSPAP:
          case TelephonyManager.NETWORK_TYPE_EHRPD:
            setThreadCount(3);
            break;
          case TelephonyManager.NETWORK_TYPE_UMTS: // 3G
          case TelephonyManager.NETWORK_TYPE_CDMA:
          case TelephonyManager.NETWORK_TYPE_EVDO_0:
          case TelephonyManager.NETWORK_TYPE_EVDO_A:
          case TelephonyManager.NETWORK_TYPE_EVDO_B:
            setThreadCount(2);
            break;
          case TelephonyManager.NETWORK_TYPE_GPRS: // 2G
          case TelephonyManager.NETWORK_TYPE_EDGE:
            setThreadCount(1);
            break;
          default:
            setThreadCount(DEFAULT_THREAD_COUNT);
        }
        break;
      default:
        setThreadCount(DEFAULT_THREAD_COUNT);
    }
  }

  private void setThreadCount(int threadCount) {
    setCorePoolSize(threadCount);
    setMaximumPoolSize(threadCount);
  }

  @Override
  protected void beforeExecute(Thread t, Runnable r) {
    super.beforeExecute(t, r);
    pauseLock.lock();
    try {
      while (isPaused) unpaused.await();
    } catch (InterruptedException ie) {
      t.interrupt();
    } finally {
      pauseLock.unlock();
    }
  }

  public void pause() {
    pauseLock.lock();
    try {
      isPaused = true;
    } finally {
      pauseLock.unlock();
    }
  }

  public void resume() {
    pauseLock.lock();
    try {
      isPaused = false;
      unpaused.signalAll();
    } finally {
      pauseLock.unlock();
    }
  }

}

@#$
/*
 * Copyright (C) 2014 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.app.Notification;
import android.app.NotificationManager;
import android.appwidget.AppWidgetManager;
import android.graphics.Bitmap;
import android.widget.RemoteViews;

import static android.content.Context.NOTIFICATION_SERVICE;
import static com.squareup.picasso.Utils.getService;

abstract class RemoteViewsAction extends Action<RemoteViewsAction.RemoteViewsTarget> {
  final RemoteViews remoteViews;
  final int viewId;

  RemoteViewsAction(Picasso picasso, Request data, RemoteViews remoteViews, int viewId,
      int errorResId, boolean skipCache, String key) {
    super(picasso, new RemoteViewsTarget(remoteViews, viewId), data, skipCache, false, errorResId,
        null, key);
    this.remoteViews = remoteViews;
    this.viewId = viewId;
  }

  @Override void complete(Bitmap result, Picasso.LoadedFrom from) {
    remoteViews.setImageViewBitmap(viewId, result);
    update();
  }

  @Override public void error() {
    if (errorResId != 0) {
      setImageResource(errorResId);
    }
  }

  void setImageResource(int resId) {
    remoteViews.setImageViewResource(viewId, resId);
    update();
  }

  abstract void update();

  static class RemoteViewsTarget {
    final RemoteViews remoteViews;
    final int viewId;

    RemoteViewsTarget(RemoteViews remoteViews, int viewId) {
      this.remoteViews = remoteViews;
      this.viewId = viewId;
    }

    @Override public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      RemoteViewsTarget remoteViewsTarget = (RemoteViewsTarget) o;
      return viewId == remoteViewsTarget.viewId && remoteViews.equals(
          remoteViewsTarget.remoteViews);
    }

    @Override public int hashCode() {
      return 31 * remoteViews.hashCode() + viewId;
    }
  }

  static class AppWidgetAction extends RemoteViewsAction {
    private final int[] appWidgetIds;

    AppWidgetAction(Picasso picasso, Request data, RemoteViews remoteViews, int viewId,
        int[] appWidgetIds, boolean skipCache, int errorResId, String key) {
      super(picasso, data, remoteViews, viewId, errorResId, skipCache, key);
      this.appWidgetIds = appWidgetIds;
    }

    @Override void update() {
      AppWidgetManager manager = AppWidgetManager.getInstance(picasso.context);
      manager.updateAppWidget(appWidgetIds, remoteViews);
    }
  }

  static class NotificationAction extends RemoteViewsAction {
    private final int notificationId;
    private final Notification notification;

    NotificationAction(Picasso picasso, Request data, RemoteViews remoteViews, int viewId,
        int notificationId, Notification notification, boolean skipCache, int errorResId,
        String key) {
      super(picasso, data, remoteViews, viewId, errorResId, skipCache, key);
      this.notificationId = notificationId;
      this.notification = notification;
    }

    @Override void update() {
      NotificationManager manager = getService(picasso.context, NOTIFICATION_SERVICE);
      manager.notify(notificationId, notification);
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.graphics.Bitmap;
import android.net.Uri;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

import static java.util.Collections.unmodifiableList;

/** Immutable data about an image and the transformations that will be applied to it. */
public final class Request {
  private static final long TOO_LONG_LOG = TimeUnit.SECONDS.toNanos(5);

  /** A unique ID for the request. */
  int id;
  /** The time that the request was first submitted (in nanos). */
  long started;

  /**
   * The image URI.
   * <p>
   * This is mutually exclusive with {@link #resourceId}.
   */
  public final Uri uri;
  /**
   * The image resource ID.
   * <p>
   * This is mutually exclusive with {@link #uri}.
   */
  public final int resourceId;
  /** List of custom transformations to be applied after the built-in transformations. */
  public final List<Transformation> transformations;
  /** Target image width for resizing. */
  public final int targetWidth;
  /** Target image height for resizing. */
  public final int targetHeight;
  /**
   * True if the final image should use the 'centerCrop' scale technique.
   * <p>
   * This is mutually exclusive with {@link #centerInside}.
   */
  public final boolean centerCrop;
  /**
   * True if the final image should use the 'centerInside' scale technique.
   * <p>
   * This is mutually exclusive with {@link #centerCrop}.
   */
  public final boolean centerInside;
  /** Amount to rotate the image in degrees. */
  public final float rotationDegrees;
  /** Rotation pivot on the X axis. */
  public final float rotationPivotX;
  /** Rotation pivot on the Y axis. */
  public final float rotationPivotY;
  /** Whether or not {@link #rotationPivotX} and {@link #rotationPivotY} are set. */
  public final boolean hasRotationPivot;
  /** Target image config for decoding. */
  public final Bitmap.Config config;

  private Request(Uri uri, int resourceId, List<Transformation> transformations, int targetWidth,
      int targetHeight, boolean centerCrop, boolean centerInside, float rotationDegrees,
      float rotationPivotX, float rotationPivotY, boolean hasRotationPivot, Bitmap.Config config) {
    this.uri = uri;
    this.resourceId = resourceId;
    if (transformations == null) {
      this.transformations = null;
    } else {
      this.transformations = unmodifiableList(transformations);
    }
    this.targetWidth = targetWidth;
    this.targetHeight = targetHeight;
    this.centerCrop = centerCrop;
    this.centerInside = centerInside;
    this.rotationDegrees = rotationDegrees;
    this.rotationPivotX = rotationPivotX;
    this.rotationPivotY = rotationPivotY;
    this.hasRotationPivot = hasRotationPivot;
    this.config = config;
  }

  @Override public String toString() {
    final StringBuilder sb = new StringBuilder("Request{");
    if (resourceId > 0) {
      sb.append(resourceId);
    } else {
      sb.append(uri);
    }
    if (transformations != null && !transformations.isEmpty()) {
      for (Transformation transformation : transformations) {
        sb.append(' ').append(transformation.key());
      }
    }
    if (targetWidth > 0) {
      sb.append(" resize(").append(targetWidth).append(',').append(targetHeight).append(')');
    }
    if (centerCrop) {
      sb.append(" centerCrop");
    }
    if (centerInside) {
      sb.append(" centerInside");
    }
    if (rotationDegrees != 0) {
      sb.append(" rotation(").append(rotationDegrees);
      if (hasRotationPivot) {
        sb.append(" @ ").append(rotationPivotX).append(',').append(rotationPivotY);
      }
      sb.append(')');
    }
    if (config != null) {
      sb.append(' ').append(config);
    }
    sb.append('}');

    return sb.toString();
  }

  String logId() {
    long delta = System.nanoTime() - started;
    if (delta > TOO_LONG_LOG) {
      return plainId() + '+' + TimeUnit.NANOSECONDS.toSeconds(delta) + 's';
    }
    return plainId() + '+' + TimeUnit.NANOSECONDS.toMillis(delta) + "ms";
  }

  String plainId() {
    return "[R" + id + ']';
  }

  String getName() {
    if (uri != null) {
      return uri.getPath();
    }
    return Integer.toHexString(resourceId);
  }

  public boolean hasSize() {
    return targetWidth != 0;
  }

  boolean needsTransformation() {
    return needsMatrixTransform() || hasCustomTransformations();
  }

  boolean needsMatrixTransform() {
    return targetWidth != 0 || rotationDegrees != 0;
  }

  boolean hasCustomTransformations() {
    return transformations != null;
  }

  public Builder buildUpon() {
    return new Builder(this);
  }

  /** Builder for creating {@link Request} instances. */
  public static final class Builder {
    private Uri uri;
    private int resourceId;
    private int targetWidth;
    private int targetHeight;
    private boolean centerCrop;
    private boolean centerInside;
    private float rotationDegrees;
    private float rotationPivotX;
    private float rotationPivotY;
    private boolean hasRotationPivot;
    private List<Transformation> transformations;
    private Bitmap.Config config;

    /** Start building a request using the specified {@link Uri}. */
    public Builder(Uri uri) {
      setUri(uri);
    }

    /** Start building a request using the specified resource ID. */
    public Builder(int resourceId) {
      setResourceId(resourceId);
    }

    Builder(Uri uri, int resourceId) {
      this.uri = uri;
      this.resourceId = resourceId;
    }

    private Builder(Request request) {
      uri = request.uri;
      resourceId = request.resourceId;
      targetWidth = request.targetWidth;
      targetHeight = request.targetHeight;
      centerCrop = request.centerCrop;
      centerInside = request.centerInside;
      rotationDegrees = request.rotationDegrees;
      rotationPivotX = request.rotationPivotX;
      rotationPivotY = request.rotationPivotY;
      hasRotationPivot = request.hasRotationPivot;
      if (request.transformations != null) {
        transformations = new ArrayList<Transformation>(request.transformations);
      }
      config = request.config;
    }

    boolean hasImage() {
      return uri != null || resourceId != 0;
    }

    boolean hasSize() {
      return targetWidth != 0;
    }

    /**
     * Set the target image Uri.
     * <p>
     * This will clear an image resource ID if one is set.
     */
    public Builder setUri(Uri uri) {
      if (uri == null) {
        throw new IllegalArgumentException("Image URI may not be null.");
      }
      this.uri = uri;
      this.resourceId = 0;
      return this;
    }

    /**
     * Set the target image resource ID.
     * <p>
     * This will clear an image Uri if one is set.
     */
    public Builder setResourceId(int resourceId) {
      if (resourceId == 0) {
        throw new IllegalArgumentException("Image resource ID may not be 0.");
      }
      this.resourceId = resourceId;
      this.uri = null;
      return this;
    }

    /** Resize the image to the specified size in pixels. */
    public Builder resize(int targetWidth, int targetHeight) {
      if (targetWidth <= 0) {
        throw new IllegalArgumentException("Width must be positive number.");
      }
      if (targetHeight <= 0) {
        throw new IllegalArgumentException("Height must be positive number.");
      }
      this.targetWidth = targetWidth;
      this.targetHeight = targetHeight;
      return this;
    }

    /** Clear the resize transformation, if any. This will also clear center crop/inside if set. */
    public Builder clearResize() {
      targetWidth = 0;
      targetHeight = 0;
      centerCrop = false;
      centerInside = false;
      return this;
    }

    /**
     * Crops an image inside of the bounds specified by {@link #resize(int, int)} rather than
     * distorting the aspect ratio. This cropping technique scales the image so that it fills the
     * requested bounds and then crops the extra.
     */
    public Builder centerCrop() {
      if (centerInside) {
        throw new IllegalStateException("Center crop can not be used after calling centerInside");
      }
      centerCrop = true;
      return this;
    }

    /** Clear the center crop transformation flag, if set. */
    public Builder clearCenterCrop() {
      centerCrop = false;
      return this;
    }

    /**
     * Centers an image inside of the bounds specified by {@link #resize(int, int)}. This scales
     * the image so that both dimensions are equal to or less than the requested bounds.
     */
    public Builder centerInside() {
      if (centerCrop) {
        throw new IllegalStateException("Center inside can not be used after calling centerCrop");
      }
      centerInside = true;
      return this;
    }

    /** Clear the center inside transformation flag, if set. */
    public Builder clearCenterInside() {
      centerInside = false;
      return this;
    }

    /** Rotate the image by the specified degrees. */
    public Builder rotate(float degrees) {
      rotationDegrees = degrees;
      return this;
    }

    /** Rotate the image by the specified degrees around a pivot point. */
    public Builder rotate(float degrees, float pivotX, float pivotY) {
      rotationDegrees = degrees;
      rotationPivotX = pivotX;
      rotationPivotY = pivotY;
      hasRotationPivot = true;
      return this;
    }

    /** Clear the rotation transformation, if any. */
    public Builder clearRotation() {
      rotationDegrees = 0;
      rotationPivotX = 0;
      rotationPivotY = 0;
      hasRotationPivot = false;
      return this;
    }

    /** Decode the image using the specified config. */
    public Builder config(Bitmap.Config config) {
      this.config = config;
      return this;
    }

    /**
     * Add a custom transformation to be applied to the image.
     * <p>
     * Custom transformations will always be run after the built-in transformations.
     */
    public Builder transform(Transformation transformation) {
      if (transformation == null) {
        throw new IllegalArgumentException("Transformation must not be null.");
      }
      if (transformations == null) {
        transformations = new ArrayList<Transformation>(2);
      }
      transformations.add(transformation);
      return this;
    }

    /** Create the immutable {@link Request} object. */
    public Request build() {
      if (centerInside && centerCrop) {
        throw new IllegalStateException("Center crop and center inside can not be used together.");
      }
      if (centerCrop && targetWidth == 0) {
        throw new IllegalStateException("Center crop requires calling resize.");
      }
      if (centerInside && targetWidth == 0) {
        throw new IllegalStateException("Center inside requires calling resize.");
      }
      return new Request(uri, resourceId, transformations, targetWidth, targetHeight, centerCrop,
          centerInside, rotationDegrees, rotationPivotX, rotationPivotY, hasRotationPivot, config);
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.app.Notification;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.widget.ImageView;
import android.widget.RemoteViews;
import java.io.IOException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;
import org.jetbrains.annotations.TestOnly;

import static com.squareup.picasso.BitmapHunter.forRequest;
import static com.squareup.picasso.Picasso.LoadedFrom.MEMORY;
import static com.squareup.picasso.PicassoDrawable.setBitmap;
import static com.squareup.picasso.PicassoDrawable.setPlaceholder;
import static com.squareup.picasso.RemoteViewsAction.AppWidgetAction;
import static com.squareup.picasso.RemoteViewsAction.NotificationAction;
import static com.squareup.picasso.Utils.OWNER_MAIN;
import static com.squareup.picasso.Utils.VERB_CHANGED;
import static com.squareup.picasso.Utils.VERB_COMPLETED;
import static com.squareup.picasso.Utils.VERB_CREATED;
import static com.squareup.picasso.Utils.checkMain;
import static com.squareup.picasso.Utils.checkNotMain;
import static com.squareup.picasso.Utils.createKey;
import static com.squareup.picasso.Utils.isMain;
import static com.squareup.picasso.Utils.log;

/** Fluent API for building an image download request. */
@SuppressWarnings("UnusedDeclaration") // Public API.
public class RequestCreator {
  private static int nextId = 0;

  private static int getRequestId() {
    if (isMain()) {
      return nextId++;
    }

    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicInteger id = new AtomicInteger();
    Picasso.HANDLER.post(new Runnable() {
      @Override public void run() {
        id.set(getRequestId());
        latch.countDown();
      }
    });
    try {
      latch.await();
    } catch (final InterruptedException e) {
      Picasso.HANDLER.post(new Runnable() {
        @Override public void run() {
          throw new RuntimeException(e);
        }
      });
    }
    return id.get();
  }

  private final Picasso picasso;
  private final Request.Builder data;

  private boolean skipMemoryCache;
  private boolean noFade;
  private boolean deferred;
  private int placeholderResId;
  private int errorResId;
  private Drawable placeholderDrawable;
  private Drawable errorDrawable;

  RequestCreator(Picasso picasso, Uri uri, int resourceId) {
    if (picasso.shutdown) {
      throw new IllegalStateException(
          "Picasso instance already shut down. Cannot submit new requests.");
    }
    this.picasso = picasso;
    this.data = new Request.Builder(uri, resourceId);
  }

  @TestOnly RequestCreator() {
    this.picasso = null;
    this.data = new Request.Builder(null, 0);
  }

  /**
   * A placeholder drawable to be used while the image is being loaded. If the requested image is
   * not immediately available in the memory cache then this resource will be set on the target
   * {@link ImageView}.
   */
  public RequestCreator placeholder(int placeholderResId) {
    if (placeholderResId == 0) {
      throw new IllegalArgumentException("Placeholder image resource invalid.");
    }
    if (placeholderDrawable != null) {
      throw new IllegalStateException("Placeholder image already set.");
    }
    this.placeholderResId = placeholderResId;
    return this;
  }

  /**
   * A placeholder drawable to be used while the image is being loaded. If the requested image is
   * not immediately available in the memory cache then this resource will be set on the target
   * {@link ImageView}.
   * <p>
   * If you are not using a placeholder image but want to clear an existing image (such as when
   * used in an {@link android.widget.Adapter adapter}), pass in {@code null}.
   */
  public RequestCreator placeholder(Drawable placeholderDrawable) {
    if (placeholderResId != 0) {
      throw new IllegalStateException("Placeholder image already set.");
    }
    this.placeholderDrawable = placeholderDrawable;
    return this;
  }

  /** An error drawable to be used if the request image could not be loaded. */
  public RequestCreator error(int errorResId) {
    if (errorResId == 0) {
      throw new IllegalArgumentException("Error image resource invalid.");
    }
    if (errorDrawable != null) {
      throw new IllegalStateException("Error image already set.");
    }
    this.errorResId = errorResId;
    return this;
  }

  /** An error drawable to be used if the request image could not be loaded. */
  public RequestCreator error(Drawable errorDrawable) {
    if (errorDrawable == null) {
      throw new IllegalArgumentException("Error image may not be null.");
    }
    if (errorResId != 0) {
      throw new IllegalStateException("Error image already set.");
    }
    this.errorDrawable = errorDrawable;
    return this;
  }

  /**
   * Attempt to resize the image to fit exactly into the target {@link ImageView}'s bounds. This
   * will result in delayed execution of the request until the {@link ImageView} has been measured.
   * <p>
   * <em>Note:</em> This method works only when your target is an {@link ImageView}.
   */
  public RequestCreator fit() {
    deferred = true;
    return this;
  }

  /** Internal use only. Used by {@link DeferredRequestCreator}. */
  RequestCreator unfit() {
    deferred = false;
    return this;
  }

  /** Resize the image to the specified dimension size. */
  public RequestCreator resizeDimen(int targetWidthResId, int targetHeightResId) {
    Resources resources = picasso.context.getResources();
    int targetWidth = resources.getDimensionPixelSize(targetWidthResId);
    int targetHeight = resources.getDimensionPixelSize(targetHeightResId);
    return resize(targetWidth, targetHeight);
  }

  /** Resize the image to the specified size in pixels. */
  public RequestCreator resize(int targetWidth, int targetHeight) {
    data.resize(targetWidth, targetHeight);
    return this;
  }

  /**
   * Crops an image inside of the bounds specified by {@link #resize(int, int)} rather than
   * distorting the aspect ratio. This cropping technique scales the image so that it fills the
   * requested bounds and then crops the extra.
   */
  public RequestCreator centerCrop() {
    data.centerCrop();
    return this;
  }

  /**
   * Centers an image inside of the bounds specified by {@link #resize(int, int)}. This scales
   * the image so that both dimensions are equal to or less than the requested bounds.
   */
  public RequestCreator centerInside() {
    data.centerInside();
    return this;
  }

  /** Rotate the image by the specified degrees. */
  public RequestCreator rotate(float degrees) {
    data.rotate(degrees);
    return this;
  }

  /** Rotate the image by the specified degrees around a pivot point. */
  public RequestCreator rotate(float degrees, float pivotX, float pivotY) {
    data.rotate(degrees, pivotX, pivotY);
    return this;
  }

  /**
   * Attempt to decode the image using the specified config.
   * <p>
   * Note: This value may be ignored by {@link BitmapFactory}. See
   * {@link BitmapFactory.Options#inPreferredConfig its documentation} for more details.
   */
  public RequestCreator config(Bitmap.Config config) {
    data.config(config);
    return this;
  }

  /**
   * Add a custom transformation to be applied to the image.
   * <p>
   * Custom transformations will always be run after the built-in transformations.
   */
  // TODO show example of calling resize after a transform in the javadoc
  public RequestCreator transform(Transformation transformation) {
    data.transform(transformation);
    return this;
  }

  /**
   * Indicate that this action should not use the memory cache for attempting to load or save the
   * image. This can be useful when you know an image will only ever be used once (e.g., loading
   * an image from the filesystem and uploading to a remote server).
   */
  public RequestCreator skipMemoryCache() {
    skipMemoryCache = true;
    return this;
  }

  /** Disable brief fade in of images loaded from the disk cache or network. */
  public RequestCreator noFade() {
    noFade = true;
    return this;
  }

  /**
   * Synchronously fulfill this request. Must not be called from the main thread.
   * <p>
   * <em>Note</em>: The result of this operation is not cached in memory because the underlying
   * {@link Cache} implementation is not guaranteed to be thread-safe.
   */
  public Bitmap get() throws IOException {
    long started = System.nanoTime();
    checkNotMain();

    if (deferred) {
      throw new IllegalStateException("Fit cannot be used with get.");
    }
    if (!data.hasImage()) {
      return null;
    }

    Request finalData = createRequest(started);
    String key = createKey(finalData, new StringBuilder());

    Action action = new GetAction(picasso, finalData, skipMemoryCache, key);
    return forRequest(picasso.context, picasso, picasso.dispatcher, picasso.cache, picasso.stats,
        action, picasso.dispatcher.downloader).hunt();
  }

  /**
   * Asynchronously fulfills the request without a {@link ImageView} or {@link Target}. This is
   * useful when you want to warm up the cache with an image.
   * <p>
   * <em>Note:</em> It is safe to invoke this method from any thread.
   */
  public void fetch() {
    long started = System.nanoTime();

    if (deferred) {
      throw new IllegalStateException("Fit cannot be used with fetch.");
    }
    if (data.hasImage()) {
      Request request = createRequest(started);
      String key = createKey(request, new StringBuilder());

      Action action = new FetchAction(picasso, request, skipMemoryCache, key);
      picasso.submit(action);
    }
  }

  /**
   * Asynchronously fulfills the request into the specified {@link Target}. In most cases, you
   * should use this when you are dealing with a custom {@link android.view.View View} or view
   * holder which should implement the {@link Target} interface.
   * <p>
   * Implementing on a {@link android.view.View View}:
   * <blockquote><pre>
   * public class ProfileView extends FrameLayout implements Target {
   *   {@literal @}Override public void onBitmapLoaded(Bitmap bitmap, LoadedFrom from) {
   *     setBackgroundDrawable(new BitmapDrawable(bitmap));
   *   }
   *
   *   {@literal @}Override public void onBitmapFailed() {
   *     setBackgroundResource(R.drawable.profile_error);
   *   }
   *
   *   {@literal @}Override public void onPrepareLoad(Drawable placeHolderDrawable) {
   *     frame.setBackgroundDrawable(placeHolderDrawable);
   *   }
   * }
   * </pre></blockquote>
   * Implementing on a view holder object for use inside of an adapter:
   * <blockquote><pre>
   * public class ViewHolder implements Target {
   *   public FrameLayout frame;
   *   public TextView name;
   *
   *   {@literal @}Override public void onBitmapLoaded(Bitmap bitmap, LoadedFrom from) {
   *     frame.setBackgroundDrawable(new BitmapDrawable(bitmap));
   *   }
   *
   *   {@literal @}Override public void onBitmapFailed() {
   *     frame.setBackgroundResource(R.drawable.profile_error);
   *   }
   *
   *   {@literal @}Override public void onPrepareLoad(Drawable placeHolderDrawable) {
   *     frame.setBackgroundDrawable(placeHolderDrawable);
   *   }
   * }
   * </pre></blockquote>
   * <p>
   * <em>Note:</em> This method keeps a weak reference to the {@link Target} instance and will be
   * garbage collected if you do not keep a strong reference to it. To receive callbacks when an
   * image is loaded use {@link #into(android.widget.ImageView, Callback)}.
   */
  public void into(Target target) {
    long started = System.nanoTime();
    checkMain();

    if (target == null) {
      throw new IllegalArgumentException("Target must not be null.");
    }
    if (deferred) {
      throw new IllegalStateException("Fit cannot be used with a Target.");
    }

    Drawable drawable =
        placeholderResId != 0 ? picasso.context.getResources().getDrawable(placeholderResId)
            : placeholderDrawable;

    if (!data.hasImage()) {
      picasso.cancelRequest(target);
      target.onPrepareLoad(drawable);
      return;
    }

    Request request = createRequest(started);
    String requestKey = createKey(request);

    if (!skipMemoryCache) {
      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);
      if (bitmap != null) {
        picasso.cancelRequest(target);
        target.onBitmapLoaded(bitmap, MEMORY);
        return;
      }
    }

    target.onPrepareLoad(drawable);

    Action action =
        new TargetAction(picasso, target, request, skipMemoryCache, errorResId, errorDrawable,
            requestKey);
    picasso.enqueueAndSubmit(action);
  }

  /**
   * Asynchronously fulfills the request into the specified {@link RemoteViews} object with the
   * given {@code viewId}. This is used for loading bitmaps into a {@link Notification}.
   */
  public void into(RemoteViews remoteViews, int viewId, int notificationId,
      Notification notification) {
    long started = System.nanoTime();
    checkMain();

    if (remoteViews == null) {
      throw new IllegalArgumentException("RemoteViews must not be null.");
    }
    if (notification == null) {
      throw new IllegalArgumentException("Notification must not be null.");
    }
    if (deferred) {
      throw new IllegalStateException("Fit cannot be used with RemoteViews.");
    }
    if (placeholderDrawable != null || errorDrawable != null) {
      throw new IllegalArgumentException(
          "Cannot use placeholder or error drawables with remote views.");
    }

    Request request = createRequest(started);
    String key = createKey(request);

    RemoteViewsAction action =
        new NotificationAction(picasso, request, remoteViews, viewId, notificationId, notification,
            skipMemoryCache, errorResId, key);

    performRemoteViewInto(action);
  }

  /**
   * Asynchronously fulfills the request into the specified {@link RemoteViews} object with the
   * given {@code viewId}. This is used for loading bitmaps into all instances of a widget.
   */
  public void into(RemoteViews remoteViews, int viewId, int[] appWidgetIds) {
    long started = System.nanoTime();
    checkMain();

    if (remoteViews == null) {
      throw new IllegalArgumentException("remoteViews must not be null.");
    }
    if (appWidgetIds == null) {
      throw new IllegalArgumentException("appWidgetIds must not be null.");
    }
    if (deferred) {
      throw new IllegalStateException("Fit cannot be used with remote views.");
    }
    if (placeholderDrawable != null || errorDrawable != null) {
      throw new IllegalArgumentException(
          "Cannot use placeholder or error drawables with remote views.");
    }

    Request request = createRequest(started);
    String key = createKey(request);

    RemoteViewsAction action =
        new AppWidgetAction(picasso, request, remoteViews, viewId, appWidgetIds, skipMemoryCache,
            errorResId, key);

    performRemoteViewInto(action);
  }

  /**
   * Asynchronously fulfills the request into the specified {@link ImageView}.
   * <p>
   * <em>Note:</em> This method keeps a weak reference to the {@link ImageView} instance and will
   * automatically support object recycling.
   */
  public void into(ImageView target) {
    into(target, null);
  }

  /**
   * Asynchronously fulfills the request into the specified {@link ImageView} and invokes the
   * target {@link Callback} if it's not {@code null}.
   * <p>
   * <em>Note:</em> The {@link Callback} param is a strong reference and will prevent your
   * {@link android.app.Activity} or {@link android.app.Fragment} from being garbage collected. If
   * you use this method, it is <b>strongly</b> recommended you invoke an adjacent
   * {@link Picasso#cancelRequest(android.widget.ImageView)} call to prevent temporary leaking.
   */
  public void into(ImageView target, Callback callback) {
    long started = System.nanoTime();
    checkMain();

    if (target == null) {
      throw new IllegalArgumentException("Target must not be null.");
    }

    if (!data.hasImage()) {
      picasso.cancelRequest(target);
      setPlaceholder(target, placeholderResId, placeholderDrawable);
      return;
    }

    if (deferred) {
      if (data.hasSize()) {
        throw new IllegalStateException("Fit cannot be used with resize.");
      }
      int measuredWidth = target.getMeasuredWidth();
      int measuredHeight = target.getMeasuredHeight();
      if (measuredWidth == 0 || measuredHeight == 0) {
        setPlaceholder(target, placeholderResId, placeholderDrawable);
        picasso.defer(target, new DeferredRequestCreator(this, target, callback));
        return;
      }
      data.resize(measuredWidth, measuredHeight);
    }

    Request request = createRequest(started);
    String requestKey = createKey(request);

    if (!skipMemoryCache) {
      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);
      if (bitmap != null) {
        picasso.cancelRequest(target);
        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);
        if (picasso.loggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + MEMORY);
        }
        if (callback != null) {
          callback.onSuccess();
        }
        return;
      }
    }

    setPlaceholder(target, placeholderResId, placeholderDrawable);

    Action action =
        new ImageViewAction(picasso, target, request, skipMemoryCache, noFade, errorResId,
            errorDrawable, requestKey, callback);

    picasso.enqueueAndSubmit(action);
  }

  /** Create the request optionally passing it through the request transformer. */
  private Request createRequest(long started) {
    int id = getRequestId();

    Request request = data.build();
    request.id = id;
    request.started = started;

    boolean loggingEnabled = picasso.loggingEnabled;
    if (loggingEnabled) {
      log(OWNER_MAIN, VERB_CREATED, request.plainId(), request.toString());
    }

    Request transformed = picasso.transformRequest(request);
    if (transformed != request) {
      // If the request was changed, copy over the id and timestamp from the original.
      transformed.id = id;
      transformed.started = started;

      if (loggingEnabled) {
        log(OWNER_MAIN, VERB_CHANGED, transformed.logId(), "into " + transformed);
      }
    }

    return transformed;
  }

  private void performRemoteViewInto(RemoteViewsAction action) {
    if (!skipMemoryCache) {
      Bitmap bitmap = picasso.quickMemoryCacheCheck(action.getKey());
      if (bitmap != null) {
        action.complete(bitmap, MEMORY);
        return;
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId);
    }

    picasso.enqueueAndSubmit(action);
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import java.io.IOException;

import static com.squareup.picasso.Picasso.LoadedFrom.DISK;

class ResourceBitmapHunter extends BitmapHunter {
  private final Context context;

  ResourceBitmapHunter(Context context, Picasso picasso, Dispatcher dispatcher, Cache cache,
      Stats stats, Action action) {
    super(picasso, dispatcher, cache, stats, action);
    this.context = context;
  }

  @Override Bitmap decode(Request data) throws IOException {
    Resources res = Utils.getResources(context, data);
    int id = Utils.getResourceId(res, data);
    return decodeResource(res, id, data);
  }

  @Override Picasso.LoadedFrom getLoadedFrom() {
    return DISK;
  }

  private Bitmap decodeResource(Resources resources, int id, Request data) {
    final BitmapFactory.Options options = createBitmapOptions(data);
    if (requiresInSampleSize(options)) {
      BitmapFactory.decodeResource(resources, id, options);
      calculateInSampleSize(data.targetWidth, data.targetHeight, options);
    }
    return BitmapFactory.decodeResource(resources, id, options);
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.graphics.Bitmap;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Message;

import static android.os.Process.THREAD_PRIORITY_BACKGROUND;

class Stats {
  private static final int CACHE_HIT = 0;
  private static final int CACHE_MISS = 1;
  private static final int BITMAP_DECODE_FINISHED = 2;
  private static final int BITMAP_TRANSFORMED_FINISHED = 3;
  private static final int DOWNLOAD_FINISHED = 4;

  private static final String STATS_THREAD_NAME = Utils.THREAD_PREFIX + "Stats";

  final HandlerThread statsThread;
  final Cache cache;
  final Handler handler;

  long cacheHits;
  long cacheMisses;
  long totalDownloadSize;
  long totalOriginalBitmapSize;
  long totalTransformedBitmapSize;
  long averageDownloadSize;
  long averageOriginalBitmapSize;
  long averageTransformedBitmapSize;
  int downloadCount;
  int originalBitmapCount;
  int transformedBitmapCount;

  Stats(Cache cache) {
    this.cache = cache;
    this.statsThread = new HandlerThread(STATS_THREAD_NAME, THREAD_PRIORITY_BACKGROUND);
    this.statsThread.start();
    this.handler = new StatsHandler(statsThread.getLooper(), this);
  }

  void dispatchBitmapDecoded(Bitmap bitmap) {
    processBitmap(bitmap, BITMAP_DECODE_FINISHED);
  }

  void dispatchBitmapTransformed(Bitmap bitmap) {
    processBitmap(bitmap, BITMAP_TRANSFORMED_FINISHED);
  }

  void dispatchDownloadFinished(long size) {
    handler.sendMessage(handler.obtainMessage(DOWNLOAD_FINISHED, size));
  }

  void dispatchCacheHit() {
    handler.sendEmptyMessage(CACHE_HIT);
  }

  void dispatchCacheMiss() {
    handler.sendEmptyMessage(CACHE_MISS);
  }

  void shutdown() {
    statsThread.quit();
  }

  void performCacheHit() {
    cacheHits++;
  }

  void performCacheMiss() {
    cacheMisses++;
  }

  void performDownloadFinished(Long size) {
    downloadCount++;
    totalDownloadSize += size;
    averageDownloadSize = getAverage(downloadCount, totalDownloadSize);
  }

  void performBitmapDecoded(long size) {
    originalBitmapCount++;
    totalOriginalBitmapSize += size;
    averageOriginalBitmapSize = getAverage(originalBitmapCount, totalOriginalBitmapSize);
  }

  void performBitmapTransformed(long size) {
    transformedBitmapCount++;
    totalTransformedBitmapSize += size;
    averageTransformedBitmapSize = getAverage(originalBitmapCount, totalTransformedBitmapSize);
  }

  StatsSnapshot createSnapshot() {
    return new StatsSnapshot(cache.maxSize(), cache.size(), cacheHits, cacheMisses,
        totalDownloadSize, totalOriginalBitmapSize, totalTransformedBitmapSize, averageDownloadSize,
        averageOriginalBitmapSize, averageTransformedBitmapSize, downloadCount, originalBitmapCount,
        transformedBitmapCount, System.currentTimeMillis());
  }

  private void processBitmap(Bitmap bitmap, int what) {
    // Never send bitmaps to the handler as they could be recycled before we process them.
    int bitmapSize = Utils.getBitmapBytes(bitmap);
    handler.sendMessage(handler.obtainMessage(what, bitmapSize, 0));
  }

  private static long getAverage(int count, long totalSize) {
    return totalSize / count;
  }

  private static class StatsHandler extends Handler {

    private final Stats stats;

    public StatsHandler(Looper looper, Stats stats) {
      super(looper);
      this.stats = stats;
    }

    @Override public void handleMessage(final Message msg) {
      switch (msg.what) {
        case CACHE_HIT:
          stats.performCacheHit();
          break;
        case CACHE_MISS:
          stats.performCacheMiss();
          break;
        case BITMAP_DECODE_FINISHED:
          stats.performBitmapDecoded(msg.arg1);
          break;
        case BITMAP_TRANSFORMED_FINISHED:
          stats.performBitmapTransformed(msg.arg1);
          break;
        case DOWNLOAD_FINISHED:
          stats.performDownloadFinished((Long) msg.obj);
          break;
        default:
          Picasso.HANDLER.post(new Runnable() {
            @Override public void run() {
              throw new AssertionError("Unhandled stats message." + msg.what);
            }
          });
      }
    }
  }
}
@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.util.Log;
import java.io.PrintWriter;
import java.io.StringWriter;

import static com.squareup.picasso.Picasso.TAG;

/** Represents all stats for a {@link Picasso} instance at a single point in time. */
public class StatsSnapshot {
  public final int maxSize;
  public final int size;
  public final long cacheHits;
  public final long cacheMisses;
  public final long totalDownloadSize;
  public final long totalOriginalBitmapSize;
  public final long totalTransformedBitmapSize;
  public final long averageDownloadSize;
  public final long averageOriginalBitmapSize;
  public final long averageTransformedBitmapSize;
  public final int downloadCount;
  public final int originalBitmapCount;
  public final int transformedBitmapCount;

  public final long timeStamp;

  public StatsSnapshot(int maxSize, int size, long cacheHits, long cacheMisses,
      long totalDownloadSize, long totalOriginalBitmapSize, long totalTransformedBitmapSize,
      long averageDownloadSize, long averageOriginalBitmapSize, long averageTransformedBitmapSize,
      int downloadCount, int originalBitmapCount, int transformedBitmapCount, long timeStamp) {
    this.maxSize = maxSize;
    this.size = size;
    this.cacheHits = cacheHits;
    this.cacheMisses = cacheMisses;
    this.totalDownloadSize = totalDownloadSize;
    this.totalOriginalBitmapSize = totalOriginalBitmapSize;
    this.totalTransformedBitmapSize = totalTransformedBitmapSize;
    this.averageDownloadSize = averageDownloadSize;
    this.averageOriginalBitmapSize = averageOriginalBitmapSize;
    this.averageTransformedBitmapSize = averageTransformedBitmapSize;
    this.downloadCount = downloadCount;
    this.originalBitmapCount = originalBitmapCount;
    this.transformedBitmapCount = transformedBitmapCount;
    this.timeStamp = timeStamp;
  }

  /** Prints out this {@link StatsSnapshot} into log. */
  @SuppressWarnings("UnusedDeclaration") public void dump() {
    StringWriter logWriter = new StringWriter();
    dump(new PrintWriter(logWriter));
    Log.i(TAG, logWriter.toString());
  }

  /** Prints out this {@link StatsSnapshot} with the the provided {@link PrintWriter}. */
  public void dump(PrintWriter writer) {
    writer.println("===============BEGIN PICASSO STATS ===============");
    writer.println("Memory Cache Stats");
    writer.print("  Max Cache Size: ");
    writer.println(maxSize);
    writer.print("  Cache Size: ");
    writer.println(size);
    writer.print("  Cache % Full: ");
    writer.println((int) Math.ceil((float) size / maxSize * 100));
    writer.print("  Cache Hits: ");
    writer.println(cacheHits);
    writer.print("  Cache Misses: ");
    writer.println(cacheMisses);
    writer.println("Network Stats");
    writer.print("  Download Count: ");
    writer.println(downloadCount);
    writer.print("  Total Download Size: ");
    writer.println(totalDownloadSize);
    writer.print("  Average Download Size: ");
    writer.println(averageDownloadSize);
    writer.println("Bitmap Stats");
    writer.print("  Total Bitmaps Decoded: ");
    writer.println(originalBitmapCount);
    writer.print("  Total Bitmap Size: ");
    writer.println(totalOriginalBitmapSize);
    writer.print("  Total Transformed Bitmaps: ");
    writer.println(transformedBitmapCount);
    writer.print("  Total Transformed Bitmap Size: ");
    writer.println(totalTransformedBitmapSize);
    writer.print("  Average Bitmap Size: ");
    writer.println(averageOriginalBitmapSize);
    writer.print("  Average Transformed Bitmap Size: ");
    writer.println(averageTransformedBitmapSize);
    writer.println("===============END PICASSO STATS ===============");
    writer.flush();
  }

  @Override public String toString() {
    return "StatsSnapshot{"
        + "maxSize="
        + maxSize
        + ", size="
        + size
        + ", cacheHits="
        + cacheHits
        + ", cacheMisses="
        + cacheMisses
        + ", downloadCount="
        + downloadCount
        + ", totalDownloadSize="
        + totalDownloadSize
        + ", averageDownloadSize="
        + averageDownloadSize
        + ", totalOriginalBitmapSize="
        + totalOriginalBitmapSize
        + ", totalTransformedBitmapSize="
        + totalTransformedBitmapSize
        + ", averageOriginalBitmapSize="
        + averageOriginalBitmapSize
        + ", averageTransformedBitmapSize="
        + averageTransformedBitmapSize
        + ", originalBitmapCount="
        + originalBitmapCount
        + ", transformedBitmapCount="
        + transformedBitmapCount
        + ", timeStamp="
        + timeStamp
        + '}';
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;

import static com.squareup.picasso.Picasso.LoadedFrom;

/**
 * Represents an arbitrary listener for image loading.
 * <p>
 * Objects implementing this class <strong>must</strong> have a working implementation of
 * {@link Object#equals(Object)} and {@link Object#hashCode()} for proper storage internally.
 * Instances of this interface will also be compared to determine if view recycling is occurring.
 * It is recommended that you add this interface directly on to a custom view type when using in an
 * adapter to ensure correct recycling behavior.
 */
public interface Target {
  /**
   * Callback when an image has been successfully loaded.
   * <p>
   * <strong>Note:</strong> You must not recycle the bitmap.
   */
  void onBitmapLoaded(Bitmap bitmap, LoadedFrom from);

  /**
   * Callback indicating the image could not be successfully loaded.
   * <p>
   * <strong>Note:</strong> The passed {@link Drawable} may be {@code null} if none has been
   * specified via {@link RequestCreator#error(android.graphics.drawable.Drawable)}
   * or {@link RequestCreator#error(int)}.
   */
  void onBitmapFailed(Drawable errorDrawable);

  /**
   * Callback invoked right before your request is submitted.
   * <p>
   * <strong>Note:</strong> The passed {@link Drawable} may be {@code null} if none has been
   * specified via {@link RequestCreator#placeholder(android.graphics.drawable.Drawable)}
   * or {@link RequestCreator#placeholder(int)}.
   */
  void onPrepareLoad(Drawable placeHolderDrawable);
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;

final class TargetAction extends Action<Target> {

  TargetAction(Picasso picasso, Target target, Request data, boolean skipCache,
        int errorResId, Drawable errorDrawable, String key) {
    super(picasso, target, data, skipCache, false, errorResId, errorDrawable, key);
  }

  @Override void complete(Bitmap result, Picasso.LoadedFrom from) {
    if (result == null) {
      throw new AssertionError(
          String.format("Attempted to complete action with no result!\n%s", this));
    }
    Target target = getTarget();
    if (target != null) {
      target.onBitmapLoaded(result, from);
      if (result.isRecycled()) {
        throw new IllegalStateException("Target callback must not recycle bitmap!");
      }
    }
  }

  @Override void error() {
    Target target = getTarget();
    if (target != null) {
      if (errorResId != 0) {
        target.onBitmapFailed(picasso.context.getResources().getDrawable(errorResId));
      } else {
        target.onBitmapFailed(errorDrawable);
      }
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.graphics.Bitmap;

/** Image transformation. */
public interface Transformation {
  /**
   * Transform the source bitmap into a new bitmap. If you create a new bitmap instance, you must
   * call {@link android.graphics.Bitmap#recycle()} on {@code source}. You may return the original
   * if no transformation is required.
   */
  Bitmap transform(Bitmap source);

  /**
   * Returns a unique key for the transformation, used for caching purposes. If the transformation
   * has parameters (e.g. size, scale factor, etc) then these should be part of the key.
   */
  String key();
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.content.Context;
import android.net.Uri;
import android.net.http.HttpResponseCache;
import android.os.Build;
import java.io.File;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;

import static com.squareup.picasso.Utils.parseResponseSourceHeader;

/**
 * A {@link Downloader} which uses {@link HttpURLConnection} to download images. A disk cache of 2%
 * of the total available space will be used (capped at 50MB) will automatically be installed in the
 * application's cache directory, when available.
 */
public class UrlConnectionDownloader implements Downloader {
  static final String RESPONSE_SOURCE = "X-Android-Response-Source";

  private static final Object lock = new Object();
  static volatile Object cache;

  private final Context context;

  public UrlConnectionDownloader(Context context) {
    this.context = context.getApplicationContext();
  }

  protected HttpURLConnection openConnection(Uri path) throws IOException {
    HttpURLConnection connection = (HttpURLConnection) new URL(path.toString()).openConnection();
    connection.setConnectTimeout(Utils.DEFAULT_CONNECT_TIMEOUT);
    connection.setReadTimeout(Utils.DEFAULT_READ_TIMEOUT);
    return connection;
  }

  @Override public Response load(Uri uri, boolean localCacheOnly) throws IOException {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
      installCacheIfNeeded(context);
    }

    HttpURLConnection connection = openConnection(uri);
    connection.setUseCaches(true);
    if (localCacheOnly) {
      connection.setRequestProperty("Cache-Control", "only-if-cached,max-age=" + Integer.MAX_VALUE);
    }

    int responseCode = connection.getResponseCode();
    if (responseCode >= 300) {
      connection.disconnect();
      throw new ResponseException(responseCode + " " + connection.getResponseMessage());
    }

    long contentLength = connection.getHeaderFieldInt("Content-Length", -1);
    boolean fromCache = parseResponseSourceHeader(connection.getHeaderField(RESPONSE_SOURCE));

    return new Response(connection.getInputStream(), fromCache, contentLength);
  }

  private static void installCacheIfNeeded(Context context) {
    // DCL + volatile should be safe after Java 5.
    if (cache == null) {
      try {
        synchronized (lock) {
          if (cache == null) {
            cache = ResponseCacheIcs.install(context);
          }
        }
      } catch (IOException ignored) {
      }
    }
  }

  private static class ResponseCacheIcs {
    static Object install(Context context) throws IOException {
      File cacheDir = Utils.createDefaultCacheDir(context);
      HttpResponseCache cache = HttpResponseCache.getInstalled();
      if (cache == null) {
        long maxSize = Utils.calculateDiskCacheSize(cacheDir);
        cache = HttpResponseCache.install(cacheDir, maxSize);
      }
      return cache;
    }
  }
}

@#$
/*
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.picasso;

import android.annotation.TargetApi;
import android.app.ActivityManager;
import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.os.Looper;
import android.os.Process;
import android.os.StatFs;
import android.provider.Settings;
import android.util.Log;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.concurrent.ThreadFactory;

import static android.content.Context.ACTIVITY_SERVICE;
import static android.content.pm.ApplicationInfo.FLAG_LARGE_HEAP;
import static android.os.Build.VERSION.SDK_INT;
import static android.os.Build.VERSION_CODES.HONEYCOMB;
import static android.os.Build.VERSION_CODES.HONEYCOMB_MR1;
import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
import static android.provider.Settings.System.AIRPLANE_MODE_ON;
import static com.squareup.picasso.Picasso.TAG;
import static java.lang.String.format;

final class Utils {
  static final String THREAD_PREFIX = "Picasso-";
  static final String THREAD_IDLE_NAME = THREAD_PREFIX + "Idle";
  static final int DEFAULT_READ_TIMEOUT = 20 * 1000; // 20s
  static final int DEFAULT_CONNECT_TIMEOUT = 15 * 1000; // 15s
  private static final String PICASSO_CACHE = "picasso-cache";
  private static final int KEY_PADDING = 50; // Determined by exact science.
  private static final int MIN_DISK_CACHE_SIZE = 5 * 1024 * 1024; // 5MB
  private static final int MAX_DISK_CACHE_SIZE = 50 * 1024 * 1024; // 50MB

  /** Thread confined to main thread for key creation. */
  static final StringBuilder MAIN_THREAD_KEY_BUILDER = new StringBuilder();

  /** Logging */
  static final String OWNER_MAIN = "Main";
  static final String OWNER_DISPATCHER = "Dispatcher";
  static final String OWNER_HUNTER = "Hunter";
  static final String VERB_CREATED = "created";
  static final String VERB_CHANGED = "changed";
  static final String VERB_IGNORED = "ignored";
  static final String VERB_ENQUEUED = "enqueued";
  static final String VERB_CANCELED = "canceled";
  static final String VERB_BATCHED = "batched";
  static final String VERB_RETRYING = "retrying";
  static final String VERB_EXECUTING = "executing";
  static final String VERB_DECODED = "decoded";
  static final String VERB_TRANSFORMED = "transformed";
  static final String VERB_JOINED = "joined";
  static final String VERB_REMOVED = "removed";
  static final String VERB_DELIVERED = "delivered";
  static final String VERB_REPLAYING = "replaying";
  static final String VERB_COMPLETED = "completed";
  static final String VERB_ERRORED = "errored";

  /* WebP file header
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      'R'      |      'I'      |      'F'      |      'F'      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           File Size                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      'W'      |      'E'      |      'B'      |      'P'      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  */
  private static final int WEBP_FILE_HEADER_SIZE = 12;
  private static final String WEBP_FILE_HEADER_RIFF = "RIFF";
  private static final String WEBP_FILE_HEADER_WEBP = "WEBP";

  private Utils() {
    // No instances.
  }

  static int getBitmapBytes(Bitmap bitmap) {
    int result;
    if (SDK_INT >= HONEYCOMB_MR1) {
      result = BitmapHoneycombMR1.getByteCount(bitmap);
    } else {
      result = bitmap.getRowBytes() * bitmap.getHeight();
    }
    if (result < 0) {
      throw new IllegalStateException("Negative size: " + bitmap);
    }
    return result;
  }

  static void checkNotMain() {
    if (isMain()) {
      throw new IllegalStateException("Method call should not happen from the main thread.");
    }
  }

  static void checkMain() {
    if (!isMain()) {
      throw new IllegalStateException("Method call should happen from the main thread.");
    }
  }

  static boolean isMain() {
    return Looper.getMainLooper().getThread() == Thread.currentThread();
  }

  static String getLogIdsForHunter(BitmapHunter hunter) {
    return getLogIdsForHunter(hunter, "");
  }

  static String getLogIdsForHunter(BitmapHunter hunter, String prefix) {
    StringBuilder builder = new StringBuilder(prefix);
    Action action = hunter.getAction();
    if (action != null) {
      builder.append(action.request.logId());
    }
    List<Action> actions = hunter.getActions();
    if (actions != null) {
      for (int i = 0, count = actions.size(); i < count; i++) {
        if (i > 0 || action != null) builder.append(", ");
        builder.append(actions.get(i).request.logId());
      }
    }
    return builder.toString();
  }

  static void log(String owner, String verb, String logId) {
    log(owner, verb, logId, "");
  }

  static void log(String owner, String verb, String logId, String extras) {
    Log.d(TAG, format("%1$-11s %2$-12s %3$s %4$s", owner, verb, logId, extras));
  }

  static String createKey(Request data) {
    String result = createKey(data, MAIN_THREAD_KEY_BUILDER);
    MAIN_THREAD_KEY_BUILDER.setLength(0);
    return result;
  }

  static String createKey(Request data, StringBuilder builder) {
    if (data.uri != null) {
      String path = data.uri.toString();
      builder.ensureCapacity(path.length() + KEY_PADDING);
      builder.append(path);
    } else {
      builder.ensureCapacity(KEY_PADDING);
      builder.append(data.resourceId);
    }
    builder.append('\n');

    if (data.rotationDegrees != 0) {
      builder.append("rotation:").append(data.rotationDegrees);
      if (data.hasRotationPivot) {
        builder.append('@').append(data.rotationPivotX).append('x').append(data.rotationPivotY);
      }
      builder.append('\n');
    }
    if (data.targetWidth != 0) {
      builder.append("resize:").append(data.targetWidth).append('x').append(data.targetHeight);
      builder.append('\n');
    }
    if (data.centerCrop) {
      builder.append("centerCrop\n");
    } else if (data.centerInside) {
      builder.append("centerInside\n");
    }

    if (data.transformations != null) {
      //noinspection ForLoopReplaceableByForEach
      for (int i = 0, count = data.transformations.size(); i < count; i++) {
        builder.append(data.transformations.get(i).key());
        builder.append('\n');
      }
    }

    return builder.toString();
  }

  static void closeQuietly(InputStream is) {
    if (is == null) return;
    try {
      is.close();
    } catch (IOException ignored) {
    }
  }

  /** Returns {@code true} if header indicates the response body was loaded from the disk cache. */
  static boolean parseResponseSourceHeader(String header) {
    if (header == null) {
      return false;
    }
    String[] parts = header.split(" ", 2);
    if ("CACHE".equals(parts[0])) {
      return true;
    }
    if (parts.length == 1) {
      return false;
    }
    try {
      return "CONDITIONAL_CACHE".equals(parts[0]) && Integer.parseInt(parts[1]) == 304;
    } catch (NumberFormatException e) {
      return false;
    }
  }

  static Downloader createDefaultDownloader(Context context) {
    boolean okUrlFactory = false;
    try {
      Class.forName("com.squareup.okhttp.OkUrlFactory");
      okUrlFactory = true;
    } catch (ClassNotFoundException ignored) {
    }

    boolean okHttpClient = false;
    try {
      Class.forName("com.squareup.okhttp.OkHttpClient");
      okHttpClient = true;
    } catch (ClassNotFoundException ignored) {
    }

    if (okHttpClient != okUrlFactory) {
      throw new RuntimeException(""
          + "Picasso detected an unsupported OkHttp on the classpath.\n"
          + "To use OkHttp with this version of Picasso, you'll need:\n"
          + "1. com.squareup.okhttp:okhttp:1.6.0 (or newer)\n"
          + "2. com.squareup.okhttp:okhttp-urlconnection:1.6.0 (or newer)\n"
          + "Note that OkHttp 2.0.0+ is supported!");
    }

    return okHttpClient
        ? OkHttpLoaderCreator.create(context)
        : new UrlConnectionDownloader(context);
  }

  static File createDefaultCacheDir(Context context) {
    File cache = new File(context.getApplicationContext().getCacheDir(), PICASSO_CACHE);
    if (!cache.exists()) {
      //noinspection ResultOfMethodCallIgnored
      cache.mkdirs();
    }
    return cache;
  }

  static long calculateDiskCacheSize(File dir) {
    long size = MIN_DISK_CACHE_SIZE;

    try {
      StatFs statFs = new StatFs(dir.getAbsolutePath());
      long available = ((long) statFs.getBlockCount()) * statFs.getBlockSize();
      // Target 2% of the total space.
      size = available / 50;
    } catch (IllegalArgumentException ignored) {
    }

    // Bound inside min/max size for disk cache.
    return Math.max(Math.min(size, MAX_DISK_CACHE_SIZE), MIN_DISK_CACHE_SIZE);
  }

  static int calculateMemoryCacheSize(Context context) {
    ActivityManager am = getService(context, ACTIVITY_SERVICE);
    boolean largeHeap = (context.getApplicationInfo().flags & FLAG_LARGE_HEAP) != 0;
    int memoryClass = am.getMemoryClass();
    if (largeHeap && SDK_INT >= HONEYCOMB) {
      memoryClass = ActivityManagerHoneycomb.getLargeMemoryClass(am);
    }
    // Target ~33% of the available heap.
    return 1024 * 1024 * memoryClass / 3;
  }

  static boolean isAirplaneModeOn(Context context) {
    ContentResolver contentResolver = context.getContentResolver();
    return Settings.System.getInt(contentResolver, AIRPLANE_MODE_ON, 0) != 0;
  }

  @SuppressWarnings("unchecked")
  static <T> T getService(Context context, String service) {
    return (T) context.getSystemService(service);
  }

  static boolean hasPermission(Context context, String permission) {
    return context.checkCallingOrSelfPermission(permission) == PackageManager.PERMISSION_GRANTED;
  }

  static byte[] toByteArray(InputStream input) throws IOException {
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    byte[] buffer = new byte[1024 * 4];
    int n;
    while (-1 != (n = input.read(buffer))) {
      byteArrayOutputStream.write(buffer, 0, n);
    }
    return byteArrayOutputStream.toByteArray();
  }

  static boolean isWebPFile(InputStream stream) throws IOException {
    byte[] fileHeaderBytes = new byte[WEBP_FILE_HEADER_SIZE];
    boolean isWebPFile = false;
    if (stream.read(fileHeaderBytes, 0, WEBP_FILE_HEADER_SIZE) == WEBP_FILE_HEADER_SIZE) {
      // If a file's header starts with RIFF and end with WEBP, the file is a WebP file
      isWebPFile = WEBP_FILE_HEADER_RIFF.equals(new String(fileHeaderBytes, 0, 4, "US-ASCII"))
          && WEBP_FILE_HEADER_WEBP.equals(new String(fileHeaderBytes, 8, 4, "US-ASCII"));
    }
    return isWebPFile;
  }

  static int getResourceId(Resources resources, Request data) throws FileNotFoundException {
    if (data.resourceId != 0 || data.uri == null) {
      return data.resourceId;
    }

    String pkg = data.uri.getAuthority();
    if (pkg == null) throw new FileNotFoundException("No package provided: " + data.uri);

    int id;
    List<String> segments = data.uri.getPathSegments();
    if (segments == null || segments.isEmpty()) {
      throw new FileNotFoundException("No path segments: " + data.uri);
    } else if (segments.size() == 1) {
      try {
        id = Integer.parseInt(segments.get(0));
      } catch (NumberFormatException e) {
        throw new FileNotFoundException("Last path segment is not a resource ID: " + data.uri);
      }
    } else if (segments.size() == 2) {
      String type = segments.get(0);
      String name = segments.get(1);

      id = resources.getIdentifier(name, type, pkg);
    } else {
      throw new FileNotFoundException("More than two path segments: " + data.uri);
    }
    return id;
  }

  static Resources getResources(Context context, Request data) throws FileNotFoundException {
    if (data.resourceId != 0 || data.uri == null) {
      return context.getResources();
    }

    String pkg = data.uri.getAuthority();
    if (pkg == null) throw new FileNotFoundException("No package provided: " + data.uri);
    try {
      PackageManager pm = context.getPackageManager();
      return pm.getResourcesForApplication(pkg);
    } catch (PackageManager.NameNotFoundException e) {
      throw new FileNotFoundException("Unable to obtain resources for package: " + data.uri);
    }
  }

  @TargetApi(HONEYCOMB)
  private static class ActivityManagerHoneycomb {
    static int getLargeMemoryClass(ActivityManager activityManager) {
      return activityManager.getLargeMemoryClass();
    }
  }

  static class PicassoThreadFactory implements ThreadFactory {
    @SuppressWarnings("NullableProblems")
    public Thread newThread(Runnable r) {
      return new PicassoThread(r);
    }
  }

  private static class PicassoThread extends Thread {
    public PicassoThread(Runnable r) {
      super(r);
    }

    @Override public void run() {
      Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND);
      super.run();
    }
  }

  @TargetApi(HONEYCOMB_MR1)
  private static class BitmapHoneycombMR1 {
    static int getByteCount(Bitmap bitmap) {
      return bitmap.getByteCount();
    }
  }

  private static class OkHttpLoaderCreator {
    static Downloader create(Context context) {
      return new OkHttpDownloader(context);
    }
  }
}

@#$
package com.andraskindler.quickscroll;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Path;
import android.util.AttributeSet;
import android.view.View;

public class Pin extends View {

    private static final int mPinColor = Color.argb(224, 66, 66, 66);
    private Paint mPaint;
    private Path mPath;

    public Pin(Context context) {
        super(context);
        init();
    }

    public Pin(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public Pin(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init();
    }

    public void setColor(int color) {
        mPaint.setColor(color);
    }

    private void init() {
        mPath = new Path();
        mPaint = new Paint();
        mPaint.setAntiAlias(true);
        mPaint.setStyle(Paint.Style.FILL);
        setColor(mPinColor);
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        if (changed) {
            mPath.reset();
            mPath.moveTo(0, getHeight());
            mPath.lineTo(getWidth(), getHeight() / 2);
            mPath.lineTo(0, 0);
            mPath.close();
        }
        super.onLayout(changed, left, top, right, bottom);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        canvas.drawPath(mPath, mPaint);
        super.onDraw(canvas);
    }

}

@#$
package com.andraskindler.quickscroll;

import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Color;
import android.graphics.drawable.GradientDrawable;
import android.graphics.drawable.StateListDrawable;
import android.os.Build;
import android.util.AttributeSet;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.widget.*;
import android.widget.AbsListView.OnScrollListener;

import com.squareup.picasso.Picasso;

public class QuickScroll extends View {

    // IDs
    protected static final int ID_PIN = 512;
    protected static final int ID_PIN_TEXT = 513;
    // type statics
    public static final int TYPE_POPUP = 0;
    public static final int TYPE_INDICATOR = 1;
    public static final int TYPE_POPUP_WITH_HANDLE = 2;
    public static final int TYPE_INDICATOR_WITH_HANDLE = 3;
    // style statics
    public static final int STYLE_NONE = 0;
    public static final int STYLE_HOLO = 1;
    // base colors
    public static final int GREY_DARK = Color.parseColor("#e0585858");
    public static final int GREY_LIGHT = Color.parseColor("#f0888888");
    public static final int GREY_SCROLLBAR = Color.parseColor("#64404040");
    public static final int BLUE_LIGHT = Color.parseColor("#FF33B5E5");
    public static final int BLUE_LIGHT_SEMITRANSPARENT = Color.parseColor("#8033B5E5");
    protected static final int SCROLLBAR_MARGIN = 10;
    // base variables
    protected boolean isScrolling;
    protected AlphaAnimation fadeInAnimation, fadeOutAnimation;
    protected TextView scrollIndicatorTextView;
    protected Scrollable scrollable;
    protected ListView listView;
    protected int groupPosition;
    protected int itemCount;
    protected int type;
    protected boolean isInitialized = false;
    protected static final int TEXT_PADDING = 4;
    // handlebar variables
    protected View handleBar;
    // indicator variables
    protected RelativeLayout scrollIndicator;

    private OnScrollListener onScrollListener;
    private Picasso picasso;

    // default constructors
    public QuickScroll(Context context) {
        super(context);
    }

    public QuickScroll(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public QuickScroll(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    /**
     * Initializing the QuickScroll, this function must be called.
     * <p/>
     *
     * @param type       the QuickScroll type. Available inputs: <b>QuickScroll.TYPE_POPUP</b> or <b>QuickScroll.TYPE_INDICATOR</b>
     * @param list       the ListView
     * @param scrollable the adapter, must implement Scrollable interface
     */
    public void init(final int type, final ListView list, final Scrollable scrollable, final int style) {
        if (isInitialized) return;

        this.type = type;
        listView = list;
        this.scrollable = scrollable;
        groupPosition = -1;
        fadeInAnimation = new AlphaAnimation(.0f, 1.0f);
        fadeInAnimation.setFillAfter(true);
        fadeOutAnimation = new AlphaAnimation(1.0f, .0f);
        fadeOutAnimation.setFillAfter(true);
        fadeOutAnimation.setAnimationListener(new AnimationListener() {

            public void onAnimationStart(Animation animation) {
            }

            public void onAnimationRepeat(Animation animation) {
            }

            public void onAnimationEnd(Animation animation) {
                isScrolling = false;
            }
        });
        isScrolling = false;

        listView.setOnTouchListener(new OnTouchListener() {
            public boolean onTouch(View v, MotionEvent event) {
                if (isScrolling && (event.getAction() == MotionEvent.ACTION_MOVE || event.getAction() == MotionEvent.ACTION_DOWN)) {
                    return true;
                }
                return false;
            }
        });

        final RelativeLayout.LayoutParams containerParams = new RelativeLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
        final RelativeLayout container = new RelativeLayout(getContext());
        container.setBackgroundColor(Color.TRANSPARENT);
        containerParams.addRule(RelativeLayout.ALIGN_TOP, getId());
        containerParams.addRule(RelativeLayout.ALIGN_BOTTOM, getId());
        container.setLayoutParams(containerParams);

        if (this.type == TYPE_POPUP || this.type == TYPE_POPUP_WITH_HANDLE) {
            scrollIndicatorTextView = new TextView(getContext());
            scrollIndicatorTextView.setTextColor(Color.WHITE);
            scrollIndicatorTextView.setVisibility(View.INVISIBLE);
            scrollIndicatorTextView.setGravity(Gravity.CENTER);
            final RelativeLayout.LayoutParams popupParams = new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
            popupParams.addRule(RelativeLayout.CENTER_IN_PARENT);
            scrollIndicatorTextView.setLayoutParams(popupParams);
            setPopupColor(GREY_LIGHT, GREY_DARK, 1, Color.WHITE, 1);
            setTextPadding(TEXT_PADDING, TEXT_PADDING, TEXT_PADDING, TEXT_PADDING);
            container.addView(scrollIndicatorTextView);
        } else {
            scrollIndicator = createPin();
            scrollIndicatorTextView = (TextView) scrollIndicator.findViewById(ID_PIN_TEXT);
            (scrollIndicator.findViewById(ID_PIN)).getLayoutParams().width = 25;
            container.addView(scrollIndicator);
        }

        // setting scrollbar width
        final float density = getResources().getDisplayMetrics().density;
        getLayoutParams().width = (int) (10 * density);
        scrollIndicatorTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 32);

        // scrollbar setup
        if (style != STYLE_NONE) {
            final RelativeLayout layout = new RelativeLayout(getContext());
            final RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
            params.addRule(RelativeLayout.ALIGN_LEFT, getId());
            params.addRule(RelativeLayout.ALIGN_TOP, getId());
            params.addRule(RelativeLayout.ALIGN_RIGHT, getId());
            params.addRule(RelativeLayout.ALIGN_BOTTOM, getId());
            layout.setLayoutParams(params);

            final View scrollbar = new View(getContext());
            scrollbar.setBackgroundColor(GREY_SCROLLBAR);
            final RelativeLayout.LayoutParams scrollBarParams = new RelativeLayout.LayoutParams(1, LayoutParams.MATCH_PARENT);
            scrollBarParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
            scrollBarParams.topMargin = SCROLLBAR_MARGIN;
            scrollBarParams.bottomMargin = SCROLLBAR_MARGIN;
            scrollbar.setLayoutParams(scrollBarParams);
            layout.addView(scrollbar);
            ViewGroup.class.cast(listView.getParent()).addView(layout);
            // creating the handlebar
            if (this.type == TYPE_INDICATOR_WITH_HANDLE || this.type == TYPE_POPUP_WITH_HANDLE) {
                handleBar = new View(getContext());
                setHandlebarColor(BLUE_LIGHT, BLUE_LIGHT, BLUE_LIGHT_SEMITRANSPARENT);
                final RelativeLayout.LayoutParams handleParams = new RelativeLayout.LayoutParams((int) (12 * density), (int) (36 * density));
                handleBar.setLayoutParams(handleParams);
                ((RelativeLayout.LayoutParams) handleBar.getLayoutParams()).addRule(RelativeLayout.CENTER_HORIZONTAL);
                layout.addView(handleBar);

                listView.setOnScrollListener(new OnScrollListener() {

                    public void onScrollStateChanged(AbsListView view, int scrollState) {
                        if (onScrollListener!=null)
                            onScrollListener.onScrollStateChanged(view, scrollState);
                    }

                    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
                        if (onScrollListener!=null)
                            onScrollListener.onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount);

                        if (!isScrolling && totalItemCount - visibleItemCount > 0) {
                            moveHandlebar(getHeight() * firstVisibleItem / (totalItemCount - visibleItemCount));
                        }
                    }
                });
            }
        }

        isInitialized = true;

        ViewGroup.class.cast(listView.getParent()).addView(container);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (listView.getAdapter() == null)
            return false;
        itemCount = listView.getAdapter().getCount();
        if (itemCount == 0)
            return false;
        if (event.getActionMasked() == MotionEvent.ACTION_CANCEL) {
            if (type == TYPE_POPUP || type == TYPE_INDICATOR) {
                scrollIndicatorTextView.startAnimation(fadeOutAnimation);
            } else {
                if (type == TYPE_INDICATOR_WITH_HANDLE || type == TYPE_POPUP_WITH_HANDLE)
                    handleBar.setSelected(false);
                scrollIndicator.startAnimation(fadeOutAnimation);
            }
        }
        switch (event.getActionMasked()) {
            case MotionEvent.ACTION_DOWN:
                //Pause image loading.
                if (picasso!=null)
                    picasso.interruptDispatching();

                if (type == TYPE_INDICATOR || type == TYPE_INDICATOR_WITH_HANDLE) {
                    scrollIndicator.startAnimation(fadeInAnimation);
                    scrollIndicator.setPadding(0, 0, getWidth(), 0);
                } else
                    scrollIndicatorTextView.startAnimation(fadeInAnimation); scroll(event.getY());
                isScrolling = true;
                return true;
            case MotionEvent.ACTION_MOVE:
                scroll(event.getY());
                return true;
            case MotionEvent.ACTION_UP:
                //Resume image loading.
                if (picasso!=null)
                    picasso.continueDispatching();

                if (type == TYPE_INDICATOR_WITH_HANDLE || type == TYPE_POPUP_WITH_HANDLE)
                    handleBar.setSelected(false);
                if (type == TYPE_INDICATOR || type == TYPE_INDICATOR_WITH_HANDLE)
                    scrollIndicator.startAnimation(fadeOutAnimation);
                else
                    scrollIndicatorTextView.startAnimation(fadeOutAnimation);
                return true;
            default:
                return false;
        }
    }

    @SuppressLint("NewApi")
    protected void scroll(final float height) {
        if (type == TYPE_INDICATOR || type == TYPE_INDICATOR_WITH_HANDLE) {
            float move = height - (scrollIndicator.getHeight() / 2);

            if (move < 0)
                move = 0;
            else if (move > getHeight() - scrollIndicator.getHeight())
                move = getHeight() - scrollIndicator.getHeight();

            // scrollIndicator.setTranslationY(move);
            ViewHelper.setTranslationY(scrollIndicator, move);
        }

        if (type == TYPE_INDICATOR_WITH_HANDLE || type == TYPE_POPUP_WITH_HANDLE) {
            handleBar.setSelected(true);
            moveHandlebar(height - (handleBar.getHeight() / 2));
        }

        int position = (int) ((height / getHeight()) * itemCount);
        if (listView instanceof ExpandableListView) {
            final int groupPosition = ExpandableListView.getPackedPositionGroup(((ExpandableListView) listView).getExpandableListPosition(position));
            if (groupPosition != -1)
                this.groupPosition = groupPosition;
        }

        if (position < 0)
            position = 0;
        else if (position >= itemCount)
            position = itemCount - 1;
        
        try {
        	scrollIndicatorTextView.setText(scrollable.getIndicatorForPosition(position, groupPosition));
            listView.setSelection(scrollable.getScrollPosition(position, groupPosition));
        } catch (NullPointerException e) {
        	e.printStackTrace();
        }
        
    }

    @SuppressLint("NewApi")
    protected void moveHandlebar(final float where) {
        float move = where;
        if (move < SCROLLBAR_MARGIN)
            move = SCROLLBAR_MARGIN;
        else if (move > getHeight() - handleBar.getHeight() - SCROLLBAR_MARGIN)
            move = getHeight() - handleBar.getHeight() - SCROLLBAR_MARGIN;

        // handleBar.setTranslationY(move);
        ViewHelper.setTranslationY(handleBar, move);
    }

    /**
     * Sets the fade in and fade out duration of the indicator; default is 150 ms.
     * <p/>
     *
     * @param millis the fade duration in milliseconds
     */
    public void setFadeDuration(long millis) {
        fadeInAnimation.setDuration(millis);
        fadeOutAnimation.setDuration(millis);
    }

    /**
     * Sets the indicator colors, when QuickScroll.TYPE_INDICATOR is selected as type.
     * <p/>
     *
     * @param background the background color of the square
     * @param tip        the background color of the tip triangle
     * @param text       the color of the text
     */
    public void setIndicatorColor(final int background, final int tip, final int text) {
        if (type == TYPE_INDICATOR || type == TYPE_INDICATOR_WITH_HANDLE) {
            ((Pin) scrollIndicator.findViewById(ID_PIN)).setColor(tip);
            scrollIndicatorTextView.setTextColor(text);
            scrollIndicatorTextView.setBackgroundColor(background);
        }
    }

    /**
     * Sets the popup colors, when QuickScroll.TYPE_POPUP is selected as type.
     * <p/>
     *
     * @param backgroundcolor the background color of the TextView
     * @param bordercolor     the background color of the border surrounding the TextView
     * @param textcolor       the color of the text
     */
    public void setPopupColor(final int backgroundcolor, final int bordercolor, final int borderwidthDPI, final int textcolor, float cornerradiusDPI) {

        final GradientDrawable popupbackground = new GradientDrawable();
        popupbackground.setCornerRadius(cornerradiusDPI * getResources().getDisplayMetrics().density);
        popupbackground.setStroke((int) (borderwidthDPI * getResources().getDisplayMetrics().density), bordercolor);
        popupbackground.setColor(backgroundcolor);

        if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN)
            scrollIndicatorTextView.setBackgroundDrawable(popupbackground);
        else
            scrollIndicatorTextView.setBackground(popupbackground);

        scrollIndicatorTextView.setTextColor(textcolor);
    }

    /**
     * Sets the width and height of the TextView containing the indicatortext. Default is WRAP_CONTENT, WRAP_CONTENT.
     * <p/>
     *
     * @param widthDP  width in DP
     * @param heightDP height in DP
     */
    public void setSize(final int widthDP, final int heightDP) {
        final float density = getResources().getDisplayMetrics().density;
        scrollIndicatorTextView.getLayoutParams().width = (int) (widthDP * density);
        scrollIndicatorTextView.getLayoutParams().height = (int) (heightDP * density);
    }

    /**
     * Sets the padding of the TextView containing the indicatortext. Default is 4 dp.
     * <p/>
     *
     * @param paddingLeftDP   left padding in DP
     * @param paddingTopDP    top param in DP
     * @param paddingBottomDP bottom param in DP
     * @param paddingRightDP  right param in DP
     */
    public void setTextPadding(final int paddingLeftDP, final int paddingTopDP, final int paddingBottomDP, final int paddingRightDP) {
        final float density = getResources().getDisplayMetrics().density;
        scrollIndicatorTextView.setPadding((int) (paddingLeftDP * density), (int) (paddingTopDP * density), (int) (paddingRightDP * density), (int) (paddingBottomDP * density));

    }

    /**
     * Turns on fixed size for the TextView containing the indicatortext. Do not use with setSize()! This mode looks good if the indicatortext length is fixed, e.g. it's always two characters long.
     * <p/>
     *
     * @param sizeEMS number of characters in the indicatortext
     */
    public void setFixedSize(final int sizeEMS) {
        scrollIndicatorTextView.setEms(sizeEMS);
    }

    /**
     * Set the textsize of the TextView containing the indicatortext.
     *
     * @param unit - use TypedValue statics
     * @param size - the size according to the selected unit
     */
    public void setTextSize(final int unit, final float size) {
        scrollIndicatorTextView.setTextSize(unit, size);
    }

    /**
     * Set the colors of the handlebar.
     *
     * @param inactive     - color of the inactive handlebar
     * @param activebase   - base color of the active handlebar
     * @param activestroke - stroke of the active handlebar
     */
    public void setHandlebarColor(final int inactive, final int activebase, final int activestroke) {
        if (type == TYPE_INDICATOR_WITH_HANDLE || type == TYPE_POPUP_WITH_HANDLE) {
            final float density = getResources().getDisplayMetrics().density;
            final GradientDrawable bg_inactive = new GradientDrawable();
            bg_inactive.setCornerRadius(density);
            bg_inactive.setColor(inactive);
            bg_inactive.setStroke((int) (5 * density), Color.TRANSPARENT);
            final GradientDrawable bg_active = new GradientDrawable();
            bg_active.setCornerRadius(density);
            bg_active.setColor(activebase);
            bg_active.setStroke((int) (5 * density), activestroke);
            final StateListDrawable states = new StateListDrawable();
            states.addState(new int[]{android.R.attr.state_selected}, bg_active);
            states.addState(new int[]{android.R.attr.state_enabled}, bg_inactive);

            if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN)
                handleBar.setBackgroundDrawable(states);
            else
                handleBar.setBackground(states);
        }
    }

    protected RelativeLayout createPin() {
        final RelativeLayout pinLayout = new RelativeLayout(getContext());
        pinLayout.setVisibility(View.INVISIBLE);

        final Pin pin = new Pin(getContext());
        pin.setId(ID_PIN);
        final RelativeLayout.LayoutParams pinParams = new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        pinParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
        pinParams.addRule(RelativeLayout.ALIGN_BOTTOM, ID_PIN_TEXT);
        pinParams.addRule(RelativeLayout.ALIGN_TOP, ID_PIN_TEXT);
        pin.setLayoutParams(pinParams);
        pinLayout.addView(pin);

        final TextView indicatorTextView = new TextView(getContext());
        indicatorTextView.setId(ID_PIN_TEXT);
        final RelativeLayout.LayoutParams indicatorParams = new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        indicatorParams.addRule(RelativeLayout.LEFT_OF, ID_PIN);
        indicatorTextView.setLayoutParams(indicatorParams);
        indicatorTextView.setTextColor(Color.WHITE);
        indicatorTextView.setGravity(Gravity.CENTER);
        indicatorTextView.setBackgroundColor(GREY_LIGHT);
        pinLayout.addView(indicatorTextView);

        return pinLayout;
    }

    public void setOnScrollListener(OnScrollListener listener) {
        onScrollListener = listener;
    }

    public void setPicassoInstance(Picasso picasso) { this.picasso = picasso; }

}

@#$
package com.andraskindler.quickscroll;

import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Color;
import android.graphics.drawable.GradientDrawable;
import android.graphics.drawable.StateListDrawable;
import android.os.Build;
import android.util.AttributeSet;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.widget.*;
import android.widget.AbsListView.OnScrollListener;

import com.squareup.picasso.Picasso;

public class QuickScrollGridView extends View {

    // IDs
    protected static final int ID_PIN = 512;
    protected static final int ID_PIN_TEXT = 513;
    // type statics
    public static final int TYPE_POPUP = 0;
    public static final int TYPE_INDICATOR = 1;
    public static final int TYPE_POPUP_WITH_HANDLE = 2;
    public static final int TYPE_INDICATOR_WITH_HANDLE = 3;
    // style statics
    public static final int STYLE_NONE = 0;
    public static final int STYLE_HOLO = 1;
    // base colors
    public static final int GREY_DARK = Color.parseColor("#e0585858");
    public static final int GREY_LIGHT = Color.parseColor("#f0888888");
    public static final int GREY_SCROLLBAR = Color.parseColor("#64404040");
    public static final int BLUE_LIGHT = Color.parseColor("#FF33B5E5");
    public static final int BLUE_LIGHT_SEMITRANSPARENT = Color.parseColor("#8033B5E5");
    protected static final int SCROLLBAR_MARGIN = 10;
    // base variables
    protected boolean isScrolling;
    protected AlphaAnimation fadeInAnimation, fadeOutAnimation;
    protected TextView scrollIndicatorTextView;
    protected Scrollable scrollable;
    protected GridView gridView;
    protected int groupPosition;
    protected int itemCount;
    protected int type;
    protected boolean isInitialized = false;
    protected static final int TEXT_PADDING = 4;
    // handlebar variables
    protected View handleBar;
    // indicator variables
    protected RelativeLayout scrollIndicator;
    private OnScrollListener onScrollListener;
    private Picasso picasso;

    // default constructors
    public QuickScrollGridView(Context context) {
        super(context);
    }

    public QuickScrollGridView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public QuickScrollGridView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    /**
     * Initializing the QuickScroll, this function must be called.
     * <p/>
     *
     * @param type       the QuickScroll type. Available inputs: <b>QuickScroll.TYPE_POPUP</b> or <b>QuickScroll.TYPE_INDICATOR</b>
     * @param list       the GridView
     * @param scrollable the adapter, must implement Scrollable interface
     */
    public void init(final int type, final GridView grid, final Scrollable scrollable, final int style) {
        if (isInitialized) return;

        this.type = type;
        gridView = grid;
        this.scrollable = scrollable;
        groupPosition = -1;
        fadeInAnimation = new AlphaAnimation(.0f, 1.0f);
        fadeInAnimation.setFillAfter(true);
        fadeOutAnimation = new AlphaAnimation(1.0f, .0f);
        fadeOutAnimation.setFillAfter(true);
        fadeOutAnimation.setAnimationListener(new AnimationListener() {

            public void onAnimationStart(Animation animation) {
            }

            public void onAnimationRepeat(Animation animation) {
            }

            public void onAnimationEnd(Animation animation) {
                isScrolling = false;
            }
        });
        isScrolling = false;

        gridView.setOnTouchListener(new OnTouchListener() {
            public boolean onTouch(View v, MotionEvent event) {
                if (isScrolling && (event.getAction() == MotionEvent.ACTION_MOVE || event.getAction() == MotionEvent.ACTION_DOWN)) {
                    return true;
                }
                return false;
            }
        });

        final RelativeLayout.LayoutParams containerParams = new RelativeLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
        final RelativeLayout container = new RelativeLayout(getContext());
        container.setBackgroundColor(Color.TRANSPARENT);
        containerParams.addRule(RelativeLayout.ALIGN_TOP, getId());
        containerParams.addRule(RelativeLayout.ALIGN_BOTTOM, getId());
        container.setLayoutParams(containerParams);

        if (this.type == TYPE_POPUP || this.type == TYPE_POPUP_WITH_HANDLE) {
            scrollIndicatorTextView = new TextView(getContext());
            scrollIndicatorTextView.setTextColor(Color.WHITE);
            scrollIndicatorTextView.setVisibility(View.INVISIBLE);
            scrollIndicatorTextView.setGravity(Gravity.CENTER);
            final RelativeLayout.LayoutParams popupParams = new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
            popupParams.addRule(RelativeLayout.CENTER_IN_PARENT);
            scrollIndicatorTextView.setLayoutParams(popupParams);
            setPopupColor(GREY_LIGHT, GREY_DARK, 1, Color.WHITE, 1);
            setTextPadding(TEXT_PADDING, TEXT_PADDING, TEXT_PADDING, TEXT_PADDING);
            container.addView(scrollIndicatorTextView);
        } else {
            scrollIndicator = createPin();
            scrollIndicatorTextView = (TextView) scrollIndicator.findViewById(ID_PIN_TEXT);
            (scrollIndicator.findViewById(ID_PIN)).getLayoutParams().width = 25;
            container.addView(scrollIndicator);
        }

        // setting scrollbar width
        final float density = getResources().getDisplayMetrics().density;
        getLayoutParams().width = (int) (10 * density);
        scrollIndicatorTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 32);

        // scrollbar setup
        if (style != STYLE_NONE) {
            final RelativeLayout layout = new RelativeLayout(getContext());
            final RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
            params.addRule(RelativeLayout.ALIGN_LEFT, getId());
            params.addRule(RelativeLayout.ALIGN_TOP, getId());
            params.addRule(RelativeLayout.ALIGN_RIGHT, getId());
            params.addRule(RelativeLayout.ALIGN_BOTTOM, getId());
            layout.setLayoutParams(params);

            final View scrollbar = new View(getContext());
            scrollbar.setBackgroundColor(GREY_SCROLLBAR);
            final RelativeLayout.LayoutParams scrollBarParams = new RelativeLayout.LayoutParams(1, LayoutParams.MATCH_PARENT);
            scrollBarParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
            scrollBarParams.topMargin = SCROLLBAR_MARGIN;
            scrollBarParams.bottomMargin = SCROLLBAR_MARGIN;
            scrollbar.setLayoutParams(scrollBarParams);
            layout.addView(scrollbar);
            ViewGroup.class.cast(gridView.getParent()).addView(layout);
            // creating the handlebar
            if (this.type == TYPE_INDICATOR_WITH_HANDLE || this.type == TYPE_POPUP_WITH_HANDLE) {
                handleBar = new View(getContext());
                setHandlebarColor(BLUE_LIGHT, BLUE_LIGHT, BLUE_LIGHT_SEMITRANSPARENT);
                final RelativeLayout.LayoutParams handleParams = new RelativeLayout.LayoutParams((int) (12 * density), (int) (36 * density));
                handleBar.setLayoutParams(handleParams);
                ((RelativeLayout.LayoutParams) handleBar.getLayoutParams()).addRule(RelativeLayout.CENTER_HORIZONTAL);
                layout.addView(handleBar);

                gridView.setOnScrollListener(new OnScrollListener() {

                    public void onScrollStateChanged(AbsListView view, int scrollState) {
                        if (onScrollListener!=null)
                            onScrollListener.onScrollStateChanged(view, scrollState);
                    }

                    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
                        if (onScrollListener!=null)
                            onScrollListener.onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount);

                        if (!isScrolling && totalItemCount - visibleItemCount > 0) {
                            moveHandlebar(getHeight() * firstVisibleItem / (totalItemCount - visibleItemCount));
                        }
                    }
                });
            }
        }

        isInitialized = true;

        ViewGroup.class.cast(gridView.getParent()).addView(container);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (gridView.getAdapter() == null)
            return false;
        itemCount = gridView.getAdapter().getCount();
        if (itemCount == 0)
            return false;
        if (event.getActionMasked() == MotionEvent.ACTION_CANCEL) {
            if (type == TYPE_POPUP || type == TYPE_INDICATOR) {
                scrollIndicatorTextView.startAnimation(fadeOutAnimation);
            } else {
                if (type == TYPE_INDICATOR_WITH_HANDLE || type == TYPE_POPUP_WITH_HANDLE)
                    handleBar.setSelected(false);
                scrollIndicator.startAnimation(fadeOutAnimation);
            }
        }
        switch (event.getActionMasked()) {
            case MotionEvent.ACTION_DOWN:
                //Pause image loading.
                if (picasso!=null)
                    picasso.interruptDispatching();

                if (type == TYPE_INDICATOR || type == TYPE_INDICATOR_WITH_HANDLE) {
                    scrollIndicator.startAnimation(fadeInAnimation);
                    scrollIndicator.setPadding(0, 0, getWidth(), 0);
                } else
                    scrollIndicatorTextView.startAnimation(fadeInAnimation); scroll(event.getY());
                isScrolling = true;
                return true;
            case MotionEvent.ACTION_MOVE:
                scroll(event.getY());
                return true;
            case MotionEvent.ACTION_UP:
                //Resume image loading.
                if (picasso!=null)
                    picasso.continueDispatching();

                if (type == TYPE_INDICATOR_WITH_HANDLE || type == TYPE_POPUP_WITH_HANDLE)
                    handleBar.setSelected(false);
                if (type == TYPE_INDICATOR || type == TYPE_INDICATOR_WITH_HANDLE)
                    scrollIndicator.startAnimation(fadeOutAnimation);
                else
                    scrollIndicatorTextView.startAnimation(fadeOutAnimation);
                return true;
            default:
                return false;
        }
    }

    @SuppressLint("NewApi")
    protected void scroll(final float height) {
        if (type == TYPE_INDICATOR || type == TYPE_INDICATOR_WITH_HANDLE) {
            float move = height - (scrollIndicator.getHeight() / 2);

            if (move < 0)
                move = 0;
            else if (move > getHeight() - scrollIndicator.getHeight())
                move = getHeight() - scrollIndicator.getHeight();

            // scrollIndicator.setTranslationY(move);
            ViewHelper.setTranslationY(scrollIndicator, move);
        }

        if (type == TYPE_INDICATOR_WITH_HANDLE || type == TYPE_POPUP_WITH_HANDLE) {
            handleBar.setSelected(true);
            moveHandlebar(height - (handleBar.getHeight() / 2));
        }

        int position = (int) ((height / getHeight()) * itemCount);
/*        if (gridView instanceof ExpandableListView) {
            final int groupPosition = ExpandableListView.getPackedPositionGroup(((ExpandableListView) listView).getExpandableListPosition(position));
            if (groupPosition != -1)
                this.groupPosition = groupPosition;
        }*/

        if (position < 0)
            position = 0;
        else if (position >= itemCount)
            position = itemCount - 1;
        
        try {
        	scrollIndicatorTextView.setText(scrollable.getIndicatorForPosition(position, groupPosition));
            gridView.setSelection(scrollable.getScrollPosition(position, groupPosition));
        } catch (NullPointerException e) {
        	e.printStackTrace();
        }
        
    }

    @SuppressLint("NewApi")
    protected void moveHandlebar(final float where) {
        float move = where;
        if (move < SCROLLBAR_MARGIN)
            move = SCROLLBAR_MARGIN;
        else if (move > getHeight() - handleBar.getHeight() - SCROLLBAR_MARGIN)
            move = getHeight() - handleBar.getHeight() - SCROLLBAR_MARGIN;

        // handleBar.setTranslationY(move);
        ViewHelper.setTranslationY(handleBar, move);
    }

    /**
     * Sets the fade in and fade out duration of the indicator; default is 150 ms.
     * <p/>
     *
     * @param millis the fade duration in milliseconds
     */
    public void setFadeDuration(long millis) {
        fadeInAnimation.setDuration(millis);
        fadeOutAnimation.setDuration(millis);
    }

    /**
     * Sets the indicator colors, when QuickScroll.TYPE_INDICATOR is selected as type.
     * <p/>
     *
     * @param background the background color of the square
     * @param tip        the background color of the tip triangle
     * @param text       the color of the text
     */
    public void setIndicatorColor(final int background, final int tip, final int text) {
        if (type == TYPE_INDICATOR || type == TYPE_INDICATOR_WITH_HANDLE) {
            ((Pin) scrollIndicator.findViewById(ID_PIN)).setColor(tip);
            scrollIndicatorTextView.setTextColor(text);
            scrollIndicatorTextView.setBackgroundColor(background);
        }
    }

    /**
     * Sets the popup colors, when QuickScroll.TYPE_POPUP is selected as type.
     * <p/>
     *
     * @param backgroundcolor the background color of the TextView
     * @param bordercolor     the background color of the border surrounding the TextView
     * @param textcolor       the color of the text
     */
    public void setPopupColor(final int backgroundcolor, final int bordercolor, final int borderwidthDPI, final int textcolor, float cornerradiusDPI) {

        final GradientDrawable popupbackground = new GradientDrawable();
        popupbackground.setCornerRadius(cornerradiusDPI * getResources().getDisplayMetrics().density);
        popupbackground.setStroke((int) (borderwidthDPI * getResources().getDisplayMetrics().density), bordercolor);
        popupbackground.setColor(backgroundcolor);

        if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN)
            scrollIndicatorTextView.setBackgroundDrawable(popupbackground);
        else
            scrollIndicatorTextView.setBackground(popupbackground);

        scrollIndicatorTextView.setTextColor(textcolor);
    }

    /**
     * Sets the width and height of the TextView containing the indicatortext. Default is WRAP_CONTENT, WRAP_CONTENT.
     * <p/>
     *
     * @param widthDP  width in DP
     * @param heightDP height in DP
     */
    public void setSize(final int widthDP, final int heightDP) {
        final float density = getResources().getDisplayMetrics().density;
        scrollIndicatorTextView.getLayoutParams().width = (int) (widthDP * density);
        scrollIndicatorTextView.getLayoutParams().height = (int) (heightDP * density);
    }

    /**
     * Sets the padding of the TextView containing the indicatortext. Default is 4 dp.
     * <p/>
     *
     * @param paddingLeftDP   left padding in DP
     * @param paddingTopDP    top param in DP
     * @param paddingBottomDP bottom param in DP
     * @param paddingRightDP  right param in DP
     */
    public void setTextPadding(final int paddingLeftDP, final int paddingTopDP, final int paddingBottomDP, final int paddingRightDP) {
        final float density = getResources().getDisplayMetrics().density;
        scrollIndicatorTextView.setPadding((int) (paddingLeftDP * density), (int) (paddingTopDP * density), (int) (paddingRightDP * density), (int) (paddingBottomDP * density));

    }

    /**
     * Turns on fixed size for the TextView containing the indicatortext. Do not use with setSize()! This mode looks good if the indicatortext length is fixed, e.g. it's always two characters long.
     * <p/>
     *
     * @param sizeEMS number of characters in the indicatortext
     */
    public void setFixedSize(final int sizeEMS) {
        scrollIndicatorTextView.setEms(sizeEMS);
    }

    /**
     * Set the textsize of the TextView containing the indicatortext.
     *
     * @param unit - use TypedValue statics
     * @param size - the size according to the selected unit
     */
    public void setTextSize(final int unit, final float size) {
        scrollIndicatorTextView.setTextSize(unit, size);
    }

    /**
     * Set the colors of the handlebar.
     *
     * @param inactive     - color of the inactive handlebar
     * @param activebase   - base color of the active handlebar
     * @param activestroke - stroke of the active handlebar
     */
    public void setHandlebarColor(final int inactive, final int activebase, final int activestroke) {
        if (type == TYPE_INDICATOR_WITH_HANDLE || type == TYPE_POPUP_WITH_HANDLE) {
            final float density = getResources().getDisplayMetrics().density;
            final GradientDrawable bg_inactive = new GradientDrawable();
            bg_inactive.setCornerRadius(density);
            bg_inactive.setColor(inactive);
            bg_inactive.setStroke((int) (5 * density), Color.TRANSPARENT);
            final GradientDrawable bg_active = new GradientDrawable();
            bg_active.setCornerRadius(density);
            bg_active.setColor(activebase);
            bg_active.setStroke((int) (5 * density), activestroke);
            final StateListDrawable states = new StateListDrawable();
            states.addState(new int[]{android.R.attr.state_selected}, bg_active);
            states.addState(new int[]{android.R.attr.state_enabled}, bg_inactive);

            if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN)
                handleBar.setBackgroundDrawable(states);
            else
                handleBar.setBackground(states);
        }
    }

    protected RelativeLayout createPin() {
        final RelativeLayout pinLayout = new RelativeLayout(getContext());
        pinLayout.setVisibility(View.INVISIBLE);

        final Pin pin = new Pin(getContext());
        pin.setId(ID_PIN);
        final RelativeLayout.LayoutParams pinParams = new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        pinParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
        pinParams.addRule(RelativeLayout.ALIGN_BOTTOM, ID_PIN_TEXT);
        pinParams.addRule(RelativeLayout.ALIGN_TOP, ID_PIN_TEXT);
        pin.setLayoutParams(pinParams);
        pinLayout.addView(pin);

        final TextView indicatorTextView = new TextView(getContext());
        indicatorTextView.setId(ID_PIN_TEXT);
        final RelativeLayout.LayoutParams indicatorParams = new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        indicatorParams.addRule(RelativeLayout.LEFT_OF, ID_PIN);
        indicatorTextView.setLayoutParams(indicatorParams);
        indicatorTextView.setTextColor(Color.WHITE);
        indicatorTextView.setGravity(Gravity.CENTER);
        indicatorTextView.setBackgroundColor(GREY_LIGHT);
        pinLayout.addView(indicatorTextView);

        return pinLayout;
    }

    public void setOnScrollListener(OnScrollListener listener) {
        onScrollListener = listener;
    }

    public void setPicassoInstance(Picasso picasso) { this.picasso = picasso; }

}

@#$
package com.andraskindler.quickscroll;

/**
 * Interface required for FastTrack.
 * 
 * @author andraskindler
 *
 */
public interface Scrollable {

	/**
	 * This function returns the corresponding String to display at any given position
	 * <p>
	 * 
	 * @param childposition
	 *            equals childposition if used with ExpandableListView, position otherwise.
	 * @param groupposition
	 *            equals groupposition if used with ExpandableListView, zero otherwise.
	 */
	String getIndicatorForPosition(final int childposition, final int groupposition);

	/**
	 * This second function is responsible for is for implementing scroll behaviour. This can be used to perform special tasks, e.g. if you want to snap to the first item starting with a letter in an alphabetically ordered list or jump between groups in an ExpandableListView. If you want the normal approach, simply return childposition.
	 * <p>
	 * 
	 * @param childposition
	 *            equals childposition if used with ExpandableListView, position otherwise.
	 * @param groupposition
	 *            equals groupposition if used with ExpandableListView, zero otherwise.
	 */
	int getScrollPosition(final int childposition, final int groupposition);

}

@#$
package com.andraskindler.quickscroll;

import android.annotation.SuppressLint;
import android.view.View;

import static com.andraskindler.quickscroll.animation.AnimatorProxy.NEEDS_PROXY;
import static com.andraskindler.quickscroll.animation.AnimatorProxy.wrap;

public final class ViewHelper {
    private ViewHelper() {}

    public static float getAlpha(View view) {
        return NEEDS_PROXY ? wrap(view).getAlpha() : Honeycomb.getAlpha(view);
    }

    public static void setAlpha(View view, float alpha) {
        if (NEEDS_PROXY) {
            wrap(view).setAlpha(alpha);
        } else {
            Honeycomb.setAlpha(view, alpha);
        }
    }

    public static float getPivotX(View view) {
        return NEEDS_PROXY ? wrap(view).getPivotX() : Honeycomb.getPivotX(view);
    }

    public static void setPivotX(View view, float pivotX) {
        if (NEEDS_PROXY) {
            wrap(view).setPivotX(pivotX);
        } else {
            Honeycomb.setPivotX(view, pivotX);
        }
    }

    public static float getPivotY(View view) {
        return NEEDS_PROXY ? wrap(view).getPivotY() : Honeycomb.getPivotY(view);
    }

    public static void setPivotY(View view, float pivotY) {
        if (NEEDS_PROXY) {
            wrap(view).setPivotY(pivotY);
        } else {
            Honeycomb.setPivotY(view, pivotY);
        }
    }

    public static float getRotation(View view) {
        return NEEDS_PROXY ? wrap(view).getRotation() : Honeycomb.getRotation(view);
    }

    public static void setRotation(View view, float rotation) {
        if (NEEDS_PROXY) {
            wrap(view).setRotation(rotation);
        } else {
            Honeycomb.setRotation(view, rotation);
        }
    }

    public static float getRotationX(View view) {
        return NEEDS_PROXY ? wrap(view).getRotationX() : Honeycomb.getRotationX(view);
    }

    public static void setRotationX(View view, float rotationX) {
        if (NEEDS_PROXY) {
            wrap(view).setRotationX(rotationX);
        } else {
            Honeycomb.setRotationX(view, rotationX);
        }
    }

    public static float getRotationY(View view) {
        return NEEDS_PROXY ? wrap(view).getRotationY() : Honeycomb.getRotationY(view);
    }

    public static void setRotationY(View view, float rotationY) {
        if (NEEDS_PROXY) {
            wrap(view).setRotationY(rotationY);
        } else {
            Honeycomb.setRotationY(view, rotationY);
        }
    }

    public static float getScaleX(View view) {
        return NEEDS_PROXY ? wrap(view).getScaleX() : Honeycomb.getScaleX(view);
    }

    public static void setScaleX(View view, float scaleX) {
        if (NEEDS_PROXY) {
            wrap(view).setScaleX(scaleX);
        } else {
            Honeycomb.setScaleX(view, scaleX);
        }
    }

    public static float getScaleY(View view) {
        return NEEDS_PROXY ? wrap(view).getScaleY() : Honeycomb.getScaleY(view);
    }

    public static void setScaleY(View view, float scaleY) {
        if (NEEDS_PROXY) {
            wrap(view).setScaleY(scaleY);
        } else {
            Honeycomb.setScaleY(view, scaleY);
        }
    }

    public static float getScrollX(View view) {
        return NEEDS_PROXY ? wrap(view).getScrollX() : Honeycomb.getScrollX(view);
    }

    public static void setScrollX(View view, int scrollX) {
        if (NEEDS_PROXY) {
            wrap(view).setScrollX(scrollX);
        } else {
            Honeycomb.setScrollX(view, scrollX);
        }
    }

    public static float getScrollY(View view) {
        return NEEDS_PROXY ? wrap(view).getScrollY() : Honeycomb.getScrollY(view);
    }

    public static void setScrollY(View view, int scrollY) {
        if (NEEDS_PROXY) {
            wrap(view).setScrollY(scrollY);
        } else {
            Honeycomb.setScrollY(view, scrollY);
        }
    }

    public static float getTranslationX(View view) {
        return NEEDS_PROXY ? wrap(view).getTranslationX() : Honeycomb.getTranslationX(view);
    }

    public static void setTranslationX(View view, float translationX) {
        if (NEEDS_PROXY) {
            wrap(view).setTranslationX(translationX);
        } else {
            Honeycomb.setTranslationX(view, translationX);
        }
    }

    public static float getTranslationY(View view) {
        return NEEDS_PROXY ? wrap(view).getTranslationY() : Honeycomb.getTranslationY(view);
    }

    public static void setTranslationY(View view, float translationY) {
        if (NEEDS_PROXY) {
            wrap(view).setTranslationY(translationY);
        } else {
            Honeycomb.setTranslationY(view, translationY);
        }
    }

    public static float getX(View view) {
        return NEEDS_PROXY ? wrap(view).getX() : Honeycomb.getX(view);
    }

    public static void setX(View view, float x) {
        if (NEEDS_PROXY) {
            wrap(view).setX(x);
        } else {
            Honeycomb.setX(view, x);
        }
    }

    public static float getY(View view) {
        return NEEDS_PROXY ? wrap(view).getY() : Honeycomb.getY(view);
    }

    public static void setY(View view, float y) {
        if (NEEDS_PROXY) {
            wrap(view).setY(y);
        } else {
            Honeycomb.setY(view, y);
        }
    }

    @SuppressLint("NewApi")
    private static final class Honeycomb {
        static float getAlpha(View view) {
            return view.getAlpha();
        }

        static void setAlpha(View view, float alpha) {
            view.setAlpha(alpha);
        }

        static float getPivotX(View view) {
            return view.getPivotX();
        }

        static void setPivotX(View view, float pivotX) {
            view.setPivotX(pivotX);
        }

        static float getPivotY(View view) {
            return view.getPivotY();
        }

        static void setPivotY(View view, float pivotY) {
            view.setPivotY(pivotY);
        }

        static float getRotation(View view) {
            return view.getRotation();
        }

        static void setRotation(View view, float rotation) {
            view.setRotation(rotation);
        }

        static float getRotationX(View view) {
            return view.getRotationX();
        }

        static void setRotationX(View view, float rotationX) {
            view.setRotationX(rotationX);
        }

        static float getRotationY(View view) {
            return view.getRotationY();
        }

        static void setRotationY(View view, float rotationY) {
            view.setRotationY(rotationY);
        }

        static float getScaleX(View view) {
            return view.getScaleX();
        }

        static void setScaleX(View view, float scaleX) {
            view.setScaleX(scaleX);
        }

        static float getScaleY(View view) {
            return view.getScaleY();
        }

        static void setScaleY(View view, float scaleY) {
            view.setScaleY(scaleY);
        }

        static float getScrollX(View view) {
            return view.getScrollX();
        }

        static void setScrollX(View view, int scrollX) {
            view.setScrollX(scrollX);
        }

        static float getScrollY(View view) {
            return view.getScrollY();
        }

        static void setScrollY(View view, int scrollY) {
            view.setScrollY(scrollY);
        }

        static float getTranslationX(View view) {
            return view.getTranslationX();
        }

        static void setTranslationX(View view, float translationX) {
            view.setTranslationX(translationX);
        }

        static float getTranslationY(View view) {
            return view.getTranslationY();
        }

        static void setTranslationY(View view, float translationY) {
            view.setTranslationY(translationY);
        }

        static float getX(View view) {
            return view.getX();
        }

        static void setX(View view, float x) {
            view.setX(x);
        }

        static float getY(View view) {
            return view.getY();
        }

        static void setY(View view, float y) {
            view.setY(y);
        }
    }
}

@#$
package com.andraskindler.quickscroll.animation;

import android.graphics.Camera;
import android.graphics.Matrix;
import android.graphics.RectF;
import android.os.Build;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.Transformation;

import java.lang.ref.WeakReference;
import java.util.WeakHashMap;

/**
 * A proxy class to allow for modifying post-3.0 view properties on all pre-3.0
 * platforms. <strong>DO NOT</strong> wrap your views with this class if you
 * are using {@code ObjectAnimator} as it will handle that itself.
 */
public final class AnimatorProxy extends Animation {
    /** Whether or not the current running platform needs to be proxied. */
    public static final boolean NEEDS_PROXY = Integer.valueOf(Build.VERSION.SDK).intValue() < Build.VERSION_CODES.HONEYCOMB;

    private static final WeakHashMap<View, AnimatorProxy> PROXIES =
            new WeakHashMap<View, AnimatorProxy>();

    /**
     * Create a proxy to allow for modifying post-3.0 view properties on all
     * pre-3.0 platforms. <strong>DO NOT</strong> wrap your views if you are
     * using {@code ObjectAnimator} as it will handle that itself.
     *
     * @param view View to wrap.
     * @return Proxy to post-3.0 properties.
     */
    public static AnimatorProxy wrap(View view) {
        AnimatorProxy proxy = PROXIES.get(view);
        // This checks if the proxy already exists and whether it still is the animation of the given view
        if (proxy == null || proxy != view.getAnimation()) {
            proxy = new AnimatorProxy(view);
            PROXIES.put(view, proxy);
        }
        return proxy;
    }

    private final WeakReference<View> mView;
    private final Camera mCamera = new Camera();
    private boolean mHasPivot;

    private float mAlpha = 1;
    private float mPivotX;
    private float mPivotY;
    private float mRotationX;
    private float mRotationY;
    private float mRotationZ;
    private float mScaleX = 1;
    private float mScaleY = 1;
    private float mTranslationX;
    private float mTranslationY;

    private final RectF mBefore = new RectF();
    private final RectF mAfter = new RectF();
    private final Matrix mTempMatrix = new Matrix();

    private AnimatorProxy(View view) {
        setDuration(0); //perform transformation immediately
        setFillAfter(true); //persist transformation beyond duration
        view.setAnimation(this);
        mView = new WeakReference<View>(view);
    }

    public float getAlpha() {
        return mAlpha;
    }
    public void setAlpha(float alpha) {
        if (mAlpha != alpha) {
            mAlpha = alpha;
            View view = mView.get();
            if (view != null) {
                view.invalidate();
            }
        }
    }
    public float getPivotX() {
        return mPivotX;
    }
    public void setPivotX(float pivotX) {
        if (!mHasPivot || mPivotX != pivotX) {
            prepareForUpdate();
            mHasPivot = true;
            mPivotX = pivotX;
            invalidateAfterUpdate();
        }
    }
    public float getPivotY() {
        return mPivotY;
    }
    public void setPivotY(float pivotY) {
        if (!mHasPivot || mPivotY != pivotY) {
            prepareForUpdate();
            mHasPivot = true;
            mPivotY = pivotY;
            invalidateAfterUpdate();
        }
    }
    public float getRotation() {
        return mRotationZ;
    }
    public void setRotation(float rotation) {
        if (mRotationZ != rotation) {
            prepareForUpdate();
            mRotationZ = rotation;
            invalidateAfterUpdate();
        }
    }
    public float getRotationX() {
        return mRotationX;
    }
    public void setRotationX(float rotationX) {
        if (mRotationX != rotationX) {
            prepareForUpdate();
            mRotationX = rotationX;
            invalidateAfterUpdate();
        }
    }
    public float getRotationY() {
        return mRotationY;
    }

    public void setRotationY(float rotationY) {
        if (mRotationY != rotationY) {
            prepareForUpdate();
            mRotationY = rotationY;
            invalidateAfterUpdate();
        }
    }
    public float getScaleX() {
        return mScaleX;
    }
    public void setScaleX(float scaleX) {
        if (mScaleX != scaleX) {
            prepareForUpdate();
            mScaleX = scaleX;
            invalidateAfterUpdate();
        }
    }
    public float getScaleY() {
        return mScaleY;
    }
    public void setScaleY(float scaleY) {
        if (mScaleY != scaleY) {
            prepareForUpdate();
            mScaleY = scaleY;
            invalidateAfterUpdate();
        }
    }
    public int getScrollX() {
        View view = mView.get();
        if (view == null) {
            return 0;
        }
        return view.getScrollX();
    }
    public void setScrollX(int value) {
        View view = mView.get();
        if (view != null) {
            view.scrollTo(value, view.getScrollY());
        }
    }
    public int getScrollY() {
        View view = mView.get();
        if (view == null) {
            return 0;
        }
        return view.getScrollY();
    }
    public void setScrollY(int value) {
        View view = mView.get();
        if (view != null) {
            view.scrollTo(view.getScrollX(), value);
        }
    }

    public float getTranslationX() {
        return mTranslationX;
    }
    public void setTranslationX(float translationX) {
        if (mTranslationX != translationX) {
            prepareForUpdate();
            mTranslationX = translationX;
            invalidateAfterUpdate();
        }
    }
    public float getTranslationY() {
        return mTranslationY;
    }
    public void setTranslationY(float translationY) {
        if (mTranslationY != translationY) {
            prepareForUpdate();
            mTranslationY = translationY;
            invalidateAfterUpdate();
        }
    }
    public float getX() {
        View view = mView.get();
        if (view == null) {
            return 0;
        }
        return view.getLeft() + mTranslationX;
    }
    public void setX(float x) {
        View view = mView.get();
        if (view != null) {
            setTranslationX(x - view.getLeft());
        }
    }
    public float getY() {
        View view = mView.get();
        if (view == null) {
            return 0;
        }
        return view.getTop() + mTranslationY;
    }
    public void setY(float y) {
        View view = mView.get();
        if (view != null) {
            setTranslationY(y - view.getTop());
        }
    }

    private void prepareForUpdate() {
        View view = mView.get();
        if (view != null) {
            computeRect(mBefore, view);
        }
    }
    private void invalidateAfterUpdate() {
        View view = mView.get();
        if (view == null || view.getParent() == null) {
            return;
        }

        final RectF after = mAfter;
        computeRect(after, view);
        after.union(mBefore);

        ((View)view.getParent()).invalidate(
                (int) Math.floor(after.left),
                (int) Math.floor(after.top),
                (int) Math.ceil(after.right),
                (int) Math.ceil(after.bottom));
    }

    private void computeRect(final RectF r, View view) {
        // compute current rectangle according to matrix transformation
        final float w = view.getWidth();
        final float h = view.getHeight();

        // use a rectangle at 0,0 to make sure we don't run into issues with scaling
        r.set(0, 0, w, h);

        final Matrix m = mTempMatrix;
        m.reset();
        transformMatrix(m, view);
        mTempMatrix.mapRect(r);

        r.offset(view.getLeft(), view.getTop());

        // Straighten coords if rotations flipped them
        if (r.right < r.left) {
            final float f = r.right;
            r.right = r.left;
            r.left = f;
        }
        if (r.bottom < r.top) {
            final float f = r.top;
            r.top = r.bottom;
            r.bottom = f;
        }
    }

    private void transformMatrix(Matrix m, View view) {
        final float w = view.getWidth();
        final float h = view.getHeight();
        final boolean hasPivot = mHasPivot;
        final float pX = hasPivot ? mPivotX : w / 2f;
        final float pY = hasPivot ? mPivotY : h / 2f;

        final float rX = mRotationX;
        final float rY = mRotationY;
        final float rZ = mRotationZ;
        if ((rX != 0) || (rY != 0) || (rZ != 0)) {
            final Camera camera = mCamera;
            camera.save();
            camera.rotateX(rX);
            camera.rotateY(rY);
            camera.rotateZ(-rZ);
            camera.getMatrix(m);
            camera.restore();
            m.preTranslate(-pX, -pY);
            m.postTranslate(pX, pY);
        }

        final float sX = mScaleX;
        final float sY = mScaleY;
        if ((sX != 1.0f) || (sY != 1.0f)) {
            m.postScale(sX, sY);
            final float sPX = -(pX / w) * ((sX * w) - w);
            final float sPY = -(pY / h) * ((sY * h) - h);
            m.postTranslate(sPX, sPY);
        }

        m.postTranslate(mTranslationX, mTranslationY);
    }

    @Override
    protected void applyTransformation(float interpolatedTime, Transformation t) {
        View view = mView.get();
        if (view != null) {
            t.setAlpha(mAlpha);
            transformMatrix(t.getMatrix(), view);
        }
    }
}

@#$
package com.velocity.view.pager.library;

/*
 * Copyright (C) 2010 The Android Open Source Project
 * Copyright (C) 2014 Benjamin Dobell, Glass Echidna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import android.content.Context;
import android.hardware.SensorManager;
import android.util.FloatMath;
import android.util.Log;
import android.view.ViewConfiguration;
import android.view.animation.AnimationUtils;
import android.view.animation.Interpolator;

/**
 * Based on Google's OverScroller, this class encapsulates scrolling with the
 * ability to overshoot the bounds of a scrolling operation. This class is a
 * drop-in replacement for {@link android.widget.Scroller} in most cases.
 *
 * Relative to Google's OverScroller, this class contains only minor changes
 * that add support for "under scrolling" behaviour. Additionally, the viscous
 * fluid behaviour is taken from Google's Scroller class and included here
 * because it is not publicly accessible through the Android SDK.
 */
public class VelocityScroller {
    private int mMode;

    private final SplineOverScroller mScrollerX;
    private final SplineOverScroller mScrollerY;

    private Interpolator mInterpolator;

    private final boolean mFlywheel;

    private static final int DEFAULT_DURATION = 250;
    private static final int SCROLL_MODE = 0;
    private static final int FLING_MODE = 1;

    private static float sViscousFluidScale;
    private static float sViscousFluidNormalize;

    private static float viscousFluid(float x)
    {
        x *= sViscousFluidScale;
        if (x < 1.0f) {
            x -= (1.0f - (float)Math.exp(-x));
        } else {
            float start = 0.36787944117f;   // 1/e == exp(-1)
            x = 1.0f - (float)Math.exp(1.0f - x);
            x = start + x * (1.0f - start);
        }
        x *= sViscousFluidNormalize;
        return x;
    }

    /**
     * Creates an VelocityScroller with a viscous fluid scroll interpolator and flywheel.
     * @param context
     */
    public VelocityScroller(Context context) {
        this(context, null);
    }

    /**
     * Creates an VelocityScroller with flywheel enabled.
     * @param context The context of this application.
     * @param interpolator The scroll interpolator. If null, a default (viscous) interpolator will
     * be used.
     */
    public VelocityScroller(Context context, Interpolator interpolator) {
        this(context, interpolator, true);
    }

    /**
     * Creates an VelocityScroller.
     * @param context The context of this application.
     * @param interpolator The scroll interpolator. If null, a default (viscous) interpolator will
     * be used.
     * @param flywheel If true, successive fling motions will keep on increasing scroll speed.
     * @hide
     */
    public VelocityScroller(Context context, Interpolator interpolator, boolean flywheel) {
        mInterpolator = interpolator;
        mFlywheel = flywheel;
        mScrollerX = new SplineOverScroller(context);
        mScrollerY = new SplineOverScroller(context);
    }

    /**
     * Creates an VelocityScroller with flywheel enabled.
     * @param context The context of this application.
     * @param interpolator The scroll interpolator. If null, a default (viscous) interpolator will
     * be used.
     * @param bounceCoefficientX A value between 0 and 1 that will determine the proportion of the
     * velocity which is preserved in the bounce when the horizontal edge is reached. A null value
     * means no bounce. This behavior is no longer supported and this coefficient has no effect.
     * @param bounceCoefficientY Same as bounceCoefficientX but for the vertical direction. This
     * behavior is no longer supported and this coefficient has no effect.
     * !deprecated Use {!link #VelocityScroller(Context, Interpolator, boolean)} instead.
     */
    public VelocityScroller(Context context, Interpolator interpolator,
                        float bounceCoefficientX, float bounceCoefficientY) {
        this(context, interpolator, true);
    }

    /**
     * Creates an VelocityScroller.
     * @param context The context of this application.
     * @param interpolator The scroll interpolator. If null, a default (viscous) interpolator will
     * be used.
     * @param bounceCoefficientX A value between 0 and 1 that will determine the proportion of the
     * velocity which is preserved in the bounce when the horizontal edge is reached. A null value
     * means no bounce. This behavior is no longer supported and this coefficient has no effect.
     * @param bounceCoefficientY Same as bounceCoefficientX but for the vertical direction. This
     * behavior is no longer supported and this coefficient has no effect.
     * @param flywheel If true, successive fling motions will keep on increasing scroll speed.
     * !deprecated Use {!link VelocityScroller(Context, Interpolator, boolean)} instead.
     */
    public VelocityScroller(Context context, Interpolator interpolator,
                        float bounceCoefficientX, float bounceCoefficientY, boolean flywheel) {
        this(context, interpolator, flywheel);
    }

    void setInterpolator(Interpolator interpolator) {
        mInterpolator = interpolator;
    }

    /**
     * The amount of friction applied to flings. The default value
     * is {@link android.view.ViewConfiguration#getScrollFriction}.
     *
     * @param friction A scalar dimension-less value representing the coefficient of
     *         friction.
     */
    public final void setFriction(float friction) {
        mScrollerX.setFriction(friction);
        mScrollerY.setFriction(friction);
    }

    /**
     *
     * Returns whether the scroller has finished scrolling.
     *
     * @return True if the scroller has finished scrolling, false otherwise.
     */
    public final boolean isFinished() {
        return mScrollerX.mFinished && mScrollerY.mFinished;
    }

    /**
     * Force the finished field to a particular value. Contrary to
     * {@link #abortAnimation()}, forcing the animation to finished
     * does NOT cause the scroller to move to the final x and y
     * position.
     *
     * @param finished The new finished value.
     */
    public final void forceFinished(boolean finished) {
        mScrollerX.mFinished = mScrollerY.mFinished = finished;
    }

    /**
     * Returns the current X offset in the scroll.
     *
     * @return The new X offset as an absolute distance from the origin.
     */
    public final int getCurrX() {
        return mScrollerX.mCurrentPosition;
    }

    /**
     * Returns the current Y offset in the scroll.
     *
     * @return The new Y offset as an absolute distance from the origin.
     */
    public final int getCurrY() {
        return mScrollerY.mCurrentPosition;
    }

    /**
     * Returns the absolute value of the current velocity.
     *
     * @return The original velocity less the deceleration, norm of the X and Y velocity vector.
     */
    public float getCurrVelocity() {
        float squaredNorm = mScrollerX.mCurrVelocity * mScrollerX.mCurrVelocity;
        squaredNorm += mScrollerY.mCurrVelocity * mScrollerY.mCurrVelocity;
        return FloatMath.sqrt(squaredNorm);
    }

    /**
     * Returns the start X offset in the scroll.
     *
     * @return The start X offset as an absolute distance from the origin.
     */
    public final int getStartX() {
        return mScrollerX.mStart;
    }

    /**
     * Returns the start Y offset in the scroll.
     *
     * @return The start Y offset as an absolute distance from the origin.
     */
    public final int getStartY() {
        return mScrollerY.mStart;
    }

    /**
     * Returns where the scroll will end. Valid only for "fling" scrolls.
     *
     * @return The final X offset as an absolute distance from the origin.
     */
    public final int getFinalX() {
        return mScrollerX.mFinal;
    }

    /**
     * Returns where the scroll will end. Valid only for "fling" scrolls.
     *
     * @return The final Y offset as an absolute distance from the origin.
     */
    public final int getFinalY() {
        return mScrollerY.mFinal;
    }

    /**
     * Returns how long the scroll event will take, in milliseconds.
     *
     * @return The duration of the scroll in milliseconds.
     *
     * @hide Pending removal once nothing depends on it
     * @deprecated VelocityScroller don't necessarily have a fixed duration.
     *             This function will lie to the best of its ability.
     */
    @Deprecated
    public final int getDuration() {
        return Math.max(mScrollerX.mDuration, mScrollerY.mDuration);
    }

    /**
     * Extend the scroll animation. This allows a running animation to scroll
     * further and longer, when used with {@link #setFinalX(int)} or {@link #setFinalY(int)}.
     *
     * @param extend Additional time to scroll in milliseconds.
     * @see #setFinalX(int)
     * @see #setFinalY(int)
     *
     * @hide Pending removal once nothing depends on it
     * @deprecated VelocityScroller don't necessarily have a fixed duration.
     *             Instead of setting a new final position and extending
     *             the duration of an existing scroll, use startScroll
     *             to begin a new animation.
     */
    @Deprecated
    public void extendDuration(int extend) {
        mScrollerX.extendDuration(extend);
        mScrollerY.extendDuration(extend);
    }

    /**
     * Sets the final position (X) for this scroller.
     *
     * @param newX The new X offset as an absolute distance from the origin.
     * @see #extendDuration(int)
     * @see #setFinalY(int)
     *
     * @hide Pending removal once nothing depends on it
     * @deprecated VelocityScroller's final position may change during an animation.
     *             Instead of setting a new final position and extending
     *             the duration of an existing scroll, use startScroll
     *             to begin a new animation.
     */
    @Deprecated
    public void setFinalX(int newX) {
        mScrollerX.setFinalPosition(newX);
    }

    /**
     * Sets the final position (Y) for this scroller.
     *
     * @param newY The new Y offset as an absolute distance from the origin.
     * @see #extendDuration(int)
     * @see #setFinalX(int)
     *
     * @hide Pending removal once nothing depends on it
     * @deprecated VelocityScroller's final position may change during an animation.
     *             Instead of setting a new final position and extending
     *             the duration of an existing scroll, use startScroll
     *             to begin a new animation.
     */
    @Deprecated
    public void setFinalY(int newY) {
        mScrollerY.setFinalPosition(newY);
    }

    /**
     * Call this when you want to know the new location. If it returns true, the
     * animation is not yet finished.
     */
    public boolean computeScrollOffset() {
        if (isFinished()) {
            return false;
        }

        switch (mMode) {
            case SCROLL_MODE:
                long time = AnimationUtils.currentAnimationTimeMillis();
                // Any scroller can be used for time, since they were started
                // together in scroll mode. We use X here.
                final long elapsedTime = time - mScrollerX.mStartTime;

                final int duration = mScrollerX.mDuration;
                if (elapsedTime < duration) {
                    float q = (float) (elapsedTime) / duration;

                    if (mInterpolator == null) {
                        q = viscousFluid(q);
                    } else {
                        q = mInterpolator.getInterpolation(q);
                    }

                    mScrollerX.updateScroll(q);
                    mScrollerY.updateScroll(q);
                } else {
                    abortAnimation();
                }
                break;

            case FLING_MODE:
                if (!mScrollerX.mFinished) {
                    if (!mScrollerX.update()) {
                        if (!mScrollerX.continueWhenFinished()) {
                            mScrollerX.finish();
                        }
                    }
                }

                if (!mScrollerY.mFinished) {
                    if (!mScrollerY.update()) {
                        if (!mScrollerY.continueWhenFinished()) {
                            mScrollerY.finish();
                        }
                    }
                }

                break;
        }

        return true;
    }

    /**
     * Start scrolling by providing a starting point and the distance to travel.
     * The scroll will use the default value of 250 milliseconds for the
     * duration.
     *
     * @param startX Starting horizontal scroll offset in pixels. Positive
     *        numbers will scroll the content to the left.
     * @param startY Starting vertical scroll offset in pixels. Positive numbers
     *        will scroll the content up.
     * @param dx Horizontal distance to travel. Positive numbers will scroll the
     *        content to the left.
     * @param dy Vertical distance to travel. Positive numbers will scroll the
     *        content up.
     */
    public void startScroll(int startX, int startY, int dx, int dy) {
        startScroll(startX, startY, dx, dy, DEFAULT_DURATION);
    }

    /**
     * Start scrolling by providing a starting point and the distance to travel.
     *
     * @param startX Starting horizontal scroll offset in pixels. Positive
     *        numbers will scroll the content to the left.
     * @param startY Starting vertical scroll offset in pixels. Positive numbers
     *        will scroll the content up.
     * @param dx Horizontal distance to travel. Positive numbers will scroll the
     *        content to the left.
     * @param dy Vertical distance to travel. Positive numbers will scroll the
     *        content up.
     * @param duration Duration of the scroll in milliseconds.
     */
    public void startScroll(int startX, int startY, int dx, int dy, int duration) {
        mMode = SCROLL_MODE;
        mScrollerX.startScroll(startX, dx, duration);
        mScrollerY.startScroll(startY, dy, duration);
    }

    /**
     * Call this when you want to 'spring back' into a valid coordinate range.
     *
     * @param startX Starting X coordinate
     * @param startY Starting Y coordinate
     * @param minX Minimum valid X value
     * @param maxX Maximum valid X value
     * @param minY Minimum valid Y value
     * @param maxY Minimum valid Y value
     * @return true if a springback was initiated, false if startX and startY were
     *          already within the valid range.
     */
    public boolean springBack(int startX, int startY, int minX, int maxX, int minY, int maxY) {
        mMode = FLING_MODE;

        // Make sure both methods are called.
        final boolean spingbackX = mScrollerX.springback(startX, minX, maxX);
        final boolean spingbackY = mScrollerY.springback(startY, minY, maxY);
        return spingbackX || spingbackY;
    }

    public void fling(int startX, int startY, int velocityX, int velocityY,
                      int minX, int maxX, int minY, int maxY) {
        fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, 0, 0);
    }

    /**
     * Start scrolling based on a fling gesture. The distance traveled will
     * depend on the initial velocity of the fling.
     *
     * @param startX Starting point of the scroll (X)
     * @param startY Starting point of the scroll (Y)
     * @param velocityX Initial velocity of the fling (X) measured in pixels per
     *            second.
     * @param velocityY Initial velocity of the fling (Y) measured in pixels per
     *            second
     * @param minX Minimum X value. The scroller will not scroll past this point
     *            unless overX > 0. If overfling is allowed, it will use minX as
     *            a springback boundary.
     * @param maxX Maximum X value. The scroller will not scroll past this point
     *            unless overX > 0. If overfling is allowed, it will use maxX as
     *            a springback boundary.
     * @param minY Minimum Y value. The scroller will not scroll past this point
     *            unless overY > 0. If overfling is allowed, it will use minY as
     *            a springback boundary.
     * @param maxY Maximum Y value. The scroller will not scroll past this point
     *            unless overY > 0. If overfling is allowed, it will use maxY as
     *            a springback boundary.
     * @param overX Overfling range. If > 0, horizontal overfling in either
     *            direction will be possible.
     * @param overY Overfling range. If > 0, vertical overfling in either
     *            direction will be possible.
     */
    public void fling(int startX, int startY, int velocityX, int velocityY,
                      int minX, int maxX, int minY, int maxY, int overX, int overY) {
        // Continue a scroll or fling in progress
        if (mFlywheel && !isFinished()) {
            float oldVelocityX = mScrollerX.mCurrVelocity;
            float oldVelocityY = mScrollerY.mCurrVelocity;
            if (Math.signum(velocityX) == Math.signum(oldVelocityX) &&
                    Math.signum(velocityY) == Math.signum(oldVelocityY)) {
                velocityX += oldVelocityX;
                velocityY += oldVelocityY;
            }
        }

        mMode = FLING_MODE;
        mScrollerX.fling(startX, velocityX, minX, maxX, overX);
        mScrollerY.fling(startY, velocityY, minY, maxY, overY);
    }

    /**
     * Notify the scroller that we've reached a horizontal boundary.
     * Normally the information to handle this will already be known
     * when the animation is started, such as in a call to one of the
     * fling functions. However there are cases where this cannot be known
     * in advance. This function will transition the current motion and
     * animate from startX to finalX as appropriate.
     *
     * @param startX Starting/current X position
     * @param finalX Desired final X position
     * @param overX Magnitude of overscroll allowed. This should be the maximum
     *              desired distance from finalX. Absolute value - must be positive.
     */
    public void notifyHorizontalEdgeReached(int startX, int finalX, int overX) {
        mScrollerX.notifyEdgeReached(startX, finalX, overX);
    }

    /**
     * Notify the scroller that we've reached a vertical boundary.
     * Normally the information to handle this will already be known
     * when the animation is started, such as in a call to one of the
     * fling functions. However there are cases where this cannot be known
     * in advance. This function will animate a parabolic motion from
     * startY to finalY.
     *
     * @param startY Starting/current Y position
     * @param finalY Desired final Y position
     * @param overY Magnitude of overscroll allowed. This should be the maximum
     *              desired distance from finalY. Absolute value - must be positive.
     */
    public void notifyVerticalEdgeReached(int startY, int finalY, int overY) {
        mScrollerY.notifyEdgeReached(startY, finalY, overY);
    }

    public void notifyFinalXExtended(int finalX) {
        mScrollerX.notifyFinalPositionExtended(finalX);
    }

    public void notifyFinalYExtended(int finalY) {
        mScrollerY.notifyFinalPositionExtended(finalY);
    }

    /**
     * Returns whether the current Scroller is currently returning to a valid position.
     * Valid bounds were provided by the
     * {@link #fling(int, int, int, int, int, int, int, int, int, int)} method.
     *
     * One should check this value before calling
     * {@link #startScroll(int, int, int, int)} as the interpolation currently in progress
     * to restore a valid position will then be stopped. The caller has to take into account
     * the fact that the started scroll will start from an overscrolled position.
     *
     * @return true when the current position is overscrolled and in the process of
     *         interpolating back to a valid value.
     */
    public boolean isOverScrolled() {
        return ((!mScrollerX.mFinished &&
                mScrollerX.mState != SplineOverScroller.SPLINE) ||
                (!mScrollerY.mFinished &&
                        mScrollerY.mState != SplineOverScroller.SPLINE));
    }

    /**
     * Stops the animation. Contrary to {@link #forceFinished(boolean)},
     * aborting the animating causes the scroller to move to the final x and y
     * positions.
     *
     * @see #forceFinished(boolean)
     */
    public void abortAnimation() {
        mScrollerX.finish();
        mScrollerY.finish();
    }

    /**
     * Returns the time elapsed since the beginning of the scrolling.
     *
     * @return The elapsed time in milliseconds.
     *
     * @hide
     */
    public int timePassed() {
        final long time = AnimationUtils.currentAnimationTimeMillis();
        final long startTime = Math.min(mScrollerX.mStartTime, mScrollerY.mStartTime);
        return (int) (time - startTime);
    }

    /**
     * @hide
     */
    public boolean isScrollingInDirection(float xvel, float yvel) {
        final int dx = mScrollerX.mFinal - mScrollerX.mStart;
        final int dy = mScrollerY.mFinal - mScrollerY.mStart;
        return !isFinished() && Math.signum(xvel) == Math.signum(dx) &&
                Math.signum(yvel) == Math.signum(dy);
    }

    static class SplineOverScroller {
        // Initial position
        private int mStart;

        // Current position
        private int mCurrentPosition;

        // Final position
        private int mFinal;

        // Initial velocity
        private int mVelocity;

        // Current velocity
        private float mCurrVelocity;

        // Constant current deceleration
        private float mDeceleration;

        // Animation starting time, in system milliseconds
        private long mStartTime;

        // Animation duration, in milliseconds
        private int mDuration;

        // Duration to complete spline component of animation
        private int mSplineDuration;

        // Distance to travel along spline animation
        private int mSplineDistance;

        // Whether the animation is currently in progress
        private boolean mFinished;

        // The allowed overshot distance before boundary is reached.
        private int mOver;

        // Fling friction
        private float mFlingFriction = ViewConfiguration.getScrollFriction();

        // Current state of the animation.
        private int mState = SPLINE;

        // Constant gravity value, used in the deceleration phase.
        private static final float GRAVITY = 2000.0f;

        // A context-specific coefficient adjusted to physical values.
        private float mPhysicalCoeff;

        private static float DECELERATION_RATE = (float) (Math.log(0.78) / Math.log(0.9));
        private static final float INFLEXION = 0.35f; // Tension lines cross at (INFLEXION, 1)
        private static final float START_TENSION = 0.5f;
        private static final float END_TENSION = 1.0f;
        private static final float P1 = START_TENSION * INFLEXION;
        private static final float P2 = 1.0f - END_TENSION * (1.0f - INFLEXION);

        private static final int NB_SAMPLES = 100;
        private static final float[] SPLINE_POSITION = new float[NB_SAMPLES + 1];
        private static final float[] SPLINE_TIME = new float[NB_SAMPLES + 1];

        private static final int SPLINE = 0;
        private static final int CUBIC = 1;
        private static final int BALLISTIC = 2;

        static {
            float x_min = 0.0f;
            float y_min = 0.0f;
            for (int i = 0; i < NB_SAMPLES; i++) {
                final float alpha = (float) i / NB_SAMPLES;

                float x_max = 1.0f;
                float x, tx, coef;
                while (true) {
                    x = x_min + (x_max - x_min) / 2.0f;
                    coef = 3.0f * x * (1.0f - x);
                    tx = coef * ((1.0f - x) * P1 + x * P2) + x * x * x;
                    if (Math.abs(tx - alpha) < 1E-5) break;
                    if (tx > alpha) x_max = x;
                    else x_min = x;
                }
                SPLINE_POSITION[i] = coef * ((1.0f - x) * START_TENSION + x) + x * x * x;

                float y_max = 1.0f;
                float y, dy;
                while (true) {
                    y = y_min + (y_max - y_min) / 2.0f;
                    coef = 3.0f * y * (1.0f - y);
                    dy = coef * ((1.0f - y) * START_TENSION + y) + y * y * y;
                    if (Math.abs(dy - alpha) < 1E-5) break;
                    if (dy > alpha) y_max = y;
                    else y_min = y;
                }
                SPLINE_TIME[i] = coef * ((1.0f - y) * P1 + y * P2) + y * y * y;
            }
            SPLINE_POSITION[NB_SAMPLES] = SPLINE_TIME[NB_SAMPLES] = 1.0f;

            // This controls the viscous fluid effect (how much of it)
            sViscousFluidScale = 8.0f;
            // must be set to 1.0 (used in viscousFluid())
            sViscousFluidNormalize = 1.0f;
            sViscousFluidNormalize = 1.0f / viscousFluid(1.0f);
        }

        void setFriction(float friction) {
            mFlingFriction = friction;
        }

        SplineOverScroller(Context context) {
            mFinished = true;
            final float ppi = context.getResources().getDisplayMetrics().density * 160.0f;
            mPhysicalCoeff = SensorManager.GRAVITY_EARTH // g (m/s^2)
                    * 39.37f // inch/meter
                    * ppi
                    * 0.84f; // look and feel tuning
        }

        void updateScroll(float q) {
            mCurrentPosition = mStart + Math.round(q * (mFinal - mStart));
        }

        /*
         * Get a signed deceleration that will reduce the velocity.
         */
        static private float getDeceleration(int velocity) {
            return velocity > 0 ? -GRAVITY : GRAVITY;
        }

        /*
         * Modifies mDuration to the duration it takes to get from start to newFinal using the
         * spline interpolation. The previous duration was needed to get to oldFinal.
         */
        private void adjustDuration(int start, int oldFinal, int newFinal) {
            final int oldDistance = oldFinal - start;
            final int newDistance = newFinal - start;
            final float x = Math.abs((float) newDistance / oldDistance);
            final int index = (int) (NB_SAMPLES * x);
            if (index < NB_SAMPLES) {
                final float x_inf = (float) index / NB_SAMPLES;
                final float x_sup = (float) (index + 1) / NB_SAMPLES;
                final float t_inf = SPLINE_TIME[index];
                final float t_sup = SPLINE_TIME[index + 1];
                final float timeCoef = t_inf + (x - x_inf) / (x_sup - x_inf) * (t_sup - t_inf);
                mDuration *= timeCoef;
            }
        }

        void startScroll(int start, int distance, int duration) {
            mFinished = false;

            mStart = start;
            mFinal = start + distance;

            mStartTime = AnimationUtils.currentAnimationTimeMillis();
            mDuration = duration;

            // Unused
            mDeceleration = 0.0f;
            mVelocity = 0;
        }

        void finish() {
            mCurrentPosition = mFinal;
            // Not reset since WebView relies on this value for fast fling.
            // TODO: restore when WebView uses the fast fling implemented in this class.
            // mCurrVelocity = 0.0f;
            mFinished = true;
        }

        void setFinalPosition(int position) {
            mFinal = position;
            mFinished = false;
        }

        void extendDuration(int extend) {
            final long time = AnimationUtils.currentAnimationTimeMillis();
            final int elapsedTime = (int) (time - mStartTime);
            mDuration = elapsedTime + extend;
            mFinished = false;
        }

        boolean springback(int start, int min, int max) {
            mFinished = true;

            mStart = mFinal = start;
            mVelocity = 0;

            mStartTime = AnimationUtils.currentAnimationTimeMillis();
            mDuration = 0;

            if (start < min) {
                startSpringback(start, min, 0);
            } else if (start > max) {
                startSpringback(start, max, 0);
            }

            return !mFinished;
        }

        private void startSpringback(int start, int end, int velocity) {
            // mStartTime has been set
            mFinished = false;
            mState = CUBIC;
            mStart = start;
            mFinal = end;
            final int delta = start - end;
            mDeceleration = getDeceleration(delta);
            // TODO take velocity into account
            mVelocity = -delta; // only sign is used
            mOver = Math.abs(delta);
            mDuration = (int) (1000.0 * Math.sqrt(-2.0 * delta / mDeceleration));
        }

        void fling(int start, int velocity, int min, int max, int over) {
            mOver = over;
            mFinished = false;
            mCurrVelocity = mVelocity = velocity;
            mDuration = mSplineDuration = 0;
            mStartTime = AnimationUtils.currentAnimationTimeMillis();
            mCurrentPosition = mStart = start;

            if (start > max || start < min) {
                startAfterEdge(start, min, max, velocity);
                return;
            }

            mState = SPLINE;
            double totalDistance = 0.0;

            if (velocity != 0) {
                mDuration = mSplineDuration = getSplineFlingDuration(velocity);
                totalDistance = getSplineFlingDistance(velocity);
            }

            mSplineDistance = (int) (totalDistance * Math.signum(velocity));
            mFinal = start + mSplineDistance;

            // Clamp to a valid final position
            if (mFinal < min) {
                adjustDuration(mStart, mFinal, min);
                mFinal = min;
            }

            if (mFinal > max) {
                adjustDuration(mStart, mFinal, max);
                mFinal = max;
            }
        }

        private double getSplineDeceleration(int velocity) {
            return Math.log(INFLEXION * Math.abs(velocity) / (mFlingFriction * mPhysicalCoeff));
        }

        private double getSplineFlingDistance(int velocity) {
            final double l = getSplineDeceleration(velocity);
            final double decelMinusOne = DECELERATION_RATE - 1.0;
            return mFlingFriction * mPhysicalCoeff * Math.exp(DECELERATION_RATE / decelMinusOne * l);
        }

        /* Returns the duration, expressed in milliseconds */
        private int getSplineFlingDuration(int velocity) {
            final double l = getSplineDeceleration(velocity);
            final double decelMinusOne = DECELERATION_RATE - 1.0;
            return (int) (1000.0 * Math.exp(l / decelMinusOne));
        }

        private void fitOnBounceCurve(int start, int end, int velocity) {
            // Simulate a bounce that started from edge
            final float durationToApex = - velocity / mDeceleration;
            final float distanceToApex = velocity * velocity / 2.0f / Math.abs(mDeceleration);
            final float distanceToEdge = Math.abs(end - start);
            final float totalDuration = (float) Math.sqrt(
                    2.0 * (distanceToApex + distanceToEdge) / Math.abs(mDeceleration));
            mStartTime -= (int) (1000.0f * (totalDuration - durationToApex));
            mStart = end;
            mVelocity = (int) (- mDeceleration * totalDuration);
        }

        private void startBounceAfterEdge(int start, int end, int velocity) {
            mDeceleration = getDeceleration(velocity == 0 ? start - end : velocity);
            fitOnBounceCurve(start, end, velocity);
            onEdgeReached();
        }

        private void startAfterEdge(int start, int min, int max, int velocity) {
            if (start > min && start < max) {
                Log.e("VelocityScroller", "startAfterEdge called from a valid position");
                mFinished = true;
                return;
            }
            final boolean positive = start > max;
            final int edge = positive ? max : min;
            final int overDistance = start - edge;
            boolean keepIncreasing = overDistance * velocity >= 0;
            if (keepIncreasing) {
                // Will result in a bounce or a to_boundary depending on velocity.
                startBounceAfterEdge(start, edge, velocity);
            } else {
                final double totalDistance = getSplineFlingDistance(velocity);
                if (totalDistance > Math.abs(overDistance)) {
                    fling(start, velocity, positive ? min : start, positive ? start : max, mOver);
                } else {
                    startSpringback(start, edge, velocity);
                }
            }
        }

        void notifyEdgeReached(int start, int end, int over) {
            // mState is used to detect successive notifications
            if (mState == SPLINE) {
                mOver = over;
                mStartTime = AnimationUtils.currentAnimationTimeMillis();
                // We were in fling/scroll mode before: current velocity is such that distance to
                // edge is increasing. This ensures that startAfterEdge will not start a new fling.
                startAfterEdge(start, end, end, (int) mCurrVelocity);
            }
        }

        // TODO: Don't discard current velocity, use spline interpolation instead.
        public void notifyFinalPositionExtended(int position) {
            mOver = 0;
            mFinished = false;
            mDuration = mDuration - (int) (mStartTime - AnimationUtils.currentAnimationTimeMillis());

            if (mDuration < 50) {
                mDuration = 50;
            }

            mSplineDuration = mDuration;

            mStartTime = AnimationUtils.currentAnimationTimeMillis();
            mStart = mCurrentPosition;
            mFinal = position;

            mState = SPLINE;

            mSplineDistance = mFinal - mStart;
        }

        private void onEdgeReached() {
            // mStart, mVelocity and mStartTime were adjusted to their values when edge was reached.
            float distance = mVelocity * mVelocity / (2.0f * Math.abs(mDeceleration));
            final float sign = Math.signum(mVelocity);

            if (distance > mOver) {
                // Default deceleration is not sufficient to slow us down before boundary
                mDeceleration = - sign * mVelocity * mVelocity / (2.0f * mOver);
                distance = mOver;
            }

            mOver = (int) distance;
            mState = BALLISTIC;
            mFinal = mStart + (int) (mVelocity > 0 ? distance : -distance);
            mDuration = - (int) (1000.0f * mVelocity / mDeceleration);
        }

        boolean continueWhenFinished() {
            switch (mState) {
                case SPLINE:
                    // Duration from start to null velocity
                    if (mDuration < mSplineDuration) {
                        // If the animation was clamped, we reached the edge
                        mStart = mFinal;
                        // TODO Better compute speed when edge was reached
                        mVelocity = (int) mCurrVelocity;
                        mDeceleration = getDeceleration(mVelocity);
                        mStartTime += mDuration;
                        onEdgeReached();
                    } else {
                        // Normal stop, no need to continue
                        return false;
                    }
                    break;
                case BALLISTIC:
                    mStartTime += mDuration;
                    startSpringback(mFinal, mStart, 0);
                    break;
                case CUBIC:
                    return false;
            }

            update();
            return true;
        }

        /*
         * Update the current position and velocity for current time. Returns
         * true if update has been done and false if animation duration has been
         * reached.
         */
        boolean update() {
            final long time = AnimationUtils.currentAnimationTimeMillis();
            final long currentTime = time - mStartTime;

            if (currentTime > mDuration) {
                return false;
            }

            double distance = 0.0;
            switch (mState) {
                case SPLINE: {
                    final float t = (float) currentTime / mSplineDuration;
                    final int index = (int) (NB_SAMPLES * t);
                    float distanceCoef = 1.f;
                    float velocityCoef = 0.f;
                    if (index < NB_SAMPLES) {
                        final float t_inf = (float) index / NB_SAMPLES;
                        final float t_sup = (float) (index + 1) / NB_SAMPLES;
                        final float d_inf = SPLINE_POSITION[index];
                        final float d_sup = SPLINE_POSITION[index + 1];
                        velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                        distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                    }

                    distance = distanceCoef * mSplineDistance;
                    mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * 1000.0f;
                    break;
                }

                case BALLISTIC: {
                    final float t = currentTime / 1000.0f;
                    mCurrVelocity = mVelocity + mDeceleration * t;
                    distance = mVelocity * t + mDeceleration * t * t / 2.0f;
                    break;
                }

                case CUBIC: {
                    final float t = (float) (currentTime) / mDuration;
                    final float t2 = t * t;
                    final float sign = Math.signum(mVelocity);
                    distance = sign * mOver * (3.0f * t2 - 2.0f * t * t2);
                    mCurrVelocity = sign * mOver * 6.0f * (- t + t2);
                    break;
                }
            }

            mCurrentPosition = mStart + (int) Math.round(distance);

            return true;
        }
    }
}

@#$
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.velocity.view.pager.library;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.database.DataSetObserver;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;
import android.os.SystemClock;
import android.support.v4.os.ParcelableCompat;
import android.support.v4.os.ParcelableCompatCreatorCallbacks;
import android.support.v4.view.*;
import android.support.v4.view.accessibility.AccessibilityEventCompat;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import android.support.v4.view.accessibility.AccessibilityRecordCompat;
import android.support.v4.widget.EdgeEffectCompat;
import android.util.AttributeSet;
import android.util.Log;
import android.view.FocusFinder;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.SoundEffectConstants;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewGroup;
import android.view.ViewParent;
import android.view.accessibility.AccessibilityEvent;
import android.view.animation.AnimationUtils;
import android.view.animation.Interpolator;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

/**
 * Layout manager that allows the user to flip left and right
 * through pages of data.  You supply an implementation of a
 * {@link PagerAdapter} to generate the pages that the view shows.
 *
 * Based on the support library's ViewPager, this class includes
 * modifications that add support continuous scrolling fling
 * gestures and customised rendering logic to allow support for
 * carousel-like behaviour.
 */
public class VelocityViewPager extends ViewGroup implements View.OnClickListener, View.OnLongClickListener {
	
    private static final String TAG = "VelocityViewPager";
    private static final boolean DEBUG = false;

    private static final boolean USE_CACHE = false;

    private static final int DEFAULT_OFFSCREEN_PAGES = 1;
    private static final int MAX_SETTLE_DURATION = 600; // ms
    private static final int MIN_DISTANCE_FOR_FLING = 25; // dips

    private static final int DEFAULT_GUTTER_SIZE = 16; // dips

    private static final int MIN_FLING_VELOCITY = 400; // dips

    private static final int[] LAYOUT_ATTRS = new int[] {
            android.R.attr.layout_gravity
    };

    /**
     * Used to track what the expected number of items in the adapter should be.
     * If the app changes this when we don't expect it, we'll throw a big obnoxious exception.
     */
    private int mExpectedAdapterCount;

    static class ItemInfo {
        Object object;
        int position;
        boolean scrolling;
        float widthFactor;
        float offset;
    }

    private static final Comparator<ItemInfo> COMPARATOR = new Comparator<ItemInfo>(){
        @Override
        public int compare(ItemInfo lhs, ItemInfo rhs) {
            return lhs.position - rhs.position;
        }
    };

    private static final Interpolator sInterpolator = new Interpolator() {
        public float getInterpolation(float t) {
            t -= 1.0f;
            return t * t * t * t * t + 1.0f;
        }
    };

    private static final int FLINGING_STOPPED = 0;
    private static final int FLINGING_LEFT = 1;
    private static final int FLINGING_RIGHT = 2;

    private final ArrayList<ItemInfo> mItems = new ArrayList<ItemInfo>();
    private final ItemInfo mTempItem = new ItemInfo();

    private final Rect mTempRect = new Rect();

    private PagerAdapter mAdapter;
    private int mCurItem;   // Index of currently displayed page.
    private int mRestoredCurItem = -1;
    private Parcelable mRestoredAdapterState = null;
    private ClassLoader mRestoredClassLoader = null;
    private VelocityScroller mScroller;
    private PagerObserver mObserver;

    private int mPageMargin;
    private Drawable mMarginDrawable;
    private int mTopPageBounds;
    private int mBottomPageBounds;

    // Offsets of the first and last items, if known.
    // Set during population, used to determine if we are at the beginning
    // or end of the pager data set during touch scrolling.
    private float mFirstOffset = -Float.MAX_VALUE;
    private float mLastOffset = Float.MAX_VALUE;
    private boolean mOffsetToLastPageAllowed = false;

    private int mChildWidthMeasureSpec;
    private int mChildHeightMeasureSpec;
    private boolean mInLayout;

    private boolean mScrollingCacheEnabled;

    private int mOffscreenPageLimit = DEFAULT_OFFSCREEN_PAGES;

    private boolean mIsBeingDragged;
    private boolean mIsUnableToDrag;
    private boolean mIgnoreGutter;
    private int mDefaultGutterSize;
    private int mGutterSize;
    private int mTouchSlop;
    /**
     * Position of the last motion event.
     */
    private float mLastMotionX;
    private float mLastMotionY;
    private float mInitialMotionX;
    private float mInitialMotionY;
    /**
     * ID of the active pointer. This is used to retain consistency during
     * drags/flings if multiple pointers are used.
     */
    private int mActivePointerId = INVALID_POINTER;
    /**
     * Sentinel value for no current active pointer.
     * Used by {@link #mActivePointerId}.
     */
    private static final int INVALID_POINTER = -1;

    /**
     * Determines speed during touch scrolling
     */
    private VelocityTracker mVelocityTracker;
    private int mMinimumVelocity;
    private int mMaximumVelocity;
    private int mFlingDistance;
    private int mCloseEnough;
    private long mScrollStartTime;
    private int mScrollDuration;
    private int mFlinging;

    // If the pager is at least this close to its final position, complete the scroll
    // on touch down and let the user interact with the content inside instead of
    // "catching" the flinging pager.
    private static final int CLOSE_ENOUGH = 2; // dp

    private boolean mFakeDragging;
    private long mFakeDragBeginTime;

    private EdgeEffectCompat mLeftEdge;
    private EdgeEffectCompat mRightEdge;

    private boolean mFirstLayout = true;
    private boolean mNeedCalculatePageOffsets = false;
    private boolean mCalledSuper;
    private int mDecorChildCount;

    private OnPageChangeListener mOnPageChangeListener;
    private OnPageChangeListener mInternalPageChangeListener;
    private OnAdapterChangeListener mAdapterChangeListener;
    private PageTransformer mPageTransformer;
    private Method mSetChildrenDrawingOrderEnabled;

    private static final int DRAW_ORDER_DEFAULT = 0;
    private static final int DRAW_ORDER_FORWARD = 1;
    private static final int DRAW_ORDER_REVERSE = 2;
    private int mDrawingOrder;
    private ArrayList<View> mDrawingOrderedChildren;
    private Comparator<View> mDrawOrderComparator = new ViewPositionComparator();

    private OnItemClickListener mOnItemClickListener;
    private OnItemLongClickListener mOnItemLongClickListener;

    /**
     * Indicates that the pager is in an idle, settled state. The current page
     * is fully in view and no animation is in progress.
     */
    public static final int SCROLL_STATE_IDLE = 0;

    /**
     * Indicates that the pager is currently being dragged by the user.
     */
    public static final int SCROLL_STATE_DRAGGING = 1;

    /**
     * Indicates that the pager is in the process of settling to a final position.
     */
    public static final int SCROLL_STATE_SETTLING = 2;

    private final Runnable mEndScrollRunnable = new Runnable() {
        public void run() {
            setScrollState(SCROLL_STATE_IDLE);
            populate();
        }
    };

    private int mScrollState = SCROLL_STATE_IDLE;

    /**
     * Callback interface for responding to changing state of the selected page.
     */
    public interface OnPageChangeListener {

        /**
         * This method will be invoked when the current page is scrolled, either as part
         * of a programmatically initiated smooth scroll or a user initiated touch scroll.
         *
         * @param position Position index of the first page currently being displayed.
         *                 Page position+1 will be visible if positionOffset is nonzero.
         * @param positionOffset Value from [0, 1) indicating the offset from the page at position.
         * @param positionOffsetPixels Value in pixels indicating the offset from position.
         */
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels);

        /**
         * This method will be invoked when a new page becomes selected. Animation is not
         * necessarily complete.
         *
         * @param position Position index of the new selected page.
         */
        public void onPageSelected(int position);

        /**
         * Called when the scroll state changes. Useful for discovering when the user
         * begins dragging, when the pager is automatically settling to the current page,
         * or when it is fully stopped/idle.
         *
         * @param state The new scroll state.
         * @see VelocityViewPager#SCROLL_STATE_IDLE
         * @see VelocityViewPager#SCROLL_STATE_DRAGGING
         * @see VelocityViewPager#SCROLL_STATE_SETTLING
         */
        public void onPageScrollStateChanged(int state);
    }

    /**
     * Simple implementation of the {@link OnPageChangeListener} interface with stub
     * implementations of each method. Extend this if you do not intend to override
     * every method of {@link OnPageChangeListener}.
     */
    public static class SimpleOnPageChangeListener implements OnPageChangeListener {
        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            // This space for rent
        }

        @Override
        public void onPageSelected(int position) {
            // This space for rent
        }

        @Override
        public void onPageScrollStateChanged(int state) {
            // This space for rent
        }
    }

    /**
     * Default view rendering order comparator identical to that used in the
     * support library's ViewPager.
     */
    public static class ViewPositionComparator implements Comparator<View> {
        @Override
        public int compare(View lhs, View rhs) {
            final LayoutParams llp = (LayoutParams) lhs.getLayoutParams();
            final LayoutParams rlp = (LayoutParams) rhs.getLayoutParams();
            if (llp.isDecor != rlp.isDecor) {
                return llp.isDecor ? 1 : -1;
            }
            return llp.position - rlp.position;
        }
    }

    /**
     * A PageTransformer is invoked whenever a visible/attached page is scrolled.
     * This offers an opportunity for the application to apply a custom transformation
     * to the page views using animation properties.
     *
     * <p>As property animation is only supported as of Android 3.0 and forward,
     * setting a PageTransformer on a ViewPager on earlier platform versions will
     * be ignored.</p>
     */
    public interface PageTransformer {
        /**
         * Apply a property transformation to the given page.
         *
         * @param page Apply the transformation to this page
         * @param position Position of page relative to the current front-and-center
         *                 position of the pager. 0 is front and center. 1 is one full
         *                 page position to the right, and -1 is one page position to the left.
         */
        public void transformPage(View page, float position);
    }

    /**
     * Used internally to monitor when adapters are switched.
     */
    interface OnAdapterChangeListener {
        public void onAdapterChanged(PagerAdapter oldAdapter, PagerAdapter newAdapter);
    }

    /**
     * Used internally to tag special types of child views that should be added as
     * pager decorations by default.
     */
    interface Decor {}

    public VelocityViewPager(Context context) {
        super(context);
        initViewPager();
    }

    public VelocityViewPager(Context context, AttributeSet attrs) {
        super(context, attrs);
        initViewPager();
    }

    void initViewPager() {
        setWillNotDraw(false);
        setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
        setFocusable(true);
        final Context context = getContext();
        mScroller = new VelocityScroller(context, sInterpolator);
        final ViewConfiguration configuration = ViewConfiguration.get(context);
        final float density = context.getResources().getDisplayMetrics().density;

        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
        mMinimumVelocity = (int) (MIN_FLING_VELOCITY * density);
        mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
        mLeftEdge = new EdgeEffectCompat(context);
        mRightEdge = new EdgeEffectCompat(context);

        mFlingDistance = (int) (MIN_DISTANCE_FOR_FLING * density);
        mCloseEnough = (int) (CLOSE_ENOUGH * density);
        mDefaultGutterSize = (int) (DEFAULT_GUTTER_SIZE * density);

        ViewCompat.setAccessibilityDelegate(this, new MyAccessibilityDelegate());

        if (ViewCompat.getImportantForAccessibility(this)
                == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            ViewCompat.setImportantForAccessibility(this,
                    ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
    }

    @Override
    protected void onDetachedFromWindow() {
        removeCallbacks(mEndScrollRunnable);
        super.onDetachedFromWindow();
    }

    private void setScrollState(int newState) {
        if (mScrollState == newState) {
            return;
        }

        mScrollState = newState;
        if (mPageTransformer != null) {
            // PageTransformers can do complex things that benefit from hardware layers.
            enableLayers(newState != SCROLL_STATE_IDLE);
        }
        if (mOnPageChangeListener != null) {
            mOnPageChangeListener.onPageScrollStateChanged(newState);
        }

}
    /**
     * Set a PagerAdapter that will supply views for this pager as needed.
     *
     * @param adapter Adapter to use
     */
    public void setAdapter(PagerAdapter adapter) {
        if (mAdapter != null) {
            mAdapter.unregisterDataSetObserver(mObserver);
            mAdapter.startUpdate(this);
            for (int i = 0; i < mItems.size(); i++) {
                final ItemInfo ii = mItems.get(i);
                mAdapter.destroyItem(this, ii.position, ii.object);
            }
            mAdapter.finishUpdate(this);
            mItems.clear();
            removeNonDecorViews();
            mCurItem = 0;
            scrollTo(0, 0);
        }

        final PagerAdapter oldAdapter = mAdapter;
        mAdapter = adapter;
        mExpectedAdapterCount = 0;

        if (mAdapter != null) {
            if (mObserver == null) {
                mObserver = new PagerObserver();
            }
            mAdapter.registerDataSetObserver(mObserver);
            final boolean wasFirstLayout = mFirstLayout;
            mFirstLayout = true;
            mExpectedAdapterCount = mAdapter.getCount();
            if (mRestoredCurItem >= 0) {
                mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);
                setCurrentItemInternal(mRestoredCurItem, false, true);
                mRestoredCurItem = -1;
                mRestoredAdapterState = null;
                mRestoredClassLoader = null;
            } else if (!wasFirstLayout) {
                populate();
            } else {
                requestLayout();
            }
        }

        if (mAdapterChangeListener != null && oldAdapter != adapter) {
            mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);
        }
    }

    private void removeNonDecorViews() {
        for (int i = 0; i < getChildCount(); i++) {
            final View child = getChildAt(i);
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            if (!lp.isDecor) {
                removeViewAt(i);
                i--;
            }
        }
    }

    /**
     * Retrieve the current adapter supplying pages.
     *
     * @return The currently registered PagerAdapter
     */
    public PagerAdapter getAdapter() {
        return mAdapter;
    }

    void setOnAdapterChangeListener(OnAdapterChangeListener listener) {
        mAdapterChangeListener = listener;
    }

    private int getClientWidth() {
        return getMeasuredWidth() - getPaddingLeft() - getPaddingRight();
    }

    /**
     * Set the currently selected page. If the ViewPager has already been through its first
     * layout with its current adapter there will be a smooth animated transition between
     * the current item and the specified item.
     *
     * @param item Item index to select
     */
    public void setCurrentItem(int item) {
        setCurrentItemInternal(item, !mFirstLayout, false);
    }

    /**
     * Set the currently selected page.
     *
     * @param item Item index to select
     * @param smoothScroll True to smoothly scroll to the new item, false to transition immediately
     */
    public void setCurrentItem(int item, boolean smoothScroll) {
        setCurrentItemInternal(item, smoothScroll, false);
    }

    public int getCurrentItem() {
        return mCurItem;
    }

    void setCurrentItemInternal(int item, boolean smoothScroll, boolean always) {
        setCurrentItemInternal(item, smoothScroll, always, 0);
    }

    void setCurrentItemInternal(int item, boolean smoothScroll, boolean always, int velocity) {
        if (mAdapter == null || mAdapter.getCount() <= 0) {
            setScrollingCacheEnabled(false);
            return;
        }
        if (!always && mCurItem == item && mItems.size() != 0) {
            setScrollingCacheEnabled(false);
            return;
        }

        if (item < 0) {
            item = 0;
        } else if (item >= mAdapter.getCount()) {
            item = mAdapter.getCount() - 1;
        }
        final int pageLimit = mOffscreenPageLimit;
        if (item > (mCurItem + pageLimit) || item < (mCurItem - pageLimit)) {
            // We are doing a jump by more than one page.  To avoid
            // glitches, we want to keep all current pages in the view
            // until the scroll ends.
            for (int i=0; i<mItems.size(); i++) {
                mItems.get(i).scrolling = true;
            }
        }
        final boolean dispatchSelected = mCurItem != item;

        if (mFirstLayout) {
            // We don't have any idea how big we are yet and shouldn't have any pages either.
            // Just set things up and let the pending layout handle things.
            mCurItem = item;
            if (dispatchSelected && mOnPageChangeListener != null) {
                mOnPageChangeListener.onPageSelected(item);
            }
            if (dispatchSelected && mInternalPageChangeListener != null) {
                mInternalPageChangeListener.onPageSelected(item);
            }
            requestLayout();
        } else {
            populate(item);
            scrollToItem(item, smoothScroll, velocity, dispatchSelected);
        }
    }

    public void scrollToItem(int item, boolean smoothScroll, int velocity,
                              boolean dispatchSelected) {
        final ItemInfo curInfo = infoForPosition(item);
        int destX = 0;
        if (curInfo != null) {
            final int width = getClientWidth();
            destX = (int) (width * Math.max(mFirstOffset,
                    Math.min(curInfo.offset, mLastOffset)));
        }
        if (smoothScroll) {
            smoothScrollTo(destX, 0, velocity);
            if (dispatchSelected && mOnPageChangeListener != null) {
                mOnPageChangeListener.onPageSelected(item);
            }
            if (dispatchSelected && mInternalPageChangeListener != null) {
                mInternalPageChangeListener.onPageSelected(item);
            }
        } else {
            if (dispatchSelected && mOnPageChangeListener != null) {
                mOnPageChangeListener.onPageSelected(item);
            }
            if (dispatchSelected && mInternalPageChangeListener != null) {
                mInternalPageChangeListener.onPageSelected(item);
            }
            completeScroll(false);
            scrollTo(destX, 0);
            pageScrolled(destX);
        }
    }

    /**
     * Set a listener that will be invoked whenever the page changes or is incrementally
     * scrolled. See {@link OnPageChangeListener}.
     *
     * @param listener Listener to set
     */
    public void setOnPageChangeListener(OnPageChangeListener listener) {
        mOnPageChangeListener = listener;
    }

    /**
     * Set a {@link PageTransformer} that will be called for each attached page whenever
     * the scroll position is changed. This allows the application to apply custom property
     * transformations to each page, overriding the default sliding look and feel.
     *
     * <p><em>Note:</em> Prior to Android 3.0 the property animation APIs did not exist.
     * As a result, setting a PageTransformer prior to Android 3.0 (API 11) will have no effect.</p>
     *
     * @param reverseDrawingOrder true if the supplied PageTransformer requires page views
     *                            to be drawn from last to first instead of first to last.
     * @param transformer PageTransformer that will modify each page's animation properties
     */
    public void setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer) {
        if (Build.VERSION.SDK_INT >= 11) {
            final boolean hasTransformer = transformer != null;
            final boolean needsPopulate = hasTransformer != (mPageTransformer != null);
            mPageTransformer = transformer;
            setChildrenDrawingOrderEnabledCompat(hasTransformer);
            if (hasTransformer) {
                mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD;
            } else {
                mDrawingOrder = DRAW_ORDER_DEFAULT;
            }
            if (needsPopulate) populate();
        }
    }

    public void setDrawOrderComparator(Comparator<View> drawOrderComparator) {
        this.mDrawOrderComparator = drawOrderComparator;
    }

    public void setOffsetToLastPageAllowed(final boolean offsetToLastPageAllowed) {
        this.mOffsetToLastPageAllowed = offsetToLastPageAllowed;
    }

    void setChildrenDrawingOrderEnabledCompat(boolean enable) {
        if (Build.VERSION.SDK_INT >= 7) {
            if (mSetChildrenDrawingOrderEnabled == null) {
                try {
                    mSetChildrenDrawingOrderEnabled = ViewGroup.class.getDeclaredMethod(
                            "setChildrenDrawingOrderEnabled", new Class[] { Boolean.TYPE });
                } catch (NoSuchMethodException e) {
                    Log.e(TAG, "Can't find setChildrenDrawingOrderEnabled", e);
                }
            }
            try {
                mSetChildrenDrawingOrderEnabled.invoke(this, enable);
            } catch (Exception e) {
                Log.e(TAG, "Error changing children drawing order", e);
            }
        }
    }

    @Override
    protected int getChildDrawingOrder(int childCount, int i) {
        final int index = mDrawingOrder == DRAW_ORDER_REVERSE ? childCount - 1 - i : i;
        final int result = ((LayoutParams) mDrawingOrderedChildren.get(index).getLayoutParams()).childIndex;
        return result;
    }

    /**
     * Set a separate OnPageChangeListener for internal use by the support library.
     *
     * @param listener Listener to set
     * @return The old listener that was set, if any.
     */
    OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener) {
        OnPageChangeListener oldListener = mInternalPageChangeListener;
        mInternalPageChangeListener = listener;
        return oldListener;
    }

    /**
     * Returns the number of pages that will be retained to either side of the
     * current page in the view hierarchy in an idle state. Defaults to 1.
     *
     * @return How many pages will be kept offscreen on either side
     * @see #setOffscreenPageLimit(int)
     */
    public int getOffscreenPageLimit() {
        return mOffscreenPageLimit;
    }

    /**
     * Set the number of pages that should be retained to either side of the
     * current page in the view hierarchy in an idle state. Pages beyond this
     * limit will be recreated from the adapter when needed.
     *
     * <p>This is offered as an optimization. If you know in advance the number
     * of pages you will need to support or have lazy-loading mechanisms in place
     * on your pages, tweaking this setting can have benefits in perceived smoothness
     * of paging animations and interaction. If you have a small number of pages (3-4)
     * that you can keep active all at once, less time will be spent in layout for
     * newly created view subtrees as the user pages back and forth.</p>
     *
     * <p>You should keep this limit low, especially if your pages have complex layouts.
     * This setting defaults to 1.</p>
     *
     * @param limit How many pages will be kept offscreen in an idle state.
     */
    public void setOffscreenPageLimit(int limit) {
        if (limit < DEFAULT_OFFSCREEN_PAGES) {
            Log.w(TAG, "Requested offscreen page limit " + limit + " too small; defaulting to " +
                    DEFAULT_OFFSCREEN_PAGES);
            limit = DEFAULT_OFFSCREEN_PAGES;
        }
        if (limit != mOffscreenPageLimit) {
            mOffscreenPageLimit = limit;
            populate();
        }
    }

    /**
     * Set the margin between pages.
     *
     * @param marginPixels Distance between adjacent pages in pixels
     * @see #getPageMargin()
     * @see #setPageMarginDrawable(Drawable)
     * @see #setPageMarginDrawable(int)
     */
    public void setPageMargin(int marginPixels) {
        final int oldMargin = mPageMargin;
        mPageMargin = marginPixels;

        final int width = getWidth();
        recomputeScrollPosition(width, width, marginPixels, oldMargin);

        requestLayout();
    }

    /**
     * Return the margin between pages.
     *
     * @return The size of the margin in pixels
     */
    public int getPageMargin() {
        return mPageMargin;
    }

    /**
     * Set a drawable that will be used to fill the margin between pages.
     *
     * @param d Drawable to display between pages
     */
    public void setPageMarginDrawable(Drawable d) {
        mMarginDrawable = d;
        if (d != null) refreshDrawableState();
        setWillNotDraw(d == null);
        invalidate();
    }

    /**
     * Set a drawable that will be used to fill the margin between pages.
     *
     * @param resId Resource ID of a drawable to display between pages
     */
    public void setPageMarginDrawable(int resId) {
        setPageMarginDrawable(getContext().getResources().getDrawable(resId));
    }

    @Override
    protected boolean verifyDrawable(Drawable who) {
        return super.verifyDrawable(who) || who == mMarginDrawable;
    }

    @Override
    protected void drawableStateChanged() {
        super.drawableStateChanged();
        final Drawable d = mMarginDrawable;
        if (d != null && d.isStateful()) {
            d.setState(getDrawableState());
        }
    }

    // We want the duration of the page snap animation to be influenced by the distance that
    // the screen has to travel, however, we don't want this duration to be effected in a
    // purely linear fashion. Instead, we use this method to moderate the effect that the distance
    // of travel has on the overall snap duration.
    float distanceInfluenceForSnapDuration(float f) {
        f -= 0.5f; // center the values about 0.
        f *= 0.3f * Math.PI / 2.0f;
        return (float) Math.sin(f);
    }

    /**
     * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
     *
     * @param x the number of pixels to scroll by on the X axis
     * @param y the number of pixels to scroll by on the Y axis
     */
    void smoothScrollTo(int x, int y) {
        smoothScrollTo(x, y, 0);
    }

    /**
     * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
     *
     * @param x the number of pixels to scroll by on the X axis
     * @param y the number of pixels to scroll by on the Y axis
     * @param velocity the velocity associated with a fling, if applicable. (0 otherwise)
     */
    void smoothScrollTo(int x, int y, int velocity) {
        if (getChildCount() == 0) {
            // Nothing to do.
            setScrollingCacheEnabled(false);
            return;
        }
        int sx = getScrollX();
        int sy = getScrollY();
        int dx = x - sx;
        int dy = y - sy;
        if (dx == 0 && dy == 0) {
            completeScroll(false);
            populate();
            setScrollState(SCROLL_STATE_IDLE);
            return;
        }

        setScrollingCacheEnabled(true);
        setScrollState(SCROLL_STATE_SETTLING);

        final int width = getClientWidth();
        final int halfWidth = width / 2;
        final float distanceRatio = Math.min(1f, 1.0f * Math.abs(dx) / width);
        final float distance = halfWidth + halfWidth *
                distanceInfluenceForSnapDuration(distanceRatio);

        int duration = 0;
        velocity = Math.abs(velocity);
        if (velocity > 0) {
            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
        } else {
            final float pageWidth = width * mAdapter.getPageWidth(mCurItem);
            final float pageDelta = (float) Math.abs(dx) / (pageWidth + mPageMargin);
            duration = (int) ((pageDelta + 1) * 100);
        }
        duration = Math.min(duration, MAX_SETTLE_DURATION);

        mScrollStartTime = AnimationUtils.currentAnimationTimeMillis();
        mScrollDuration = duration;
        mScroller.startScroll(sx, sy, dx, dy, duration);
        ViewCompat.postInvalidateOnAnimation(this);
    }

    ItemInfo addNewItem(int position, int index) {
        ItemInfo ii = new ItemInfo();
        ii.position = position;
        ii.object = mAdapter.instantiateItem(this, position);
        ii.widthFactor = mAdapter.getPageWidth(position);
        if (index < 0 || index >= mItems.size()) {
            mItems.add(ii);
        } else {
            mItems.add(index, ii);
        }
        return ii;
    }

    void dataSetChanged() {
        // This method only gets called if our observer is attached, so mAdapter is non-null.

        final int adapterCount = mAdapter.getCount();
        mExpectedAdapterCount = adapterCount;
        boolean needPopulate = mItems.size() < mOffscreenPageLimit * 2 + 1 &&
                mItems.size() < adapterCount;
        int newCurrItem = mCurItem;

        boolean isUpdating = false;
        for (int i = 0; i < mItems.size(); i++) {
            final ItemInfo ii = mItems.get(i);
            final int newPos = mAdapter.getItemPosition(ii.object);

            if (newPos == PagerAdapter.POSITION_UNCHANGED) {
                continue;
            }

            if (newPos == PagerAdapter.POSITION_NONE) {
                mItems.remove(i);
                i--;

                if (!isUpdating) {
                    mAdapter.startUpdate(this);
                    isUpdating = true;
                }

                mAdapter.destroyItem(this, ii.position, ii.object);
                needPopulate = true;

                if (mCurItem == ii.position) {
                    // Keep the current item in the valid range
                    newCurrItem = Math.max(0, Math.min(mCurItem, adapterCount - 1));
                    needPopulate = true;
                }
                continue;
            }

            if (ii.position != newPos) {
                if (ii.position == mCurItem) {
                    // Our current item changed position. Follow it.
                    newCurrItem = newPos;
                }

                ii.position = newPos;
                needPopulate = true;
            }
        }

        if (isUpdating) {
            mAdapter.finishUpdate(this);

            updateViewOnClickListeners();
            updateViewOnLongClickListeners();
        }

        Collections.sort(mItems, COMPARATOR);

        if (needPopulate) {
            // Reset our known page widths; populate will recompute them.
            final int childCount = getChildCount();
            for (int i = 0; i < childCount; i++) {
                final View child = getChildAt(i);
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                if (!lp.isDecor) {
                    lp.widthFactor = 0.f;
                }
            }

            setCurrentItemInternal(newCurrItem, false, true);
            requestLayout();
        }
    }

    void populate() {
        populate(mCurItem);
    }

    void populate(int newCurrentItem) {
        ItemInfo oldCurInfo = null;
        int focusDirection = View.FOCUS_FORWARD;
        if (mCurItem != newCurrentItem) {
            focusDirection = mCurItem < newCurrentItem ? View.FOCUS_RIGHT : View.FOCUS_LEFT;
            oldCurInfo = infoForPosition(mCurItem);
            mCurItem = newCurrentItem;
        }

        if (mAdapter == null) {
            sortChildDrawingOrder();
            return;
        }

        // Also, don't populate until we are attached to a window.  This is to
        // avoid trying to populate before we have restored our view hierarchy
        // state and conflicting with what is restored.
        if (getWindowToken() == null) {
            return;
        }

        mAdapter.startUpdate(this);

        final int pageLimit = mOffscreenPageLimit;
        final int startPos = Math.max(0, mCurItem - pageLimit);
        final int N = mAdapter.getCount();
        final int endPos = Math.min(N-1, mCurItem + pageLimit);

        if (N != mExpectedAdapterCount) {
/*            String resName;
            try {
                resName = getResources().getResourceName(getId());
            } catch (Resources.NotFoundException e) {
                resName = Integer.toHexString(getId());
            }
            throw new IllegalStateException("The application's PagerAdapter changed the adapter's" +
                    " contents without calling PagerAdapter#notifyDataSetChanged!" +
                    " Expected adapter item count: " + mExpectedAdapterCount + ", found: " + N +
                    " Pager id: " + resName +
                    " Pager class: " + getClass() +
                    " Problematic adapter: " + mAdapter.getClass());*/
        	return;
        }

        // Locate the currently focused item or add it if needed.
        int curIndex = -1;
        ItemInfo curItem = null;
        for (curIndex = 0; curIndex < mItems.size(); curIndex++) {
            final ItemInfo ii = mItems.get(curIndex);
            if (ii.position >= mCurItem) {
                if (ii.position == mCurItem) curItem = ii;
                break;
            }
        }

        if (curItem == null && N > 0) {
            curItem = addNewItem(mCurItem, curIndex);
        }

        // Fill 3x the available width or up to the number of offscreen
        // pages requested to either side, whichever is larger.
        // If we have no current item we have no work to do.
        if (curItem != null) {
            float extraWidthLeft = 0.f;
            int itemIndex = curIndex - 1;
            ItemInfo ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
            final int clientWidth = getClientWidth();
            final float leftWidthNeeded = clientWidth <= 0 ? 0 :
                    2.f - curItem.widthFactor + (float) getPaddingLeft() / (float) clientWidth;
            for (int pos = mCurItem - 1; pos >= 0; pos--) {
                if (extraWidthLeft >= leftWidthNeeded && pos < startPos) {
                    if (ii == null) {
                        break;
                    }
                    if (pos == ii.position && !ii.scrolling) {
                        mItems.remove(itemIndex);
                        mAdapter.destroyItem(this, pos, ii.object);
                        if (DEBUG) {
                            Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
                                    " view: " + ((View) ii.object));
                        }
                        itemIndex--;
                        curIndex--;
                        ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
                    }
                } else if (ii != null && pos == ii.position) {
                    extraWidthLeft += ii.widthFactor;
                    itemIndex--;
                    ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
                } else {
                    ii = addNewItem(pos, itemIndex + 1);
                    extraWidthLeft += ii.widthFactor;
                    curIndex++;
                    ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
                }
            }

            float extraWidthRight = curItem.widthFactor;
            itemIndex = curIndex + 1;
            if (extraWidthRight < 2.f) {
                ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
                final float rightWidthNeeded = clientWidth <= 0 ? 0 :
                        (float) getPaddingRight() / (float) clientWidth + 2.f;
                for (int pos = mCurItem + 1; pos < N; pos++) {
                    if (extraWidthRight >= rightWidthNeeded && pos > endPos) {
                        if (ii == null) {
                            break;
                        }
                        if (pos == ii.position && !ii.scrolling) {
                            mItems.remove(itemIndex);
                            mAdapter.destroyItem(this, pos, ii.object);
                            if (DEBUG) {
                                Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
                                        " view: " + ((View) ii.object));
                            }
                            ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
                        }
                    } else if (ii != null && pos == ii.position) {
                        extraWidthRight += ii.widthFactor;
                        itemIndex++;
                        ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
                    } else {
                        ii = addNewItem(pos, itemIndex);
                        itemIndex++;
                        extraWidthRight += ii.widthFactor;
                        ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
                    }
                }
            }

            calculatePageOffsets(curItem, curIndex, oldCurInfo);
        }

        if (DEBUG) {
            Log.i(TAG, "Current page list:");
            for (int i=0; i<mItems.size(); i++) {
                Log.i(TAG, "#" + i + ": page " + mItems.get(i).position);
            }
        }

        mAdapter.setPrimaryItem(this, mCurItem, curItem != null ? curItem.object : null);

        mAdapter.finishUpdate(this);

        // Check width measurement of current pages and drawing sort order.
        // Update LayoutParams as needed.
        final int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            lp.childIndex = i;
            if (!lp.isDecor) {
                if (lp.widthFactor == 0.f) {
                    // 0 means requery the adapter for this, it doesn't have a valid width.
                    final ItemInfo ii = infoForChild(child);
                    if (ii != null) {
                        lp.widthFactor = ii.widthFactor;
                        lp.position = ii.position;
                    }
                }
            }
        }

        updateViewOnClickListeners();
        updateViewOnLongClickListeners();

        sortChildDrawingOrder();

        if (hasFocus()) {
            View currentFocused = findFocus();
            ItemInfo ii = currentFocused != null ? infoForAnyChild(currentFocused) : null;
            if (ii == null || ii.position != mCurItem) {
                for (int i=0; i<getChildCount(); i++) {
                    View child = getChildAt(i);
                    ii = infoForChild(child);
                    if (ii != null && ii.position == mCurItem) {
                        if (child.requestFocus(focusDirection)) {
                            break;
                        }
                    }
                }
            }
        }
    }

    private void sortChildDrawingOrder() {
        if (mDrawingOrder != DRAW_ORDER_DEFAULT) {
            if (mDrawingOrderedChildren == null) {
                mDrawingOrderedChildren = new ArrayList<View>();
            } else {
                mDrawingOrderedChildren.clear();
            }
            final int childCount = getChildCount();
            for (int i = 0; i < childCount; i++) {
                final View child = getChildAt(i);
                mDrawingOrderedChildren.add(child);
            }
            Collections.sort(mDrawingOrderedChildren, mDrawOrderComparator);
        }
    }

    private void calculatePageOffsets(ItemInfo curItem, int curIndex, ItemInfo oldCurInfo) {
        final int N = mAdapter.getCount();
        final int width = getClientWidth();
        final float marginOffset = width > 0 ? (float) mPageMargin / width : 0;
        // Fix up offsets for later layout.
        if (oldCurInfo != null) {
            final int oldCurPosition = oldCurInfo.position;
            // Base offsets off of oldCurInfo.
            if (oldCurPosition < curItem.position) {
                int itemIndex = 0;
                ItemInfo ii = null;
                float offset = oldCurInfo.offset + oldCurInfo.widthFactor + marginOffset;
                for (int pos = oldCurPosition + 1;
                     pos <= curItem.position && itemIndex < mItems.size(); pos++) {
                    ii = mItems.get(itemIndex);
                    while (pos > ii.position && itemIndex < mItems.size() - 1) {
                        itemIndex++;
                        ii = mItems.get(itemIndex);
                    }
                    while (pos < ii.position) {
                        // We don't have an item populated for this,
                        // ask the adapter for an offset.
                        offset += mAdapter.getPageWidth(pos) + marginOffset;
                        pos++;
                    }
                    ii.offset = offset;
                    offset += ii.widthFactor + marginOffset;
                }
            } else if (oldCurPosition > curItem.position) {
                int itemIndex = mItems.size() - 1;
                ItemInfo ii = null;
                float offset = oldCurInfo.offset;
                for (int pos = oldCurPosition - 1;
                     pos >= curItem.position && itemIndex >= 0; pos--) {
                    ii = mItems.get(itemIndex);
                    while (pos < ii.position && itemIndex > 0) {
                        itemIndex--;
                        ii = mItems.get(itemIndex);
                    }
                    while (pos > ii.position) {
                        // We don't have an item populated for this,
                        // ask the adapter for an offset.
                        offset -= mAdapter.getPageWidth(pos) + marginOffset;
                        pos--;
                    }
                    offset -= ii.widthFactor + marginOffset;
                    ii.offset = offset;
                }
            }
        }

        // Base all offsets off of curItem.
        final int itemCount = mItems.size();
        float offset = curItem.offset;
        int pos = curItem.position - 1;
        mFirstOffset = curItem.position == 0 ? curItem.offset : -Float.MAX_VALUE;

        if (mOffsetToLastPageAllowed) {
            mLastOffset = curItem.position == N - 1 ? curItem.offset : Float.MAX_VALUE;
        } else {
            mLastOffset = curItem.position == N - 1 ?
                curItem.offset + curItem.widthFactor - 1 : Float.MAX_VALUE;
        }
        // Previous pages
        for (int i = curIndex - 1; i >= 0; i--, pos--) {
            final ItemInfo ii = mItems.get(i);
            while (pos > ii.position) {
                offset -= mAdapter.getPageWidth(pos--) + marginOffset;
            }
            offset -= ii.widthFactor + marginOffset;
            ii.offset = offset;
            if (ii.position == 0) mFirstOffset = offset;
        }
        offset = curItem.offset + curItem.widthFactor + marginOffset;
        pos = curItem.position + 1;
        // Next pages
        for (int i = curIndex + 1; i < itemCount; i++, pos++) {
            final ItemInfo ii = mItems.get(i);
            while (pos < ii.position) {
                offset += mAdapter.getPageWidth(pos++) + marginOffset;
            }
            if (ii.position == N - 1) {
                mLastOffset = (mOffsetToLastPageAllowed) ? offset :
                    offset + curItem.widthFactor - 1;
            }
            ii.offset = offset;
            offset += ii.widthFactor + marginOffset;
        }

        mNeedCalculatePageOffsets = false;
    }

    /**
     * This is the persistent state that is saved by ViewPager.  Only needed
     * if you are creating a sublass of ViewPager that must save its own
     * state, in which case it should implement a subclass of this which
     * contains that state.
     */
    public static class SavedState extends BaseSavedState {
        int position;
        Parcelable adapterState;
        ClassLoader loader;

        public SavedState(Parcelable superState) {
            super(superState);
        }

        @Override
        public void writeToParcel(Parcel out, int flags) {
            super.writeToParcel(out, flags);
            out.writeInt(position);
            out.writeParcelable(adapterState, flags);
        }

        @Override
        public String toString() {
            return "FragmentPager.SavedState{"
                    + Integer.toHexString(System.identityHashCode(this))
                    + " position=" + position + "}";
        }

        public static final Parcelable.Creator<SavedState> CREATOR
                = ParcelableCompat.newCreator(new ParcelableCompatCreatorCallbacks<SavedState>() {
            @Override
            public SavedState createFromParcel(Parcel in, ClassLoader loader) {
                return new SavedState(in, loader);
            }
            @Override
            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        });

        SavedState(Parcel in, ClassLoader loader) {
            super(in);
            if (loader == null) {
                loader = getClass().getClassLoader();
            }
            position = in.readInt();
            adapterState = in.readParcelable(loader);
            this.loader = loader;
        }
    }

    @Override
    public Parcelable onSaveInstanceState() {
        Parcelable superState = super.onSaveInstanceState();
        SavedState ss = new SavedState(superState);
        ss.position = mCurItem;
        if (mAdapter != null) {
            ss.adapterState = mAdapter.saveState();
        }
        return ss;
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
        if (!(state instanceof SavedState)) {
            super.onRestoreInstanceState(state);
            return;
        }

        SavedState ss = (SavedState)state;
        super.onRestoreInstanceState(ss.getSuperState());

        if (mAdapter != null) {
            mAdapter.restoreState(ss.adapterState, ss.loader);
            setCurrentItemInternal(ss.position, false, true);
        } else {
            mRestoredCurItem = ss.position;
            mRestoredAdapterState = ss.adapterState;
            mRestoredClassLoader = ss.loader;
        }
    }

    @Override
    public void addView(View child, int index, ViewGroup.LayoutParams params) {
        if (!checkLayoutParams(params)) {
            params = generateLayoutParams(params);
        }
        final LayoutParams lp = (LayoutParams) params;
        lp.isDecor |= child instanceof Decor;
        if (mInLayout) {
            if (lp != null && lp.isDecor) {
                throw new IllegalStateException("Cannot add pager decor view during layout");
            }
            lp.needsMeasure = true;
            addViewInLayout(child, index, params);
        } else {
            super.addView(child, index, params);
        }

        if (USE_CACHE) {
            if (child.getVisibility() != GONE) {
                child.setDrawingCacheEnabled(mScrollingCacheEnabled);
            } else {
                child.setDrawingCacheEnabled(false);
            }
        }
    }

    @Override
    public void removeView(View view) {
        if (mInLayout) {
            removeViewInLayout(view);
        } else {
            super.removeView(view);
        }
    }

    ItemInfo infoForChild(View child) {
        for (int i=0; i<mItems.size(); i++) {
            ItemInfo ii = mItems.get(i);
            if (mAdapter.isViewFromObject(child, ii.object)) {
                return ii;
            }
        }
        return null;
    }

    ItemInfo infoForAnyChild(View child) {
        ViewParent parent;
        while ((parent=child.getParent()) != this) {
            if (parent == null || !(parent instanceof View)) {
                return null;
            }
            child = (View)parent;
        }
        return infoForChild(child);
    }

    ItemInfo infoForPosition(int position) {
        for (int i = 0; i < mItems.size(); i++) {
            ItemInfo ii = mItems.get(i);
            if (ii.position == position) {
                return ii;
            }
        }
        return null;
    }

    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        mFirstLayout = true;
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        // For simple implementation, our internal size is always 0.
        // We depend on the container to specify the layout size of
        // our view.  We can't really know what it is since we will be
        // adding and removing different arbitrary views and do not
        // want the layout to change as this happens.
        setMeasuredDimension(getDefaultSize(0, widthMeasureSpec),
                getDefaultSize(0, heightMeasureSpec));

        final int measuredWidth = getMeasuredWidth();
        final int maxGutterSize = measuredWidth / 10;
        mGutterSize = Math.min(maxGutterSize, mDefaultGutterSize);

        // Children are just made to fill our space.
        int childWidthSize = measuredWidth - getPaddingLeft() - getPaddingRight();
        int childHeightSize = getMeasuredHeight() - getPaddingTop() - getPaddingBottom();

        /*
         * Make sure all children have been properly measured. Decor views first.
         * Right now we cheat and make this less complicated by assuming decor
         * views won't intersect. We will pin to edges based on gravity.
         */
        int size = getChildCount();
        for (int i = 0; i < size; ++i) {
            final View child = getChildAt(i);
            if (child.getVisibility() != GONE) {
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                if (lp != null && lp.isDecor) {
                    final int hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                    final int vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;
                    int widthMode = MeasureSpec.AT_MOST;
                    int heightMode = MeasureSpec.AT_MOST;
                    boolean consumeVertical = vgrav == Gravity.TOP || vgrav == Gravity.BOTTOM;
                    boolean consumeHorizontal = hgrav == Gravity.LEFT || hgrav == Gravity.RIGHT;

                    if (consumeVertical) {
                        widthMode = MeasureSpec.EXACTLY;
                    } else if (consumeHorizontal) {
                        heightMode = MeasureSpec.EXACTLY;
                    }

                    int widthSize = childWidthSize;
                    int heightSize = childHeightSize;
                    if (lp.width != LayoutParams.WRAP_CONTENT) {
                        widthMode = MeasureSpec.EXACTLY;
                        if (lp.width != LayoutParams.FILL_PARENT) {
                            widthSize = lp.width;
                        }
                    }
                    if (lp.height != LayoutParams.WRAP_CONTENT) {
                        heightMode = MeasureSpec.EXACTLY;
                        if (lp.height != LayoutParams.FILL_PARENT) {
                            heightSize = lp.height;
                        }
                    }
                    final int widthSpec = MeasureSpec.makeMeasureSpec(widthSize, widthMode);
                    final int heightSpec = MeasureSpec.makeMeasureSpec(heightSize, heightMode);
                    child.measure(widthSpec, heightSpec);

                    if (consumeVertical) {
                        childHeightSize -= child.getMeasuredHeight();
                    } else if (consumeHorizontal) {
                        childWidthSize -= child.getMeasuredWidth();
                    }
                }
            }
        }

        mChildWidthMeasureSpec = MeasureSpec.makeMeasureSpec(childWidthSize, MeasureSpec.EXACTLY);
        mChildHeightMeasureSpec = MeasureSpec.makeMeasureSpec(childHeightSize, MeasureSpec.EXACTLY);

        // Make sure we have created all fragments that we need to have shown.
        mInLayout = true;
        populate();
        mInLayout = false;

        // Page views next.
        size = getChildCount();
        for (int i = 0; i < size; ++i) {
            final View child = getChildAt(i);
            if (child.getVisibility() != GONE) {
                if (DEBUG) Log.v(TAG, "Measuring #" + i + " " + child
                        + ": " + mChildWidthMeasureSpec);

                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                if (lp == null || !lp.isDecor) {
                    final int widthSpec = MeasureSpec.makeMeasureSpec(
                            (int) (childWidthSize * lp.widthFactor), MeasureSpec.EXACTLY);
                    child.measure(widthSpec, mChildHeightMeasureSpec);
                }
            }
        }
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);

        // Make sure scroll position is set correctly.
        if (w != oldw) {
            recomputeScrollPosition(w, oldw, mPageMargin, mPageMargin);
        }
    }

    // TODO: This is incorrect for flings...
    private void recomputeScrollPosition(int width, int oldWidth, int margin, int oldMargin) {
        if (oldWidth > 0 && !mItems.isEmpty()) {
            final int widthWithMargin = width - getPaddingLeft() - getPaddingRight() + margin;
            final int oldWidthWithMargin = oldWidth - getPaddingLeft() - getPaddingRight()
                    + oldMargin;
            final int xpos = getScrollX();
            final float pageOffset = (float) xpos / oldWidthWithMargin;
            final int newOffsetPixels = (int) (pageOffset * widthWithMargin);

            scrollTo(newOffsetPixels, getScrollY());
            if (!mScroller.isFinished()) {
                // We now return to your regularly scheduled scroll, already in progress.
                final int newDuration = Math.max(0, (int) (mScrollDuration - AnimationUtils.currentAnimationTimeMillis() - mScrollStartTime));
                ItemInfo targetInfo = infoForPosition(mCurItem);

                mScrollStartTime = AnimationUtils.currentAnimationTimeMillis();
                mScrollDuration = newDuration;
                mScroller.startScroll(newOffsetPixels, 0,
                        (int) (targetInfo.offset * width), 0, newDuration);
            }
        } else {
            final ItemInfo ii = infoForPosition(mCurItem);
            final float scrollOffset = ii != null ? Math.min(ii.offset, mLastOffset) : 0;
            final int scrollPos = (int) (scrollOffset *
                    (width - getPaddingLeft() - getPaddingRight()));
            if (scrollPos != getScrollX()) {
                completeScroll(false);
                scrollTo(scrollPos, getScrollY());
            }
        }
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        final int count = getChildCount();
        int width = r - l;
        int height = b - t;
        int paddingLeft = getPaddingLeft();
        int paddingTop = getPaddingTop();
        int paddingRight = getPaddingRight();
        int paddingBottom = getPaddingBottom();
        final int scrollX = getScrollX();

        int decorCount = 0;

        // First pass - decor views. We need to do this in two passes so that
        // we have the proper offsets for non-decor views later.
        for (int i = 0; i < count; i++) {
            final View child = getChildAt(i);
            if (child.getVisibility() != GONE) {
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                int childLeft = 0;
                int childTop = 0;
                if (lp.isDecor) {
                    final int hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                    final int vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;
                    switch (hgrav) {
                        default:
                            childLeft = paddingLeft;
                            break;
                        case Gravity.LEFT:
                            childLeft = paddingLeft;
                            paddingLeft += child.getMeasuredWidth();
                            break;
                        case Gravity.CENTER_HORIZONTAL:
                            childLeft = Math.max((width - child.getMeasuredWidth()) / 2,
                                    paddingLeft);
                            break;
                        case Gravity.RIGHT:
                            childLeft = width - paddingRight - child.getMeasuredWidth();
                            paddingRight += child.getMeasuredWidth();
                            break;
                    }
                    switch (vgrav) {
                        default:
                            childTop = paddingTop;
                            break;
                        case Gravity.TOP:
                            childTop = paddingTop;
                            paddingTop += child.getMeasuredHeight();
                            break;
                        case Gravity.CENTER_VERTICAL:
                            childTop = Math.max((height - child.getMeasuredHeight()) / 2,
                                    paddingTop);
                            break;
                        case Gravity.BOTTOM:
                            childTop = height - paddingBottom - child.getMeasuredHeight();
                            paddingBottom += child.getMeasuredHeight();
                            break;
                    }
                    childLeft += scrollX;
                    child.layout(childLeft, childTop,
                            childLeft + child.getMeasuredWidth(),
                            childTop + child.getMeasuredHeight());
                    decorCount++;
                }
            }
        }

        final int childWidth = width - paddingLeft - paddingRight;
        // Page views. Do this once we have the right padding offsets from above.
        for (int i = 0; i < count; i++) {
            final View child = getChildAt(i);
            if (child.getVisibility() != GONE) {
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                ItemInfo ii;
                if (!lp.isDecor && (ii = infoForChild(child)) != null) {
                    int loff = (int) (childWidth * ii.offset);
                    int childLeft = paddingLeft + loff;
                    int childTop = paddingTop;
                    if (lp.needsMeasure) {
                        // This was added during layout and needs measurement.
                        // Do it now that we know what we're working with.
                        lp.needsMeasure = false;
                        final int widthSpec = MeasureSpec.makeMeasureSpec(
                                (int) (childWidth * lp.widthFactor),
                                MeasureSpec.EXACTLY);
                        final int heightSpec = MeasureSpec.makeMeasureSpec(
                                (int) (height - paddingTop - paddingBottom),
                                MeasureSpec.EXACTLY);
                        child.measure(widthSpec, heightSpec);
                    }
                    if (DEBUG) Log.v(TAG, "Positioning #" + i + " " + child + " f=" + ii.object
                            + ":" + childLeft + "," + childTop + " " + child.getMeasuredWidth()
                            + "x" + child.getMeasuredHeight());
                    child.layout(childLeft, childTop,
                            childLeft + child.getMeasuredWidth(),
                            childTop + child.getMeasuredHeight());
                }
            }
        }
        mTopPageBounds = paddingTop;
        mBottomPageBounds = height - paddingBottom;
        mDecorChildCount = decorCount;

        if (mFirstLayout) {
            scrollToItem(mCurItem, false, 0, false);
        }

        sortChildDrawingOrder();

        mFirstLayout = false;
    }

    private int constrainScroll(int x) {
        int width = getClientWidth();

        int firstOffset = (int) (mFirstOffset * width);
        if (x < firstOffset) {
            if (ViewCompat.getOverScrollMode(this) != OVER_SCROLL_NEVER && mLeftEdge.isFinished()) {
                mLeftEdge.onAbsorb((int) Math.abs(mScroller.getCurrVelocity()));
            }

            mFlinging = FLINGING_STOPPED;
            mScroller.startScroll(firstOffset, 0, 0, 0);
            mScroller.abortAnimation();
            return firstOffset;
        }

        int lastOffset = (int) (mLastOffset * width);
        if (x > lastOffset) {
            if (ViewCompat.getOverScrollMode(this) != OVER_SCROLL_NEVER && mRightEdge.isFinished()) {
                mRightEdge.onAbsorb((int) Math.abs(mScroller.getCurrVelocity()));
            }

            mFlinging = FLINGING_STOPPED;
            mScroller.startScroll(lastOffset, 0, 0, 0);
            mScroller.abortAnimation();
            return lastOffset;
        }


        if (mFlinging != FLINGING_STOPPED) {
            int finalX = mScroller.getFinalX();
            ItemInfo snapItemInfo = infoForScrollPosition(finalX);
            int snapItemWidth = (int) (snapItemInfo.widthFactor * width);
            int snapItemOffset = (int) (snapItemInfo.offset * width);

            // infoForScrollPosition() returns the closest item. However, we can only snap when we
            // have the ItemInfo that finalX is inside of.
            if (finalX > snapItemOffset && finalX < snapItemOffset + snapItemWidth) {
                // If finalX was in the right half of the snap item, then we want to snap to the
                // next item along.
                if (finalX - snapItemOffset > snapItemWidth / 2) {
                    snapItemOffset += snapItemWidth;
                }

                if (mFlinging == FLINGING_RIGHT) {
                    if (finalX > snapItemOffset) {
                        // Overscroll
                        if (x > snapItemOffset) {
                            mFlinging = FLINGING_STOPPED;
                            int overscroll = finalX - snapItemOffset;
                            mScroller.notifyHorizontalEdgeReached(x, snapItemOffset, overscroll);
                        }
                    } else {
                        // Underscroll
                        if (x > snapItemOffset - snapItemWidth) {
                            mFlinging = FLINGING_STOPPED;
                            mScroller.notifyFinalXExtended(snapItemOffset);
                        }
                    }
                } else if (mFlinging == FLINGING_LEFT) {
                    if (finalX < snapItemOffset) {
                        // Overscroll
                        if (x < snapItemOffset) {
                            mFlinging = FLINGING_STOPPED;
                            int overscroll = snapItemOffset - finalX;
                            mScroller.notifyHorizontalEdgeReached(x, snapItemOffset, overscroll);
                        }
                    } else {
                        // Underscroll
                        if (x < snapItemOffset + snapItemWidth) {
                            mFlinging = FLINGING_STOPPED;
                            mScroller.notifyFinalXExtended(snapItemOffset);
                        }
                    }

                }
            }
        }

        return x;
    }

    @Override
    public void computeScroll() {
        if (!mScroller.isFinished() && mScroller.computeScrollOffset()) {
            int oldX = getScrollX();
            int oldY = getScrollY();
            int x = mScroller.getCurrX();
            int y = mScroller.getCurrY();

            if (oldX != x || oldY != y) {
                final ItemInfo ii = infoForScrollPosition(x);
                populate(ii.position);

                x = constrainScroll(x);
                scrollTo(x, y);

                if (!pageScrolled(x)) {
                    mScroller.abortAnimation();
                    scrollTo(0, y);
                }
            }

            // Keep on drawing until the animation has finished.
            ViewCompat.postInvalidateOnAnimation(this);
            return;
        }

        // Done with scroll, clean up state.
        completeScroll(true);
    }

    private boolean pageScrolled(int xpos) {
        if (mItems.size() == 0) {
            mCalledSuper = false;
            onPageScrolled(0, 0, 0);
            if (!mCalledSuper) {
                throw new IllegalStateException(
                        "onPageScrolled did not call superclass implementation");
            }
            return false;
        }
        final ItemInfo ii = infoForCurrentScrollPosition();
        final int width = getClientWidth();
        final int widthWithMargin = width + mPageMargin;
        final float marginOffset = (float) mPageMargin / width;
        final int currentPage = ii.position;
        final float pageOffset = (((float) xpos / width) - ii.offset) /
                (ii.widthFactor + marginOffset);
        final int offsetPixels = (int) (pageOffset * widthWithMargin);

        mCalledSuper = false;
        onPageScrolled(currentPage, pageOffset, offsetPixels);
        if (!mCalledSuper) {
            throw new IllegalStateException(
                    "onPageScrolled did not call superclass implementation");
        }
        return true;
    }

    private void transformPages() {
        if (mPageTransformer != null) {
            final int scrollX = getScrollX();
            final int childCount = getChildCount();
            for (int i = 0; i < childCount; i++) {
                final View child = getChildAt(i);
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();

                if (lp.isDecor) continue;

                final float transformPos = (float) (child.getLeft() - scrollX) / getClientWidth();
                mPageTransformer.transformPage(child, transformPos);
            }
        }
    }

    /**
     * This method will be invoked when the current page is scrolled, either as part
     * of a programmatically initiated smooth scroll or a user initiated touch scroll.
     * If you override this method you must call through to the superclass implementation
     * (e.g. super.onPageScrolled(position, offset, offsetPixels)) before onPageScrolled
     * returns.
     *
     * @param position Position index of the first page currently being displayed.
     *                 Page position+1 will be visible if positionOffset is nonzero.
     * @param offset Value from [0, 1) indicating the offset from the page at position.
     * @param offsetPixels Value in pixels indicating the offset from position.
     */
    protected void onPageScrolled(int position, float offset, int offsetPixels) {
        // Offset any decor views if needed - keep them on-screen at all times.
        if (mDecorChildCount > 0) {
            final int scrollX = getScrollX();
            int paddingLeft = getPaddingLeft();
            int paddingRight = getPaddingRight();
            final int width = getWidth();
            final int childCount = getChildCount();
            for (int i = 0; i < childCount; i++) {
                final View child = getChildAt(i);
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                if (!lp.isDecor) continue;

                final int hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                int childLeft = 0;
                switch (hgrav) {
                    default:
                        childLeft = paddingLeft;
                        break;
                    case Gravity.LEFT:
                        childLeft = paddingLeft;
                        paddingLeft += child.getWidth();
                        break;
                    case Gravity.CENTER_HORIZONTAL:
                        childLeft = Math.max((width - child.getMeasuredWidth()) / 2,
                                paddingLeft);
                        break;
                    case Gravity.RIGHT:
                        childLeft = width - paddingRight - child.getMeasuredWidth();
                        paddingRight += child.getMeasuredWidth();
                        break;
                }
                childLeft += scrollX;

                final int childOffset = childLeft - child.getLeft();
                if (childOffset != 0) {
                    child.offsetLeftAndRight(childOffset);
                }
            }
        }

        if (mOnPageChangeListener != null) {
            mOnPageChangeListener.onPageScrolled(position, offset, offsetPixels);
        }
        if (mInternalPageChangeListener != null) {
            mInternalPageChangeListener.onPageScrolled(position, offset, offsetPixels);
        }

        transformPages();

        mCalledSuper = true;
    }

    private void completeScroll(boolean postEvents) {
        boolean needPopulate = mScrollState == SCROLL_STATE_SETTLING;
        if (needPopulate) {
            // Done with scroll, no longer want to cache view drawing.
            setScrollingCacheEnabled(false);
            mScroller.abortAnimation();
            int oldX = getScrollX();
            int oldY = getScrollY();
            int x = mScroller.getCurrX();
            int y = mScroller.getCurrY();
            if (oldX != x || oldY != y) {
                scrollTo(x, y);
            }
        }
        for (int i=0; i<mItems.size(); i++) {
            ItemInfo ii = mItems.get(i);
            if (ii.scrolling) {
                needPopulate = true;
                ii.scrolling = false;
            }
        }
        if (needPopulate) {
            if (postEvents) {
                ViewCompat.postOnAnimation(this, mEndScrollRunnable);
            } else {
                mEndScrollRunnable.run();
            }
        }
    }

    private boolean isGutterDrag(float x, float dx) {
        return (x < mGutterSize && dx > 0) || (x > getWidth() - mGutterSize && dx < 0);
    }

    private void enableLayers(boolean enable) {
        final int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            final int layerType = enable ?
                    ViewCompat.LAYER_TYPE_HARDWARE : ViewCompat.LAYER_TYPE_NONE;
            ViewCompat.setLayerType(getChildAt(i), layerType, null);
        }
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */

        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;

        // Always take care of the touch gesture being complete.
        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
            // Release the drag.
            if (DEBUG) Log.v(TAG, "Intercept done!");
            mIsBeingDragged = false;
            mIsUnableToDrag = false;
            mActivePointerId = INVALID_POINTER;
            if (mVelocityTracker != null) {
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            return false;
        }

        // Nothing more to do here if we have decided whether or not we
        // are dragging.
        if (action != MotionEvent.ACTION_DOWN) {
            if (mIsBeingDragged) {
                if (DEBUG) Log.v(TAG, "Intercept returning true!");
                return true;
            }
            if (mIsUnableToDrag) {
                if (DEBUG) Log.v(TAG, "Intercept returning false!");
                return false;
            }
        }

        switch (action) {
            case MotionEvent.ACTION_MOVE: {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */

                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }

                final int pointerIndex = MotionEventCompat.findPointerIndex(ev, activePointerId);
                final float x = MotionEventCompat.getX(ev, pointerIndex);
                final float dx = x - mLastMotionX;
                final float xDiff = Math.abs(dx);
                final float y = MotionEventCompat.getY(ev, pointerIndex);
                final float yDiff = Math.abs(y - mInitialMotionY);
                if (DEBUG) Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff);

                if (dx != 0 && !isGutterDrag(mLastMotionX, dx) &&
                        canScroll(this, false, (int) dx, (int) x, (int) y)) {
                    // Nested view has scrollable area under this point. Let it be handled there.
                    mLastMotionX = x;
                    mLastMotionY = y;
                    mIsUnableToDrag = true;
                    return false;
                }
                if (xDiff > mTouchSlop && xDiff * 0.5f > yDiff) {
                    if (DEBUG) Log.v(TAG, "Starting drag!");
                    mIsBeingDragged = true;
                    requestParentDisallowInterceptTouchEvent(true);
                    setScrollState(SCROLL_STATE_DRAGGING);
                    mLastMotionX = dx > 0 ? mInitialMotionX + mTouchSlop :
                            mInitialMotionX - mTouchSlop;
                    mLastMotionY = y;
                    setScrollingCacheEnabled(true);
                } else if (yDiff > mTouchSlop) {
                    // The finger has moved enough in the vertical
                    // direction to be counted as a drag...  abort
                    // any attempt to drag horizontally, to work correctly
                    // with children that have scrolling containers.
                    if (DEBUG) Log.v(TAG, "Starting unable to drag!");
                    mIsUnableToDrag = true;
                }
                if (mIsBeingDragged) {
                    // Scroll to follow the motion event
                    if (performDrag(x)) {
                        ViewCompat.postInvalidateOnAnimation(this);
                    }
                }
                break;
            }

            case MotionEvent.ACTION_DOWN: {
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = mInitialMotionX = ev.getX();
                mLastMotionY = mInitialMotionY = ev.getY();
                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
                mIsUnableToDrag = false;

                mScroller.computeScrollOffset();
                if (mScrollState == SCROLL_STATE_SETTLING &&
                        Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) > mCloseEnough) {
                    // Let the user 'catch' the pager as it animates.
                    mScroller.abortAnimation();
                    populate();
                    mIsBeingDragged = true;
                    requestParentDisallowInterceptTouchEvent(true);
                    setScrollState(SCROLL_STATE_DRAGGING);
                } else {
                    completeScroll(false);
                    mIsBeingDragged = false;
                }

                if (DEBUG) Log.v(TAG, "Down at " + mLastMotionX + "," + mLastMotionY
                        + " mIsBeingDragged=" + mIsBeingDragged
                        + "mIsUnableToDrag=" + mIsUnableToDrag);
                break;
            }

            case MotionEventCompat.ACTION_POINTER_UP:
                onSecondaryPointerUp(ev);
                break;
        }

        if (mVelocityTracker == null) {
            mVelocityTracker = VelocityTracker.obtain();
        }
        mVelocityTracker.addMovement(ev);

        /*
         * The only time we want to intercept motion events is if we are in the
         * drag mode.
         */
        return mIsBeingDragged;
    }

    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        if (mFakeDragging) {
            // A fake drag is in progress already, ignore this real one
            // but still eat the touch events.
            // (It is likely that the user is multi-touching the screen.)
            return true;
        }

        if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
            // Don't handle edge touches immediately -- they may actually belong to one of our
            // descendants.
            return false;
        }

        if (mAdapter == null || mAdapter.getCount() == 0) {
            // Nothing to present or scroll; nothing to touch.
            return false;
        }

        if (mVelocityTracker == null) {
            mVelocityTracker = VelocityTracker.obtain();
        }
        mVelocityTracker.addMovement(ev);

        final int action = ev.getAction();
        boolean needsInvalidate = false;

        switch (action & MotionEventCompat.ACTION_MASK) {
            case MotionEvent.ACTION_DOWN: {
                mScroller.abortAnimation();
                populate();

                // Remember where the motion event started
                mLastMotionX = mInitialMotionX = ev.getX();
                mLastMotionY = mInitialMotionY = ev.getY();
                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
                break;
            }
            case MotionEvent.ACTION_MOVE:
                if (!mIsBeingDragged) {
                    final int pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                    final float x = MotionEventCompat.getX(ev, pointerIndex);
                    final float xDiff = Math.abs(x - mLastMotionX);
                    final float y = MotionEventCompat.getY(ev, pointerIndex);
                    final float yDiff = Math.abs(y - mLastMotionY);
                    if (DEBUG) Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff);
                    if (xDiff > mTouchSlop && xDiff > yDiff) {
                        if (DEBUG) Log.v(TAG, "Starting drag!");
                        mIsBeingDragged = true;
                        requestParentDisallowInterceptTouchEvent(true);
                        mLastMotionX = x - mInitialMotionX > 0 ? mInitialMotionX + mTouchSlop :
                                mInitialMotionX - mTouchSlop;
                        mLastMotionY = y;
                        setScrollState(SCROLL_STATE_DRAGGING);
                        setScrollingCacheEnabled(true);

                        // Disallow Parent Intercept, just in case
                        ViewParent parent = getParent();
                        if (parent != null) {
                            parent.requestDisallowInterceptTouchEvent(true);
                        }
                    }
                }
                // Not else! Note that mIsBeingDragged can be set above.
                if (mIsBeingDragged) {
                    // Scroll to follow the motion event
                    final int activePointerIndex = MotionEventCompat.findPointerIndex(
                            ev, mActivePointerId);
                    final float x = MotionEventCompat.getX(ev, activePointerIndex);
                    needsInvalidate |= performDrag(x);
                }
                break;
            case MotionEvent.ACTION_UP:
                if (mIsBeingDragged) {
                    final VelocityTracker velocityTracker = mVelocityTracker;
                    velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                    int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(
                            velocityTracker, mActivePointerId);
                    final int width = getClientWidth();
                    final int scrollX = getScrollX();
                    final ItemInfo ii = infoForCurrentScrollPosition();
                    final int currentPage = ii.position;
                    final float pageOffset = (((float) scrollX / width) - ii.offset) / ii.widthFactor;
                    final int activePointerIndex =
                            MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                    final float x = MotionEventCompat.getX(ev, activePointerIndex);
                    final int totalDelta = (int) (x - mInitialMotionX);

                    if (Math.abs(initialVelocity) > mMinimumVelocity) {
                        fling(initialVelocity);
                        ViewCompat.postInvalidateOnAnimation(this);
                    } else {
                        int nextPage = determineTargetPage(currentPage, pageOffset, initialVelocity,
                                totalDelta);
                        setCurrentItemInternal(nextPage, true, true, initialVelocity);
                        needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();
                    }

                    mActivePointerId = INVALID_POINTER;
                    endDrag();
                } else {

                }
                break;
            case MotionEvent.ACTION_CANCEL:
                if (mIsBeingDragged) {
                    scrollToItem(mCurItem, true, 0, false);
                    mActivePointerId = INVALID_POINTER;
                    endDrag();
                    needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();
                }
                break;
            case MotionEventCompat.ACTION_POINTER_DOWN: {
                final int index = MotionEventCompat.getActionIndex(ev);
                final float x = MotionEventCompat.getX(ev, index);
                mLastMotionX = x;
                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
                break;
            }
            case MotionEventCompat.ACTION_POINTER_UP:
                onSecondaryPointerUp(ev);
                mLastMotionX = MotionEventCompat.getX(ev,
                        MotionEventCompat.findPointerIndex(ev, mActivePointerId));
                break;
        }
        if (needsInvalidate) {
            ViewCompat.postInvalidateOnAnimation(this);
        }
        return true;
    }

    private void requestParentDisallowInterceptTouchEvent(boolean disallowIntercept) {
        final ViewParent parent = getParent();
        if (parent != null) {
            parent.requestDisallowInterceptTouchEvent(disallowIntercept);
        }
    }

    private boolean performDrag(float x) {
        boolean needsInvalidate = false;

        final float deltaX = mLastMotionX - x;
        mLastMotionX = x;

        float oldScrollX = getScrollX();
        float scrollX = oldScrollX + deltaX;
        final int width = getClientWidth();

        float leftBound = width * mFirstOffset;
        float rightBound = width * mLastOffset;
        boolean leftAbsolute = true;
        boolean rightAbsolute = true;

        final ItemInfo firstItem = mItems.get(0);
        final ItemInfo lastItem = mItems.get(mItems.size() - 1);
        if (firstItem.position != 0) {
            leftAbsolute = false;
            leftBound = firstItem.offset * width;
        }
        if (lastItem.position != mAdapter.getCount() - 1) {
            rightAbsolute = false;
            rightBound = lastItem.offset * width;
        }

        if (scrollX < leftBound) {
            if (ViewCompat.getOverScrollMode(this) != OVER_SCROLL_NEVER && leftAbsolute) {
                float over = leftBound - scrollX;
                needsInvalidate = mLeftEdge.onPull(Math.abs(over) / width);
            }
            scrollX = leftBound;
        } else if (scrollX > rightBound) {
            if (ViewCompat.getOverScrollMode(this) != OVER_SCROLL_NEVER && rightAbsolute) {
                float over = scrollX - rightBound;
                needsInvalidate = mRightEdge.onPull(Math.abs(over) / width);
            }
            scrollX = rightBound;
        }

        // Don't lose the rounded component
        mLastMotionX += scrollX - (int) scrollX;
        scrollTo((int) scrollX, getScrollY());
        pageScrolled((int) scrollX);

        final ItemInfo ii = infoForCurrentScrollPosition();
        populate(ii.position);

        return needsInvalidate;
    }

    /**
     *
     * @param x scroll position
     * @return Info about the page at the specified scroll position.
     *         This can be synthetic for a missing middle page; the 'object' field can be null.
     */
    private ItemInfo infoForScrollPosition(int x) {
        final int width = getClientWidth();
        final float scrollOffset = width > 0 ? (float) x / width : 0;
        final float marginOffset = width > 0 ? (float) mPageMargin / width : 0;
        int lastPos = -1;
        float lastOffset = 0.f;
        float lastWidth = 0.f;
        boolean first = true;

        ItemInfo lastItem = null;
        for (int i = 0; i < mItems.size(); i++) {
            ItemInfo ii = mItems.get(i);
            float offset;
            if (!first && ii.position != lastPos + 1) {
                // Create a synthetic item for a missing page.
                ii = mTempItem;
                ii.offset = lastOffset + lastWidth + marginOffset;
                ii.position = lastPos + 1;
                ii.widthFactor = mAdapter.getPageWidth(ii.position);
                i--;
            }
            offset = ii.offset;

            final float leftBound = offset;
            final float rightBound = offset + ii.widthFactor + marginOffset;
            if (first || scrollOffset >= leftBound) {
                if (scrollOffset < rightBound || i == mItems.size() - 1) {
                    return ii;
                }
            } else {
                return lastItem;
            }
            first = false;
            lastPos = ii.position;
            lastOffset = offset;
            lastWidth = ii.widthFactor;
            lastItem = ii;
        }

        return lastItem;
    }

    /**
     * @return Info about the page at the current scroll position.
     *         This can be synthetic for a missing middle page; the 'object' field can be null.
     */
    private ItemInfo infoForCurrentScrollPosition() {
        return infoForScrollPosition(getScrollX());
    }

    private int determineTargetPage(int currentPage, float pageOffset, int velocity, int deltaX) {
        int targetPage;
        if (Math.abs(deltaX) > mFlingDistance && Math.abs(velocity) > mMinimumVelocity) {
            targetPage = velocity > 0 ? currentPage : currentPage + 1;
        } else {
            final float truncator = currentPage >= mCurItem ? 0.4f : 0.6f;
            targetPage = (int) (currentPage + pageOffset + truncator);
        }

        if (mItems.size() > 0) {
            final ItemInfo firstItem = mItems.get(0);
            final ItemInfo lastItem = mItems.get(mItems.size() - 1);

            // Only let the user target pages we have items for
            targetPage = Math.max(firstItem.position, Math.min(targetPage, lastItem.position));
        }

        return targetPage;
    }

    private void fling(int velocity) {
        final int sx = getScrollX();
        final int sy = getScrollY();

        mScroller.fling(sx, sy, -velocity, 0, Integer.MIN_VALUE, Integer.MAX_VALUE, sy, sy);
        mFlinging = (velocity > 0) ? FLINGING_LEFT : FLINGING_RIGHT;

        setScrollState(SCROLL_STATE_SETTLING);
    }

    @Override
    public void draw(Canvas canvas) {
        super.draw(canvas);
        boolean needsInvalidate = false;

        final int overScrollMode = ViewCompat.getOverScrollMode(this);
        if (overScrollMode == ViewCompat.OVER_SCROLL_ALWAYS ||
                (overScrollMode == ViewCompat.OVER_SCROLL_IF_CONTENT_SCROLLS &&
                        mAdapter != null && mAdapter.getCount() > 1)) {
            if (!mLeftEdge.isFinished()) {
                final int restoreCount = canvas.save();
                final int height = getHeight() - getPaddingTop() - getPaddingBottom();
                final int width = getWidth();

                canvas.rotate(270);
                canvas.translate(-height + getPaddingTop(), mFirstOffset * width);
                mLeftEdge.setSize(height, width);
                needsInvalidate |= mLeftEdge.draw(canvas);
                canvas.restoreToCount(restoreCount);
            }
            if (!mRightEdge.isFinished()) {
                final int restoreCount = canvas.save();
                final int width = getWidth();
                final int height = getHeight() - getPaddingTop() - getPaddingBottom();

                canvas.rotate(90);
                canvas.translate(-getPaddingTop(), -(mLastOffset + 1) * width);
                mRightEdge.setSize(height, width);
                needsInvalidate |= mRightEdge.draw(canvas);
                canvas.restoreToCount(restoreCount);
            }
        } else {
            mLeftEdge.finish();
            mRightEdge.finish();
        }

        if (needsInvalidate) {
            // Keep animating
            ViewCompat.postInvalidateOnAnimation(this);
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        // Draw the margin drawable between pages if needed.
        if (mPageMargin > 0 && mMarginDrawable != null && mItems.size() > 0 && mAdapter != null) {
            final int scrollX = getScrollX();
            final int width = getWidth();

            final float marginOffset = (float) mPageMargin / width;
            int itemIndex = 0;
            ItemInfo ii = mItems.get(0);
            float offset = ii.offset;
            final int itemCount = mItems.size();
            final int firstPos = ii.position;
            final int lastPos = mItems.get(itemCount - 1).position;
            for (int pos = firstPos; pos < lastPos; pos++) {
                while (pos > ii.position && itemIndex < itemCount) {
                    ii = mItems.get(++itemIndex);
                }

                float drawAt;
                if (pos == ii.position) {
                    drawAt = (ii.offset + ii.widthFactor) * width;
                    offset = ii.offset + ii.widthFactor + marginOffset;
                } else {
                    float widthFactor = mAdapter.getPageWidth(pos);
                    drawAt = (offset + widthFactor) * width;
                    offset += widthFactor + marginOffset;
                }

                if (drawAt + mPageMargin > scrollX) {
                    mMarginDrawable.setBounds((int) drawAt, mTopPageBounds,
                            (int) (drawAt + mPageMargin + 0.5f), mBottomPageBounds);
                    mMarginDrawable.draw(canvas);
                }

                if (drawAt > scrollX + width) {
                    break; // No more visible, no sense in continuing
                }
            }
        }
    }

    /**
     * Start a fake drag of the pager.
     *
     * <p>A fake drag can be useful if you want to synchronize the motion of the ViewPager
     * with the touch scrolling of another view, while still letting the ViewPager
     * control the snapping motion and fling behavior. (e.g. parallax-scrolling tabs.)
     * Call {@link #fakeDragBy(float)} to simulate the actual drag motion. Call
     * {@link #endFakeDrag()} to complete the fake drag and fling as necessary.
     *
     * <p>During a fake drag the ViewPager will ignore all touch events. If a real drag
     * is already in progress, this method will return false.
     *
     * @return true if the fake drag began successfully, false if it could not be started.
     *
     * @see #fakeDragBy(float)
     * @see #endFakeDrag()
     */
    public boolean beginFakeDrag() {
        if (mIsBeingDragged) {
            return false;
        }
        mFakeDragging = true;
        setScrollState(SCROLL_STATE_DRAGGING);
        mInitialMotionX = mLastMotionX = 0;
        if (mVelocityTracker == null) {
            mVelocityTracker = VelocityTracker.obtain();
        } else {
            mVelocityTracker.clear();
        }
        final long time = SystemClock.uptimeMillis();
        final MotionEvent ev = MotionEvent.obtain(time, time, MotionEvent.ACTION_DOWN, 0, 0, 0);
        mVelocityTracker.addMovement(ev);
        ev.recycle();
        mFakeDragBeginTime = time;
        return true;
    }

    /**
     * End a fake drag of the pager.
     *
     * @see #beginFakeDrag()
     * @see #fakeDragBy(float)
     */
    public void endFakeDrag() {
        if (!mFakeDragging) {
            throw new IllegalStateException("No fake drag in progress. Call beginFakeDrag first.");
        }

        final VelocityTracker velocityTracker = mVelocityTracker;
        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
        int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(
                velocityTracker, mActivePointerId);
        final int width = getClientWidth();
        final int scrollX = getScrollX();
        final ItemInfo ii = infoForCurrentScrollPosition();
        final int currentPage = ii.position;
        final float pageOffset = (((float) scrollX / width) - ii.offset) / ii.widthFactor;
        final int totalDelta = (int) (mLastMotionX - mInitialMotionX);
        int nextPage = determineTargetPage(currentPage, pageOffset, initialVelocity,
                totalDelta);
        setCurrentItemInternal(nextPage, true, true, initialVelocity);
        endDrag();

        mFakeDragging = false;
    }

    /**
     * Fake drag by an offset in pixels. You must have called {@link #beginFakeDrag()} first.
     *
     * @param xOffset Offset in pixels to drag by.
     * @see #beginFakeDrag()
     * @see #endFakeDrag()
     */
    public void fakeDragBy(float xOffset) {
        if (!mFakeDragging) {
            throw new IllegalStateException("No fake drag in progress. Call beginFakeDrag first.");
        }

        mLastMotionX += xOffset;

        float oldScrollX = getScrollX();
        float scrollX = oldScrollX - xOffset;
        final int width = getClientWidth();

        float leftBound = width * mFirstOffset;
        float rightBound = width * mLastOffset;

        final ItemInfo firstItem = mItems.get(0);
        final ItemInfo lastItem = mItems.get(mItems.size() - 1);
        if (firstItem.position != 0) {
            leftBound = firstItem.offset * width;
        }
        if (lastItem.position != mAdapter.getCount() - 1) {
            rightBound = lastItem.offset * width;
        }

        if (scrollX < leftBound) {
            scrollX = leftBound;
        } else if (scrollX > rightBound) {
            scrollX = rightBound;
        }
        // Don't lose the rounded component
        mLastMotionX += scrollX - (int) scrollX;
        scrollTo((int) scrollX, getScrollY());
        pageScrolled((int) scrollX);

        // Synthesize an event for the VelocityTracker.
        final long time = SystemClock.uptimeMillis();
        final MotionEvent ev = MotionEvent.obtain(mFakeDragBeginTime, time, MotionEvent.ACTION_MOVE,
                mLastMotionX, 0, 0);
        mVelocityTracker.addMovement(ev);
        ev.recycle();
    }

    /**
     * Returns true if a fake drag is in progress.
     *
     * @return true if currently in a fake drag, false otherwise.
     *
     * @see #beginFakeDrag()
     * @see #fakeDragBy(float)
     * @see #endFakeDrag()
     */
    public boolean isFakeDragging() {
        return mFakeDragging;
    }

    private void onSecondaryPointerUp(MotionEvent ev) {
        final int pointerIndex = MotionEventCompat.getActionIndex(ev);
        final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
        if (pointerId == mActivePointerId) {
            // This was our active pointer going up. Choose a new
            // active pointer and adjust accordingly.
            final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
            mLastMotionX = MotionEventCompat.getX(ev, newPointerIndex);
            mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
            if (mVelocityTracker != null) {
                mVelocityTracker.clear();
            }
        }
    }

    private void endDrag() {
        mIsBeingDragged = false;
        mIsUnableToDrag = false;

        if (mVelocityTracker != null) {
            mVelocityTracker.recycle();
            mVelocityTracker = null;
        }
    }

    private void setScrollingCacheEnabled(boolean enabled) {
        if (mScrollingCacheEnabled != enabled) {
            mScrollingCacheEnabled = enabled;
            if (USE_CACHE) {
                final int size = getChildCount();
                for (int i = 0; i < size; ++i) {
                    final View child = getChildAt(i);
                    if (child.getVisibility() != GONE) {
                        child.setDrawingCacheEnabled(enabled);
                    }
                }
            }
        }
    }

    public boolean canScrollHorizontally(int direction) {
        if (mAdapter == null) {
            return false;
        }

        final int width = getClientWidth();
        final int scrollX = getScrollX();
        if (direction < 0) {
            return (scrollX > (int) (width * mFirstOffset));
        } else if (direction > 0) {
            return (scrollX < (int) (width * mLastOffset));
        } else {
            return false;
        }
    }

    /**
     * Tests scrollability within child views of v given a delta of dx.
     *
     * @param v View to test for horizontal scrollability
     * @param checkV Whether the view v passed should itself be checked for scrollability (true),
     *               or just its children (false).
     * @param dx Delta scrolled in pixels
     * @param x X coordinate of the active touch point
     * @param y Y coordinate of the active touch point
     * @return true if child views of v can be scrolled by delta of dx.
     */
    protected boolean canScroll(View v, boolean checkV, int dx, int x, int y) {
        if (v instanceof ViewGroup) {
            final ViewGroup group = (ViewGroup) v;
            final int scrollX = v.getScrollX();
            final int scrollY = v.getScrollY();
            final int count = group.getChildCount();
            // Count backwards - let topmost views consume scroll distance first.
            for (int i = count - 1; i >= 0; i--) {
                // TODO: Add versioned support here for transformed views.
                // This will not work for transformed views in Honeycomb+
                final View child = group.getChildAt(i);
                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() &&
                        y + scrollY >= child.getTop() && y + scrollY < child.getBottom() &&
                        canScroll(child, true, dx, x + scrollX - child.getLeft(),
                                y + scrollY - child.getTop())) {
                    return true;
                }
            }
        }

        return checkV && ViewCompat.canScrollHorizontally(v, -dx);
    }

    @Override
    public boolean dispatchKeyEvent(KeyEvent event) {
        // Let the focused view and/or our descendants get the key first
        return super.dispatchKeyEvent(event) || executeKeyEvent(event);
    }

    /**
     * You can call this function yourself to have the scroll view perform
     * scrolling from a key event, just as if the event had been dispatched to
     * it by the view hierarchy.
     *
     * @param event The key event to execute.
     * @return Return true if the event was handled, else false.
     */
    public boolean executeKeyEvent(KeyEvent event) {
        boolean handled = false;
        if (event.getAction() == KeyEvent.ACTION_DOWN) {
            switch (event.getKeyCode()) {
                case KeyEvent.KEYCODE_DPAD_LEFT:
                    handled = arrowScroll(FOCUS_LEFT);
                    break;
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                    handled = arrowScroll(FOCUS_RIGHT);
                    break;
                case KeyEvent.KEYCODE_TAB:
                    if (Build.VERSION.SDK_INT >= 11) {
                        // The focus finder had a bug handling FOCUS_FORWARD and FOCUS_BACKWARD
                        // before Android 3.0. Ignore the tab key on those devices.
                        if (KeyEventCompat.hasNoModifiers(event)) {
                            handled = arrowScroll(FOCUS_FORWARD);
                        } else if (KeyEventCompat.hasModifiers(event, KeyEvent.META_SHIFT_ON)) {
                            handled = arrowScroll(FOCUS_BACKWARD);
                        }
                    }
                    break;
            }
        }
        return handled;
    }

    public boolean arrowScroll(int direction) {
        View currentFocused = findFocus();
        if (currentFocused == this) {
            currentFocused = null;
        } else if (currentFocused != null) {
            boolean isChild = false;
            for (ViewParent parent = currentFocused.getParent(); parent instanceof ViewGroup;
                 parent = parent.getParent()) {
                if (parent == this) {
                    isChild = true;
                    break;
                }
            }
            if (!isChild) {
                // This would cause the focus search down below to fail in fun ways.
                final StringBuilder sb = new StringBuilder();
                sb.append(currentFocused.getClass().getSimpleName());
                for (ViewParent parent = currentFocused.getParent(); parent instanceof ViewGroup;
                     parent = parent.getParent()) {
                    sb.append(" => ").append(parent.getClass().getSimpleName());
                }
                Log.e(TAG, "arrowScroll tried to find focus based on non-child " +
                        "current focused view " + sb.toString());
                currentFocused = null;
            }
        }

        boolean handled = false;

        View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused,
                direction);
        if (nextFocused != null && nextFocused != currentFocused) {
            if (direction == View.FOCUS_LEFT) {
                // If there is nothing to the left, or this is causing us to
                // jump to the right, then what we really want to do is page left.
                final int nextLeft = getChildRectInPagerCoordinates(mTempRect, nextFocused).left;
                final int currLeft = getChildRectInPagerCoordinates(mTempRect, currentFocused).left;
                if (currentFocused != null && nextLeft >= currLeft) {
                    handled = pageLeft();
                } else {
                    handled = nextFocused.requestFocus();
                }
            } else if (direction == View.FOCUS_RIGHT) {
                // If there is nothing to the right, or this is causing us to
                // jump to the left, then what we really want to do is page right.
                final int nextLeft = getChildRectInPagerCoordinates(mTempRect, nextFocused).left;
                final int currLeft = getChildRectInPagerCoordinates(mTempRect, currentFocused).left;
                if (currentFocused != null && nextLeft <= currLeft) {
                    handled = pageRight();
                } else {
                    handled = nextFocused.requestFocus();
                }
            }
        } else if (direction == FOCUS_LEFT || direction == FOCUS_BACKWARD) {
            // Trying to move left and nothing there; try to page.
            handled = pageLeft();
        } else if (direction == FOCUS_RIGHT || direction == FOCUS_FORWARD) {
            // Trying to move right and nothing there; try to page.
            handled = pageRight();
        }
        if (handled) {
            playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
        }
        return handled;
    }

    private Rect getChildRectInPagerCoordinates(Rect outRect, View child) {
        if (outRect == null) {
            outRect = new Rect();
        }
        if (child == null) {
            outRect.set(0, 0, 0, 0);
            return outRect;
        }
        outRect.left = child.getLeft();
        outRect.right = child.getRight();
        outRect.top = child.getTop();
        outRect.bottom = child.getBottom();

        ViewParent parent = child.getParent();
        while (parent instanceof ViewGroup && parent != this) {
            final ViewGroup group = (ViewGroup) parent;
            outRect.left += group.getLeft();
            outRect.right += group.getRight();
            outRect.top += group.getTop();
            outRect.bottom += group.getBottom();

            parent = group.getParent();
        }
        return outRect;
    }

    boolean pageLeft() {
        if (mCurItem > 0) {
            setCurrentItem(mCurItem-1, true);
            return true;
        }
        return false;
    }

    boolean pageRight() {
        if (mAdapter != null && mCurItem < (mAdapter.getCount()-1)) {
            setCurrentItem(mCurItem+1, true);
            return true;
        }
        return false;
    }

    /**
     * We only want the current page that is being shown to be focusable.
     */
    @Override
    public void addFocusables(ArrayList<View> views, int direction, int focusableMode) {
        final int focusableCount = views.size();

        final int descendantFocusability = getDescendantFocusability();

        if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {
            for (int i = 0; i < getChildCount(); i++) {
                final View child = getChildAt(i);
                if (child.getVisibility() == VISIBLE) {
                    ItemInfo ii = infoForChild(child);
                    if (ii != null && ii.position == mCurItem) {
                        child.addFocusables(views, direction, focusableMode);
                    }
                }
            }
        }

        // we add ourselves (if focusable) in all cases except for when we are
        // FOCUS_AFTER_DESCENDANTS and there are some descendants focusable.  this is
        // to avoid the focus search finding layouts when a more precise search
        // among the focusable children would be more interesting.
        if (
                descendantFocusability != FOCUS_AFTER_DESCENDANTS ||
                        // No focusable descendants
                        (focusableCount == views.size())) {
            // Note that we can't call the superclass here, because it will
            // add all views in.  So we need to do the same thing View does.
            if (!isFocusable()) {
                return;
            }
            if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE &&
                    isInTouchMode() && !isFocusableInTouchMode()) {
                return;
            }
            if (views != null) {
                views.add(this);
            }
        }
    }

    /**
     * We only want the current page that is being shown to be touchable.
     */
    @Override
    public void addTouchables(ArrayList<View> views) {
        // Note that we don't call super.addTouchables(), which means that
        // we don't call View.addTouchables().  This is okay because a ViewPager
        // is itself not touchable.
        for (int i = 0; i < getChildCount(); i++) {
            final View child = getChildAt(i);
            if (child.getVisibility() == VISIBLE) {
                ItemInfo ii = infoForChild(child);
                if (ii != null && ii.position == mCurItem) {
                    child.addTouchables(views);
                }
            }
        }
    }

    /**
     * We only want the current page that is being shown to be focusable.
     */
    @Override
    protected boolean onRequestFocusInDescendants(int direction,
                                                  Rect previouslyFocusedRect) {
        int index;
        int increment;
        int end;
        int count = getChildCount();
        if ((direction & FOCUS_FORWARD) != 0) {
            index = 0;
            increment = 1;
            end = count;
        } else {
            index = count - 1;
            increment = -1;
            end = -1;
        }
        for (int i = index; i != end; i += increment) {
            View child = getChildAt(i);
            if (child.getVisibility() == VISIBLE) {
                ItemInfo ii = infoForChild(child);
                if (ii != null && ii.position == mCurItem) {
                    if (child.requestFocus(direction, previouslyFocusedRect)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        // Dispatch scroll events from this ViewPager.
        if (event.getEventType() == AccessibilityEventCompat.TYPE_VIEW_SCROLLED) {
            return super.dispatchPopulateAccessibilityEvent(event);
        }

        // Dispatch all other accessibility events from the current page.
        final int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getVisibility() == VISIBLE) {
                final ItemInfo ii = infoForChild(child);
                if (ii != null && ii.position == mCurItem &&
                        child.dispatchPopulateAccessibilityEvent(event)) {
                    return true;
                }
            }
        }

        return false;
    }

    @Override
    protected ViewGroup.LayoutParams generateDefaultLayoutParams() {
        return new LayoutParams();
    }

    @Override
    protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
        return generateDefaultLayoutParams();
    }

    @Override
    protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
        return p instanceof LayoutParams && super.checkLayoutParams(p);
    }

    @Override
    public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
        return new LayoutParams(getContext(), attrs);
    }

    @Override
    public void onClick(View v) {
        final ItemInfo ii = infoForChild(v);

        if (ii != null && mOnItemClickListener != null) {
            mOnItemClickListener.onItemClick(ii.object, v, ii.position);
        }
    }

    @Override
    public boolean onLongClick(View v) {
        final ItemInfo ii = infoForChild(v);

        if (ii != null && mOnItemLongClickListener != null) {
            return mOnItemLongClickListener.onItemLongClick(ii.object, v, ii.position);
        }

        return false;
    }

    private void updateViewOnClickListeners() {
        final int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            final LayoutParams layoutParams = (LayoutParams) child.getLayoutParams();
            if (!layoutParams.isDecor) {
                if (mOnItemClickListener != null) {
                    child.setOnClickListener(this);
                }
            }
        }
    }

    private void updateViewOnLongClickListeners() {
        final int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            final LayoutParams layoutParams = (LayoutParams) child.getLayoutParams();
            if (!layoutParams.isDecor) {
                if (mOnItemLongClickListener != null) {
                    child.setOnLongClickListener(this);
                }
            }
        }
    }

    public void setOnItemClickListener(OnItemClickListener onItemClickListener) {
        if (mOnItemClickListener != onItemClickListener) {
            mOnItemClickListener = onItemClickListener;
            updateViewOnClickListeners();
        }
    }

    public void setOnItemLongClickListener(OnItemLongClickListener onItemLongClickListener) {
        if (mOnItemLongClickListener != onItemLongClickListener) {
            mOnItemLongClickListener = onItemLongClickListener;
            updateViewOnLongClickListeners();
        }
    }

    class MyAccessibilityDelegate extends AccessibilityDelegateCompat {

        @Override
        public void onInitializeAccessibilityEvent(View host, AccessibilityEvent event) {
            super.onInitializeAccessibilityEvent(host, event);
            event.setClassName(VelocityViewPager.class.getName());
            final AccessibilityRecordCompat recordCompat = AccessibilityRecordCompat.obtain();
            recordCompat.setScrollable(canScroll());
            if (event.getEventType() == AccessibilityEventCompat.TYPE_VIEW_SCROLLED
                    && mAdapter != null) {
                recordCompat.setItemCount(mAdapter.getCount());
                recordCompat.setFromIndex(mCurItem);
                recordCompat.setToIndex(mCurItem);
            }
        }

        @Override
        public void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfoCompat info) {
            super.onInitializeAccessibilityNodeInfo(host, info);
            info.setClassName(VelocityViewPager.class.getName());
            info.setScrollable(canScroll());
            if (canScrollHorizontally(1)) {
                info.addAction(AccessibilityNodeInfoCompat.ACTION_SCROLL_FORWARD);
            }
            if (canScrollHorizontally(-1)) {
                info.addAction(AccessibilityNodeInfoCompat.ACTION_SCROLL_BACKWARD);
            }
        }

        @Override
        public boolean performAccessibilityAction(View host, int action, Bundle args) {
            if (super.performAccessibilityAction(host, action, args)) {
                return true;
            }
            switch (action) {
                case AccessibilityNodeInfoCompat.ACTION_SCROLL_FORWARD: {
                    if (canScrollHorizontally(1)) {
                        setCurrentItem(mCurItem + 1);
                        return true;
                    }
                } return false;
                case AccessibilityNodeInfoCompat.ACTION_SCROLL_BACKWARD: {
                    if (canScrollHorizontally(-1)) {
                        setCurrentItem(mCurItem - 1);
                        return true;
                    }
                } return false;
            }
            return false;
        }

        private boolean canScroll() {
            return (mAdapter != null) && (mAdapter.getCount() > 1);
        }
    }

    private class PagerObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            dataSetChanged();
        }
        @Override
        public void onInvalidated() {
            dataSetChanged();
        }
    }

    /**
     * Layout parameters that should be supplied for views added to a
     * ViewPager.
     */
    public static class LayoutParams extends ViewGroup.LayoutParams {
        /**
         * true if this view is a decoration on the pager itself and not
         * a view supplied by the adapter.
         */
        public boolean isDecor;

        /**
         * Gravity setting for use on decor views only:
         * Where to position the view page within the overall ViewPager
         * container; constants are defined in {@link android.view.Gravity}.
         */
        public int gravity;

        /**
         * Width as a 0-1 multiplier of the measured pager width
         */
        float widthFactor = 0.f;

        /**
         * true if this view was added during layout and needs to be measured
         * before being positioned.
         */
        boolean needsMeasure;

        /**
         * Adapter position this view is for if !isDecor
         */
        int position;

        /**
         * Current child index within the ViewPager that this view occupies
         */
        int childIndex;

        public LayoutParams() {
            super(FILL_PARENT, FILL_PARENT);
        }

        public LayoutParams(Context context, AttributeSet attrs) {
            super(context, attrs);

            final TypedArray a = context.obtainStyledAttributes(attrs, LAYOUT_ATTRS);
            gravity = a.getInteger(0, Gravity.TOP);
            a.recycle();
        }
    }

    public interface OnItemClickListener {
        void onItemClick(Object object, View view, int position);
    }

    public interface OnItemLongClickListener {
        boolean onItemLongClick(Object object, View view, int position);
    }
}
@#$
/*
 * Copyright (C) 2011 Patrik Akerfeldt
 * Copyright (C) 2011 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.velocityviewpagerindicator;

import static android.graphics.Paint.ANTI_ALIAS_FLAG;
import static android.widget.LinearLayout.HORIZONTAL;
import static android.widget.LinearLayout.VERTICAL;
import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.drawable.Drawable;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.v4.view.MotionEventCompat;
import android.support.v4.view.ViewConfigurationCompat;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;

import com.velocity.view.pager.library.VelocityViewPager;

/**
 * Draws circles (one for each view). The current view position is filled and
 * others are only stroked.
 */
public class VelocityCirclePageIndicator extends View implements VelocityPageIndicator {
    private static final int INVALID_POINTER = -1;

    private float mRadius;
    private final Paint mPaintPageFill = new Paint(ANTI_ALIAS_FLAG);
    private final Paint mPaintStroke = new Paint(ANTI_ALIAS_FLAG);
    private final Paint mPaintFill = new Paint(ANTI_ALIAS_FLAG);
    private VelocityViewPager mVelocityViewPager;
    private VelocityViewPager.OnPageChangeListener mListener;
    private int mCurrentPage;
    private int mSnapPage;
    private float mPageOffset;
    private int mScrollState;
    private int mOrientation;
    private boolean mCentered;
    private boolean mSnap;

    private int mTouchSlop;
    private float mLastMotionX = -1;
    private int mActivePointerId = INVALID_POINTER;
    private boolean mIsDragging;


    public VelocityCirclePageIndicator(Context context) {
        this(context, null);
    }

    public VelocityCirclePageIndicator(Context context, AttributeSet attrs) {
        this(context, attrs, R.attr.vpiCirclePageIndicatorStyle);
    }

    public VelocityCirclePageIndicator(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        if (isInEditMode()) return;

        //Load defaults from resources
        final Resources res = getResources();
        final int defaultPageColor = res.getColor(R.color.default_circle_indicator_page_color);
        final int defaultFillColor = res.getColor(R.color.default_circle_indicator_fill_color);
        final int defaultOrientation = res.getInteger(R.integer.default_circle_indicator_orientation);
        final int defaultStrokeColor = res.getColor(R.color.default_circle_indicator_stroke_color);
        final float defaultStrokeWidth = res.getDimension(R.dimen.default_circle_indicator_stroke_width);
        final float defaultRadius = res.getDimension(R.dimen.default_circle_indicator_radius);
        final boolean defaultCentered = res.getBoolean(R.bool.default_circle_indicator_centered);
        final boolean defaultSnap = res.getBoolean(R.bool.default_circle_indicator_snap);

        //Retrieve styles attributes
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.VelocityCirclePageIndicator, defStyle, 0);

        mCentered = a.getBoolean(R.styleable.VelocityCirclePageIndicator_centered, defaultCentered);
        mOrientation = a.getInt(R.styleable.VelocityCirclePageIndicator_android_orientation, defaultOrientation);
        mPaintPageFill.setStyle(Style.FILL);
        mPaintPageFill.setColor(a.getColor(R.styleable.VelocityCirclePageIndicator_pageColor, defaultPageColor));
        mPaintStroke.setStyle(Style.STROKE);
        mPaintStroke.setColor(a.getColor(R.styleable.VelocityCirclePageIndicator_strokeColor, defaultStrokeColor));
        mPaintStroke.setStrokeWidth(a.getDimension(R.styleable.VelocityCirclePageIndicator_strokeWidth, defaultStrokeWidth));
        mPaintFill.setStyle(Style.FILL);
        mPaintFill.setColor(a.getColor(R.styleable.VelocityCirclePageIndicator_fillColor, defaultFillColor));
        mRadius = a.getDimension(R.styleable.VelocityCirclePageIndicator_radius, defaultRadius);
        mSnap = a.getBoolean(R.styleable.VelocityCirclePageIndicator_snap, defaultSnap);

        Drawable background = a.getDrawable(R.styleable.VelocityCirclePageIndicator_android_background);
        if (background != null) {
          setBackgroundDrawable(background);
        }

        a.recycle();

        final ViewConfiguration configuration = ViewConfiguration.get(context);
        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
    }


    public void setCentered(boolean centered) {
        mCentered = centered;
        invalidate();
    }

    public boolean isCentered() {
        return mCentered;
    }

    public void setPageColor(int pageColor) {
        mPaintPageFill.setColor(pageColor);
        invalidate();
    }

    public int getPageColor() {
        return mPaintPageFill.getColor();
    }

    public void setFillColor(int fillColor) {
        mPaintFill.setColor(fillColor);
        invalidate();
    }

    public int getFillColor() {
        return mPaintFill.getColor();
    }

    public void setOrientation(int orientation) {
        switch (orientation) {
            case HORIZONTAL:
            case VERTICAL:
                mOrientation = orientation;
                requestLayout();
                break;

            default:
                throw new IllegalArgumentException("Orientation must be either HORIZONTAL or VERTICAL.");
        }
    }

    public int getOrientation() {
        return mOrientation;
    }

    public void setStrokeColor(int strokeColor) {
        mPaintStroke.setColor(strokeColor);
        invalidate();
    }

    public int getStrokeColor() {
        return mPaintStroke.getColor();
    }

    public void setStrokeWidth(float strokeWidth) {
        mPaintStroke.setStrokeWidth(strokeWidth);
        invalidate();
    }

    public float getStrokeWidth() {
        return mPaintStroke.getStrokeWidth();
    }

    public void setRadius(float radius) {
        mRadius = radius;
        invalidate();
    }

    public float getRadius() {
        return mRadius;
    }

    public void setSnap(boolean snap) {
        mSnap = snap;
        invalidate();
    }

    public boolean isSnap() {
        return mSnap;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (mVelocityViewPager == null) {
            return;
        }
        final int count = mVelocityViewPager.getAdapter().getCount();
        if (count == 0) {
            return;
        }

        if (mCurrentPage >= count) {
            setCurrentItem(count - 1);
            return;
        }

        int longSize;
        int longPaddingBefore;
        int longPaddingAfter;
        int shortPaddingBefore;
        if (mOrientation == HORIZONTAL) {
            longSize = getWidth();
            longPaddingBefore = getPaddingLeft();
            longPaddingAfter = getPaddingRight();
            shortPaddingBefore = getPaddingTop();
        } else {
            longSize = getHeight();
            longPaddingBefore = getPaddingTop();
            longPaddingAfter = getPaddingBottom();
            shortPaddingBefore = getPaddingLeft();
        }

        final float threeRadius = mRadius * 3;
        final float shortOffset = shortPaddingBefore + mRadius;
        float longOffset = longPaddingBefore + mRadius;
        if (mCentered) {
            longOffset += ((longSize - longPaddingBefore - longPaddingAfter) / 2.0f) - ((count * threeRadius) / 2.0f);
        }

        float dX;
        float dY;

        float pageFillRadius = mRadius;
        if (mPaintStroke.getStrokeWidth() > 0) {
            pageFillRadius -= mPaintStroke.getStrokeWidth() / 2.0f;
        }

        //Draw stroked circles
        for (int iLoop = 0; iLoop < count; iLoop++) {
            float drawLong = longOffset + (iLoop * threeRadius);
            if (mOrientation == HORIZONTAL) {
                dX = drawLong;
                dY = shortOffset;
            } else {
                dX = shortOffset;
                dY = drawLong;
            }
            // Only paint fill if not completely transparent
            if (mPaintPageFill.getAlpha() > 0) {
                canvas.drawCircle(dX, dY, pageFillRadius, mPaintPageFill);
            }

            // Only paint stroke if a stroke width was non-zero
            if (pageFillRadius != mRadius) {
                canvas.drawCircle(dX, dY, mRadius, mPaintStroke);
            }
        }

        //Draw the filled circle according to the current scroll
        float cx = (mSnap ? mSnapPage : mCurrentPage) * threeRadius;
        if (!mSnap) {
            cx += mPageOffset * threeRadius;
        }
        if (mOrientation == HORIZONTAL) {
            dX = longOffset + cx;
            dY = shortOffset;
        } else {
            dX = shortOffset;
            dY = longOffset + cx;
        }
        canvas.drawCircle(dX, dY, mRadius, mPaintFill);
    }

    public boolean onTouchEvent(android.view.MotionEvent ev) {
        if (super.onTouchEvent(ev)) {
            return true;
        }
        if ((mVelocityViewPager == null) || (mVelocityViewPager.getAdapter().getCount() == 0)) {
            return false;
        }

        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
                mLastMotionX = ev.getX();
                break;

            case MotionEvent.ACTION_MOVE: {
                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                final float x = MotionEventCompat.getX(ev, activePointerIndex);
                final float deltaX = x - mLastMotionX;

                if (!mIsDragging) {
                    if (Math.abs(deltaX) > mTouchSlop) {
                        mIsDragging = true;
                    }
                }

                if (mIsDragging) {
                    mLastMotionX = x;
                    if (mVelocityViewPager.isFakeDragging() || mVelocityViewPager.beginFakeDrag()) {
                        mVelocityViewPager.fakeDragBy(deltaX);
                    }
                }

                break;
            }

            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                if (!mIsDragging) {
                    final int count = mVelocityViewPager.getAdapter().getCount();
                    final int width = getWidth();
                    final float halfWidth = width / 2f;
                    final float sixthWidth = width / 6f;

                    if ((mCurrentPage > 0) && (ev.getX() < halfWidth - sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mVelocityViewPager.setCurrentItem(mCurrentPage - 1);
                        }
                        return true;
                    } else if ((mCurrentPage < count - 1) && (ev.getX() > halfWidth + sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mVelocityViewPager.setCurrentItem(mCurrentPage + 1);
                        }
                        return true;
                    }
                }

                mIsDragging = false;
                mActivePointerId = INVALID_POINTER;
                if (mVelocityViewPager.isFakeDragging()) mVelocityViewPager.endFakeDrag();
                break;

            case MotionEventCompat.ACTION_POINTER_DOWN: {
                final int index = MotionEventCompat.getActionIndex(ev);
                mLastMotionX = MotionEventCompat.getX(ev, index);
                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
                break;
            }

            case MotionEventCompat.ACTION_POINTER_UP:
                final int pointerIndex = MotionEventCompat.getActionIndex(ev);
                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
                if (pointerId == mActivePointerId) {
                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
                }
                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));
                break;
        }

        return true;
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager view) {
        if (mVelocityViewPager == view) {
            return;
        }
        if (mVelocityViewPager != null) {
            mVelocityViewPager.setOnPageChangeListener(null);
        }
        if (view.getAdapter() == null) {
            throw new IllegalStateException("VelocityViewPager does not have adapter instance.");
        }
        mVelocityViewPager = view;
        mVelocityViewPager.setOnPageChangeListener(this);
        invalidate();
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager view, int initialPosition) {
        setVelocityViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void setCurrentItem(int item) {
        if (mVelocityViewPager == null) {
            throw new IllegalStateException("VelocityViewPager has not been bound.");
        }
        mVelocityViewPager.setCurrentItem(item);
        mCurrentPage = item;
        invalidate();
    }

    @Override
    public void notifyDataSetChanged() {
        invalidate();
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        mScrollState = state;

        if (mListener != null) {
            mListener.onPageScrollStateChanged(state);
        }
    }

    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        mCurrentPage = position;
        mPageOffset = positionOffset;
        invalidate();

        if (mListener != null) {
            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);
        }
    }

    @Override
    public void onPageSelected(int position) {
        if (mSnap || mScrollState == VelocityViewPager.SCROLL_STATE_IDLE) {
            mCurrentPage = position;
            mSnapPage = position;
            invalidate();
        }

        if (mListener != null) {
            mListener.onPageSelected(position);
        }
    }

    @Override
    public void setOnPageChangeListener(VelocityViewPager.OnPageChangeListener listener) {
        mListener = listener;
    }

    /*
     * (non-Javadoc)
     *
     * @see android.view.View#onMeasure(int, int)
     */
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (mOrientation == HORIZONTAL) {
            setMeasuredDimension(measureLong(widthMeasureSpec), measureShort(heightMeasureSpec));
        } else {
            setMeasuredDimension(measureShort(widthMeasureSpec), measureLong(heightMeasureSpec));
        }
    }

    /**
     * Determines the width of this view
     *
     * @param measureSpec
     *            A measureSpec packed into an int
     * @return The width of the view, honoring constraints from measureSpec
     */
    private int measureLong(int measureSpec) {
        int result;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        if ((specMode == MeasureSpec.EXACTLY) || (mVelocityViewPager == null)) {
            //We were told how big to be
            result = specSize;
        } else {
            //Calculate the width according the views count
            final int count = mVelocityViewPager.getAdapter().getCount();
            result = (int)(getPaddingLeft() + getPaddingRight()
                    + (count * 2 * mRadius) + (count - 1) * mRadius + 1);
            //Respect AT_MOST value if that was what is called for by measureSpec
            if (specMode == MeasureSpec.AT_MOST) {
                result = Math.min(result, specSize);
            }
        }
        return result;
    }

    /**
     * Determines the height of this view
     *
     * @param measureSpec
     *            A measureSpec packed into an int
     * @return The height of the view, honoring constraints from measureSpec
     */
    private int measureShort(int measureSpec) {
        int result;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        if (specMode == MeasureSpec.EXACTLY) {
            //We were told how big to be
            result = specSize;
        } else {
            //Measure the height
            result = (int)(2 * mRadius + getPaddingTop() + getPaddingBottom() + 1);
            //Respect AT_MOST value if that was what is called for by measureSpec
            if (specMode == MeasureSpec.AT_MOST) {
                result = Math.min(result, specSize);
            }
        }
        return result;
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
        SavedState savedState = (SavedState)state;
        super.onRestoreInstanceState(savedState.getSuperState());
        mCurrentPage = savedState.currentPage;
        mSnapPage = savedState.currentPage;
        requestLayout();
    }

    @Override
    public Parcelable onSaveInstanceState() {
        Parcelable superState = super.onSaveInstanceState();
        SavedState savedState = new SavedState(superState);
        savedState.currentPage = mCurrentPage;
        return savedState;
    }

    static class SavedState extends BaseSavedState {
        int currentPage;

        public SavedState(Parcelable superState) {
            super(superState);
        }

        private SavedState(Parcel in) {
            super(in);
            currentPage = in.readInt();
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            super.writeToParcel(dest, flags);
            dest.writeInt(currentPage);
        }

        @SuppressWarnings("UnusedDeclaration")
        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
            @Override
            public SavedState createFromParcel(Parcel in) {
                return new SavedState(in);
            }

            @Override
            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        };
    }
}

@#$
/*
 * Copyright (C) 2011 The Android Open Source Project
 * Copyright (C) 2012 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.velocityviewpagerindicator;

import static android.view.ViewGroup.LayoutParams.FILL_PARENT;
import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
import android.content.Context;
import android.support.v4.view.PagerAdapter;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.View;
import android.widget.HorizontalScrollView;
import android.widget.ImageView;

import com.velocity.view.pager.library.VelocityViewPager;
import com.velocity.view.pager.library.VelocityViewPager.OnPageChangeListener;

/**
 * This widget implements the dynamic action bar tab behavior that can change
 * across different configurations or circumstances.
 */
public class VelocityIconPageIndicator extends HorizontalScrollView implements VelocityPageIndicator {
    private final VelocityIcsLinearLayout mIconsLayout;

    private VelocityViewPager mVelocityViewPager;
    private OnPageChangeListener mListener;
    private Runnable mIconSelector;
    private int mSelectedIndex;

    public VelocityIconPageIndicator(Context context) {
        this(context, null);
    }

    public VelocityIconPageIndicator(Context context, AttributeSet attrs) {
        super(context, attrs);
        setHorizontalScrollBarEnabled(false);

        mIconsLayout = new VelocityIcsLinearLayout(context, R.attr.vpiIconPageIndicatorStyle);
        addView(mIconsLayout, new LayoutParams(WRAP_CONTENT, FILL_PARENT, Gravity.CENTER));
    }

    private void animateToIcon(final int position) {
        final View iconView = mIconsLayout.getChildAt(position);
        if (mIconSelector != null) {
            removeCallbacks(mIconSelector);
        }
        mIconSelector = new Runnable() {
            public void run() {
                final int scrollPos = iconView.getLeft() - (getWidth() - iconView.getWidth()) / 2;
                smoothScrollTo(scrollPos, 0);
                mIconSelector = null;
            }
        };
        post(mIconSelector);
    }

    @Override
    public void onAttachedToWindow() {
        super.onAttachedToWindow();
        if (mIconSelector != null) {
            // Re-post the selector we saved
            post(mIconSelector);
        }
    }

    @Override
    public void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        if (mIconSelector != null) {
            removeCallbacks(mIconSelector);
        }
    }

    @Override
    public void onPageScrollStateChanged(int arg0) {
        if (mListener != null) {
            mListener.onPageScrollStateChanged(arg0);
        }
    }

    @Override
    public void onPageScrolled(int arg0, float arg1, int arg2) {
        if (mListener != null) {
            mListener.onPageScrolled(arg0, arg1, arg2);
        }
    }

    @Override
    public void onPageSelected(int arg0) {
        setCurrentItem(arg0);
        if (mListener != null) {
            mListener.onPageSelected(arg0);
        }
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager view) {
        if (mVelocityViewPager == view) {
            return;
        }
        if (mVelocityViewPager != null) {
            mVelocityViewPager.setOnPageChangeListener(null);
        }
        PagerAdapter adapter = view.getAdapter();
        if (adapter == null) {
            throw new IllegalStateException("VelocityViewPager does not have adapter instance.");
        }
        mVelocityViewPager = view;
        view.setOnPageChangeListener(this);
        notifyDataSetChanged();
    }

    public void notifyDataSetChanged() {
        mIconsLayout.removeAllViews();
        VelocityIconPagerAdapter iconAdapter = (VelocityIconPagerAdapter) mVelocityViewPager.getAdapter();
        int count = iconAdapter.getCount();
        for (int i = 0; i < count; i++) {
            ImageView view = new ImageView(getContext(), null, R.attr.vpiIconPageIndicatorStyle);
            view.setImageResource(iconAdapter.getIconResId(i));
            mIconsLayout.addView(view);
        }
        if (mSelectedIndex > count) {
            mSelectedIndex = count - 1;
        }
        setCurrentItem(mSelectedIndex);
        requestLayout();
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager view, int initialPosition) {
        setVelocityViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void setCurrentItem(int item) {
        if (mVelocityViewPager == null) {
            throw new IllegalStateException("VelocityViewPager has not been bound.");
        }
        mSelectedIndex = item;
        mVelocityViewPager.setCurrentItem(item);

        int tabCount = mIconsLayout.getChildCount();
        for (int i = 0; i < tabCount; i++) {
            View child = mIconsLayout.getChildAt(i);
            boolean isSelected = (i == item);
            child.setSelected(isSelected);
            if (isSelected) {
                animateToIcon(item);
            }
        }
    }

    @Override
    public void setOnPageChangeListener(OnPageChangeListener listener) {
        mListener = listener;
    }
}

@#$
package com.velocityviewpagerindicator;

public interface VelocityIconPagerAdapter {
    /**
     * Get icon representing the page at {@code index} in the adapter.
     */
    int getIconResId(int index);

    // From PagerAdapter
    int getCount();
}

@#$
package com.velocityviewpagerindicator;

import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.drawable.Drawable;
import android.view.View;
import android.widget.LinearLayout;

/**
 * A simple extension of a regular linear layout that supports the divider API
 * of Android 4.0+. The dividers are added adjacent to the children by changing
 * their layout params. If you need to rely on the margins which fall in the
 * same orientation as the layout you should wrap the child in a simple
 * {@link android.widget.FrameLayout} so it can receive the margin.
 */
class VelocityIcsLinearLayout extends LinearLayout {
    private static final int[] LL = new int[] {
        /* 0 */ android.R.attr.divider,
        /* 1 */ android.R.attr.showDividers,
        /* 2 */ android.R.attr.dividerPadding,
    };
    private static final int LL_DIVIDER = 0;
    private static final int LL_SHOW_DIVIDER = 1;
    private static final int LL_DIVIDER_PADDING = 2;

    private Drawable mDivider;
    private int mDividerWidth;
    private int mDividerHeight;
    private int mShowDividers;
    private int mDividerPadding;


    public VelocityIcsLinearLayout(Context context, int themeAttr) {
        super(context);

        TypedArray a = context.obtainStyledAttributes(null, LL, themeAttr, 0);
        setDividerDrawable(a.getDrawable(VelocityIcsLinearLayout.LL_DIVIDER));
        mDividerPadding = a.getDimensionPixelSize(LL_DIVIDER_PADDING, 0);
        mShowDividers = a.getInteger(LL_SHOW_DIVIDER, SHOW_DIVIDER_NONE);
        a.recycle();
    }

    public void setDividerDrawable(Drawable divider) {
        if (divider == mDivider) {
            return;
        }
        mDivider = divider;
        if (divider != null) {
            mDividerWidth = divider.getIntrinsicWidth();
            mDividerHeight = divider.getIntrinsicHeight();
        } else {
            mDividerWidth = 0;
            mDividerHeight = 0;
        }
        setWillNotDraw(divider == null);
        requestLayout();
    }

    @Override
    protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) {
        final int index = indexOfChild(child);
        final int orientation = getOrientation();
        final LayoutParams params = (LayoutParams) child.getLayoutParams();
        if (hasDividerBeforeChildAt(index)) {
            if (orientation == VERTICAL) {
                //Account for the divider by pushing everything up
                params.topMargin = mDividerHeight;
            } else {
                //Account for the divider by pushing everything left
                params.leftMargin = mDividerWidth;
            }
        }

        final int count = getChildCount();
        if (index == count - 1) {
            if (hasDividerBeforeChildAt(count)) {
                if (orientation == VERTICAL) {
                    params.bottomMargin = mDividerHeight;
                } else {
                    params.rightMargin = mDividerWidth;
                }
            }
        }
        super.measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (mDivider != null) {
            if (getOrientation() == VERTICAL) {
                drawDividersVertical(canvas);
            } else {
                drawDividersHorizontal(canvas);
            }
        }
        super.onDraw(canvas);
    }

    private void drawDividersVertical(Canvas canvas) {
        final int count = getChildCount();
        for (int i = 0; i < count; i++) {
            final View child = getChildAt(i);

            if (child != null && child.getVisibility() != GONE) {
                if (hasDividerBeforeChildAt(i)) {
                    final android.widget.LinearLayout.LayoutParams lp = (android.widget.LinearLayout.LayoutParams) child.getLayoutParams();
                    final int top = child.getTop() - lp.topMargin/* - mDividerHeight*/;
                    drawHorizontalDivider(canvas, top);
                }
            }
        }

        if (hasDividerBeforeChildAt(count)) {
            final View child = getChildAt(count - 1);
            int bottom = 0;
            if (child == null) {
                bottom = getHeight() - getPaddingBottom() - mDividerHeight;
            } else {
                //final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                bottom = child.getBottom()/* + lp.bottomMargin*/;
            }
            drawHorizontalDivider(canvas, bottom);
        }
    }

    private void drawDividersHorizontal(Canvas canvas) {
        final int count = getChildCount();
        for (int i = 0; i < count; i++) {
            final View child = getChildAt(i);

            if (child != null && child.getVisibility() != GONE) {
                if (hasDividerBeforeChildAt(i)) {
                    final android.widget.LinearLayout.LayoutParams lp = (android.widget.LinearLayout.LayoutParams) child.getLayoutParams();
                    final int left = child.getLeft() - lp.leftMargin/* - mDividerWidth*/;
                    drawVerticalDivider(canvas, left);
                }
            }
        }

        if (hasDividerBeforeChildAt(count)) {
            final View child = getChildAt(count - 1);
            int right = 0;
            if (child == null) {
                right = getWidth() - getPaddingRight() - mDividerWidth;
            } else {
                //final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                right = child.getRight()/* + lp.rightMargin*/;
            }
            drawVerticalDivider(canvas, right);
        }
    }

    private void drawHorizontalDivider(Canvas canvas, int top) {
        mDivider.setBounds(getPaddingLeft() + mDividerPadding, top,
                getWidth() - getPaddingRight() - mDividerPadding, top + mDividerHeight);
        mDivider.draw(canvas);
    }

    private void drawVerticalDivider(Canvas canvas, int left) {
        mDivider.setBounds(left, getPaddingTop() + mDividerPadding,
                left + mDividerWidth, getHeight() - getPaddingBottom() - mDividerPadding);
        mDivider.draw(canvas);
    }

    private boolean hasDividerBeforeChildAt(int childIndex) {
        if (childIndex == 0 || childIndex == getChildCount()) {
          return false;
        }
        if ((mShowDividers & SHOW_DIVIDER_MIDDLE) != 0) {
            boolean hasVisibleViewBefore = false;
            for (int i = childIndex - 1; i >= 0; i--) {
                if (getChildAt(i).getVisibility() != GONE) {
                    hasVisibleViewBefore = true;
                    break;
                }
            }
            return hasVisibleViewBefore;
        }
        return false;
    }
}

@#$
/*
 * Copyright (C) 2012 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.velocityviewpagerindicator;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.drawable.Drawable;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.v4.view.MotionEventCompat;
import android.support.v4.view.ViewConfigurationCompat;
import android.util.AttributeSet;
import android.util.FloatMath;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;

import com.velocity.view.pager.library.VelocityViewPager;

/**
 * Draws a line for each page. The current page line is colored differently
 * than the unselected page lines.
 */
public class VelocityLinePageIndicator extends View implements VelocityPageIndicator {
    private static final int INVALID_POINTER = -1;

    private final Paint mPaintUnselected = new Paint(Paint.ANTI_ALIAS_FLAG);
    private final Paint mPaintSelected = new Paint(Paint.ANTI_ALIAS_FLAG);
    private VelocityViewPager mVelocityViewPager;
    private VelocityViewPager.OnPageChangeListener mListener;
    private int mCurrentPage;
    private boolean mCentered;
    private float mLineWidth;
    private float mGapWidth;

    private int mTouchSlop;
    private float mLastMotionX = -1;
    private int mActivePointerId = INVALID_POINTER;
    private boolean mIsDragging;


    public VelocityLinePageIndicator(Context context) {
        this(context, null);
    }

    public VelocityLinePageIndicator(Context context, AttributeSet attrs) {
        this(context, attrs, R.attr.vpiLinePageIndicatorStyle);
    }

    public VelocityLinePageIndicator(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        if (isInEditMode()) return;

        final Resources res = getResources();

        //Load defaults from resources
        final int defaultSelectedColor = res.getColor(R.color.default_line_indicator_selected_color);
        final int defaultUnselectedColor = res.getColor(R.color.default_line_indicator_unselected_color);
        final float defaultLineWidth = res.getDimension(R.dimen.default_line_indicator_line_width);
        final float defaultGapWidth = res.getDimension(R.dimen.default_line_indicator_gap_width);
        final float defaultStrokeWidth = res.getDimension(R.dimen.default_line_indicator_stroke_width);
        final boolean defaultCentered = res.getBoolean(R.bool.default_line_indicator_centered);

        //Retrieve styles attributes
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.VelocityLinePageIndicator, defStyle, 0);

        mCentered = a.getBoolean(R.styleable.VelocityLinePageIndicator_centered, defaultCentered);
        mLineWidth = a.getDimension(R.styleable.VelocityLinePageIndicator_lineWidth, defaultLineWidth);
        mGapWidth = a.getDimension(R.styleable.VelocityLinePageIndicator_gapWidth, defaultGapWidth);
        setStrokeWidth(a.getDimension(R.styleable.VelocityLinePageIndicator_strokeWidth, defaultStrokeWidth));
        mPaintUnselected.setColor(a.getColor(R.styleable.VelocityLinePageIndicator_unselectedColor, defaultUnselectedColor));
        mPaintSelected.setColor(a.getColor(R.styleable.VelocityLinePageIndicator_selectedColor, defaultSelectedColor));

        Drawable background = a.getDrawable(R.styleable.VelocityLinePageIndicator_android_background);
        if (background != null) {
          setBackgroundDrawable(background);
        }

        a.recycle();

        final ViewConfiguration configuration = ViewConfiguration.get(context);
        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
    }


    public void setCentered(boolean centered) {
        mCentered = centered;
        invalidate();
    }

    public boolean isCentered() {
        return mCentered;
    }

    public void setUnselectedColor(int unselectedColor) {
        mPaintUnselected.setColor(unselectedColor);
        invalidate();
    }

    public int getUnselectedColor() {
        return mPaintUnselected.getColor();
    }

    public void setSelectedColor(int selectedColor) {
        mPaintSelected.setColor(selectedColor);
        invalidate();
    }

    public int getSelectedColor() {
        return mPaintSelected.getColor();
    }

    public void setLineWidth(float lineWidth) {
        mLineWidth = lineWidth;
        invalidate();
    }

    public float getLineWidth() {
        return mLineWidth;
    }

    public void setStrokeWidth(float lineHeight) {
        mPaintSelected.setStrokeWidth(lineHeight);
        mPaintUnselected.setStrokeWidth(lineHeight);
        invalidate();
    }

    public float getStrokeWidth() {
        return mPaintSelected.getStrokeWidth();
    }

    public void setGapWidth(float gapWidth) {
        mGapWidth = gapWidth;
        invalidate();
    }

    public float getGapWidth() {
        return mGapWidth;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (mVelocityViewPager == null) {
            return;
        }
        final int count = mVelocityViewPager.getAdapter().getCount();
        if (count == 0) {
            return;
        }

        if (mCurrentPage >= count) {
            setCurrentItem(count - 1);
            return;
        }

        final float lineWidthAndGap = mLineWidth + mGapWidth;
        final float indicatorWidth = (count * lineWidthAndGap) - mGapWidth;
        final float paddingTop = getPaddingTop();
        final float paddingLeft = getPaddingLeft();
        final float paddingRight = getPaddingRight();

        float verticalOffset = paddingTop + ((getHeight() - paddingTop - getPaddingBottom()) / 2.0f);
        float horizontalOffset = paddingLeft;
        if (mCentered) {
            horizontalOffset += ((getWidth() - paddingLeft - paddingRight) / 2.0f) - (indicatorWidth / 2.0f);
        }

        //Draw stroked circles
        for (int i = 0; i < count; i++) {
            float dx1 = horizontalOffset + (i * lineWidthAndGap);
            float dx2 = dx1 + mLineWidth;
            canvas.drawLine(dx1, verticalOffset, dx2, verticalOffset, (i == mCurrentPage) ? mPaintSelected : mPaintUnselected);
        }
    }

    public boolean onTouchEvent(android.view.MotionEvent ev) {
        if (super.onTouchEvent(ev)) {
            return true;
        }
        if ((mVelocityViewPager == null) || (mVelocityViewPager.getAdapter().getCount() == 0)) {
            return false;
        }

        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
                mLastMotionX = ev.getX();
                break;

            case MotionEvent.ACTION_MOVE: {
                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                final float x = MotionEventCompat.getX(ev, activePointerIndex);
                final float deltaX = x - mLastMotionX;

                if (!mIsDragging) {
                    if (Math.abs(deltaX) > mTouchSlop) {
                        mIsDragging = true;
                    }
                }

                if (mIsDragging) {
                    mLastMotionX = x;
                    if (mVelocityViewPager.isFakeDragging() || mVelocityViewPager.beginFakeDrag()) {
                        mVelocityViewPager.fakeDragBy(deltaX);
                    }
                }

                break;
            }

            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                if (!mIsDragging) {
                    final int count = mVelocityViewPager.getAdapter().getCount();
                    final int width = getWidth();
                    final float halfWidth = width / 2f;
                    final float sixthWidth = width / 6f;

                    if ((mCurrentPage > 0) && (ev.getX() < halfWidth - sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mVelocityViewPager.setCurrentItem(mCurrentPage - 1);
                        }
                        return true;
                    } else if ((mCurrentPage < count - 1) && (ev.getX() > halfWidth + sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mVelocityViewPager.setCurrentItem(mCurrentPage + 1);
                        }
                        return true;
                    }
                }

                mIsDragging = false;
                mActivePointerId = INVALID_POINTER;
                if (mVelocityViewPager.isFakeDragging()) mVelocityViewPager.endFakeDrag();
                break;

            case MotionEventCompat.ACTION_POINTER_DOWN: {
                final int index = MotionEventCompat.getActionIndex(ev);
                mLastMotionX = MotionEventCompat.getX(ev, index);
                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
                break;
            }

            case MotionEventCompat.ACTION_POINTER_UP:
                final int pointerIndex = MotionEventCompat.getActionIndex(ev);
                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
                if (pointerId == mActivePointerId) {
                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
                }
                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));
                break;
        }

        return true;
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager VelocityViewPager) {
        if (mVelocityViewPager == VelocityViewPager) {
            return;
        }
        if (mVelocityViewPager != null) {
            //Clear us from the old pager.
            mVelocityViewPager.setOnPageChangeListener(null);
        }
        if (VelocityViewPager.getAdapter() == null) {
            throw new IllegalStateException("VelocityViewPager does not have adapter instance.");
        }
        mVelocityViewPager = VelocityViewPager;
        mVelocityViewPager.setOnPageChangeListener(this);
        invalidate();
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager view, int initialPosition) {
        setVelocityViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void setCurrentItem(int item) {
        if (mVelocityViewPager == null) {
            throw new IllegalStateException("VelocityViewPager has not been bound.");
        }
        mVelocityViewPager.setCurrentItem(item);
        mCurrentPage = item;
        invalidate();
    }

    @Override
    public void notifyDataSetChanged() {
        invalidate();
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        if (mListener != null) {
            mListener.onPageScrollStateChanged(state);
        }
    }

    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        if (mListener != null) {
            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);
        }
    }

    @Override
    public void onPageSelected(int position) {
        mCurrentPage = position;
        invalidate();

        if (mListener != null) {
            mListener.onPageSelected(position);
        }
    }

    @Override
    public void setOnPageChangeListener(VelocityViewPager.OnPageChangeListener listener) {
        mListener = listener;
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec));
    }

    /**
     * Determines the width of this view
     *
     * @param measureSpec
     *            A measureSpec packed into an int
     * @return The width of the view, honoring constraints from measureSpec
     */
    private int measureWidth(int measureSpec) {
        float result;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        if ((specMode == MeasureSpec.EXACTLY) || (mVelocityViewPager == null)) {
            //We were told how big to be
            result = specSize;
        } else {
            //Calculate the width according the views count
            final int count = mVelocityViewPager.getAdapter().getCount();
            result = getPaddingLeft() + getPaddingRight() + (count * mLineWidth) + ((count - 1) * mGapWidth);
            //Respect AT_MOST value if that was what is called for by measureSpec
            if (specMode == MeasureSpec.AT_MOST) {
                result = Math.min(result, specSize);
            }
        }
        return (int)FloatMath.ceil(result);
    }

    /**
     * Determines the height of this view
     *
     * @param measureSpec
     *            A measureSpec packed into an int
     * @return The height of the view, honoring constraints from measureSpec
     */
    private int measureHeight(int measureSpec) {
        float result;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        if (specMode == MeasureSpec.EXACTLY) {
            //We were told how big to be
            result = specSize;
        } else {
            //Measure the height
            result = mPaintSelected.getStrokeWidth() + getPaddingTop() + getPaddingBottom();
            //Respect AT_MOST value if that was what is called for by measureSpec
            if (specMode == MeasureSpec.AT_MOST) {
                result = Math.min(result, specSize);
            }
        }
        return (int)FloatMath.ceil(result);
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
        SavedState savedState = (SavedState)state;
        super.onRestoreInstanceState(savedState.getSuperState());
        mCurrentPage = savedState.currentPage;
        requestLayout();
    }

    @Override
    public Parcelable onSaveInstanceState() {
        Parcelable superState = super.onSaveInstanceState();
        SavedState savedState = new SavedState(superState);
        savedState.currentPage = mCurrentPage;
        return savedState;
    }

    static class SavedState extends BaseSavedState {
        int currentPage;

        public SavedState(Parcelable superState) {
            super(superState);
        }

        private SavedState(Parcel in) {
            super(in);
            currentPage = in.readInt();
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            super.writeToParcel(dest, flags);
            dest.writeInt(currentPage);
        }

        @SuppressWarnings("UnusedDeclaration")
        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
            @Override
            public SavedState createFromParcel(Parcel in) {
                return new SavedState(in);
            }

            @Override
            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        };
    }
}
@#$
/*
 * Copyright (C) 2011 Patrik Akerfeldt
 * Copyright (C) 2011 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.velocityviewpagerindicator;

import com.velocity.view.pager.library.VelocityViewPager;


/**
 * A PageIndicator is responsible to show an visual indicator on the total views
 * number and the current visible view.
 */
public interface VelocityPageIndicator extends VelocityViewPager.OnPageChangeListener {
    /**
     * Bind the indicator to a VelocityViewPager.
     *
     * @param view
     */
    void setVelocityViewPager(VelocityViewPager view);

    /**
     * Bind the indicator to a VelocityViewPager.
     *
     * @param view
     * @param initialPosition
     */
    void setVelocityViewPager(VelocityViewPager view, int initialPosition);

    /**
     * <p>Set the current page of both the VelocityViewPager and indicator.</p>
     *
     * <p>This <strong>must</strong> be used if you need to set the page before
     * the views are drawn on screen (e.g., default start page).</p>
     *
     * @param item
     */
    void setCurrentItem(int item);

    /**
     * Set a page change listener which will receive forwarded events.
     *
     * @param listener
     */
    void setOnPageChangeListener(VelocityViewPager.OnPageChangeListener listener);

    /**
     * Notify the indicator that the fragment list has changed.
     */
    void notifyDataSetChanged();
}

@#$
/*
 * Copyright (C) 2011 The Android Open Source Project
 * Copyright (C) 2011 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.velocityviewpagerindicator;

import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
import android.content.Context;
import android.support.v4.view.PagerAdapter;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;
import android.widget.HorizontalScrollView;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.velocity.view.pager.library.VelocityViewPager;
import com.velocity.view.pager.library.VelocityViewPager.OnPageChangeListener;

/**
 * This widget implements the dynamic action bar tab behavior that can change
 * across different configurations or circumstances.
 */
public class VelocityTabPageIndicator extends HorizontalScrollView implements VelocityPageIndicator {
    /** Title text used when no title is provided by the adapter. */
    private static final CharSequence EMPTY_TITLE = "";

    /**
     * Interface for a callback when the selected tab has been reselected.
     */
    public interface OnTabReselectedListener {
        /**
         * Callback when the selected tab has been reselected.
         *
         * @param position Position of the current center item.
         */
        void onTabReselected(int position);
    }

    private Runnable mTabSelector;

    private final OnClickListener mTabClickListener = new OnClickListener() {
        public void onClick(View view) {
            TabView tabView = (TabView)view;
            final int oldSelected = mVelocityViewPager.getCurrentItem();
            final int newSelected = tabView.getIndex();
            mVelocityViewPager.setCurrentItem(newSelected);
            if (oldSelected == newSelected && mTabReselectedListener != null) {
                mTabReselectedListener.onTabReselected(newSelected);
            }
        }
    };

    private final VelocityIcsLinearLayout mTabLayout;

    private VelocityViewPager mVelocityViewPager;
    private VelocityViewPager.OnPageChangeListener mListener;

    private int mMaxTabWidth;
    private int mSelectedTabIndex;

    private OnTabReselectedListener mTabReselectedListener;

    public VelocityTabPageIndicator(Context context) {
        this(context, null);
    }

    public VelocityTabPageIndicator(Context context, AttributeSet attrs) {
        super(context, attrs);
        setHorizontalScrollBarEnabled(false);

        mTabLayout = new VelocityIcsLinearLayout(context, R.attr.vpiTabPageIndicatorStyle);
        addView(mTabLayout, new ViewGroup.LayoutParams(WRAP_CONTENT, MATCH_PARENT));
    }

    public void setOnTabReselectedListener(OnTabReselectedListener listener) {
        mTabReselectedListener = listener;
    }

    @Override
    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        final boolean lockedExpanded = widthMode == MeasureSpec.EXACTLY;
        setFillViewport(lockedExpanded);

        final int childCount = mTabLayout.getChildCount();
        if (childCount > 1 && (widthMode == MeasureSpec.EXACTLY || widthMode == MeasureSpec.AT_MOST)) {
            if (childCount > 2) {
                mMaxTabWidth = (int)(MeasureSpec.getSize(widthMeasureSpec) * 0.4f);
            } else {
                mMaxTabWidth = MeasureSpec.getSize(widthMeasureSpec) / 2;
            }
        } else {
            mMaxTabWidth = -1;
        }

        final int oldWidth = getMeasuredWidth();
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        final int newWidth = getMeasuredWidth();

        if (lockedExpanded && oldWidth != newWidth) {
            // Recenter the tab display if we're at a new (scrollable) size.
            setCurrentItem(mSelectedTabIndex);
        }
    }

    private void animateToTab(final int position) {
        final View tabView = mTabLayout.getChildAt(position);
        if (mTabSelector != null) {
            removeCallbacks(mTabSelector);
        }
        mTabSelector = new Runnable() {
            public void run() {
                final int scrollPos = tabView.getLeft() - (getWidth() - tabView.getWidth()) / 2;
                smoothScrollTo(scrollPos, 0);
                mTabSelector = null;
            }
        };
        post(mTabSelector);
    }

    @Override
    public void onAttachedToWindow() {
        super.onAttachedToWindow();
        if (mTabSelector != null) {
            // Re-post the selector we saved
            post(mTabSelector);
        }
    }

    @Override
    public void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        if (mTabSelector != null) {
            removeCallbacks(mTabSelector);
        }
    }

    private void addTab(int index, CharSequence text, int iconResId) {
        final TabView tabView = new TabView(getContext());
        tabView.mIndex = index;
        tabView.setFocusable(true);
        tabView.setOnClickListener(mTabClickListener);
        tabView.setText(text);

        if (iconResId != 0) {
            tabView.setCompoundDrawablesWithIntrinsicBounds(iconResId, 0, 0, 0);
        }

        mTabLayout.addView(tabView, new LinearLayout.LayoutParams(0, MATCH_PARENT, 1));
    }

    @Override
    public void onPageScrollStateChanged(int arg0) {
        if (mListener != null) {
            mListener.onPageScrollStateChanged(arg0);
        }
    }

    @Override
    public void onPageScrolled(int arg0, float arg1, int arg2) {
        if (mListener != null) {
            mListener.onPageScrolled(arg0, arg1, arg2);
        }
    }

    @Override
    public void onPageSelected(int arg0) {
        setCurrentItem(arg0);
        if (mListener != null) {
            mListener.onPageSelected(arg0);
        }
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager view) {
        if (mVelocityViewPager == view) {
            return;
        }
        if (mVelocityViewPager != null) {
            mVelocityViewPager.setOnPageChangeListener(null);
        }
        final PagerAdapter adapter = view.getAdapter();
        if (adapter == null) {
            throw new IllegalStateException("VelocityViewPager does not have adapter instance.");
        }
        mVelocityViewPager = view;
        view.setOnPageChangeListener(this);
        notifyDataSetChanged();
    }

    public void notifyDataSetChanged() {
        mTabLayout.removeAllViews();
        PagerAdapter adapter = mVelocityViewPager.getAdapter();
        VelocityIconPagerAdapter iconAdapter = null;
        if (adapter instanceof VelocityIconPagerAdapter) {
            iconAdapter = (VelocityIconPagerAdapter)adapter;
        }
        final int count = adapter.getCount();
        for (int i = 0; i < count; i++) {
            CharSequence title = adapter.getPageTitle(i);
            if (title == null) {
                title = EMPTY_TITLE;
            }
            int iconResId = 0;
            if (iconAdapter != null) {
                iconResId = iconAdapter.getIconResId(i);
            }
            addTab(i, title, iconResId);
        }
        if (mSelectedTabIndex > count) {
            mSelectedTabIndex = count - 1;
        }
        setCurrentItem(mSelectedTabIndex);
        requestLayout();
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager view, int initialPosition) {
        setVelocityViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void setCurrentItem(int item) {
        if (mVelocityViewPager == null) {
            throw new IllegalStateException("VelocityViewPager has not been bound.");
        }
        mSelectedTabIndex = item;
        mVelocityViewPager.setCurrentItem(item);

        final int tabCount = mTabLayout.getChildCount();
        for (int i = 0; i < tabCount; i++) {
            final View child = mTabLayout.getChildAt(i);
            final boolean isSelected = (i == item);
            child.setSelected(isSelected);
            if (isSelected) {
                animateToTab(item);
            }
        }
    }

    @Override
    public void setOnPageChangeListener(OnPageChangeListener listener) {
        mListener = listener;
    }

    private class TabView extends TextView {
        private int mIndex;

        public TabView(Context context) {
            super(context, null, R.attr.vpiTabPageIndicatorStyle);
        }

        @Override
        public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
            super.onMeasure(widthMeasureSpec, heightMeasureSpec);

            // Re-measure if we went beyond our maximum size.
            if (mMaxTabWidth > 0 && getMeasuredWidth() > mMaxTabWidth) {
                super.onMeasure(MeasureSpec.makeMeasureSpec(mMaxTabWidth, MeasureSpec.EXACTLY),
                        heightMeasureSpec);
            }
        }

        public int getIndex() {
            return mIndex;
        }
    }
}

@#$
/*
 * Copyright (C) 2011 Jake Wharton
 * Copyright (C) 2011 Patrik Akerfeldt
 * Copyright (C) 2011 Francisco Figueiredo Jr.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.velocityviewpagerindicator;

import java.util.ArrayList;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.v4.view.MotionEventCompat;
import android.support.v4.view.ViewConfigurationCompat;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;

import com.velocity.view.pager.library.VelocityViewPager;

/**
 * A TitlePageIndicator is a PageIndicator which displays the title of left view
 * (if exist), the title of the current select view (centered) and the title of
 * the right view (if exist). When the user scrolls the VelocityViewPager then titles are
 * also scrolled.
 */
public class VelocityTitlePageIndicator extends View implements VelocityPageIndicator {
    /**
     * Percentage indicating what percentage of the screen width away from
     * center should the underline be fully faded. A value of 0.25 means that
     * halfway between the center of the screen and an edge.
     */
    private static final float SELECTION_FADE_PERCENTAGE = 0.25f;

    /**
     * Percentage indicating what percentage of the screen width away from
     * center should the selected text bold turn off. A value of 0.05 means
     * that 10% between the center and an edge.
     */
    private static final float BOLD_FADE_PERCENTAGE = 0.05f;

    /**
     * Title text used when no title is provided by the adapter.
     */
    private static final String EMPTY_TITLE = "";

    /**
     * Interface for a callback when the center item has been clicked.
     */
    public interface OnCenterItemClickListener {
        /**
         * Callback when the center item has been clicked.
         *
         * @param position Position of the current center item.
         */
        void onCenterItemClick(int position);
    }

    public enum IndicatorStyle {
        None(0), Triangle(1), Underline(2);

        public final int value;

        private IndicatorStyle(int value) {
            this.value = value;
        }

        public static IndicatorStyle fromValue(int value) {
            for (IndicatorStyle style : IndicatorStyle.values()) {
                if (style.value == value) {
                    return style;
                }
            }
            return null;
        }
    }

    public enum LinePosition {
        Bottom(0), Top(1);

        public final int value;

        private LinePosition(int value) {
            this.value = value;
        }

        public static LinePosition fromValue(int value) {
            for (LinePosition position : LinePosition.values()) {
                if (position.value == value) {
                    return position;
                }
            }
            return null;
        }
    }

    private VelocityViewPager mVelocityViewPager;
    private VelocityViewPager.OnPageChangeListener mListener;
    private int mCurrentPage = -1;
    private float mPageOffset;
    private int mScrollState;
    private final Paint mPaintText = new Paint();
    private boolean mBoldText;
    private int mColorText;
    private int mColorSelected;
    private Path mPath = new Path();
    private final Rect mBounds = new Rect();
    private final Paint mPaintFooterLine = new Paint();
    private IndicatorStyle mFooterIndicatorStyle;
    private LinePosition mLinePosition;
    private final Paint mPaintFooterIndicator = new Paint();
    private float mFooterIndicatorHeight;
    private float mFooterIndicatorUnderlinePadding;
    private float mFooterPadding;
    private float mTitlePadding;
    private float mTopPadding;
    /** Left and right side padding for not active view titles. */
    private float mClipPadding;
    private float mFooterLineHeight;

    private static final int INVALID_POINTER = -1;

    private int mTouchSlop;
    private float mLastMotionX = -1;
    private int mActivePointerId = INVALID_POINTER;
    private boolean mIsDragging;

    private OnCenterItemClickListener mCenterItemClickListener;


    public VelocityTitlePageIndicator(Context context) {
        this(context, null);
    }

    public VelocityTitlePageIndicator(Context context, AttributeSet attrs) {
        this(context, attrs, R.attr.vpiTitlePageIndicatorStyle);
    }

    public VelocityTitlePageIndicator(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        if (isInEditMode()) return;

        //Load defaults from resources
        final Resources res = getResources();
        final int defaultFooterColor = res.getColor(R.color.default_title_indicator_footer_color);
        final float defaultFooterLineHeight = res.getDimension(R.dimen.default_title_indicator_footer_line_height);
        final int defaultFooterIndicatorStyle = res.getInteger(R.integer.default_title_indicator_footer_indicator_style);
        final float defaultFooterIndicatorHeight = res.getDimension(R.dimen.default_title_indicator_footer_indicator_height);
        final float defaultFooterIndicatorUnderlinePadding = res.getDimension(R.dimen.default_title_indicator_footer_indicator_underline_padding);
        final float defaultFooterPadding = res.getDimension(R.dimen.default_title_indicator_footer_padding);
        final int defaultLinePosition = res.getInteger(R.integer.default_title_indicator_line_position);
        final int defaultSelectedColor = res.getColor(R.color.default_title_indicator_selected_color);
        final boolean defaultSelectedBold = res.getBoolean(R.bool.default_title_indicator_selected_bold);
        final int defaultTextColor = res.getColor(R.color.default_title_indicator_text_color);
        final float defaultTextSize = res.getDimension(R.dimen.default_title_indicator_text_size);
        final float defaultTitlePadding = res.getDimension(R.dimen.default_title_indicator_title_padding);
        final float defaultClipPadding = res.getDimension(R.dimen.default_title_indicator_clip_padding);
        final float defaultTopPadding = res.getDimension(R.dimen.default_title_indicator_top_padding);

        //Retrieve styles attributes
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.VelocityTitlePageIndicator, defStyle, 0);

        //Retrieve the colors to be used for this view and apply them.
        mFooterLineHeight = a.getDimension(R.styleable.VelocityTitlePageIndicator_footerLineHeight, defaultFooterLineHeight);
        mFooterIndicatorStyle = IndicatorStyle.fromValue(a.getInteger(R.styleable.VelocityTitlePageIndicator_footerIndicatorStyle, defaultFooterIndicatorStyle));
        mFooterIndicatorHeight = a.getDimension(R.styleable.VelocityTitlePageIndicator_footerIndicatorHeight, defaultFooterIndicatorHeight);
        mFooterIndicatorUnderlinePadding = a.getDimension(R.styleable.VelocityTitlePageIndicator_footerIndicatorUnderlinePadding, defaultFooterIndicatorUnderlinePadding);
        mFooterPadding = a.getDimension(R.styleable.VelocityTitlePageIndicator_footerPadding, defaultFooterPadding);
        mLinePosition = LinePosition.fromValue(a.getInteger(R.styleable.VelocityTitlePageIndicator_linePosition, defaultLinePosition));
        mTopPadding = a.getDimension(R.styleable.VelocityTitlePageIndicator_topPadding, defaultTopPadding);
        mTitlePadding = a.getDimension(R.styleable.VelocityTitlePageIndicator_titlePadding, defaultTitlePadding);
        mClipPadding = a.getDimension(R.styleable.VelocityTitlePageIndicator_clipPadding, defaultClipPadding);
        mColorSelected = a.getColor(R.styleable.VelocityTitlePageIndicator_selectedColor, defaultSelectedColor);
        mColorText = a.getColor(R.styleable.VelocityTitlePageIndicator_android_textColor, defaultTextColor);
        mBoldText = a.getBoolean(R.styleable.VelocityTitlePageIndicator_selectedBold, defaultSelectedBold);

        final float textSize = a.getDimension(R.styleable.VelocityTitlePageIndicator_android_textSize, defaultTextSize);
        final int footerColor = a.getColor(R.styleable.VelocityTitlePageIndicator_footerColor, defaultFooterColor);
        mPaintText.setTextSize(textSize);
        mPaintText.setAntiAlias(true);
        mPaintFooterLine.setStyle(Paint.Style.FILL_AND_STROKE);
        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);
        mPaintFooterLine.setColor(footerColor);
        mPaintFooterIndicator.setStyle(Paint.Style.FILL_AND_STROKE);
        mPaintFooterIndicator.setColor(footerColor);

        Drawable background = a.getDrawable(R.styleable.VelocityTitlePageIndicator_android_background);
        if (background != null) {
          setBackgroundDrawable(background);
        }

        a.recycle();

        final ViewConfiguration configuration = ViewConfiguration.get(context);
        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
    }


    public int getFooterColor() {
        return mPaintFooterLine.getColor();
    }

    public void setFooterColor(int footerColor) {
        mPaintFooterLine.setColor(footerColor);
        mPaintFooterIndicator.setColor(footerColor);
        invalidate();
    }

    public float getFooterLineHeight() {
        return mFooterLineHeight;
    }

    public void setFooterLineHeight(float footerLineHeight) {
        mFooterLineHeight = footerLineHeight;
        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);
        invalidate();
    }

    public float getFooterIndicatorHeight() {
        return mFooterIndicatorHeight;
    }

    public void setFooterIndicatorHeight(float footerTriangleHeight) {
        mFooterIndicatorHeight = footerTriangleHeight;
        invalidate();
    }

    public float getFooterIndicatorPadding() {
        return mFooterPadding;
    }

    public void setFooterIndicatorPadding(float footerIndicatorPadding) {
        mFooterPadding = footerIndicatorPadding;
        invalidate();
    }

    public IndicatorStyle getFooterIndicatorStyle() {
        return mFooterIndicatorStyle;
    }

    public void setFooterIndicatorStyle(IndicatorStyle indicatorStyle) {
        mFooterIndicatorStyle = indicatorStyle;
        invalidate();
    }

    public LinePosition getLinePosition() {
        return mLinePosition;
    }

    public void setLinePosition(LinePosition linePosition) {
        mLinePosition = linePosition;
        invalidate();
    }

    public int getSelectedColor() {
        return mColorSelected;
    }

    public void setSelectedColor(int selectedColor) {
        mColorSelected = selectedColor;
        invalidate();
    }

    public boolean isSelectedBold() {
        return mBoldText;
    }

    public void setSelectedBold(boolean selectedBold) {
        mBoldText = selectedBold;
        invalidate();
    }

    public int getTextColor() {
        return mColorText;
    }

    public void setTextColor(int textColor) {
        mPaintText.setColor(textColor);
        mColorText = textColor;
        invalidate();
    }

    public float getTextSize() {
        return mPaintText.getTextSize();
    }

    public void setTextSize(float textSize) {
        mPaintText.setTextSize(textSize);
        invalidate();
    }

    public float getTitlePadding() {
        return this.mTitlePadding;
    }

    public void setTitlePadding(float titlePadding) {
        mTitlePadding = titlePadding;
        invalidate();
    }

    public float getTopPadding() {
        return this.mTopPadding;
    }

    public void setTopPadding(float topPadding) {
        mTopPadding = topPadding;
        invalidate();
    }

    public float getClipPadding() {
        return this.mClipPadding;
    }

    public void setClipPadding(float clipPadding) {
        mClipPadding = clipPadding;
        invalidate();
    }

    public void setTypeface(Typeface typeface) {
        mPaintText.setTypeface(typeface);
        invalidate();
    }

    public Typeface getTypeface() {
        return mPaintText.getTypeface();
    }

    /*
     * (non-Javadoc)
     *
     * @see android.view.View#onDraw(android.graphics.Canvas)
     */
    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (mVelocityViewPager == null) {
            return;
        }
        final int count = mVelocityViewPager.getAdapter().getCount();
        if (count == 0) {
            return;
        }

        // mCurrentPage is -1 on first start and after orientation changed. If so, retrieve the correct index from VelocityViewPager.
        if (mCurrentPage == -1 && mVelocityViewPager != null) {
            mCurrentPage = mVelocityViewPager.getCurrentItem();
        }

        //Calculate views bounds
        ArrayList<Rect> bounds = calculateAllBounds(mPaintText);
        final int boundsSize = bounds.size();

        //Make sure we're on a page that still exists
        if (mCurrentPage >= boundsSize) {
            setCurrentItem(boundsSize - 1);
            return;
        }

        final int countMinusOne = count - 1;
        final float halfWidth = getWidth() / 2f;
        final int left = getLeft();
        final float leftClip = left + mClipPadding;
        final int width = getWidth();
        int height = getHeight();
        final int right = left + width;
        final float rightClip = right - mClipPadding;

        int page = mCurrentPage;
        float offsetPercent;
        if (mPageOffset <= 0.5) {
            offsetPercent = mPageOffset;
        } else {
            page += 1;
            offsetPercent = 1 - mPageOffset;
        }
        final boolean currentSelected = (offsetPercent <= SELECTION_FADE_PERCENTAGE);
        final boolean currentBold = (offsetPercent <= BOLD_FADE_PERCENTAGE);
        final float selectedPercent = (SELECTION_FADE_PERCENTAGE - offsetPercent) / SELECTION_FADE_PERCENTAGE;

        //Verify if the current view must be clipped to the screen
        Rect curPageBound = bounds.get(mCurrentPage);
        float curPageWidth = curPageBound.right - curPageBound.left;
        if (curPageBound.left < leftClip) {
            //Try to clip to the screen (left side)
            clipViewOnTheLeft(curPageBound, curPageWidth, left);
        }
        if (curPageBound.right > rightClip) {
            //Try to clip to the screen (right side)
            clipViewOnTheRight(curPageBound, curPageWidth, right);
        }

        //Left views starting from the current position
        if (mCurrentPage > 0) {
            for (int i = mCurrentPage - 1; i >= 0; i--) {
                Rect bound = bounds.get(i);
                //Is left side is outside the screen
                if (bound.left < leftClip) {
                    int w = bound.right - bound.left;
                    //Try to clip to the screen (left side)
                    clipViewOnTheLeft(bound, w, left);
                    //Except if there's an intersection with the right view
                    Rect rightBound = bounds.get(i + 1);
                    //Intersection
                    if (bound.right + mTitlePadding > rightBound.left) {
                        bound.left = (int) (rightBound.left - w - mTitlePadding);
                        bound.right = bound.left + w;
                    }
                }
            }
        }
        //Right views starting from the current position
        if (mCurrentPage < countMinusOne) {
            for (int i = mCurrentPage + 1 ; i < count; i++) {
                Rect bound = bounds.get(i);
                //If right side is outside the screen
                if (bound.right > rightClip) {
                    int w = bound.right - bound.left;
                    //Try to clip to the screen (right side)
                    clipViewOnTheRight(bound, w, right);
                    //Except if there's an intersection with the left view
                    Rect leftBound = bounds.get(i - 1);
                    //Intersection
                    if (bound.left - mTitlePadding < leftBound.right) {
                        bound.left = (int) (leftBound.right + mTitlePadding);
                        bound.right = bound.left + w;
                    }
                }
            }
        }

        //Now draw views
        int colorTextAlpha = mColorText >>> 24;
        for (int i = 0; i < count; i++) {
            //Get the title
            Rect bound = bounds.get(i);
            //Only if one side is visible
            if ((bound.left > left && bound.left < right) || (bound.right > left && bound.right < right)) {
                final boolean currentPage = (i == page);
                final CharSequence pageTitle = getTitle(i);

                //Only set bold if we are within bounds
                mPaintText.setFakeBoldText(currentPage && currentBold && mBoldText);

                //Draw text as unselected
                mPaintText.setColor(mColorText);
                if(currentPage && currentSelected) {
                    //Fade out/in unselected text as the selected text fades in/out
                    mPaintText.setAlpha(colorTextAlpha - (int)(colorTextAlpha * selectedPercent));
                }

                //Except if there's an intersection with the right view
                if (i < boundsSize - 1)  {
                    Rect rightBound = bounds.get(i + 1);
                    //Intersection
                    if (bound.right + mTitlePadding > rightBound.left) {
                        int w = bound.right - bound.left;
                        bound.left = (int) (rightBound.left - w - mTitlePadding);
                        bound.right = bound.left + w;
                    }
                }
                canvas.drawText(pageTitle, 0, pageTitle.length(), bound.left, bound.bottom + mTopPadding, mPaintText);

                //If we are within the selected bounds draw the selected text
                if (currentPage && currentSelected) {
                    mPaintText.setColor(mColorSelected);
                    mPaintText.setAlpha((int)((mColorSelected >>> 24) * selectedPercent));
                    canvas.drawText(pageTitle, 0, pageTitle.length(), bound.left, bound.bottom + mTopPadding, mPaintText);
                }
            }
        }

        //If we want the line on the top change height to zero and invert the line height to trick the drawing code
        float footerLineHeight = mFooterLineHeight;
        float footerIndicatorLineHeight = mFooterIndicatorHeight;
        if (mLinePosition == LinePosition.Top) {
            height = 0;
            footerLineHeight = -footerLineHeight;
            footerIndicatorLineHeight = -footerIndicatorLineHeight;
        }

        //Draw the footer line
        mPath.reset();
        mPath.moveTo(0, height - footerLineHeight / 2f);
        mPath.lineTo(width, height - footerLineHeight / 2f);
        mPath.close();
        canvas.drawPath(mPath, mPaintFooterLine);

        float heightMinusLine = height - footerLineHeight;
        switch (mFooterIndicatorStyle) {
            case Triangle:
                mPath.reset();
                mPath.moveTo(halfWidth, heightMinusLine - footerIndicatorLineHeight);
                mPath.lineTo(halfWidth + footerIndicatorLineHeight, heightMinusLine);
                mPath.lineTo(halfWidth - footerIndicatorLineHeight, heightMinusLine);
                mPath.close();
                canvas.drawPath(mPath, mPaintFooterIndicator);
                break;

            case Underline:
                if (!currentSelected || page >= boundsSize) {
                    break;
                }

                Rect underlineBounds = bounds.get(page);
                final float rightPlusPadding = underlineBounds.right + mFooterIndicatorUnderlinePadding;
                final float leftMinusPadding = underlineBounds.left - mFooterIndicatorUnderlinePadding;
                final float heightMinusLineMinusIndicator = heightMinusLine - footerIndicatorLineHeight;

                mPath.reset();
                mPath.moveTo(leftMinusPadding, heightMinusLine);
                mPath.lineTo(rightPlusPadding, heightMinusLine);
                mPath.lineTo(rightPlusPadding, heightMinusLineMinusIndicator);
                mPath.lineTo(leftMinusPadding, heightMinusLineMinusIndicator);
                mPath.close();

                mPaintFooterIndicator.setAlpha((int)(0xFF * selectedPercent));
                canvas.drawPath(mPath, mPaintFooterIndicator);
                mPaintFooterIndicator.setAlpha(0xFF);
                break;
        }
    }

    public boolean onTouchEvent(android.view.MotionEvent ev) {
        if (super.onTouchEvent(ev)) {
            return true;
        }
        if ((mVelocityViewPager == null) || (mVelocityViewPager.getAdapter().getCount() == 0)) {
            return false;
        }

        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
                mLastMotionX = ev.getX();
                break;

            case MotionEvent.ACTION_MOVE: {
                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                final float x = MotionEventCompat.getX(ev, activePointerIndex);
                final float deltaX = x - mLastMotionX;

                if (!mIsDragging) {
                    if (Math.abs(deltaX) > mTouchSlop) {
                        mIsDragging = true;
                    }
                }

                if (mIsDragging) {
                    mLastMotionX = x;
                    if (mVelocityViewPager.isFakeDragging() || mVelocityViewPager.beginFakeDrag()) {
                        mVelocityViewPager.fakeDragBy(deltaX);
                    }
                }

                break;
            }

            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                if (!mIsDragging) {
                    final int count = mVelocityViewPager.getAdapter().getCount();
                    final int width = getWidth();
                    final float halfWidth = width / 2f;
                    final float sixthWidth = width / 6f;
                    final float leftThird = halfWidth - sixthWidth;
                    final float rightThird = halfWidth + sixthWidth;
                    final float eventX = ev.getX();

                    if (eventX < leftThird) {
                        if (mCurrentPage > 0) {
                            if (action != MotionEvent.ACTION_CANCEL) {
                                mVelocityViewPager.setCurrentItem(mCurrentPage - 1);
                            }
                            return true;
                        }
                    } else if (eventX > rightThird) {
                        if (mCurrentPage < count - 1) {
                            if (action != MotionEvent.ACTION_CANCEL) {
                                mVelocityViewPager.setCurrentItem(mCurrentPage + 1);
                            }
                            return true;
                        }
                    } else {
                        //Middle third
                        if (mCenterItemClickListener != null && action != MotionEvent.ACTION_CANCEL) {
                            mCenterItemClickListener.onCenterItemClick(mCurrentPage);
                        }
                    }
                }

                mIsDragging = false;
                mActivePointerId = INVALID_POINTER;
                if (mVelocityViewPager.isFakeDragging()) mVelocityViewPager.endFakeDrag();
                break;

            case MotionEventCompat.ACTION_POINTER_DOWN: {
                final int index = MotionEventCompat.getActionIndex(ev);
                mLastMotionX = MotionEventCompat.getX(ev, index);
                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
                break;
            }

            case MotionEventCompat.ACTION_POINTER_UP:
                final int pointerIndex = MotionEventCompat.getActionIndex(ev);
                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
                if (pointerId == mActivePointerId) {
                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
                }
                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));
                break;
        }

        return true;
    }

    /**
     * Set bounds for the right textView including clip padding.
     *
     * @param curViewBound
     *            current bounds.
     * @param curViewWidth
     *            width of the view.
     */
    private void clipViewOnTheRight(Rect curViewBound, float curViewWidth, int right) {
        curViewBound.right = (int) (right - mClipPadding);
        curViewBound.left = (int) (curViewBound.right - curViewWidth);
    }

    /**
     * Set bounds for the left textView including clip padding.
     *
     * @param curViewBound
     *            current bounds.
     * @param curViewWidth
     *            width of the view.
     */
    private void clipViewOnTheLeft(Rect curViewBound, float curViewWidth, int left) {
        curViewBound.left = (int) (left + mClipPadding);
        curViewBound.right = (int) (mClipPadding + curViewWidth);
    }

    /**
     * Calculate views bounds and scroll them according to the current index
     *
     * @param paint
     * @return
     */
    private ArrayList<Rect> calculateAllBounds(Paint paint) {
        ArrayList<Rect> list = new ArrayList<Rect>();
        //For each views (If no values then add a fake one)
        final int count = mVelocityViewPager.getAdapter().getCount();
        final int width = getWidth();
        final int halfWidth = width / 2;
        for (int i = 0; i < count; i++) {
            Rect bounds = calcBounds(i, paint);
            int w = bounds.right - bounds.left;
            int h = bounds.bottom - bounds.top;
            bounds.left = (int)(halfWidth - (w / 2f) + ((i - mCurrentPage - mPageOffset) * width));
            bounds.right = bounds.left + w;
            bounds.top = 0;
            bounds.bottom = h;
            list.add(bounds);
        }

        return list;
    }

    /**
     * Calculate the bounds for a view's title
     *
     * @param index
     * @param paint
     * @return
     */
    private Rect calcBounds(int index, Paint paint) {
        //Calculate the text bounds
        Rect bounds = new Rect();
        CharSequence title = getTitle(index);
        bounds.right = (int) paint.measureText(title, 0, title.length());
        bounds.bottom = (int) (paint.descent() - paint.ascent());
        return bounds;
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager view) {
        if (mVelocityViewPager == view) {
            return;
        }
        if (mVelocityViewPager != null) {
            mVelocityViewPager.setOnPageChangeListener(null);
        }
        if (view.getAdapter() == null) {
            throw new IllegalStateException("VelocityViewPager does not have adapter instance.");
        }
        mVelocityViewPager = view;
        mVelocityViewPager.setOnPageChangeListener(this);
        invalidate();
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager view, int initialPosition) {
        setVelocityViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void notifyDataSetChanged() {
        invalidate();
    }

    /**
     * Set a callback listener for the center item click.
     *
     * @param listener Callback instance.
     */
    public void setOnCenterItemClickListener(OnCenterItemClickListener listener) {
        mCenterItemClickListener = listener;
    }

    @Override
    public void setCurrentItem(int item) {
        if (mVelocityViewPager == null) {
            throw new IllegalStateException("VelocityViewPager has not been bound.");
        }
        mVelocityViewPager.setCurrentItem(item);
        mCurrentPage = item;
        invalidate();
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        mScrollState = state;

        if (mListener != null) {
            mListener.onPageScrollStateChanged(state);
        }
    }

    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        mCurrentPage = position;
        mPageOffset = positionOffset;
        invalidate();

        if (mListener != null) {
            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);
        }
    }

    @Override
    public void onPageSelected(int position) {
        if (mScrollState == VelocityViewPager.SCROLL_STATE_IDLE) {
            mCurrentPage = position;
            invalidate();
        }

        if (mListener != null) {
            mListener.onPageSelected(position);
        }
    }

    @Override
    public void setOnPageChangeListener(VelocityViewPager.OnPageChangeListener listener) {
        mListener = listener;
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        //Measure our width in whatever mode specified
        final int measuredWidth = MeasureSpec.getSize(widthMeasureSpec);

        //Determine our height
        float height;
        final int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
        if (heightSpecMode == MeasureSpec.EXACTLY) {
            //We were told how big to be
            height = MeasureSpec.getSize(heightMeasureSpec);
        } else {
            //Calculate the text bounds
            mBounds.setEmpty();
            mBounds.bottom = (int) (mPaintText.descent() - mPaintText.ascent());
            height = mBounds.bottom - mBounds.top + mFooterLineHeight + mFooterPadding + mTopPadding;
            if (mFooterIndicatorStyle != IndicatorStyle.None) {
                height += mFooterIndicatorHeight;
            }
        }
        final int measuredHeight = (int)height;

        setMeasuredDimension(measuredWidth, measuredHeight);
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
        SavedState savedState = (SavedState)state;
        super.onRestoreInstanceState(savedState.getSuperState());
        mCurrentPage = savedState.currentPage;
        requestLayout();
    }

    @Override
    public Parcelable onSaveInstanceState() {
        Parcelable superState = super.onSaveInstanceState();
        SavedState savedState = new SavedState(superState);
        savedState.currentPage = mCurrentPage;
        return savedState;
    }

    static class SavedState extends BaseSavedState {
        int currentPage;

        public SavedState(Parcelable superState) {
            super(superState);
        }

        private SavedState(Parcel in) {
            super(in);
            currentPage = in.readInt();
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            super.writeToParcel(dest, flags);
            dest.writeInt(currentPage);
        }

        @SuppressWarnings("UnusedDeclaration")
        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
            @Override
            public SavedState createFromParcel(Parcel in) {
                return new SavedState(in);
            }

            @Override
            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        };
    }

    private CharSequence getTitle(int i) {
        CharSequence title = mVelocityViewPager.getAdapter().getPageTitle(i);
        if (title == null) {
            title = EMPTY_TITLE;
        }
        return title;
    }
}

@#$
/*
 * Copyright (C) 2012 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.velocityviewpagerindicator;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.drawable.Drawable;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.v4.view.MotionEventCompat;
import android.support.v4.view.ViewConfigurationCompat;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;

import com.velocity.view.pager.library.VelocityViewPager;

/**
 * Draws a line for each page. The current page line is colored differently
 * than the unselected page lines.
 */
public class VelocityUnderlinePageIndicator extends View implements VelocityPageIndicator {
    private static final int INVALID_POINTER = -1;
    private static final int FADE_FRAME_MS = 30;

    private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);

    private boolean mFades;
    private int mFadeDelay;
    private int mFadeLength;
    private int mFadeBy;

    private VelocityViewPager mVelocityViewPager;
    private VelocityViewPager.OnPageChangeListener mListener;
    private int mScrollState;
    private int mCurrentPage;
    private float mPositionOffset;

    private int mTouchSlop;
    private float mLastMotionX = -1;
    private int mActivePointerId = INVALID_POINTER;
    private boolean mIsDragging;

    private final Runnable mFadeRunnable = new Runnable() {
      @Override public void run() {
        if (!mFades) return;

        final int alpha = Math.max(mPaint.getAlpha() - mFadeBy, 0);
        mPaint.setAlpha(alpha);
        invalidate();
        if (alpha > 0) {
          postDelayed(this, FADE_FRAME_MS);
        }
      }
    };

    public VelocityUnderlinePageIndicator(Context context) {
        this(context, null);
    }

    public VelocityUnderlinePageIndicator(Context context, AttributeSet attrs) {
        this(context, attrs, R.attr.vpiUnderlinePageIndicatorStyle);
    }

    public VelocityUnderlinePageIndicator(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        if (isInEditMode()) return;

        final Resources res = getResources();

        //Load defaults from resources
        final boolean defaultFades = res.getBoolean(R.bool.default_underline_indicator_fades);
        final int defaultFadeDelay = res.getInteger(R.integer.default_underline_indicator_fade_delay);
        final int defaultFadeLength = res.getInteger(R.integer.default_underline_indicator_fade_length);
        final int defaultSelectedColor = res.getColor(R.color.default_underline_indicator_selected_color);

        //Retrieve styles attributes
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.VelocityUnderlinePageIndicator, defStyle, 0);

        setFades(a.getBoolean(R.styleable.VelocityUnderlinePageIndicator_fades, defaultFades));
        setSelectedColor(a.getColor(R.styleable.VelocityUnderlinePageIndicator_selectedColor, defaultSelectedColor));
        setFadeDelay(a.getInteger(R.styleable.VelocityUnderlinePageIndicator_fadeDelay, defaultFadeDelay));
        setFadeLength(a.getInteger(R.styleable.VelocityUnderlinePageIndicator_fadeLength, defaultFadeLength));

        Drawable background = a.getDrawable(R.styleable.VelocityUnderlinePageIndicator_android_background);
        if (background != null) {
          setBackgroundDrawable(background);
        }

        a.recycle();

        final ViewConfiguration configuration = ViewConfiguration.get(context);
        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
    }

    public boolean getFades() {
        return mFades;
    }

    public void setFades(boolean fades) {
        if (fades != mFades) {
            mFades = fades;
            if (fades) {
                post(mFadeRunnable);
            } else {
                removeCallbacks(mFadeRunnable);
                mPaint.setAlpha(0xFF);
                invalidate();
            }
        }
    }

    public int getFadeDelay() {
        return mFadeDelay;
    }

    public void setFadeDelay(int fadeDelay) {
        mFadeDelay = fadeDelay;
    }

    public int getFadeLength() {
        return mFadeLength;
    }

    public void setFadeLength(int fadeLength) {
        mFadeLength = fadeLength;
        mFadeBy = 0xFF / (mFadeLength / FADE_FRAME_MS);
    }

    public int getSelectedColor() {
        return mPaint.getColor();
    }

    public void setSelectedColor(int selectedColor) {
        mPaint.setColor(selectedColor);
        invalidate();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (mVelocityViewPager == null) {
            return;
        }
        final int count = mVelocityViewPager.getAdapter().getCount();
        if (count == 0) {
            return;
        }

        if (mCurrentPage >= count) {
            setCurrentItem(count - 1);
            return;
        }

        final int paddingLeft = getPaddingLeft();
        final float pageWidth = (getWidth() - paddingLeft - getPaddingRight()) / (1f * count);
        final float left = paddingLeft + pageWidth * (mCurrentPage + mPositionOffset);
        final float right = left + pageWidth;
        final float top = getPaddingTop();
        final float bottom = getHeight() - getPaddingBottom();
        
        Log.e("DEBUG", ">>>LEFT:" + left + " >>>RIGHT: " + right + " >>>>TOP: " + top + " >>>>BOTTOM: " + bottom);
        
        canvas.drawRect(left, top, right, bottom, mPaint);
    }

    public boolean onTouchEvent(MotionEvent ev) {
        if (super.onTouchEvent(ev)) {
            return true;
        }
        if ((mVelocityViewPager == null) || (mVelocityViewPager.getAdapter().getCount() == 0)) {
            return false;
        }

        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
                mLastMotionX = ev.getX();
                break;

            case MotionEvent.ACTION_MOVE: {
                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                final float x = MotionEventCompat.getX(ev, activePointerIndex);
                final float deltaX = x - mLastMotionX;

                if (!mIsDragging) {
                    if (Math.abs(deltaX) > mTouchSlop) {
                        mIsDragging = true;
                    }
                }

                if (mIsDragging) {
                    mLastMotionX = x;
                    if (mVelocityViewPager.isFakeDragging() || mVelocityViewPager.beginFakeDrag()) {
                        mVelocityViewPager.fakeDragBy(deltaX);
                    }
                }

                break;
            }

            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                if (!mIsDragging) {
                    final int count = mVelocityViewPager.getAdapter().getCount();
                    final int width = getWidth();
                    final float halfWidth = width / 2f;
                    final float sixthWidth = width / 6f;

                    if ((mCurrentPage > 0) && (ev.getX() < halfWidth - sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mVelocityViewPager.setCurrentItem(mCurrentPage - 1);
                        }
                        return true;
                    } else if ((mCurrentPage < count - 1) && (ev.getX() > halfWidth + sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mVelocityViewPager.setCurrentItem(mCurrentPage + 1);
                        }
                        return true;
                    }
                }

                mIsDragging = false;
                mActivePointerId = INVALID_POINTER;
                if (mVelocityViewPager.isFakeDragging()) mVelocityViewPager.endFakeDrag();
                break;

            case MotionEventCompat.ACTION_POINTER_DOWN: {
                final int index = MotionEventCompat.getActionIndex(ev);
                mLastMotionX = MotionEventCompat.getX(ev, index);
                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
                break;
            }

            case MotionEventCompat.ACTION_POINTER_UP:
                final int pointerIndex = MotionEventCompat.getActionIndex(ev);
                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
                if (pointerId == mActivePointerId) {
                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
                }
                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));
                break;
        }

        return true;
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager VelocityViewPager) {
        if (mVelocityViewPager == VelocityViewPager) {
            return;
        }
        if (mVelocityViewPager != null) {
            //Clear us from the old pager.
            mVelocityViewPager.setOnPageChangeListener(null);
        }
        if (VelocityViewPager.getAdapter() == null) {
            throw new IllegalStateException("VelocityViewPager does not have adapter instance.");
        }
        mVelocityViewPager = VelocityViewPager;
        mVelocityViewPager.setOnPageChangeListener(this);
        invalidate();
        post(new Runnable() {
            @Override public void run() {
                if (mFades) {
                    post(mFadeRunnable);
                }
            }
        });
    }

    @Override
    public void setVelocityViewPager(VelocityViewPager view, int initialPosition) {
        setVelocityViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void setCurrentItem(int item) {
        if (mVelocityViewPager == null) {
            throw new IllegalStateException("VelocityViewPager has not been bound.");
        }
        mVelocityViewPager.setCurrentItem(item);
        mCurrentPage = item;
        invalidate();
    }

    @Override
    public void notifyDataSetChanged() {
        invalidate();
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        mScrollState = state;

        if (mListener != null) {
            mListener.onPageScrollStateChanged(state);
        }
    }

    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        mCurrentPage = position;
        mPositionOffset = positionOffset;
        if (mFades) {
            if (positionOffsetPixels > 0) {
                removeCallbacks(mFadeRunnable);
                mPaint.setAlpha(0xFF);
            } else if (mScrollState != VelocityViewPager.SCROLL_STATE_DRAGGING) {
                postDelayed(mFadeRunnable, mFadeDelay);
            }
        }
        invalidate();

        if (mListener != null) {
            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);
        }
    }

    @Override
    public void onPageSelected(int position) {
        if (mScrollState == VelocityViewPager.SCROLL_STATE_IDLE) {
            mCurrentPage = position;
            mPositionOffset = 0;
            invalidate();
            mFadeRunnable.run();
        }
        if (mListener != null) {
            mListener.onPageSelected(position);
        }
    }

    @Override
    public void setOnPageChangeListener(VelocityViewPager.OnPageChangeListener listener) {
        mListener = listener;
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
        SavedState savedState = (SavedState)state;
        super.onRestoreInstanceState(savedState.getSuperState());
        mCurrentPage = savedState.currentPage;
        requestLayout();
    }

    @Override
    public Parcelable onSaveInstanceState() {
        Parcelable superState = super.onSaveInstanceState();
        SavedState savedState = new SavedState(superState);
        savedState.currentPage = mCurrentPage;
        return savedState;
    }

    static class SavedState extends BaseSavedState {
        int currentPage;

        public SavedState(Parcelable superState) {
            super(superState);
        }

        private SavedState(Parcel in) {
            super(in);
            currentPage = in.readInt();
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            super.writeToParcel(dest, flags);
            dest.writeInt(currentPage);
        }

        @SuppressWarnings("UnusedDeclaration")
        public static final Creator<SavedState> CREATOR = new Creator<SavedState>() {
            @Override
            public SavedState createFromParcel(Parcel in) {
                return new SavedState(in);
            }

            @Override
            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        };
    }
}
@#$
/*
 * Copyright (C) 2011 Patrik Akerfeldt
 * Copyright (C) 2011 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.viewpagerindicator;

import static android.graphics.Paint.ANTI_ALIAS_FLAG;
import static android.widget.LinearLayout.HORIZONTAL;
import static android.widget.LinearLayout.VERTICAL;
import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.drawable.Drawable;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.v4.view.MotionEventCompat;
import android.support.v4.view.ViewConfigurationCompat;
import android.support.v4.view.ViewPager;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;

import com.velocityviewpagerindicator.R;

/**
 * Draws circles (one for each view). The current view position is filled and
 * others are only stroked.
 */
public class CirclePageIndicator extends View implements PageIndicator {
    private static final int INVALID_POINTER = -1;

    private float mRadius;
    private final Paint mPaintPageFill = new Paint(ANTI_ALIAS_FLAG);
    private final Paint mPaintStroke = new Paint(ANTI_ALIAS_FLAG);
    private final Paint mPaintFill = new Paint(ANTI_ALIAS_FLAG);
    private ViewPager mViewPager;
    private ViewPager.OnPageChangeListener mListener;
    private int mCurrentPage;
    private int mSnapPage;
    private float mPageOffset;
    private int mScrollState;
    private int mOrientation;
    private boolean mCentered;
    private boolean mSnap;

    private int mTouchSlop;
    private float mLastMotionX = -1;
    private int mActivePointerId = INVALID_POINTER;
    private boolean mIsDragging;


    public CirclePageIndicator(Context context) {
        this(context, null);
    }

    public CirclePageIndicator(Context context, AttributeSet attrs) {
        this(context, attrs, R.attr.vpiCirclePageIndicatorStyle);
    }

    public CirclePageIndicator(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        if (isInEditMode()) return;

        //Load defaults from resources
        final Resources res = getResources();
        final int defaultPageColor = res.getColor(R.color.default_circle_indicator_page_color);
        final int defaultFillColor = res.getColor(R.color.default_circle_indicator_fill_color);
        final int defaultOrientation = res.getInteger(R.integer.default_circle_indicator_orientation);
        final int defaultStrokeColor = res.getColor(R.color.default_circle_indicator_stroke_color);
        final float defaultStrokeWidth = res.getDimension(R.dimen.default_circle_indicator_stroke_width);
        final float defaultRadius = res.getDimension(R.dimen.default_circle_indicator_radius);
        final boolean defaultCentered = res.getBoolean(R.bool.default_circle_indicator_centered);
        final boolean defaultSnap = res.getBoolean(R.bool.default_circle_indicator_snap);

        //Retrieve styles attributes
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.VelocityCirclePageIndicator, defStyle, 0);

        mCentered = a.getBoolean(R.styleable.VelocityCirclePageIndicator_centered, defaultCentered);
        mOrientation = a.getInt(R.styleable.VelocityCirclePageIndicator_android_orientation, defaultOrientation);
        mPaintPageFill.setStyle(Style.FILL);
        mPaintPageFill.setColor(a.getColor(R.styleable.VelocityCirclePageIndicator_pageColor, defaultPageColor));
        mPaintStroke.setStyle(Style.STROKE);
        mPaintStroke.setColor(a.getColor(R.styleable.VelocityCirclePageIndicator_strokeColor, defaultStrokeColor));
        mPaintStroke.setStrokeWidth(a.getDimension(R.styleable.VelocityCirclePageIndicator_strokeWidth, defaultStrokeWidth));
        mPaintFill.setStyle(Style.FILL);
        mPaintFill.setColor(a.getColor(R.styleable.VelocityCirclePageIndicator_fillColor, defaultFillColor));
        mRadius = a.getDimension(R.styleable.VelocityCirclePageIndicator_radius, defaultRadius);
        mSnap = a.getBoolean(R.styleable.VelocityCirclePageIndicator_snap, defaultSnap);

        Drawable background = a.getDrawable(R.styleable.VelocityCirclePageIndicator_android_background);
        if (background != null) {
          setBackgroundDrawable(background);
        }

        a.recycle();

        final ViewConfiguration configuration = ViewConfiguration.get(context);
        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
    }


    public void setCentered(boolean centered) {
        mCentered = centered;
        invalidate();
    }

    public boolean isCentered() {
        return mCentered;
    }

    public void setPageColor(int pageColor) {
        mPaintPageFill.setColor(pageColor);
        invalidate();
    }

    public int getPageColor() {
        return mPaintPageFill.getColor();
    }

    public void setFillColor(int fillColor) {
        mPaintFill.setColor(fillColor);
        invalidate();
    }

    public int getFillColor() {
        return mPaintFill.getColor();
    }

    public void setOrientation(int orientation) {
        switch (orientation) {
            case HORIZONTAL:
            case VERTICAL:
                mOrientation = orientation;
                requestLayout();
                break;

            default:
                throw new IllegalArgumentException("Orientation must be either HORIZONTAL or VERTICAL.");
        }
    }

    public int getOrientation() {
        return mOrientation;
    }

    public void setStrokeColor(int strokeColor) {
        mPaintStroke.setColor(strokeColor);
        invalidate();
    }

    public int getStrokeColor() {
        return mPaintStroke.getColor();
    }

    public void setStrokeWidth(float strokeWidth) {
        mPaintStroke.setStrokeWidth(strokeWidth);
        invalidate();
    }

    public float getStrokeWidth() {
        return mPaintStroke.getStrokeWidth();
    }

    public void setRadius(float radius) {
        mRadius = radius;
        invalidate();
    }

    public float getRadius() {
        return mRadius;
    }

    public void setSnap(boolean snap) {
        mSnap = snap;
        invalidate();
    }

    public boolean isSnap() {
        return mSnap;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (mViewPager == null) {
            return;
        }
        final int count = mViewPager.getAdapter().getCount();
        if (count == 0) {
            return;
        }

        if (mCurrentPage >= count) {
            setCurrentItem(count - 1);
            return;
        }

        int longSize;
        int longPaddingBefore;
        int longPaddingAfter;
        int shortPaddingBefore;
        if (mOrientation == HORIZONTAL) {
            longSize = getWidth();
            longPaddingBefore = getPaddingLeft();
            longPaddingAfter = getPaddingRight();
            shortPaddingBefore = getPaddingTop();
        } else {
            longSize = getHeight();
            longPaddingBefore = getPaddingTop();
            longPaddingAfter = getPaddingBottom();
            shortPaddingBefore = getPaddingLeft();
        }

        final float threeRadius = mRadius * 3;
        final float shortOffset = shortPaddingBefore + mRadius;
        float longOffset = longPaddingBefore + mRadius;
        if (mCentered) {
            longOffset += ((longSize - longPaddingBefore - longPaddingAfter) / 2.0f) - ((count * threeRadius) / 2.0f);
        }

        float dX;
        float dY;

        float pageFillRadius = mRadius;
        if (mPaintStroke.getStrokeWidth() > 0) {
            pageFillRadius -= mPaintStroke.getStrokeWidth() / 2.0f;
        }

        //Draw stroked circles
        for (int iLoop = 0; iLoop < count; iLoop++) {
            float drawLong = longOffset + (iLoop * threeRadius);
            if (mOrientation == HORIZONTAL) {
                dX = drawLong;
                dY = shortOffset;
            } else {
                dX = shortOffset;
                dY = drawLong;
            }
            // Only paint fill if not completely transparent
            if (mPaintPageFill.getAlpha() > 0) {
                canvas.drawCircle(dX, dY, pageFillRadius, mPaintPageFill);
            }

            // Only paint stroke if a stroke width was non-zero
            if (pageFillRadius != mRadius) {
                canvas.drawCircle(dX, dY, mRadius, mPaintStroke);
            }
        }

        //Draw the filled circle according to the current scroll
        float cx = (mSnap ? mSnapPage : mCurrentPage) * threeRadius;
        if (!mSnap) {
            cx += mPageOffset * threeRadius;
        }
        if (mOrientation == HORIZONTAL) {
            dX = longOffset + cx;
            dY = shortOffset;
        } else {
            dX = shortOffset;
            dY = longOffset + cx;
        }
        canvas.drawCircle(dX, dY, mRadius, mPaintFill);
    }

    public boolean onTouchEvent(android.view.MotionEvent ev) {
        if (super.onTouchEvent(ev)) {
            return true;
        }
        if ((mViewPager == null) || (mViewPager.getAdapter().getCount() == 0)) {
            return false;
        }

        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
                mLastMotionX = ev.getX();
                break;

            case MotionEvent.ACTION_MOVE: {
                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                final float x = MotionEventCompat.getX(ev, activePointerIndex);
                final float deltaX = x - mLastMotionX;

                if (!mIsDragging) {
                    if (Math.abs(deltaX) > mTouchSlop) {
                        mIsDragging = true;
                    }
                }

                if (mIsDragging) {
                    mLastMotionX = x;
                    if (mViewPager.isFakeDragging() || mViewPager.beginFakeDrag()) {
                        mViewPager.fakeDragBy(deltaX);
                    }
                }

                break;
            }

            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                if (!mIsDragging) {
                    final int count = mViewPager.getAdapter().getCount();
                    final int width = getWidth();
                    final float halfWidth = width / 2f;
                    final float sixthWidth = width / 6f;

                    if ((mCurrentPage > 0) && (ev.getX() < halfWidth - sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mViewPager.setCurrentItem(mCurrentPage - 1);
                        }
                        return true;
                    } else if ((mCurrentPage < count - 1) && (ev.getX() > halfWidth + sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mViewPager.setCurrentItem(mCurrentPage + 1);
                        }
                        return true;
                    }
                }

                mIsDragging = false;
                mActivePointerId = INVALID_POINTER;
                if (mViewPager.isFakeDragging()) mViewPager.endFakeDrag();
                break;

            case MotionEventCompat.ACTION_POINTER_DOWN: {
                final int index = MotionEventCompat.getActionIndex(ev);
                mLastMotionX = MotionEventCompat.getX(ev, index);
                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
                break;
            }

            case MotionEventCompat.ACTION_POINTER_UP:
                final int pointerIndex = MotionEventCompat.getActionIndex(ev);
                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
                if (pointerId == mActivePointerId) {
                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
                }
                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));
                break;
        }

        return true;
    }

    @Override
    public void setViewPager(ViewPager view) {
        if (mViewPager == view) {
            return;
        }
        if (mViewPager != null) {
            mViewPager.setOnPageChangeListener(null);
        }
        if (view.getAdapter() == null) {
            throw new IllegalStateException("ViewPager does not have adapter instance.");
        }
        mViewPager = view;
        mViewPager.setOnPageChangeListener(this);
        invalidate();
    }

    @Override
    public void setViewPager(ViewPager view, int initialPosition) {
        setViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void setCurrentItem(int item) {
        if (mViewPager == null) {
            throw new IllegalStateException("ViewPager has not been bound.");
        }
        mViewPager.setCurrentItem(item);
        mCurrentPage = item;
        invalidate();
    }

    @Override
    public void notifyDataSetChanged() {
        invalidate();
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        mScrollState = state;

        if (mListener != null) {
            mListener.onPageScrollStateChanged(state);
        }
    }

    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        mCurrentPage = position;
        mPageOffset = positionOffset;
        invalidate();

        if (mListener != null) {
            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);
        }
    }

    @Override
    public void onPageSelected(int position) {
        if (mSnap || mScrollState == ViewPager.SCROLL_STATE_IDLE) {
            mCurrentPage = position;
            mSnapPage = position;
            invalidate();
        }

        if (mListener != null) {
            mListener.onPageSelected(position);
        }
    }

    @Override
    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {
        mListener = listener;
    }

    /*
     * (non-Javadoc)
     *
     * @see android.view.View#onMeasure(int, int)
     */
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (mOrientation == HORIZONTAL) {
            setMeasuredDimension(measureLong(widthMeasureSpec), measureShort(heightMeasureSpec));
        } else {
            setMeasuredDimension(measureShort(widthMeasureSpec), measureLong(heightMeasureSpec));
        }
    }

    /**
     * Determines the width of this view
     *
     * @param measureSpec
     *            A measureSpec packed into an int
     * @return The width of the view, honoring constraints from measureSpec
     */
    private int measureLong(int measureSpec) {
        int result;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {
            //We were told how big to be
            result = specSize;
        } else {
            //Calculate the width according the views count
            final int count = mViewPager.getAdapter().getCount();
            result = (int)(getPaddingLeft() + getPaddingRight()
                    + (count * 2 * mRadius) + (count - 1) * mRadius + 1);
            //Respect AT_MOST value if that was what is called for by measureSpec
            if (specMode == MeasureSpec.AT_MOST) {
                result = Math.min(result, specSize);
            }
        }
        return result;
    }

    /**
     * Determines the height of this view
     *
     * @param measureSpec
     *            A measureSpec packed into an int
     * @return The height of the view, honoring constraints from measureSpec
     */
    private int measureShort(int measureSpec) {
        int result;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        if (specMode == MeasureSpec.EXACTLY) {
            //We were told how big to be
            result = specSize;
        } else {
            //Measure the height
            result = (int)(2 * mRadius + getPaddingTop() + getPaddingBottom() + 1);
            //Respect AT_MOST value if that was what is called for by measureSpec
            if (specMode == MeasureSpec.AT_MOST) {
                result = Math.min(result, specSize);
            }
        }
        return result;
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
        SavedState savedState = (SavedState)state;
        super.onRestoreInstanceState(savedState.getSuperState());
        mCurrentPage = savedState.currentPage;
        mSnapPage = savedState.currentPage;
        requestLayout();
    }

    @Override
    public Parcelable onSaveInstanceState() {
        Parcelable superState = super.onSaveInstanceState();
        SavedState savedState = new SavedState(superState);
        savedState.currentPage = mCurrentPage;
        return savedState;
    }

    static class SavedState extends BaseSavedState {
        int currentPage;

        public SavedState(Parcelable superState) {
            super(superState);
        }

        private SavedState(Parcel in) {
            super(in);
            currentPage = in.readInt();
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            super.writeToParcel(dest, flags);
            dest.writeInt(currentPage);
        }

        @SuppressWarnings("UnusedDeclaration")
        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
            @Override
            public SavedState createFromParcel(Parcel in) {
                return new SavedState(in);
            }

            @Override
            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        };
    }
}

@#$
/*
 * Copyright (C) 2011 The Android Open Source Project
 * Copyright (C) 2012 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.viewpagerindicator;

import static android.view.ViewGroup.LayoutParams.FILL_PARENT;
import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
import android.content.Context;
import android.support.v4.view.PagerAdapter;
import android.support.v4.view.ViewPager;
import android.support.v4.view.ViewPager.OnPageChangeListener;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.View;
import android.widget.HorizontalScrollView;
import android.widget.ImageView;

import com.velocityviewpagerindicator.R;

/**
 * This widget implements the dynamic action bar tab behavior that can change
 * across different configurations or circumstances.
 */
public class IconPageIndicator extends HorizontalScrollView implements PageIndicator {
    private final IcsLinearLayout mIconsLayout;

    private ViewPager mViewPager;
    private OnPageChangeListener mListener;
    private Runnable mIconSelector;
    private int mSelectedIndex;

    public IconPageIndicator(Context context) {
        this(context, null);
    }

    public IconPageIndicator(Context context, AttributeSet attrs) {
        super(context, attrs);
        setHorizontalScrollBarEnabled(false);

        mIconsLayout = new IcsLinearLayout(context, R.attr.vpiIconPageIndicatorStyle);
        addView(mIconsLayout, new LayoutParams(WRAP_CONTENT, FILL_PARENT, Gravity.CENTER));
    }

    private void animateToIcon(final int position) {
        final View iconView = mIconsLayout.getChildAt(position);
        if (mIconSelector != null) {
            removeCallbacks(mIconSelector);
        }
        mIconSelector = new Runnable() {
            public void run() {
                final int scrollPos = iconView.getLeft() - (getWidth() - iconView.getWidth()) / 2;
                smoothScrollTo(scrollPos, 0);
                mIconSelector = null;
            }
        };
        post(mIconSelector);
    }

    @Override
    public void onAttachedToWindow() {
        super.onAttachedToWindow();
        if (mIconSelector != null) {
            // Re-post the selector we saved
            post(mIconSelector);
        }
    }

    @Override
    public void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        if (mIconSelector != null) {
            removeCallbacks(mIconSelector);
        }
    }

    @Override
    public void onPageScrollStateChanged(int arg0) {
        if (mListener != null) {
            mListener.onPageScrollStateChanged(arg0);
        }
    }

    @Override
    public void onPageScrolled(int arg0, float arg1, int arg2) {
        if (mListener != null) {
            mListener.onPageScrolled(arg0, arg1, arg2);
        }
    }

    @Override
    public void onPageSelected(int arg0) {
        setCurrentItem(arg0);
        if (mListener != null) {
            mListener.onPageSelected(arg0);
        }
    }

    @Override
    public void setViewPager(ViewPager view) {
        if (mViewPager == view) {
            return;
        }
        if (mViewPager != null) {
            mViewPager.setOnPageChangeListener(null);
        }
        PagerAdapter adapter = view.getAdapter();
        if (adapter == null) {
            throw new IllegalStateException("ViewPager does not have adapter instance.");
        }
        mViewPager = view;
        view.setOnPageChangeListener(this);
        notifyDataSetChanged();
    }

    public void notifyDataSetChanged() {
        mIconsLayout.removeAllViews();
        IconPagerAdapter iconAdapter = (IconPagerAdapter) mViewPager.getAdapter();
        int count = iconAdapter.getCount();
        for (int i = 0; i < count; i++) {
            ImageView view = new ImageView(getContext(), null, R.attr.vpiIconPageIndicatorStyle);
            view.setImageResource(iconAdapter.getIconResId(i));
            mIconsLayout.addView(view);
        }
        if (mSelectedIndex > count) {
            mSelectedIndex = count - 1;
        }
        setCurrentItem(mSelectedIndex);
        requestLayout();
    }

    @Override
    public void setViewPager(ViewPager view, int initialPosition) {
        setViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void setCurrentItem(int item) {
        if (mViewPager == null) {
            throw new IllegalStateException("ViewPager has not been bound.");
        }
        mSelectedIndex = item;
        mViewPager.setCurrentItem(item);

        int tabCount = mIconsLayout.getChildCount();
        for (int i = 0; i < tabCount; i++) {
            View child = mIconsLayout.getChildAt(i);
            boolean isSelected = (i == item);
            child.setSelected(isSelected);
            if (isSelected) {
                animateToIcon(item);
            }
        }
    }

    @Override
    public void setOnPageChangeListener(OnPageChangeListener listener) {
        mListener = listener;
    }
}

@#$
package com.viewpagerindicator;

public interface IconPagerAdapter {
    /**
     * Get icon representing the page at {@code index} in the adapter.
     */
    int getIconResId(int index);

    // From PagerAdapter
    int getCount();
}

@#$
package com.viewpagerindicator;

import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.drawable.Drawable;
import android.view.View;
import android.widget.LinearLayout;

/**
 * A simple extension of a regular linear layout that supports the divider API
 * of Android 4.0+. The dividers are added adjacent to the children by changing
 * their layout params. If you need to rely on the margins which fall in the
 * same orientation as the layout you should wrap the child in a simple
 * {@link android.widget.FrameLayout} so it can receive the margin.
 */
class IcsLinearLayout extends LinearLayout {
    private static final int[] LL = new int[] {
        /* 0 */ android.R.attr.divider,
        /* 1 */ android.R.attr.showDividers,
        /* 2 */ android.R.attr.dividerPadding,
    };
    private static final int LL_DIVIDER = 0;
    private static final int LL_SHOW_DIVIDER = 1;
    private static final int LL_DIVIDER_PADDING = 2;

    private Drawable mDivider;
    private int mDividerWidth;
    private int mDividerHeight;
    private int mShowDividers;
    private int mDividerPadding;


    public IcsLinearLayout(Context context, int themeAttr) {
        super(context);

        TypedArray a = context.obtainStyledAttributes(null, LL, themeAttr, 0);
        setDividerDrawable(a.getDrawable(IcsLinearLayout.LL_DIVIDER));
        mDividerPadding = a.getDimensionPixelSize(LL_DIVIDER_PADDING, 0);
        mShowDividers = a.getInteger(LL_SHOW_DIVIDER, SHOW_DIVIDER_NONE);
        a.recycle();
    }

    public void setDividerDrawable(Drawable divider) {
        if (divider == mDivider) {
            return;
        }
        mDivider = divider;
        if (divider != null) {
            mDividerWidth = divider.getIntrinsicWidth();
            mDividerHeight = divider.getIntrinsicHeight();
        } else {
            mDividerWidth = 0;
            mDividerHeight = 0;
        }
        setWillNotDraw(divider == null);
        requestLayout();
    }

    @Override
    protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) {
        final int index = indexOfChild(child);
        final int orientation = getOrientation();
        final LayoutParams params = (LayoutParams) child.getLayoutParams();
        if (hasDividerBeforeChildAt(index)) {
            if (orientation == VERTICAL) {
                //Account for the divider by pushing everything up
                params.topMargin = mDividerHeight;
            } else {
                //Account for the divider by pushing everything left
                params.leftMargin = mDividerWidth;
            }
        }

        final int count = getChildCount();
        if (index == count - 1) {
            if (hasDividerBeforeChildAt(count)) {
                if (orientation == VERTICAL) {
                    params.bottomMargin = mDividerHeight;
                } else {
                    params.rightMargin = mDividerWidth;
                }
            }
        }
        super.measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (mDivider != null) {
            if (getOrientation() == VERTICAL) {
                drawDividersVertical(canvas);
            } else {
                drawDividersHorizontal(canvas);
            }
        }
        super.onDraw(canvas);
    }

    private void drawDividersVertical(Canvas canvas) {
        final int count = getChildCount();
        for (int i = 0; i < count; i++) {
            final View child = getChildAt(i);

            if (child != null && child.getVisibility() != GONE) {
                if (hasDividerBeforeChildAt(i)) {
                    final android.widget.LinearLayout.LayoutParams lp = (android.widget.LinearLayout.LayoutParams) child.getLayoutParams();
                    final int top = child.getTop() - lp.topMargin/* - mDividerHeight*/;
                    drawHorizontalDivider(canvas, top);
                }
            }
        }

        if (hasDividerBeforeChildAt(count)) {
            final View child = getChildAt(count - 1);
            int bottom = 0;
            if (child == null) {
                bottom = getHeight() - getPaddingBottom() - mDividerHeight;
            } else {
                //final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                bottom = child.getBottom()/* + lp.bottomMargin*/;
            }
            drawHorizontalDivider(canvas, bottom);
        }
    }

    private void drawDividersHorizontal(Canvas canvas) {
        final int count = getChildCount();
        for (int i = 0; i < count; i++) {
            final View child = getChildAt(i);

            if (child != null && child.getVisibility() != GONE) {
                if (hasDividerBeforeChildAt(i)) {
                    final android.widget.LinearLayout.LayoutParams lp = (android.widget.LinearLayout.LayoutParams) child.getLayoutParams();
                    final int left = child.getLeft() - lp.leftMargin/* - mDividerWidth*/;
                    drawVerticalDivider(canvas, left);
                }
            }
        }

        if (hasDividerBeforeChildAt(count)) {
            final View child = getChildAt(count - 1);
            int right = 0;
            if (child == null) {
                right = getWidth() - getPaddingRight() - mDividerWidth;
            } else {
                //final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                right = child.getRight()/* + lp.rightMargin*/;
            }
            drawVerticalDivider(canvas, right);
        }
    }

    private void drawHorizontalDivider(Canvas canvas, int top) {
        mDivider.setBounds(getPaddingLeft() + mDividerPadding, top,
                getWidth() - getPaddingRight() - mDividerPadding, top + mDividerHeight);
        mDivider.draw(canvas);
    }

    private void drawVerticalDivider(Canvas canvas, int left) {
        mDivider.setBounds(left, getPaddingTop() + mDividerPadding,
                left + mDividerWidth, getHeight() - getPaddingBottom() - mDividerPadding);
        mDivider.draw(canvas);
    }

    private boolean hasDividerBeforeChildAt(int childIndex) {
        if (childIndex == 0 || childIndex == getChildCount()) {
          return false;
        }
        if ((mShowDividers & SHOW_DIVIDER_MIDDLE) != 0) {
            boolean hasVisibleViewBefore = false;
            for (int i = childIndex - 1; i >= 0; i--) {
                if (getChildAt(i).getVisibility() != GONE) {
                    hasVisibleViewBefore = true;
                    break;
                }
            }
            return hasVisibleViewBefore;
        }
        return false;
    }
}

@#$
/*
 * Copyright (C) 2012 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.viewpagerindicator;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.drawable.Drawable;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.v4.view.MotionEventCompat;
import android.support.v4.view.ViewConfigurationCompat;
import android.support.v4.view.ViewPager;
import android.util.AttributeSet;
import android.util.FloatMath;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;

import com.velocityviewpagerindicator.R;

/**
 * Draws a line for each page. The current page line is colored differently
 * than the unselected page lines.
 */
public class LinePageIndicator extends View implements PageIndicator {
    private static final int INVALID_POINTER = -1;

    private final Paint mPaintUnselected = new Paint(Paint.ANTI_ALIAS_FLAG);
    private final Paint mPaintSelected = new Paint(Paint.ANTI_ALIAS_FLAG);
    private ViewPager mViewPager;
    private ViewPager.OnPageChangeListener mListener;
    private int mCurrentPage;
    private boolean mCentered;
    private float mLineWidth;
    private float mGapWidth;

    private int mTouchSlop;
    private float mLastMotionX = -1;
    private int mActivePointerId = INVALID_POINTER;
    private boolean mIsDragging;


    public LinePageIndicator(Context context) {
        this(context, null);
    }

    public LinePageIndicator(Context context, AttributeSet attrs) {
        this(context, attrs, R.attr.vpiLinePageIndicatorStyle);
    }

    public LinePageIndicator(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        if (isInEditMode()) return;

        final Resources res = getResources();

        //Load defaults from resources
        final int defaultSelectedColor = res.getColor(R.color.default_line_indicator_selected_color);
        final int defaultUnselectedColor = res.getColor(R.color.default_line_indicator_unselected_color);
        final float defaultLineWidth = res.getDimension(R.dimen.default_line_indicator_line_width);
        final float defaultGapWidth = res.getDimension(R.dimen.default_line_indicator_gap_width);
        final float defaultStrokeWidth = res.getDimension(R.dimen.default_line_indicator_stroke_width);
        final boolean defaultCentered = res.getBoolean(R.bool.default_line_indicator_centered);

        //Retrieve styles attributes
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.VelocityLinePageIndicator, defStyle, 0);

        mCentered = a.getBoolean(R.styleable.VelocityLinePageIndicator_centered, defaultCentered);
        mLineWidth = a.getDimension(R.styleable.VelocityLinePageIndicator_lineWidth, defaultLineWidth);
        mGapWidth = a.getDimension(R.styleable.VelocityLinePageIndicator_gapWidth, defaultGapWidth);
        setStrokeWidth(a.getDimension(R.styleable.VelocityLinePageIndicator_strokeWidth, defaultStrokeWidth));
        mPaintUnselected.setColor(a.getColor(R.styleable.VelocityLinePageIndicator_unselectedColor, defaultUnselectedColor));
        mPaintSelected.setColor(a.getColor(R.styleable.VelocityLinePageIndicator_selectedColor, defaultSelectedColor));

        Drawable background = a.getDrawable(R.styleable.VelocityLinePageIndicator_android_background);
        if (background != null) {
          setBackgroundDrawable(background);
        }

        a.recycle();

        final ViewConfiguration configuration = ViewConfiguration.get(context);
        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
    }


    public void setCentered(boolean centered) {
        mCentered = centered;
        invalidate();
    }

    public boolean isCentered() {
        return mCentered;
    }

    public void setUnselectedColor(int unselectedColor) {
        mPaintUnselected.setColor(unselectedColor);
        invalidate();
    }

    public int getUnselectedColor() {
        return mPaintUnselected.getColor();
    }

    public void setSelectedColor(int selectedColor) {
        mPaintSelected.setColor(selectedColor);
        invalidate();
    }

    public int getSelectedColor() {
        return mPaintSelected.getColor();
    }

    public void setLineWidth(float lineWidth) {
        mLineWidth = lineWidth;
        invalidate();
    }

    public float getLineWidth() {
        return mLineWidth;
    }

    public void setStrokeWidth(float lineHeight) {
        mPaintSelected.setStrokeWidth(lineHeight);
        mPaintUnselected.setStrokeWidth(lineHeight);
        invalidate();
    }

    public float getStrokeWidth() {
        return mPaintSelected.getStrokeWidth();
    }

    public void setGapWidth(float gapWidth) {
        mGapWidth = gapWidth;
        invalidate();
    }

    public float getGapWidth() {
        return mGapWidth;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (mViewPager == null) {
            return;
        }
        final int count = mViewPager.getAdapter().getCount();
        if (count == 0) {
            return;
        }

        if (mCurrentPage >= count) {
            setCurrentItem(count - 1);
            return;
        }

        final float lineWidthAndGap = mLineWidth + mGapWidth;
        final float indicatorWidth = (count * lineWidthAndGap) - mGapWidth;
        final float paddingTop = getPaddingTop();
        final float paddingLeft = getPaddingLeft();
        final float paddingRight = getPaddingRight();

        float verticalOffset = paddingTop + ((getHeight() - paddingTop - getPaddingBottom()) / 2.0f);
        float horizontalOffset = paddingLeft;
        if (mCentered) {
            horizontalOffset += ((getWidth() - paddingLeft - paddingRight) / 2.0f) - (indicatorWidth / 2.0f);
        }

        //Draw stroked circles
        for (int i = 0; i < count; i++) {
            float dx1 = horizontalOffset + (i * lineWidthAndGap);
            float dx2 = dx1 + mLineWidth;
            canvas.drawLine(dx1, verticalOffset, dx2, verticalOffset, (i == mCurrentPage) ? mPaintSelected : mPaintUnselected);
        }
    }

    public boolean onTouchEvent(android.view.MotionEvent ev) {
        if (super.onTouchEvent(ev)) {
            return true;
        }
        if ((mViewPager == null) || (mViewPager.getAdapter().getCount() == 0)) {
            return false;
        }

        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
                mLastMotionX = ev.getX();
                break;

            case MotionEvent.ACTION_MOVE: {
                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                final float x = MotionEventCompat.getX(ev, activePointerIndex);
                final float deltaX = x - mLastMotionX;

                if (!mIsDragging) {
                    if (Math.abs(deltaX) > mTouchSlop) {
                        mIsDragging = true;
                    }
                }

                if (mIsDragging) {
                    mLastMotionX = x;
                    if (mViewPager.isFakeDragging() || mViewPager.beginFakeDrag()) {
                        mViewPager.fakeDragBy(deltaX);
                    }
                }

                break;
            }

            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                if (!mIsDragging) {
                    final int count = mViewPager.getAdapter().getCount();
                    final int width = getWidth();
                    final float halfWidth = width / 2f;
                    final float sixthWidth = width / 6f;

                    if ((mCurrentPage > 0) && (ev.getX() < halfWidth - sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mViewPager.setCurrentItem(mCurrentPage - 1);
                        }
                        return true;
                    } else if ((mCurrentPage < count - 1) && (ev.getX() > halfWidth + sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mViewPager.setCurrentItem(mCurrentPage + 1);
                        }
                        return true;
                    }
                }

                mIsDragging = false;
                mActivePointerId = INVALID_POINTER;
                if (mViewPager.isFakeDragging()) mViewPager.endFakeDrag();
                break;

            case MotionEventCompat.ACTION_POINTER_DOWN: {
                final int index = MotionEventCompat.getActionIndex(ev);
                mLastMotionX = MotionEventCompat.getX(ev, index);
                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
                break;
            }

            case MotionEventCompat.ACTION_POINTER_UP:
                final int pointerIndex = MotionEventCompat.getActionIndex(ev);
                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
                if (pointerId == mActivePointerId) {
                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
                }
                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));
                break;
        }

        return true;
    }

    @Override
    public void setViewPager(ViewPager ViewPager) {
        if (mViewPager == ViewPager) {
            return;
        }
        if (mViewPager != null) {
            //Clear us from the old pager.
            mViewPager.setOnPageChangeListener(null);
        }
        if (ViewPager.getAdapter() == null) {
            throw new IllegalStateException("ViewPager does not have adapter instance.");
        }
        mViewPager = ViewPager;
        mViewPager.setOnPageChangeListener(this);
        invalidate();
    }

    @Override
    public void setViewPager(ViewPager view, int initialPosition) {
        setViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void setCurrentItem(int item) {
        if (mViewPager == null) {
            throw new IllegalStateException("ViewPager has not been bound.");
        }
        mViewPager.setCurrentItem(item);
        mCurrentPage = item;
        invalidate();
    }

    @Override
    public void notifyDataSetChanged() {
        invalidate();
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        if (mListener != null) {
            mListener.onPageScrollStateChanged(state);
        }
    }

    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        if (mListener != null) {
            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);
        }
    }

    @Override
    public void onPageSelected(int position) {
        mCurrentPage = position;
        invalidate();

        if (mListener != null) {
            mListener.onPageSelected(position);
        }
    }

    @Override
    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {
        mListener = listener;
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec));
    }

    /**
     * Determines the width of this view
     *
     * @param measureSpec
     *            A measureSpec packed into an int
     * @return The width of the view, honoring constraints from measureSpec
     */
    private int measureWidth(int measureSpec) {
        float result;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {
            //We were told how big to be
            result = specSize;
        } else {
            //Calculate the width according the views count
            final int count = mViewPager.getAdapter().getCount();
            result = getPaddingLeft() + getPaddingRight() + (count * mLineWidth) + ((count - 1) * mGapWidth);
            //Respect AT_MOST value if that was what is called for by measureSpec
            if (specMode == MeasureSpec.AT_MOST) {
                result = Math.min(result, specSize);
            }
        }
        return (int)FloatMath.ceil(result);
    }

    /**
     * Determines the height of this view
     *
     * @param measureSpec
     *            A measureSpec packed into an int
     * @return The height of the view, honoring constraints from measureSpec
     */
    private int measureHeight(int measureSpec) {
        float result;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        if (specMode == MeasureSpec.EXACTLY) {
            //We were told how big to be
            result = specSize;
        } else {
            //Measure the height
            result = mPaintSelected.getStrokeWidth() + getPaddingTop() + getPaddingBottom();
            //Respect AT_MOST value if that was what is called for by measureSpec
            if (specMode == MeasureSpec.AT_MOST) {
                result = Math.min(result, specSize);
            }
        }
        return (int)FloatMath.ceil(result);
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
        SavedState savedState = (SavedState)state;
        super.onRestoreInstanceState(savedState.getSuperState());
        mCurrentPage = savedState.currentPage;
        requestLayout();
    }

    @Override
    public Parcelable onSaveInstanceState() {
        Parcelable superState = super.onSaveInstanceState();
        SavedState savedState = new SavedState(superState);
        savedState.currentPage = mCurrentPage;
        return savedState;
    }

    static class SavedState extends BaseSavedState {
        int currentPage;

        public SavedState(Parcelable superState) {
            super(superState);
        }

        private SavedState(Parcel in) {
            super(in);
            currentPage = in.readInt();
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            super.writeToParcel(dest, flags);
            dest.writeInt(currentPage);
        }

        @SuppressWarnings("UnusedDeclaration")
        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
            @Override
            public SavedState createFromParcel(Parcel in) {
                return new SavedState(in);
            }

            @Override
            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        };
    }
}
@#$
/*
 * Copyright (C) 2011 Patrik Akerfeldt
 * Copyright (C) 2011 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.viewpagerindicator;

import android.support.v4.view.ViewPager;


/**
 * A PageIndicator is responsible to show an visual indicator on the total views
 * number and the current visible view.
 */
public interface PageIndicator extends ViewPager.OnPageChangeListener {
    /**
     * Bind the indicator to a ViewPager.
     *
     * @param view
     */
    void setViewPager(ViewPager view);

    /**
     * Bind the indicator to a ViewPager.
     *
     * @param view
     * @param initialPosition
     */
    void setViewPager(ViewPager view, int initialPosition);

    /**
     * <p>Set the current page of both the ViewPager and indicator.</p>
     *
     * <p>This <strong>must</strong> be used if you need to set the page before
     * the views are drawn on screen (e.g., default start page).</p>
     *
     * @param item
     */
    void setCurrentItem(int item);

    /**
     * Set a page change listener which will receive forwarded events.
     *
     * @param listener
     */
    void setOnPageChangeListener(ViewPager.OnPageChangeListener listener);

    /**
     * Notify the indicator that the fragment list has changed.
     */
    void notifyDataSetChanged();
}

@#$
/*
 * Copyright (C) 2011 The Android Open Source Project
 * Copyright (C) 2011 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.viewpagerindicator;

import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
import android.content.Context;
import android.support.v4.view.PagerAdapter;
import android.support.v4.view.ViewPager;
import android.support.v4.view.ViewPager.OnPageChangeListener;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;
import android.widget.HorizontalScrollView;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.velocityviewpagerindicator.R;

/**
 * This widget implements the dynamic action bar tab behavior that can change
 * across different configurations or circumstances.
 */
public class TabPageIndicator extends HorizontalScrollView implements PageIndicator {
    /** Title text used when no title is provided by the adapter. */
    private static final CharSequence EMPTY_TITLE = "";

    /**
     * Interface for a callback when the selected tab has been reselected.
     */
    public interface OnTabReselectedListener {
        /**
         * Callback when the selected tab has been reselected.
         *
         * @param position Position of the current center item.
         */
        void onTabReselected(int position);
    }

    private Runnable mTabSelector;

    private final OnClickListener mTabClickListener = new OnClickListener() {
        public void onClick(View view) {
            TabView tabView = (TabView)view;
            final int oldSelected = mViewPager.getCurrentItem();
            final int newSelected = tabView.getIndex();
            mViewPager.setCurrentItem(newSelected);
            if (oldSelected == newSelected && mTabReselectedListener != null) {
                mTabReselectedListener.onTabReselected(newSelected);
            }
        }
    };

    private final IcsLinearLayout mTabLayout;

    private ViewPager mViewPager;
    private ViewPager.OnPageChangeListener mListener;

    private int mMaxTabWidth;
    private int mSelectedTabIndex;

    private OnTabReselectedListener mTabReselectedListener;

    public TabPageIndicator(Context context) {
        this(context, null);
    }

    public TabPageIndicator(Context context, AttributeSet attrs) {
        super(context, attrs);
        setHorizontalScrollBarEnabled(false);

        mTabLayout = new IcsLinearLayout(context, R.attr.vpiTabPageIndicatorStyle);
        addView(mTabLayout, new ViewGroup.LayoutParams(WRAP_CONTENT, MATCH_PARENT));
    }

    public void setOnTabReselectedListener(OnTabReselectedListener listener) {
        mTabReselectedListener = listener;
    }

    @Override
    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        final boolean lockedExpanded = widthMode == MeasureSpec.EXACTLY;
        setFillViewport(lockedExpanded);

        final int childCount = mTabLayout.getChildCount();
        if (childCount > 1 && (widthMode == MeasureSpec.EXACTLY || widthMode == MeasureSpec.AT_MOST)) {
            if (childCount > 2) {
                mMaxTabWidth = (int)(MeasureSpec.getSize(widthMeasureSpec) * 0.4f);
            } else {
                mMaxTabWidth = MeasureSpec.getSize(widthMeasureSpec) / 2;
            }
        } else {
            mMaxTabWidth = -1;
        }

        final int oldWidth = getMeasuredWidth();
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        final int newWidth = getMeasuredWidth();

        if (lockedExpanded && oldWidth != newWidth) {
            // Recenter the tab display if we're at a new (scrollable) size.
            setCurrentItem(mSelectedTabIndex);
        }
    }

    private void animateToTab(final int position) {
        final View tabView = mTabLayout.getChildAt(position);
        if (mTabSelector != null) {
            removeCallbacks(mTabSelector);
        }
        mTabSelector = new Runnable() {
            public void run() {
                final int scrollPos = tabView.getLeft() - (getWidth() - tabView.getWidth()) / 2;
                smoothScrollTo(scrollPos, 0);
                mTabSelector = null;
            }
        };
        post(mTabSelector);
    }

    @Override
    public void onAttachedToWindow() {
        super.onAttachedToWindow();
        if (mTabSelector != null) {
            // Re-post the selector we saved
            post(mTabSelector);
        }
    }

    @Override
    public void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        if (mTabSelector != null) {
            removeCallbacks(mTabSelector);
        }
    }

    private void addTab(int index, CharSequence text, int iconResId) {
        final TabView tabView = new TabView(getContext());
        tabView.mIndex = index;
        tabView.setFocusable(true);
        tabView.setOnClickListener(mTabClickListener);
        tabView.setText(text);

        if (iconResId != 0) {
            tabView.setCompoundDrawablesWithIntrinsicBounds(iconResId, 0, 0, 0);
        }

        mTabLayout.addView(tabView, new LinearLayout.LayoutParams(0, MATCH_PARENT, 1));
    }

    @Override
    public void onPageScrollStateChanged(int arg0) {
        if (mListener != null) {
            mListener.onPageScrollStateChanged(arg0);
        }
    }

    @Override
    public void onPageScrolled(int arg0, float arg1, int arg2) {
        if (mListener != null) {
            mListener.onPageScrolled(arg0, arg1, arg2);
        }
    }

    @Override
    public void onPageSelected(int arg0) {
        setCurrentItem(arg0);
        if (mListener != null) {
            mListener.onPageSelected(arg0);
        }
    }

    @Override
    public void setViewPager(ViewPager view) {
        if (mViewPager == view) {
            return;
        }
        if (mViewPager != null) {
            mViewPager.setOnPageChangeListener(null);
        }
        final PagerAdapter adapter = view.getAdapter();
        if (adapter == null) {
            throw new IllegalStateException("ViewPager does not have adapter instance.");
        }
        mViewPager = view;
        view.setOnPageChangeListener(this);
        notifyDataSetChanged();
    }

    public void notifyDataSetChanged() {
        mTabLayout.removeAllViews();
        PagerAdapter adapter = mViewPager.getAdapter();
        IconPagerAdapter iconAdapter = null;
        if (adapter instanceof IconPagerAdapter) {
            iconAdapter = (IconPagerAdapter)adapter;
        }
        final int count = adapter.getCount();
        for (int i = 0; i < count; i++) {
            CharSequence title = adapter.getPageTitle(i);
            if (title == null) {
                title = EMPTY_TITLE;
            }
            int iconResId = 0;
            if (iconAdapter != null) {
                iconResId = iconAdapter.getIconResId(i);
            }
            addTab(i, title, iconResId);
        }
        if (mSelectedTabIndex > count) {
            mSelectedTabIndex = count - 1;
        }
        setCurrentItem(mSelectedTabIndex);
        requestLayout();
    }

    @Override
    public void setViewPager(ViewPager view, int initialPosition) {
        setViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void setCurrentItem(int item) {
        if (mViewPager == null) {
            throw new IllegalStateException("ViewPager has not been bound.");
        }
        mSelectedTabIndex = item;
        mViewPager.setCurrentItem(item);

        final int tabCount = mTabLayout.getChildCount();
        for (int i = 0; i < tabCount; i++) {
            final View child = mTabLayout.getChildAt(i);
            final boolean isSelected = (i == item);
            child.setSelected(isSelected);
            if (isSelected) {
                animateToTab(item);
            }
        }
    }

    @Override
    public void setOnPageChangeListener(OnPageChangeListener listener) {
        mListener = listener;
    }

    private class TabView extends TextView {
        private int mIndex;

        public TabView(Context context) {
            super(context, null, R.attr.vpiTabPageIndicatorStyle);
        }

        @Override
        public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
            super.onMeasure(widthMeasureSpec, heightMeasureSpec);

            // Re-measure if we went beyond our maximum size.
            if (mMaxTabWidth > 0 && getMeasuredWidth() > mMaxTabWidth) {
                super.onMeasure(MeasureSpec.makeMeasureSpec(mMaxTabWidth, MeasureSpec.EXACTLY),
                        heightMeasureSpec);
            }
        }

        public int getIndex() {
            return mIndex;
        }
    }
}

@#$
/*
 * Copyright (C) 2011 Jake Wharton
 * Copyright (C) 2011 Patrik Akerfeldt
 * Copyright (C) 2011 Francisco Figueiredo Jr.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.viewpagerindicator;

import java.util.ArrayList;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.v4.view.MotionEventCompat;
import android.support.v4.view.ViewConfigurationCompat;
import android.support.v4.view.ViewPager;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;

import com.velocityviewpagerindicator.R;

/**
 * A TitlePageIndicator is a PageIndicator which displays the title of left view
 * (if exist), the title of the current select view (centered) and the title of
 * the right view (if exist). When the user scrolls the ViewPager then titles are
 * also scrolled.
 */
public class TitlePageIndicator extends View implements PageIndicator {
    /**
     * Percentage indicating what percentage of the screen width away from
     * center should the underline be fully faded. A value of 0.25 means that
     * halfway between the center of the screen and an edge.
     */
    private static final float SELECTION_FADE_PERCENTAGE = 0.25f;

    /**
     * Percentage indicating what percentage of the screen width away from
     * center should the selected text bold turn off. A value of 0.05 means
     * that 10% between the center and an edge.
     */
    private static final float BOLD_FADE_PERCENTAGE = 0.05f;

    /**
     * Title text used when no title is provided by the adapter.
     */
    private static final String EMPTY_TITLE = "";

    /**
     * Interface for a callback when the center item has been clicked.
     */
    public interface OnCenterItemClickListener {
        /**
         * Callback when the center item has been clicked.
         *
         * @param position Position of the current center item.
         */
        void onCenterItemClick(int position);
    }

    public enum IndicatorStyle {
        None(0), Triangle(1), Underline(2);

        public final int value;

        private IndicatorStyle(int value) {
            this.value = value;
        }

        public static IndicatorStyle fromValue(int value) {
            for (IndicatorStyle style : IndicatorStyle.values()) {
                if (style.value == value) {
                    return style;
                }
            }
            return null;
        }
    }

    public enum LinePosition {
        Bottom(0), Top(1);

        public final int value;

        private LinePosition(int value) {
            this.value = value;
        }

        public static LinePosition fromValue(int value) {
            for (LinePosition position : LinePosition.values()) {
                if (position.value == value) {
                    return position;
                }
            }
            return null;
        }
    }

    private ViewPager mViewPager;
    private ViewPager.OnPageChangeListener mListener;
    private int mCurrentPage = -1;
    private float mPageOffset;
    private int mScrollState;
    private final Paint mPaintText = new Paint();
    private boolean mBoldText;
    private int mColorText;
    private int mColorSelected;
    private Path mPath = new Path();
    private final Rect mBounds = new Rect();
    private final Paint mPaintFooterLine = new Paint();
    private IndicatorStyle mFooterIndicatorStyle;
    private LinePosition mLinePosition;
    private final Paint mPaintFooterIndicator = new Paint();
    private float mFooterIndicatorHeight;
    private float mFooterIndicatorUnderlinePadding;
    private float mFooterPadding;
    private float mTitlePadding;
    private float mTopPadding;
    /** Left and right side padding for not active view titles. */
    private float mClipPadding;
    private float mFooterLineHeight;

    private static final int INVALID_POINTER = -1;

    private int mTouchSlop;
    private float mLastMotionX = -1;
    private int mActivePointerId = INVALID_POINTER;
    private boolean mIsDragging;

    private OnCenterItemClickListener mCenterItemClickListener;


    public TitlePageIndicator(Context context) {
        this(context, null);
    }

    public TitlePageIndicator(Context context, AttributeSet attrs) {
        this(context, attrs, R.attr.vpiTitlePageIndicatorStyle);
    }

    public TitlePageIndicator(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        if (isInEditMode()) return;

        //Load defaults from resources
        final Resources res = getResources();
        final int defaultFooterColor = res.getColor(R.color.default_title_indicator_footer_color);
        final float defaultFooterLineHeight = res.getDimension(R.dimen.default_title_indicator_footer_line_height);
        final int defaultFooterIndicatorStyle = res.getInteger(R.integer.default_title_indicator_footer_indicator_style);
        final float defaultFooterIndicatorHeight = res.getDimension(R.dimen.default_title_indicator_footer_indicator_height);
        final float defaultFooterIndicatorUnderlinePadding = res.getDimension(R.dimen.default_title_indicator_footer_indicator_underline_padding);
        final float defaultFooterPadding = res.getDimension(R.dimen.default_title_indicator_footer_padding);
        final int defaultLinePosition = res.getInteger(R.integer.default_title_indicator_line_position);
        final int defaultSelectedColor = res.getColor(R.color.default_title_indicator_selected_color);
        final boolean defaultSelectedBold = res.getBoolean(R.bool.default_title_indicator_selected_bold);
        final int defaultTextColor = res.getColor(R.color.default_title_indicator_text_color);
        final float defaultTextSize = res.getDimension(R.dimen.default_title_indicator_text_size);
        final float defaultTitlePadding = res.getDimension(R.dimen.default_title_indicator_title_padding);
        final float defaultClipPadding = res.getDimension(R.dimen.default_title_indicator_clip_padding);
        final float defaultTopPadding = res.getDimension(R.dimen.default_title_indicator_top_padding);

        //Retrieve styles attributes
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.VelocityTitlePageIndicator, defStyle, 0);

        //Retrieve the colors to be used for this view and apply them.
        mFooterLineHeight = a.getDimension(R.styleable.VelocityTitlePageIndicator_footerLineHeight, defaultFooterLineHeight);
        mFooterIndicatorStyle = IndicatorStyle.fromValue(a.getInteger(R.styleable.VelocityTitlePageIndicator_footerIndicatorStyle, defaultFooterIndicatorStyle));
        mFooterIndicatorHeight = a.getDimension(R.styleable.VelocityTitlePageIndicator_footerIndicatorHeight, defaultFooterIndicatorHeight);
        mFooterIndicatorUnderlinePadding = a.getDimension(R.styleable.VelocityTitlePageIndicator_footerIndicatorUnderlinePadding, defaultFooterIndicatorUnderlinePadding);
        mFooterPadding = a.getDimension(R.styleable.VelocityTitlePageIndicator_footerPadding, defaultFooterPadding);
        mLinePosition = LinePosition.fromValue(a.getInteger(R.styleable.VelocityTitlePageIndicator_linePosition, defaultLinePosition));
        mTopPadding = a.getDimension(R.styleable.VelocityTitlePageIndicator_topPadding, defaultTopPadding);
        mTitlePadding = a.getDimension(R.styleable.VelocityTitlePageIndicator_titlePadding, defaultTitlePadding);
        mClipPadding = a.getDimension(R.styleable.VelocityTitlePageIndicator_clipPadding, defaultClipPadding);
        mColorSelected = a.getColor(R.styleable.VelocityTitlePageIndicator_selectedColor, defaultSelectedColor);
        mColorText = a.getColor(R.styleable.VelocityTitlePageIndicator_android_textColor, defaultTextColor);
        mBoldText = a.getBoolean(R.styleable.VelocityTitlePageIndicator_selectedBold, defaultSelectedBold);

        final float textSize = a.getDimension(R.styleable.VelocityTitlePageIndicator_android_textSize, defaultTextSize);
        final int footerColor = a.getColor(R.styleable.VelocityTitlePageIndicator_footerColor, defaultFooterColor);
        mPaintText.setTextSize(textSize);
        mPaintText.setAntiAlias(true);
        mPaintFooterLine.setStyle(Paint.Style.FILL_AND_STROKE);
        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);
        mPaintFooterLine.setColor(footerColor);
        mPaintFooterIndicator.setStyle(Paint.Style.FILL_AND_STROKE);
        mPaintFooterIndicator.setColor(footerColor);

        Drawable background = a.getDrawable(R.styleable.VelocityTitlePageIndicator_android_background);
        if (background != null) {
          setBackgroundDrawable(background);
        }

        a.recycle();

        final ViewConfiguration configuration = ViewConfiguration.get(context);
        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
    }


    public int getFooterColor() {
        return mPaintFooterLine.getColor();
    }

    public void setFooterColor(int footerColor) {
        mPaintFooterLine.setColor(footerColor);
        mPaintFooterIndicator.setColor(footerColor);
        invalidate();
    }

    public float getFooterLineHeight() {
        return mFooterLineHeight;
    }

    public void setFooterLineHeight(float footerLineHeight) {
        mFooterLineHeight = footerLineHeight;
        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);
        invalidate();
    }

    public float getFooterIndicatorHeight() {
        return mFooterIndicatorHeight;
    }

    public void setFooterIndicatorHeight(float footerTriangleHeight) {
        mFooterIndicatorHeight = footerTriangleHeight;
        invalidate();
    }

    public float getFooterIndicatorPadding() {
        return mFooterPadding;
    }

    public void setFooterIndicatorPadding(float footerIndicatorPadding) {
        mFooterPadding = footerIndicatorPadding;
        invalidate();
    }

    public IndicatorStyle getFooterIndicatorStyle() {
        return mFooterIndicatorStyle;
    }

    public void setFooterIndicatorStyle(IndicatorStyle indicatorStyle) {
        mFooterIndicatorStyle = indicatorStyle;
        invalidate();
    }

    public LinePosition getLinePosition() {
        return mLinePosition;
    }

    public void setLinePosition(LinePosition linePosition) {
        mLinePosition = linePosition;
        invalidate();
    }

    public int getSelectedColor() {
        return mColorSelected;
    }

    public void setSelectedColor(int selectedColor) {
        mColorSelected = selectedColor;
        invalidate();
    }

    public boolean isSelectedBold() {
        return mBoldText;
    }

    public void setSelectedBold(boolean selectedBold) {
        mBoldText = selectedBold;
        invalidate();
    }

    public int getTextColor() {
        return mColorText;
    }

    public void setTextColor(int textColor) {
        mPaintText.setColor(textColor);
        mColorText = textColor;
        invalidate();
    }

    public float getTextSize() {
        return mPaintText.getTextSize();
    }

    public void setTextSize(float textSize) {
        mPaintText.setTextSize(textSize);
        invalidate();
    }

    public float getTitlePadding() {
        return this.mTitlePadding;
    }

    public void setTitlePadding(float titlePadding) {
        mTitlePadding = titlePadding;
        invalidate();
    }

    public float getTopPadding() {
        return this.mTopPadding;
    }

    public void setTopPadding(float topPadding) {
        mTopPadding = topPadding;
        invalidate();
    }

    public float getClipPadding() {
        return this.mClipPadding;
    }

    public void setClipPadding(float clipPadding) {
        mClipPadding = clipPadding;
        invalidate();
    }

    public void setTypeface(Typeface typeface) {
        mPaintText.setTypeface(typeface);
        invalidate();
    }

    public Typeface getTypeface() {
        return mPaintText.getTypeface();
    }

    /*
     * (non-Javadoc)
     *
     * @see android.view.View#onDraw(android.graphics.Canvas)
     */
    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (mViewPager == null) {
            return;
        }
        final int count = mViewPager.getAdapter().getCount();
        if (count == 0) {
            return;
        }

        // mCurrentPage is -1 on first start and after orientation changed. If so, retrieve the correct index from ViewPager.
        if (mCurrentPage == -1 && mViewPager != null) {
            mCurrentPage = mViewPager.getCurrentItem();
        }

        //Calculate views bounds
        ArrayList<Rect> bounds = calculateAllBounds(mPaintText);
        final int boundsSize = bounds.size();

        //Make sure we're on a page that still exists
        if (mCurrentPage >= boundsSize) {
            setCurrentItem(boundsSize - 1);
            return;
        }

        final int countMinusOne = count - 1;
        final float halfWidth = getWidth() / 2f;
        final int left = getLeft();
        final float leftClip = left + mClipPadding;
        final int width = getWidth();
        int height = getHeight();
        final int right = left + width;
        final float rightClip = right - mClipPadding;

        int page = mCurrentPage;
        float offsetPercent;
        if (mPageOffset <= 0.5) {
            offsetPercent = mPageOffset;
        } else {
            page += 1;
            offsetPercent = 1 - mPageOffset;
        }
        final boolean currentSelected = (offsetPercent <= SELECTION_FADE_PERCENTAGE);
        final boolean currentBold = (offsetPercent <= BOLD_FADE_PERCENTAGE);
        final float selectedPercent = (SELECTION_FADE_PERCENTAGE - offsetPercent) / SELECTION_FADE_PERCENTAGE;

        //Verify if the current view must be clipped to the screen
        Rect curPageBound = bounds.get(mCurrentPage);
        float curPageWidth = curPageBound.right - curPageBound.left;
        if (curPageBound.left < leftClip) {
            //Try to clip to the screen (left side)
            clipViewOnTheLeft(curPageBound, curPageWidth, left);
        }
        if (curPageBound.right > rightClip) {
            //Try to clip to the screen (right side)
            clipViewOnTheRight(curPageBound, curPageWidth, right);
        }

        //Left views starting from the current position
        if (mCurrentPage > 0) {
            for (int i = mCurrentPage - 1; i >= 0; i--) {
                Rect bound = bounds.get(i);
                //Is left side is outside the screen
                if (bound.left < leftClip) {
                    int w = bound.right - bound.left;
                    //Try to clip to the screen (left side)
                    clipViewOnTheLeft(bound, w, left);
                    //Except if there's an intersection with the right view
                    Rect rightBound = bounds.get(i + 1);
                    //Intersection
                    if (bound.right + mTitlePadding > rightBound.left) {
                        bound.left = (int) (rightBound.left - w - mTitlePadding);
                        bound.right = bound.left + w;
                    }
                }
            }
        }
        //Right views starting from the current position
        if (mCurrentPage < countMinusOne) {
            for (int i = mCurrentPage + 1 ; i < count; i++) {
                Rect bound = bounds.get(i);
                //If right side is outside the screen
                if (bound.right > rightClip) {
                    int w = bound.right - bound.left;
                    //Try to clip to the screen (right side)
                    clipViewOnTheRight(bound, w, right);
                    //Except if there's an intersection with the left view
                    Rect leftBound = bounds.get(i - 1);
                    //Intersection
                    if (bound.left - mTitlePadding < leftBound.right) {
                        bound.left = (int) (leftBound.right + mTitlePadding);
                        bound.right = bound.left + w;
                    }
                }
            }
        }

        //Now draw views
        int colorTextAlpha = mColorText >>> 24;
        for (int i = 0; i < count; i++) {
            //Get the title
            Rect bound = bounds.get(i);
            //Only if one side is visible
            if ((bound.left > left && bound.left < right) || (bound.right > left && bound.right < right)) {
                final boolean currentPage = (i == page);
                final CharSequence pageTitle = getTitle(i);

                //Only set bold if we are within bounds
                mPaintText.setFakeBoldText(currentPage && currentBold && mBoldText);

                //Draw text as unselected
                mPaintText.setColor(mColorText);
                if(currentPage && currentSelected) {
                    //Fade out/in unselected text as the selected text fades in/out
                    mPaintText.setAlpha(colorTextAlpha - (int)(colorTextAlpha * selectedPercent));
                }

                //Except if there's an intersection with the right view
                if (i < boundsSize - 1)  {
                    Rect rightBound = bounds.get(i + 1);
                    //Intersection
                    if (bound.right + mTitlePadding > rightBound.left) {
                        int w = bound.right - bound.left;
                        bound.left = (int) (rightBound.left - w - mTitlePadding);
                        bound.right = bound.left + w;
                    }
                }
                canvas.drawText(pageTitle, 0, pageTitle.length(), bound.left, bound.bottom + mTopPadding, mPaintText);

                //If we are within the selected bounds draw the selected text
                if (currentPage && currentSelected) {
                    mPaintText.setColor(mColorSelected);
                    mPaintText.setAlpha((int)((mColorSelected >>> 24) * selectedPercent));
                    canvas.drawText(pageTitle, 0, pageTitle.length(), bound.left, bound.bottom + mTopPadding, mPaintText);
                }
            }
        }

        //If we want the line on the top change height to zero and invert the line height to trick the drawing code
        float footerLineHeight = mFooterLineHeight;
        float footerIndicatorLineHeight = mFooterIndicatorHeight;
        if (mLinePosition == LinePosition.Top) {
            height = 0;
            footerLineHeight = -footerLineHeight;
            footerIndicatorLineHeight = -footerIndicatorLineHeight;
        }

        //Draw the footer line
        mPath.reset();
        mPath.moveTo(0, height - footerLineHeight / 2f);
        mPath.lineTo(width, height - footerLineHeight / 2f);
        mPath.close();
        canvas.drawPath(mPath, mPaintFooterLine);

        float heightMinusLine = height - footerLineHeight;
        switch (mFooterIndicatorStyle) {
            case Triangle:
                mPath.reset();
                mPath.moveTo(halfWidth, heightMinusLine - footerIndicatorLineHeight);
                mPath.lineTo(halfWidth + footerIndicatorLineHeight, heightMinusLine);
                mPath.lineTo(halfWidth - footerIndicatorLineHeight, heightMinusLine);
                mPath.close();
                canvas.drawPath(mPath, mPaintFooterIndicator);
                break;

            case Underline:
                if (!currentSelected || page >= boundsSize) {
                    break;
                }

                Rect underlineBounds = bounds.get(page);
                final float rightPlusPadding = underlineBounds.right + mFooterIndicatorUnderlinePadding;
                final float leftMinusPadding = underlineBounds.left - mFooterIndicatorUnderlinePadding;
                final float heightMinusLineMinusIndicator = heightMinusLine - footerIndicatorLineHeight;

                mPath.reset();
                mPath.moveTo(leftMinusPadding, heightMinusLine);
                mPath.lineTo(rightPlusPadding, heightMinusLine);
                mPath.lineTo(rightPlusPadding, heightMinusLineMinusIndicator);
                mPath.lineTo(leftMinusPadding, heightMinusLineMinusIndicator);
                mPath.close();

                mPaintFooterIndicator.setAlpha((int)(0xFF * selectedPercent));
                canvas.drawPath(mPath, mPaintFooterIndicator);
                mPaintFooterIndicator.setAlpha(0xFF);
                break;
        }
    }

    public boolean onTouchEvent(android.view.MotionEvent ev) {
        if (super.onTouchEvent(ev)) {
            return true;
        }
        if ((mViewPager == null) || (mViewPager.getAdapter().getCount() == 0)) {
            return false;
        }

        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
                mLastMotionX = ev.getX();
                break;

            case MotionEvent.ACTION_MOVE: {
                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                final float x = MotionEventCompat.getX(ev, activePointerIndex);
                final float deltaX = x - mLastMotionX;

                if (!mIsDragging) {
                    if (Math.abs(deltaX) > mTouchSlop) {
                        mIsDragging = true;
                    }
                }

                if (mIsDragging) {
                    mLastMotionX = x;
                    if (mViewPager.isFakeDragging() || mViewPager.beginFakeDrag()) {
                        mViewPager.fakeDragBy(deltaX);
                    }
                }

                break;
            }

            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                if (!mIsDragging) {
                    final int count = mViewPager.getAdapter().getCount();
                    final int width = getWidth();
                    final float halfWidth = width / 2f;
                    final float sixthWidth = width / 6f;
                    final float leftThird = halfWidth - sixthWidth;
                    final float rightThird = halfWidth + sixthWidth;
                    final float eventX = ev.getX();

                    if (eventX < leftThird) {
                        if (mCurrentPage > 0) {
                            if (action != MotionEvent.ACTION_CANCEL) {
                                mViewPager.setCurrentItem(mCurrentPage - 1);
                            }
                            return true;
                        }
                    } else if (eventX > rightThird) {
                        if (mCurrentPage < count - 1) {
                            if (action != MotionEvent.ACTION_CANCEL) {
                                mViewPager.setCurrentItem(mCurrentPage + 1);
                            }
                            return true;
                        }
                    } else {
                        //Middle third
                        if (mCenterItemClickListener != null && action != MotionEvent.ACTION_CANCEL) {
                            mCenterItemClickListener.onCenterItemClick(mCurrentPage);
                        }
                    }
                }

                mIsDragging = false;
                mActivePointerId = INVALID_POINTER;
                if (mViewPager.isFakeDragging()) mViewPager.endFakeDrag();
                break;

            case MotionEventCompat.ACTION_POINTER_DOWN: {
                final int index = MotionEventCompat.getActionIndex(ev);
                mLastMotionX = MotionEventCompat.getX(ev, index);
                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
                break;
            }

            case MotionEventCompat.ACTION_POINTER_UP:
                final int pointerIndex = MotionEventCompat.getActionIndex(ev);
                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
                if (pointerId == mActivePointerId) {
                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
                }
                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));
                break;
        }

        return true;
    }

    /**
     * Set bounds for the right textView including clip padding.
     *
     * @param curViewBound
     *            current bounds.
     * @param curViewWidth
     *            width of the view.
     */
    private void clipViewOnTheRight(Rect curViewBound, float curViewWidth, int right) {
        curViewBound.right = (int) (right - mClipPadding);
        curViewBound.left = (int) (curViewBound.right - curViewWidth);
    }

    /**
     * Set bounds for the left textView including clip padding.
     *
     * @param curViewBound
     *            current bounds.
     * @param curViewWidth
     *            width of the view.
     */
    private void clipViewOnTheLeft(Rect curViewBound, float curViewWidth, int left) {
        curViewBound.left = (int) (left + mClipPadding);
        curViewBound.right = (int) (mClipPadding + curViewWidth);
    }

    /**
     * Calculate views bounds and scroll them according to the current index
     *
     * @param paint
     * @return
     */
    private ArrayList<Rect> calculateAllBounds(Paint paint) {
        ArrayList<Rect> list = new ArrayList<Rect>();
        //For each views (If no values then add a fake one)
        final int count = mViewPager.getAdapter().getCount();
        final int width = getWidth();
        final int halfWidth = width / 2;
        for (int i = 0; i < count; i++) {
            Rect bounds = calcBounds(i, paint);
            int w = bounds.right - bounds.left;
            int h = bounds.bottom - bounds.top;
            bounds.left = (int)(halfWidth - (w / 2f) + ((i - mCurrentPage - mPageOffset) * width));
            bounds.right = bounds.left + w;
            bounds.top = 0;
            bounds.bottom = h;
            list.add(bounds);
        }

        return list;
    }

    /**
     * Calculate the bounds for a view's title
     *
     * @param index
     * @param paint
     * @return
     */
    private Rect calcBounds(int index, Paint paint) {
        //Calculate the text bounds
        Rect bounds = new Rect();
        CharSequence title = getTitle(index);
        bounds.right = (int) paint.measureText(title, 0, title.length());
        bounds.bottom = (int) (paint.descent() - paint.ascent());
        return bounds;
    }

    @Override
    public void setViewPager(ViewPager view) {
        if (mViewPager == view) {
            return;
        }
        if (mViewPager != null) {
            mViewPager.setOnPageChangeListener(null);
        }
        if (view.getAdapter() == null) {
            throw new IllegalStateException("ViewPager does not have adapter instance.");
        }
        mViewPager = view;
        mViewPager.setOnPageChangeListener(this);
        invalidate();
    }

    @Override
    public void setViewPager(ViewPager view, int initialPosition) {
        setViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void notifyDataSetChanged() {
        invalidate();
    }

    /**
     * Set a callback listener for the center item click.
     *
     * @param listener Callback instance.
     */
    public void setOnCenterItemClickListener(OnCenterItemClickListener listener) {
        mCenterItemClickListener = listener;
    }

    @Override
    public void setCurrentItem(int item) {
        if (mViewPager == null) {
            throw new IllegalStateException("ViewPager has not been bound.");
        }
        mViewPager.setCurrentItem(item);
        mCurrentPage = item;
        invalidate();
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        mScrollState = state;

        if (mListener != null) {
            mListener.onPageScrollStateChanged(state);
        }
    }

    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        mCurrentPage = position;
        mPageOffset = positionOffset;
        invalidate();

        if (mListener != null) {
            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);
        }
    }

    @Override
    public void onPageSelected(int position) {
        if (mScrollState == ViewPager.SCROLL_STATE_IDLE) {
            mCurrentPage = position;
            invalidate();
        }

        if (mListener != null) {
            mListener.onPageSelected(position);
        }
    }

    @Override
    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {
        mListener = listener;
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        //Measure our width in whatever mode specified
        final int measuredWidth = MeasureSpec.getSize(widthMeasureSpec);

        //Determine our height
        float height;
        final int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
        if (heightSpecMode == MeasureSpec.EXACTLY) {
            //We were told how big to be
            height = MeasureSpec.getSize(heightMeasureSpec);
        } else {
            //Calculate the text bounds
            mBounds.setEmpty();
            mBounds.bottom = (int) (mPaintText.descent() - mPaintText.ascent());
            height = mBounds.bottom - mBounds.top + mFooterLineHeight + mFooterPadding + mTopPadding;
            if (mFooterIndicatorStyle != IndicatorStyle.None) {
                height += mFooterIndicatorHeight;
            }
        }
        final int measuredHeight = (int)height;

        setMeasuredDimension(measuredWidth, measuredHeight);
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
        SavedState savedState = (SavedState)state;
        super.onRestoreInstanceState(savedState.getSuperState());
        mCurrentPage = savedState.currentPage;
        requestLayout();
    }

    @Override
    public Parcelable onSaveInstanceState() {
        Parcelable superState = super.onSaveInstanceState();
        SavedState savedState = new SavedState(superState);
        savedState.currentPage = mCurrentPage;
        return savedState;
    }

    static class SavedState extends BaseSavedState {
        int currentPage;

        public SavedState(Parcelable superState) {
            super(superState);
        }

        private SavedState(Parcel in) {
            super(in);
            currentPage = in.readInt();
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            super.writeToParcel(dest, flags);
            dest.writeInt(currentPage);
        }

        @SuppressWarnings("UnusedDeclaration")
        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
            @Override
            public SavedState createFromParcel(Parcel in) {
                return new SavedState(in);
            }

            @Override
            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        };
    }

    private CharSequence getTitle(int i) {
        CharSequence title = mViewPager.getAdapter().getPageTitle(i);
        if (title == null) {
            title = EMPTY_TITLE;
        }
        return title;
    }
}

@#$
/*
 * Copyright (C) 2012 Jake Wharton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.viewpagerindicator;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.drawable.Drawable;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.v4.view.MotionEventCompat;
import android.support.v4.view.ViewConfigurationCompat;
import android.support.v4.view.ViewPager;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;

import com.velocityviewpagerindicator.R;

/**
 * Draws a line for each page. The current page line is colored differently
 * than the unselected page lines.
 */
public class UnderlinePageIndicator extends View implements PageIndicator {
    private static final int INVALID_POINTER = -1;
    private static final int FADE_FRAME_MS = 30;

    private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);

    private boolean mFades;
    private int mFadeDelay;
    private int mFadeLength;
    private int mFadeBy;

    private ViewPager mViewPager;
    private ViewPager.OnPageChangeListener mListener;
    private int mScrollState;
    private int mCurrentPage;
    private float mPositionOffset;

    private int mTouchSlop;
    private float mLastMotionX = -1;
    private int mActivePointerId = INVALID_POINTER;
    private boolean mIsDragging;

    private final Runnable mFadeRunnable = new Runnable() {
      @Override public void run() {
        if (!mFades) return;

        final int alpha = Math.max(mPaint.getAlpha() - mFadeBy, 0);
        mPaint.setAlpha(alpha);
        invalidate();
        if (alpha > 0) {
          postDelayed(this, FADE_FRAME_MS);
        }
      }
    };

    public UnderlinePageIndicator(Context context) {
        this(context, null);
    }

    public UnderlinePageIndicator(Context context, AttributeSet attrs) {
        this(context, attrs, R.attr.vpiUnderlinePageIndicatorStyle);
    }

    public UnderlinePageIndicator(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        if (isInEditMode()) return;

        final Resources res = getResources();

        //Load defaults from resources
        final boolean defaultFades = res.getBoolean(R.bool.default_underline_indicator_fades);
        final int defaultFadeDelay = res.getInteger(R.integer.default_underline_indicator_fade_delay);
        final int defaultFadeLength = res.getInteger(R.integer.default_underline_indicator_fade_length);
        final int defaultSelectedColor = res.getColor(R.color.default_underline_indicator_selected_color);

        //Retrieve styles attributes
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.VelocityUnderlinePageIndicator, defStyle, 0);

        setFades(a.getBoolean(R.styleable.VelocityUnderlinePageIndicator_fades, defaultFades));
        setSelectedColor(a.getColor(R.styleable.VelocityUnderlinePageIndicator_selectedColor, defaultSelectedColor));
        setFadeDelay(a.getInteger(R.styleable.VelocityUnderlinePageIndicator_fadeDelay, defaultFadeDelay));
        setFadeLength(a.getInteger(R.styleable.VelocityUnderlinePageIndicator_fadeLength, defaultFadeLength));

        Drawable background = a.getDrawable(R.styleable.VelocityUnderlinePageIndicator_android_background);
        if (background != null) {
          setBackgroundDrawable(background);
        }

        a.recycle();

        final ViewConfiguration configuration = ViewConfiguration.get(context);
        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
    }

    public boolean getFades() {
        return mFades;
    }

    public void setFades(boolean fades) {
        if (fades != mFades) {
            mFades = fades;
            if (fades) {
                post(mFadeRunnable);
            } else {
                removeCallbacks(mFadeRunnable);
                mPaint.setAlpha(0xFF);
                invalidate();
            }
        }
    }

    public int getFadeDelay() {
        return mFadeDelay;
    }

    public void setFadeDelay(int fadeDelay) {
        mFadeDelay = fadeDelay;
    }

    public int getFadeLength() {
        return mFadeLength;
    }

    public void setFadeLength(int fadeLength) {
        mFadeLength = fadeLength;
        mFadeBy = 0xFF / (mFadeLength / FADE_FRAME_MS);
    }

    public int getSelectedColor() {
        return mPaint.getColor();
    }

    public void setSelectedColor(int selectedColor) {
        mPaint.setColor(selectedColor);
        invalidate();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (mViewPager == null) {
            return;
        }
        final int count = mViewPager.getAdapter().getCount();
        if (count == 0) {
            return;
        }

        if (mCurrentPage >= count) {
            setCurrentItem(count - 1);
            return;
        }

        final int paddingLeft = getPaddingLeft();
        final float pageWidth = (getWidth() - paddingLeft - getPaddingRight()) / (1f * count);
        final float left = paddingLeft + pageWidth * (mCurrentPage + mPositionOffset);
        final float right = left + pageWidth;
        final float top = getPaddingTop();
        final float bottom = getHeight() - getPaddingBottom();
        
        Log.e("DEBUG", ">>>LEFT:" + left + " >>>RIGHT: " + right + " >>>>TOP: " + top + " >>>>BOTTOM: " + bottom);
        
        canvas.drawRect(left, top, right, bottom, mPaint);
    }

    public boolean onTouchEvent(MotionEvent ev) {
        if (super.onTouchEvent(ev)) {
            return true;
        }
        if ((mViewPager == null) || (mViewPager.getAdapter().getCount() == 0)) {
            return false;
        }

        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
                mLastMotionX = ev.getX();
                break;

            case MotionEvent.ACTION_MOVE: {
                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                final float x = MotionEventCompat.getX(ev, activePointerIndex);
                final float deltaX = x - mLastMotionX;

                if (!mIsDragging) {
                    if (Math.abs(deltaX) > mTouchSlop) {
                        mIsDragging = true;
                    }
                }

                if (mIsDragging) {
                    mLastMotionX = x;
                    if (mViewPager.isFakeDragging() || mViewPager.beginFakeDrag()) {
                        mViewPager.fakeDragBy(deltaX);
                    }
                }

                break;
            }

            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                if (!mIsDragging) {
                    final int count = mViewPager.getAdapter().getCount();
                    final int width = getWidth();
                    final float halfWidth = width / 2f;
                    final float sixthWidth = width / 6f;

                    if ((mCurrentPage > 0) && (ev.getX() < halfWidth - sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mViewPager.setCurrentItem(mCurrentPage - 1);
                        }
                        return true;
                    } else if ((mCurrentPage < count - 1) && (ev.getX() > halfWidth + sixthWidth)) {
                        if (action != MotionEvent.ACTION_CANCEL) {
                            mViewPager.setCurrentItem(mCurrentPage + 1);
                        }
                        return true;
                    }
                }

                mIsDragging = false;
                mActivePointerId = INVALID_POINTER;
                if (mViewPager.isFakeDragging()) mViewPager.endFakeDrag();
                break;

            case MotionEventCompat.ACTION_POINTER_DOWN: {
                final int index = MotionEventCompat.getActionIndex(ev);
                mLastMotionX = MotionEventCompat.getX(ev, index);
                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
                break;
            }

            case MotionEventCompat.ACTION_POINTER_UP:
                final int pointerIndex = MotionEventCompat.getActionIndex(ev);
                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
                if (pointerId == mActivePointerId) {
                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
                }
                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));
                break;
        }

        return true;
    }

    @Override
    public void setViewPager(ViewPager ViewPager) {
        if (mViewPager == ViewPager) {
            return;
        }
        if (mViewPager != null) {
            //Clear us from the old pager.
            mViewPager.setOnPageChangeListener(null);
        }
        if (ViewPager.getAdapter() == null) {
            throw new IllegalStateException("ViewPager does not have adapter instance.");
        }
        mViewPager = ViewPager;
        mViewPager.setOnPageChangeListener(this);
        invalidate();
        post(new Runnable() {
            @Override public void run() {
                if (mFades) {
                    post(mFadeRunnable);
                }
            }
        });
    }

    @Override
    public void setViewPager(ViewPager view, int initialPosition) {
        setViewPager(view);
        setCurrentItem(initialPosition);
    }

    @Override
    public void setCurrentItem(int item) {
        if (mViewPager == null) {
            throw new IllegalStateException("ViewPager has not been bound.");
        }
        mViewPager.setCurrentItem(item);
        mCurrentPage = item;
        invalidate();
    }

    @Override
    public void notifyDataSetChanged() {
        invalidate();
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        mScrollState = state;

        if (mListener != null) {
            mListener.onPageScrollStateChanged(state);
        }
    }

    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        mCurrentPage = position;
        mPositionOffset = positionOffset;
        if (mFades) {
            if (positionOffsetPixels > 0) {
                removeCallbacks(mFadeRunnable);
                mPaint.setAlpha(0xFF);
            } else if (mScrollState != ViewPager.SCROLL_STATE_DRAGGING) {
                postDelayed(mFadeRunnable, mFadeDelay);
            }
        }
        invalidate();

        if (mListener != null) {
            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);
        }
    }

    @Override
    public void onPageSelected(int position) {
        if (mScrollState == ViewPager.SCROLL_STATE_IDLE) {
            mCurrentPage = position;
            mPositionOffset = 0;
            invalidate();
            mFadeRunnable.run();
        }
        if (mListener != null) {
            mListener.onPageSelected(position);
        }
    }

    @Override
    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {
        mListener = listener;
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
        SavedState savedState = (SavedState)state;
        super.onRestoreInstanceState(savedState.getSuperState());
        mCurrentPage = savedState.currentPage;
        requestLayout();
    }

    @Override
    public Parcelable onSaveInstanceState() {
        Parcelable superState = super.onSaveInstanceState();
        SavedState savedState = new SavedState(superState);
        savedState.currentPage = mCurrentPage;
        return savedState;
    }

    static class SavedState extends BaseSavedState {
        int currentPage;

        public SavedState(Parcelable superState) {
            super(superState);
        }

        private SavedState(Parcel in) {
            super(in);
            currentPage = in.readInt();
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            super.writeToParcel(dest, flags);
            dest.writeInt(currentPage);
        }

        @SuppressWarnings("UnusedDeclaration")
        public static final Creator<SavedState> CREATOR = new Creator<SavedState>() {
            @Override
            public SavedState createFromParcel(Parcel in) {
                return new SavedState(in);
            }

            @Override
            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        };
    }
}
@#$